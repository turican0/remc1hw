#include <stdio.h>
#include <defs.h>
//#include <cwchar>
#include "sub_main.h"

//fix
int unk_A9998;
int loc_24080;
int unk_110003;
int unk_B0004;
int loc_50005;
int loc_70000;
int _no_support_loaded;
int unk_A7325;
int unk_AC2B8;
int16 word_9AD90;
int16 word_9AD92;
int16 word_12CADC;
int16 word_12CADE;
int unk_12C9A0;
int unk_12CA00;
int16 word_9ADA0;

//fix
//-------------------------------------------------------------------------
// Function declarations

void sub_10000(); // weak
void sub_10010(__int16 a1, __int16 a2);
int sub_1002D(int a1, int a2);
__int16 sub_100B8();
__int16 sub_10166();
int sub_10190();
__int16 sub_101A1();
int sub_10254();
void sub_10300();
unsigned int sub_103C0(void *a1, unsigned int a2);
int sub_103F0();
void sub_104D0();
int sub_107C0(__int16 a1, __int16 a2, int a3);
unsigned int sub_108C0();
__int16 sub_10960();
__int16 sub_10AB0();
__int16 sub_10BD0();
int sub_10CB0(unsigned __int16 a1);
int sub_10D40(unsigned __int16 *a1, int *a2, __int16 a3);
int sub_10EB0(int a1);
_DWORD *sub_10F10(_DWORD *a1);
int sub_10FD0(int a1, __int16 a2);
int *sub_11010(int *a1);
__int16 sub_11050();
// void sub_111B0(int a1, int a2);
int sub_11410(int a1, int a2);
int sub_11490(int a1);
int sub_114B0(int a1, _DWORD *a2, _DWORD *a3);
int sub_11540();
int sub_11640(int a1, __int16 *a2, char a3);
int sub_11760(int a1);
int sub_11810(__int16 *a1);
bool sub_118C0(_WORD *a1, __int16 *a2, _WORD *a3, __int16 *a4);
bool sub_11950(int a1, int a2);
int sub_11980(int a1);
int sub_11AC0(_WORD *a1);
int sub_11C00(__int16 *a1);
int sub_11D10(int a1);
int sub_11E50(__int16 *a1, char a2, char a3);
int sub_11F50(__int16 *a1);
int sub_120B0(int a1, unsigned __int8 a2, unsigned __int16 a3);
int sub_124F0(int a1, char a2, unsigned __int16 a3);
int sub_127E0(int a1, char a2, unsigned __int16 a3);
int sub_12B50(int a1, int a2, unsigned __int8 a3, unsigned __int16 a4);
unsigned int sub_12C50(_WORD *a1);
char sub_12D10(_WORD *a1);
_BOOL1 sub_12F70(_WORD *a1);
int sub_13170(int a1);
int sub_132B0(int a1);
int sub_136C0(int a1);
bool sub_13800(int a1);
int sub_138E0();
int sub_138F0(int a1);
bool sub_13990(_WORD *a1);
int sub_13A10(int a1);
bool sub_13A70(int a1);
bool sub_13BA0(int a1);
bool sub_13CA0(int a1);
bool sub_13DC0(int a1);
bool sub_13DD0(int a1);
int sub_13F00(int a1);
int sub_14120(int a1);
unsigned int sub_14230(int a1);
int sub_14310(int a1);
int sub_143A0(int a1);
int sub_145B0(int a1);
int sub_147E0(int a1);
int sub_14B10(int a1);
int sub_14C40(int a1);
int sub_14C80(int a1);
int sub_14CE0(int a1);
int sub_14D00(int a1);
int sub_14D20(int a1);
int sub_14D40(int a1);
int sub_14D60(int a1);
int sub_14DA0(int a1);
int sub_14DC0(int a1);
unsigned int sub_14E60(int a1, unsigned __int8 a2);
int sub_14EB0(int a1);
unsigned int sub_15080(int a1);
unsigned int sub_15260(int a1, unsigned __int8 a2);
unsigned int sub_15340(int a1, int a2);
unsigned int sub_153B0(int a1, int a2);
__int16 sub_15420(int a1);
bool sub_15440(int a1, int a2);
int sub_15470(int a1, int a2, signed int a3, signed int a4);
int sub_155F0(int a1, unsigned __int8 a2);
int sub_15A00(int a1, unsigned __int8 a2);
bool sub_15E60(int a1, unsigned __int8 a2);
bool sub_15E90(int a1, unsigned __int8 a2);
int sub_15EC0(int a1);
unsigned int sub_16000(int a1, unsigned __int8 a2);
char sub_16030(int a1);
char sub_16310(_DWORD *a1);
int sub_16540(int result);
unsigned int sub_16800(unsigned int a1, int a2);
int sub_16870(int a1);
char sub_16890(int a1, int a2);
_BOOL1 sub_16920(int a1);
char sub_16990();
int sub_169E0();
char sub_16B00();
// char sub_17C20(__int16 a1, __int16 a2, __int16 a3);
int sub_188A0(int a1, char a2);
// void sub_192D8(char a1, _BOOL1 a2, char a3, char a4, __int16 a5);
int sub_192F3(char _CF, _BOOL1 _ZF, char _SF, char _OF);
// void sub_193EE(__int16 a1);
// int sub_19470(__int16 a1);
int sub_194F0();
__int16 sub_19550(int a1);
signed int sub_19650(__int16 *a1);
int sub_196E0(int a1);
void sub_19B10(int a1, char a2);
void sub_19D70(int a1, char a2);
int sub_1A120(int a1, char a2, unsigned __int16 (*a3)(int, int));
char sub_1A390(int a1, unsigned __int16 a2);
int sub_1A6C0(int a1, char a2);
void sub_1A800(int a1);
int sub_1A8E0(int a1, int a2);
int sub_1A990(int a1, int a2);
int sub_1AA40(int a1, int a2);
int sub_1AB10(int a1, int a2);
int sub_1AB70(int a1, int a2);
int sub_1AE30(int a1, int a2);
int sub_1AEE0(_WORD *a1, int a2);
void sub_1B060(int a1);
int sub_1B070(_WORD *a1);
int sub_1B090(_WORD *a1);
int sub_1B0E0(_WORD *a1);
int sub_1B100(int a1);
void sub_1B110(int a1);
int sub_1B120(_WORD *a1);
__int16 sub_1B160(int a1);
unsigned int sub_1B200(int a1);
void sub_1B2D0(int a1);
char sub_1B320(int a1);
int sub_1B330(int a1);
void sub_1B340(int a1);
void sub_1B350(int a1);
void sub_1B370(int a1);
__int16 sub_1B3C0(int a1);
char sub_1B4C0(int a1);
int sub_1B4E0(int a1);
void sub_1B4F0(int a1);
void sub_1B500(int a1);
void sub_1B510(int a1);
void sub_1B520(int a1);
char sub_1B570(int a1);
int sub_1B580(int a1);
void sub_1B590(int a1);
void sub_1B5A0(int a1);
char sub_1B5D0(int a1);
int sub_1BB20(int a1);
char sub_1BBE0(int a1);
int sub_1BC10(int a1);
void sub_1BC40(int a1);
char sub_1BC50(int a1);
int sub_1BCE0(int a1);
int sub_1BD10(int a1);
int sub_1BD20(int a1);
int sub_1C110(int a1);
__int16 sub_1C170(int a1);
int sub_1C3C0(int a1);
void sub_1C3D0(int a1);
void sub_1C490(int a1);
void sub_1C4A0(int a1);
void sub_1C4F0(int a1);
void sub_1C880(int a1);
int sub_1C8D0(int a1);
void sub_1C8E0(int a1);
void sub_1C8F0(int a1);
void sub_1C900(int a1);
__int16 sub_1C960(int a1);
char sub_1CA00(int a1);
int sub_1CA20(int a1);
void sub_1CA30(int a1);
void sub_1CA40(int a1);
void sub_1CA50(int a1);
void sub_1CE30(int a1);
char sub_1CF50(int a1);
int sub_1CF60(int a1);
void sub_1CFE0(int a1);
int sub_1CFF0(int a1);
void sub_1D060(int a1);
void sub_1D6D0(int a1);
void sub_1DA60(int a1);
char sub_1DC80(int a1);
int sub_1DCB0(int a1);
void sub_1DCC0(int a1);
char sub_1DCD0(int a1);
int sub_1DD50(int a1);
int sub_1DD90(int a1);
int sub_1DDB0(int a1);
void sub_1DDD0(int a1);
void sub_1DDE0(int a1);
int sub_1DDF0(int a1);
char sub_1DE10(int a1);
int sub_1DE20(int a1);
void sub_1DE30(int a1);
__int16 sub_1DE40(int a1);
void sub_1DFE0(int a1);
void sub_1E380(int a1);
char sub_1E6F0(int a1);
int sub_1E700(int a1);
void sub_1E710(int a1);
void sub_1E720(int a1);
void sub_1E770(_WORD *a1);
void sub_1E810(int a1);
_BOOL1 sub_1E920(_WORD *a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4);
_WORD *sub_1E9B0(unsigned __int16 a1, _WORD *a2, _WORD *a3);
char sub_1EA40(int a1);
void sub_1EED0(int a1);
void sub_1F120(int a1);
void sub_1F390(int a1);
int sub_1F5A0(int a1);
void sub_1F5B0(int a1);
char sub_1F640(int a1);
int sub_1FA00(int a1);
void sub_1FAA0(int a1);
char sub_1FAC0(int a1);
int sub_1FE90(int a1);
void sub_1FEC0(int a1);
// void sub_1FF40(char a1, int a2, char a3, int a4, int a5);
void sub_1FF60(int a1);
void sub_201D0(int a1);
char sub_203E0(int a1);
int sub_203F0(int a1);
void sub_20400(int a1);
int sub_20410(int a1);
int sub_20450(int a1);
int sub_20480(int a1);
void sub_20700(int a1);
void sub_20710(int a1);
unsigned __int16 sub_207E0(int a1);
char sub_20B60(int a1);
int sub_20B70(int a1);
void sub_20B80(int a1);
int sub_20BD0();
void sub_20D00(char a1);
void sub_20E60();
int nullsub_1(_DWORD, _DWORD); // weak
int sub_20FB0();
void sub_22810(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6);
int sub_22880();
void sub_22E50(int a1);
char sub_23940(__int16 a1, __int16 a2, int a3);
char sub_23AE0(__int16 a1, __int16 a2, int a3, unsigned __int8 a4);
char sub_23CF0(__int16 a1, __int16 a2, int a3);
char sub_23D40(int a1, int a2, unsigned int a3, char a4);
char sub_24230(__int16 a1, __int16 a2, unsigned int a3, char a4);
int sub_247C0(int result, int a2, __int16 a3, __int16 a4, int a5, unsigned __int8 a6);
void sub_24AB0();
unsigned __int8 *sub_24B50(unsigned __int8 *a1);
int sub_24B80();
int sub_24BB0();
unsigned __int8 sub_24BF0(unsigned __int8 a1);
void sub_24C20(int a1, int a2, int a3, int a4, unsigned __int16 a5);
void sub_24CA0(int a1, int a2, int a3, int a4, unsigned __int16 a5);
void sub_24D20(int a1, int a2, int a3, int a4, unsigned __int16 a5);
void sub_24DA0(int a1, int a2, int a3, int a4, unsigned __int16 a5);
int nullsub_2(void); // weak
void sub_24F60(int a1);
int sub_25130(int a1);
int sub_252B0(int a1);
int sub_252D0(int a1);
int sub_253E0(int a1);
int sub_253F0(int a1);
void sub_25410(int a1);
void sub_25470(int a1);
int sub_25570(int a1);
int sub_255D0(__int16 *a1, __int16 a2, __int16 a3);
void sub_25670(int a1);
int sub_25760(int a1);
int sub_257B0(int a1);
int sub_258A0(int a1);
int nullsub_19(_DWORD); // weak
int sub_25990(int a1);
int sub_25A60(int a1);
__int16 sub_25CE0(int a1);
void sub_25EC0(int a1);
int sub_26140(int a1);
void sub_262D0(int a1);
int sub_26360(int a1);
int sub_263C0(int a1);
_BOOL1 sub_264D0(unsigned __int16 a1);
// int sub_26560(int a1, int a2);
// int sub_26670(int a1, _WORD *a2);
// int sub_26760(int a1, _WORD *a2);
int sub_26890(_WORD *a1);
_WORD *sub_26920(int a1);
_WORD *sub_269A0(int a1);
void sub_26A60(int a1);
int sub_26C00(int a1);
int sub_26CE0(int a1);
void sub_26D20(int a1);
int sub_26E90(int a1);
void sub_27030(int a1);
__int16 sub_274D0(int a1);
int sub_275C0(__int16 *a1);
// _WORD * sub_27690(_WORD *result, int a2);
int sub_277D0(int a1, int a2);
char sub_279D0(int a1);
char sub_27D30(int a1);
unsigned __int16 sub_28200(int a1);
char sub_285C0(int a1);
// int sub_28D10(int a1, int a2);
unsigned int sub_28DC0(int a1);
int sub_28FE0(int a1);
int sub_293D0(int a1);
int sub_29540(int a1);
int sub_29640(int a1);
__int16 sub_296A0(int a1);
int sub_29700(int a1);
int sub_29780(int a1);
int sub_29920(int a1);
void sub_299D0(int a1);
int *sub_29BA0(int a1);
_DWORD *sub_29C30(__int16 a1);
// char sub_2A700(int a1, __int16 a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8);
int sub_2C410(unsigned int a1);
// unsigned __int16 sub_2DCB0(int a1, int a2);
// unsigned __int16 sub_2F170(int a1, int a2);
// unsigned __int16 sub_2FC50(int a1, int a2);
__int16 sub_30730(__int16 a1);
int sub_309D0(int a1);
int sub_30A70(int a1);
void sub_30B30();
int sub_30D30(__int16 a1);
char sub_30D90(int a1, int a2, int a3, __int16 a4, int a5, int a6, int a7, int a8);
int sub_315C0();
void sub_31600();
unsigned __int8 sub_319A0(unsigned __int8 *a1);
unsigned __int8 sub_31A00();
void sub_31A60();
int sub_31AA0(int a1);
unsigned __int16 sub_31BB0();
unsigned __int16 sub_31D40();
unsigned __int16 sub_31EC0();
unsigned __int16 sub_31FA0();
unsigned __int16 sub_320A0(unsigned __int16 a1);
unsigned __int16 sub_32300();
char sub_32560();
int sub_329C0();
int sub_32A50();
unsigned __int16 sub_32AE0(int a1, unsigned __int8 a2);
// unsigned __int16 sub_32B90(int a1, int a2);
unsigned __int8 sub_32D00(unsigned __int8 a1, unsigned __int8 a2);
char sub_32EB0(unsigned __int8 a1, unsigned __int8 a2);
unsigned __int16 sub_33180(unsigned __int8 a1);
unsigned __int16 sub_33500();
// char sub_33640(char a1, char a2, unsigned __int16 a3);
// char sub_33800(char a1, char a2, unsigned __int16 a3, unsigned __int8 a4);
unsigned __int16 sub_33AE0(unsigned __int16 a1, char a2);
char sub_33B90(unsigned __int16 a1, __int16 a2);
char sub_33E10(unsigned __int16 a1, __int16 a2);
unsigned __int16 sub_34070();
// int sub_340B0(int a1, __int16 a2, __int16 a3, unsigned __int16 a4, int a5);
int sub_34460();
int sub_344F0();
// void sub_34530(__int16 a1, __int16 a2, __int16 a3);
int sub_34610(__int16 a1, __int16 a2, __int16 a3);
char sub_34690();
int sub_34B00();
int sub_34B40();
int sub_34C60(int a1, int a2);
int sub_34C80();
// __int16 sub_34DD0(__int16 a1, unsigned __int16 a2, int a3);
int sub_356E0();
int sub_35710();
int sub_357A0(); // weak
// void sub_357C0(__int16 a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
int sub_358A0();
int sub_358D0(__int16 a1, __int16 a2, __int16 a3);
int sub_35900(__int16 a1, int a2, char a3, char a4);
int sub_35960(__int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4);
_WORD *sub_35BF0(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
int sub_35D30(unsigned __int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4);
int sub_35DE0(unsigned __int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4);
unsigned int sub_35EA0(char a1, char a2, char a3, char a4);
// char sub_35F30(int a1, char a2, char a3, int a4, int a5, unsigned __int8 a6);
void sub_36080(unsigned __int8 a1, char a2, int a3, int a4);
int sub_360C0(int a1);
__int16 sub_361C0(char a1, char a2, char a3, char a4);
int sub_362C0(int a1, _WORD *a2);
int sub_36430(int a1);
char sub_36480(int a1, _WORD *a2);
_WORD *sub_365C0(int a1);
int sub_36620();
int sub_36700(int a1, unsigned __int16 a2, int a3);
int sub_36850(int a1);
// _DWORD ios::failure::cause(_DWORD); weak
int sub_369E0(int a1, unsigned int a2, __int16 a3);
__int16 sub_36A90(int a1, int a2);
int *sub_36C10(int *a1);
// void sub_36C65(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int sub_36D83(int a1, __int16 a2);
int sub_36DC2();
int sub_36DE0(int a1);
char sub_36DF0(int a1, unsigned __int16 a2);
int sub_36F90(int a1);
int sub_36FA0(int a1, __int16 a2);
int sub_37030(_WORD *a1, __int16 a2);
int sub_370A0(_WORD *a1, __int16 a2);
__int16 sub_370E0(__int16 *a1, __int16 a2);
_WORD *sub_37130(_WORD *a1, __int16 a2, __int16 a3);
unsigned int sub_37150(_WORD *a1, __int16 a2);
int sub_371C0();
int sub_37220();
int sub_372C0();
int sub_373F0(int a1, int a2, int a3);
int sub_37440(int a1, char a2);
char sub_37560(unsigned __int16 *a1);
int sub_37710();
int sub_37720(int a1);
int sub_37740(int a1);
int sub_37760(int a1);
int sub_37780(int a1);
int sub_377A0(int a1);
int sub_377C0(int a1);
int sub_377E0(int a1);
int sub_37800(int a1);
int sub_37820(int a1);
int sub_378A0(int a1);
int sub_37920(int a1);
int sub_37A00(int a1);
int sub_37A80();
int sub_37AA0();
int sub_37AC0();
int sub_37AE0();
int sub_37B00();
int sub_37B20();
int sub_37B40();
int sub_37B60();
int sub_37B80();
int sub_37BA0();
int sub_37BC0(int *a1);
int sub_37CF0(int a1);
int sub_37D70(int a1);
int sub_37E00(int a1);
int sub_37E80(int a1);
int sub_37EF0(int a1);
_DWORD *sub_38030(int a1);
int sub_38270(int a1);
int sub_38370(int a1);
int sub_38820(int a1);
int sub_38890(int a1);
_DWORD *sub_389E0(int a1);
int sub_38C00(int a1);
int sub_38D09(); // weak
int sub_38D60(int a1);
int sub_38E70(int a1);
int sub_38FC0(int a1);
int sub_390D0(int a1);
int sub_39200(int a1);
int sub_39490(int a1);
int sub_395B0(int a1);
int sub_396E0(int a1);
int sub_39800();
int sub_39820();
int sub_39840();
int sub_39860();
int sub_39880();
int sub_398A0();
int sub_398C0();
int sub_39940();
int sub_39960();
int sub_39980();
int sub_399A0();
int sub_399C0();
int sub_399E0();
int sub_39A10(int a1);
int sub_39A90(int a1);
int sub_39B40(int a1);
int sub_39BC0(int a1);
int sub_39C40(int a1);
int sub_39CC0(int a1);
int sub_39D40(int a1);
int sub_39DC0(int a1);
int sub_39E40(int a1);
int sub_39EC0(int a1);
int sub_39F40(int a1);
int sub_39FC0(int a1);
int sub_3A040(int a1);
int sub_3A0C0(int a1);
int sub_3A1A0(int a1);
int sub_3A210(int a1);
int sub_3A270(int a1);
int sub_3A2F0(int a1);
int sub_3A390(int a1);
int sub_3A410(int a1);
_WORD *sub_3A490(int a1);
int sub_3A510(int a1);
int sub_3A570(int a1);
int sub_3A5D0(int a1);
int sub_3A640(int a1);
int sub_3A6B0(int a1);
_WORD *sub_3A730(__int16 *a1);
int sub_3A7D0(__int16 *a1);
int sub_3A870(int a1);
_WORD *sub_3A8D0(int a1);
_WORD *sub_3A930(int a1);
_WORD *sub_3A9A0(int a1);
int sub_3AA10(int a1);
int sub_3AAA0(int a1);
int sub_3AB40(int a1);
int sub_3ABE0(int a1);
int sub_3AC70(int a1);
int sub_3ACC0(__int16 *a1);
int sub_3ADB0(int a1);
int sub_3AE00(int a1);
int sub_3AE80(int a1);
_WORD *sub_3AF00(int a1);
_WORD *sub_3AF80(int a1);
int sub_3B000(int a1);
int sub_3B060(int a1);
int sub_3B0C0(int a1);
int sub_3B120(int a1);
int sub_3B180(int a1);
int sub_3B1D0(int a1);
int sub_3B230(int a1);
int sub_3B2A0(int a1);
int sub_3B300(int a1);
int sub_3B3D0();
_WORD *sub_3B3E0(int a1);
int sub_3B460(int a1);
_WORD *sub_3B4D0(int a1);
int sub_3B5A0(int a1);
int sub_3B620(int a1);
int sub_3B690(int a1);
_WORD *sub_3B6F0(int a1);
int sub_3B760(int a1);
int sub_3B7B0(int a1);
int sub_3B800(int a1);
int sub_3B860(int a1);
int sub_3B8E0(int a1);
int sub_3B970(int a1);
int sub_3BA00(int a1);
int sub_3BA90(int a1);
int sub_3BB20(int a1, char a2, char a3);
int sub_3BB70(int a1);
int sub_3BB90(int a1);
int sub_3BBB0(int a1);
int sub_3BBD0(int a1);
int sub_3BBF0(int a1);
int sub_3BC10(int a1);
int sub_3BC30(int a1);
int sub_3BC50(int a1);
int sub_3BC70(int a1);
int sub_3BC90(int a1);
int sub_3BCB0(int a1);
int sub_3BCD0(int a1);
int sub_3BCF0(int a1);
int sub_3BD10(int a1);
int sub_3BD30(int a1);
int sub_3BD50(int a1);
int sub_3BD70(int a1);
int sub_3BD90(int a1);
int sub_3BDB0(int a1);
int sub_3BDD0(int a1);
int sub_3BDF0(int a1);
int sub_3BE10(int a1);
int sub_3BE30(int a1);
int sub_3BE50(int a1);
int sub_3BE70(int a1);
int sub_3BE90(int a1);
int sub_3BEB0(int a1);
int sub_3BED0(int a1);
int sub_3BEF0(int a1);
int sub_3BF10(int a1);
int sub_3BF30(int a1);
int sub_3BF50(int a1);
int sub_3BF70(int a1, char a2, char a3, int a4, __int16 a5, char a6, char a7, int a8, __int16 a9);
int sub_3C040(int a1);
int sub_3C060(int a1);
int sub_3C090(int a1);
int sub_3C0C0(int a1);
int sub_3C0F0(int a1);
int sub_3C120(int a1);
int sub_3C150(int a1);
int sub_3C180(int a1);
int sub_3C1B0(int a1);
int sub_3C1E0(int a1);
int sub_3C210(int a1);
int sub_3C240(int a1);
int sub_3C270(int a1);
int sub_3C2A0(int a1);
int sub_3C2D0(int a1);
int sub_3C300(int a1);
int sub_3C330(int a1);
int sub_3C360(int a1);
int sub_3C390(int a1);
int sub_3C3C0(int a1);
int sub_3C3F0(int a1);
int sub_3C420(int a1);
int sub_3C450(int a1);
int sub_3C480(int a1);
int sub_3C4B0();
int sub_3C4E0();
int sub_3C510();
int sub_3C540();
char sub_3C570();
int sub_3C800(int a1, unsigned __int16 a2, unsigned __int16 a3);
int sub_3C9D0();
char sub_3DC90(int a1, char a2);
char sub_3DD10();
int sub_3DD50();
char sub_3E100(__int16 a1, void *a2);
char sub_3E350(__int16 a1);
_BOOL1 sub_3E410(__int16 a1);
char sub_3E460(__int16 a1);
char sub_3E4B0(__int16 a1);
char sub_3E580(__int16 a1);
char sub_3E640(__int16 a1);
char sub_3E690(__int16 a1);
_BOOL1 sub_3E750(__int16 a1);
char sub_3E7A0(__int16 a1);
char sub_3E7F0(__int16 a1);
char sub_3E8C0(__int16 a1);
char sub_3E980(__int16 a1);
void sub_3E9D0(_BYTE *a1);
_BYTE *sub_3EC50();
int sub_3EC80(int a1);
char sub_3EC90(unsigned __int8 a1, const char *a2, char *a3);
int sub_3EEA0(const char *a1, char *a2);
int sub_3EF20();
bool sub_3EF30(int a1);
char sub_3EF50(const char *a1, const char *a2, const char *a3);
char sub_3F1D0();
int sub_3F370();
__int16 sub_3F398(__int16 a1);
void sub_3F413(unsigned __int8 a1);
__int16 sub_3F4CE(__int16 a1);
// void sub_3F54D(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
// void sub_3F587(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
// unsigned __int8 sub_3F76D(int a1);
char sub_3F7D0(int a1);
// char sub_3F820(__int16 a1, __int16 a2, int a3, int a4, int a5, char a6);
unsigned __int8 sub_3FB30(__int16 a1, __int16 a2, int a3);
// char sub_3FCA0(int a1, __int16 a2, __int16 a3, __int16 a4, char a5, __int16 a6, __int16 a7, __int16 a8, __int16 a9, __int16 a10, __int16 a11);
__int16 sub_40440(int a1);
int sub_40550();
int sub_407A0();
int sub_408D0();
_BOOL1 sub_409E0(unsigned __int16 a1);
char sub_40A10(__int16 a1, __int16 a2, __int16 a3, char a4);
int sub_40D30(__int16 *a1, __int16 a2, __int16 a3, __int16 a4, char a5);
int nullsub_3(_DWORD); // weak
int sub_40E20(unsigned __int16 a1, unsigned __int16 a2);
char sub_40EDC(_BYTE *a1, _BYTE *a2, char a3, char a4, char a5, __int16 a6, __int16 a7, __int16 a8);
__int16 sub_40F87(__int16 a1, __int16 a2);
unsigned int sub_410CE(unsigned int a1);
void sub_41144(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int sub_411D7(int a1, void *a2, unsigned __int16 a3, char a4);
int sub_411FD(int a1, void *a2, unsigned __int16 a3, char a4);
int *sub_41230();
void sub_41490();
void sub_41540();
unsigned __int16 sub_415C0();
unsigned int sub_416B0();
char sub_41780();
char sub_41B20(int a1, int a2);
int sub_41C70(__int16 a1, int a2, int a3);
// int sub_41CC0(__int16 a1, int a2, int a3);
int sub_41CF0(int a1, int a2);
// __int16 sub_41DD0(__int16 result, int a2);
int sub_41E80(int a1);
int sub_41E90(__int16 a1, int a2);
_WORD *sub_41EC0(_WORD *a1, unsigned __int16 a2, __int16 a3, __int16 a4);
_WORD *sub_41F50(int a1, _WORD *a2);
int sub_42000(int a1, int a2, int a3, int a4, int a5);
int sub_42090(int a1, int a2, int a3, int a4, int a5);
__int16 sub_42150(_WORD *a1, _WORD *a2);
__int16 sub_42180(_WORD *a1, _WORD *a2);
int sub_42210(__int16 a1, __int16 a2);
int sub_42240(int a1, __int16 a2);
int sub_422A0(unsigned __int16 a1, __int16 a2, int a3, unsigned __int16 a4);
int sub_42300(_WORD *a1, _WORD *a2);
unsigned int sub_42340(_WORD *a1, _WORD *a2);
int sub_42390(_WORD *a1, _WORD *a2);
unsigned int sub_423D0(_WORD *a1, _WORD *a2);
int sub_42410(_WORD *a1, _WORD *a2);
int sub_424F0(int a1, unsigned __int8 a2);
int sub_42510(int a1);
char sub_42530(char a1);
int sub_42540(int a1);
int sub_425C0(int a1);
char sub_42650(int a1, int a2);
int *sub_426E0(int a1);
int sub_42730(int a1, int a2);
int sub_427A0(int a1, int a2);
int sub_42860(int a1);
__int16 sub_428B0();
int sub_42930(_BYTE *a1, char *a2, unsigned __int8 a3);
int sub_42A00(__int16 a1);
int sub_42C70(__int16 a1);
int sub_42CF0(int a1, __int16 a2);
int sub_42D40(_BYTE *a1, char *a2);
int sub_42DE0(_BYTE *a1);
int sub_42E10(__int16 a1);
int sub_42F30(unsigned int a1, void *a2);
int sub_42FB0(unsigned int a1, char *a2, unsigned int a3);
int sub_43010(unsigned int a1, int a2, unsigned __int16 a3);
int sub_43080(unsigned int a1, const void *a2, unsigned int a3);
int sub_430F0(unsigned int a1, char *a2, unsigned int a3);
int sub_43150();
int sub_43170(__int16 a1);
int sub_431A0(unsigned int a1);
int sub_43270(int a1, __int16 a2);
int *sub_433C0();
int sub_43430(char *a1, __int16 a2);
int sub_43760(__int16 a1);
void sub_43870(unsigned __int16 a1, char *a2, unsigned int a3);
void sub_438D0(unsigned __int16 a1, char *a2, unsigned int a3);
void sub_43930(char *a1, unsigned int a2);
// char sub_43B20(int a1, unsigned int a2);
char *sub_43E50(const char *a1);
int sub_43EC0(__int16 a1, int a2, int a3, unsigned __int16 a4, unsigned __int16 a5);
int sub_44470();
void sub_44700(const char *a1, int a2, int a3);
void sub_44730(int a1);
int sub_44840();
int sub_448E0();
__int16 sub_44BE0(int a1, char a2);
signed int sub_44C10(int a1);
signed int sub_44C90(int a1);
int sub_44D30(int a1, int a2);
int sub_45410(int a1);
void sub_455D0(int a1);
int sub_45C10(int a1);
void sub_45C90(int a1);
int sub_45FC0(int a1);
int sub_463B0(int a1);
int sub_46480(int a1);
int sub_46520(int a1);
int sub_46540(int a1);
void sub_46840(int a1);
void sub_46B00(int a1, unsigned int a2, int a3, int a4);
unsigned int sub_46CA0(int a1, int a2, int a3);
int sub_46D20(int a1, __int16 a2);
__int16 sub_46DB0(int a1);
char sub_46F10(int a1);
int sub_47020(int a1);
int sub_47080(int a1);
int sub_470E0(int a1);
int sub_47130(int a1);
int sub_47400(int a1);
char sub_47960(int a1);
int sub_47A70(int a1);
int sub_47BD0(_DWORD *a1, int a2, int a3, int a4);
int sub_47C60(int a1);
int sub_47DD0(int a1);
int sub_47EC0(int a1);
int sub_47F90(int a1);
int sub_481D0(int a1);
int sub_48230(int a1);
int sub_48340(int a1);
void sub_483C0(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
void sub_48470(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
int sub_48520(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
bool sub_48570(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
char sub_48710(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8);
int sub_49300(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10);
int sub_49890(int a1);
int sub_499C0(int a1);
int sub_49A50(_WORD *a1);
int sub_49AA0(int a1);
int sub_49AD0(int a1);
int sub_49B50(int a1);
int sub_4A980();
// void sub_4AB20(__int16 a1, const char *a2, const char *a3, __int16 a4, __int16 a5);
// void sub_4AC70(const char *a1, const char *a2);
int sub_4B430();
int sub_4B480(int (*a1)(void), int a2);
int sub_4B520();
int sub_4B560();
char **sub_4B6A0();
void sub_4B6F0(unsigned __int8 **a1);
void sub_4B8D0(__int16 a1);
__int16 sub_4BB20();
int sub_4BC90();
void sub_4BD60();
int sub_4C580();
bool sub_4C640();
bool sub_4C670();
bool sub_4C6A0();
int sub_4C6F0();
void sub_4C7E0();
int sub_4CAC0();
void sub_4CB70();
int sub_4CC00(); // weak
int sub_4CCA0(int a1);
bool sub_4D0F0();
int sub_4D190();
void sub_4D300();
void sub_4D3B0();
void sub_4D560();
void sub_4D680();
char sub_4DCC0();
char sub_4E0E0();
void sub_4E270();
void sub_4E320();
void sub_4E3D0(unsigned __int8 a1);
void sub_4E470(unsigned __int8 a1);
void sub_4E510(unsigned __int8 a1);
int sub_4E5B0();
void sub_4EE70();
// void sub_4EFC0(__int16 a1);
void sub_4F120();
int sub_4F1E0();
// void sub_4F3F0(__int16 a1);
int sub_4F8D0(int a1, void (*a2)(int));
// int sub_4FD20(int a1);
int sub_4FE00();
// void sub_4FF30(int a1);
void sub_4FFE0();
void sub_50030();
void sub_50350();
void sub_503E0();
_BYTE *sub_50470();
int sub_504A0();
int sub_505A0();
// char sub_50770(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
bool sub_50D40(int a1, __int16 a2, __int16 a3, char *a4, char *a5, char a6, int a7, void (*a8)(void), char a9, int a10);
char *sub_512D0(char *a1, const char *a2);
int sub_51330(int a1, __int16 a2);
int sub_51360(int a1, int a2, int a3, int a4);
_DWORD *sub_513A0(_DWORD *a1);
void sub_513E0();
void sub_51400();
int sub_51420(_DWORD *a1, char *a2);
char sub_51480(int a1, _DWORD *a2, unsigned __int8 *a3);
void sub_51560(_BYTE *a1, int a2, __int16 a3, unsigned __int8 *a4);
__int16 sub_51650(int a1, int a2, __int16 a3, int a4);
unsigned int *sub_519E0(int a1);
int sub_51A10();
int sub_51AF0(char a1);
int sub_51C90(char a1);
void sub_51DF0(char a1);
void sub_51E84(_BYTE *a1, _BYTE *a2, _BYTE *a3, int a4, char a5);
int sub_51ECC(int a1, int a2, int a3, int a4, char a5, char a6);
void sub_51FC0();
void sub_520F0(__int16 a1, __int16 a2, char a3, __int16 a4);
void sub_52120(__int16 a1, __int16 a2);
void sub_522E0();
void sub_52400(__int16 a1, __int16 a2, __int16 a3);
int sub_524C0(int a1);
int sub_524E0(int a1);
int sub_52500(_WORD *a1, int a2);
int sub_52550(int a1, int a2);
__int16 sub_52610(int a1, int a2);
char sub_526C0(int a1, unsigned int a2, unsigned int a3);
char sub_52770(int a1);
int sub_52B30(int a1);
char sub_52ED0(int a1);
char sub_53060(int a1);
char sub_53070(int a1);
char sub_530B0(int a1);
char sub_530C0(int a1);
char sub_534C0(int a1);
__int16 sub_535E0(unsigned int a1);
char sub_53980(int a1);
char sub_53B50(int a1);
char sub_53DC0(int a1);
int sub_54180(int a1);
int sub_54290(int a1);
char sub_542B0(int a1);
_WORD *sub_54480(int a1);
int sub_54520(int a1);
int sub_54A90(__int16 *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
int sub_54BD0(__int16 *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
int sub_54F00();
int sub_54F80(int a1);
int sub_55100();
void sub_55370(__int16 a1, __int16 a2, __int16 a3);
bool sub_55870(int a1, int a2);
void sub_55890(int a1, __int16 a2, __int16 a3);
int sub_558F0();
int sub_55960();
int sub_559A0();
int sub_55A40(int a1, char a2, char a3);
int sub_55D30(int a1);
int sub_55DB0(int a1);
int sub_55DD0(int a1, int *a2);
int sub_55E80(int a1, int a2);
// int sub_55EF0(__int16 a1, int a2, int a3);
int sub_56090(int a1);
void sub_56270(int a1);
void sub_56380(int a1);
int sub_56510(int a1);
int sub_566C0(int a1);
void sub_56730(int a1);
int sub_567A0(int a1);
int sub_56950(int a1);
int sub_56AF0(int a1);
int sub_56CA0(int a1);
void sub_56E50(int a1);
int sub_57040(int a1);
void sub_571B0(int a1);
int sub_57250(int a1);
int sub_573F0(int a1);
int sub_57470(int a1);
void sub_57610(int a1);
void sub_57800(int a1);
int sub_579D0(int a1);
int sub_57B80(int a1);
int sub_57D40(int a1);
void sub_57F00(int a1);
int sub_580A0(int a1);
int sub_58240(int a1);
int sub_58768(__int16 a1, __int16 a2, int a3, unsigned __int8 a4);
char sub_587E0();
int sub_58860(unsigned __int16 a1, char *a2);
char sub_58910(unsigned __int16 a1);
char sub_58A00(unsigned __int16 a1);
int sub_58AD0(unsigned __int16 a1);
__int16 sub_58B30(unsigned __int16 a1);
int sub_58C30(unsigned int a1);
__int16 sub_58E70();
int sub_58F00(int a1, int a2);
int sub_58F70();
int sub_58F90();
bool sub_59050(unsigned __int16 a1);
char *sub_590D0();
int sub_59140();
__int16 *sub_59160(unsigned __int16 a1, unsigned __int16 a2, signed __int16 a3);
int sub_591E0(unsigned __int16 a1);
char sub_59230();
void sub_59320();
__int16 sub_59370();
int sub_593B0();
char sub_59420();
unsigned int sub_59500(unsigned int **a1);
unsigned int sub_59560(unsigned int **a1);
int sub_59720();
int sub_59750(__int16 a1, __int16 a2);
void sub_599B0(__int16 a1);
int sub_59A80(int a1);
int sub_59AB0(int a1);
int sub_59AE0(int a1);
int sub_59B30(int a1);
void sub_59B80(int a1);
int sub_59C40(int a1);
int sub_59C70(int a1);
int sub_59CA0(int a1);
int sub_59CF0(int a1);
int sub_59D40(int a1);
int sub_59D70(int a1);
int sub_59DA0(int a1);
int sub_59DF0(int a1);
int sub_59E40(int a1, int a2);
int sub_59F60(int a1);
int sub_59F70(int a1);
int sub_59F80(int a1);
int sub_59F90(int a1);
int sub_59FA0(int a1);
int sub_59FB0(int a1);
int sub_59FC0(int a1);
int sub_59FD0(int a1);
int sub_59FE0(int a1);
int sub_59FF0(int a1);
int sub_5A000(int a1);
int sub_5A010(int a1);
int sub_5A020(int a1);
int sub_5A030(int a1);
int sub_5A040(int a1);
int sub_5A050(int a1);
int sub_5A060(int a1);
int sub_5A070(int a1);
int sub_5A090(int a1, int a2);
int sub_5A120(int a1, int a2);
int sub_5A180(_BYTE *a1, int a2, __int16 a3, unsigned __int8 a4);
__int16 sub_5A3A0();
__int16 sub_5A3B0();
int sub_5A3C0(__int16 a1);
// void sub_5A3E3(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int sub_5A459(int a1, __int16 a2);
int sub_5A4EA();
int sub_5A560();
int sub_5ACA0();
int sub_5AD10(int a1);
int sub_5AD30();
int sub_5ADB0(int a1, _DWORD *a2, _BYTE *a3);
int sub_5AE30(int a1, char *a2);
int sub_5AEB0(int a1, _DWORD *a2, _BYTE *a3);
int sub_5AF50();
int sub_5B210();
int sub_5B2B0();
unsigned __int8 sub_5B310(int a1, unsigned __int8 *a2);
int sub_5B3B0();
int sub_5B3E0(int a1);
int sub_5B450(__int16 a1);
int sub_5B480(int a1, __int16 *a2, _WORD *a3);
void sub_5B500();
void sub_5B560();
int nullsub_11(_DWORD); // weak
void sub_5B5E0();
void sub_5B5F4();
int sub_5B650();
int sub_5B95C();
int sub_5BB60();
int sub_5BD40();
int sub_5BDF8();
void sub_5BE50();
int sub_5C05C(int a1);
int sub_5C214();
int sub_5C468();
__int16 sub_5C76B();
__int16 sub_5C82E();
int sub_5C891();
int sub_5C8AF();
int sub_5C8CD();
void sub_5C8F4();
__int16 sub_5C969();
int sub_5CA40();
char sub_5CAE7();
void sub_5CB73(int a1, __int16 a2);
int sub_5CBD0(int a1, int a2, int a3);
// _DWORD printf(const char *, ...); weak
// _DWORD memset(_DWORD, _DWORD, _DWORD); weak
unsigned __int8 sub_5CC54();
char sub_5CC70(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int sub_5CD70();
void sub_5CDA0();
int sub_5CDE0(int a1, int a2);
int sub_5CE50(int a1);
// _DWORD dos_getdrive(_DWORD); weak
// _DWORD dos_getdiskfree(_DWORD, _DWORD); weak
int sub_5CEF0(unsigned __int16 a1);
unsigned int sub_5CFA4();
void sub_5D010();
int sub_5D070(unsigned __int8 a1);
unsigned int sub_5D138();
int sub_5D1A0(int a1, int a2, unsigned int a3);
int sub_5D230(int a1, int a2, int a3);
void sub_5D290(__int16 a1);
void sub_5D460(__int16 a1, __int16 a2, __int16 a3);
void sub_5D610(__int16 a1, __int16 a2);
void sub_5D750(__int16 a1, __int16 a2);
void sub_5D7DF();
bool sub_5D7F0(int a1);
void sub_5D829();
// int rand(void); weak
void sub_5D872();
int sub_5D883(int a1, unsigned int a2, char a3);
int sub_5D948();
int sub_5D97B(unsigned int a1, int a2, __int16 a3, unsigned int a4);
int sub_5DB1D(unsigned int a1, unsigned int a2);
int sub_5DC91(int a1);
int sub_5DE40(int a1);
int sub_5DE63(int a1);
int sub_5DE91(int a1, int a2, int a3);
int sub_5DF4B(int a1, int a2, int a3);
void sub_5DF61();
void sub_5DF72();
int sub_5DF83(int a1, unsigned int a2, unsigned __int16 a3, int a4, int a5);
int sub_5E9C1(int a1);
int sub_5EDA0(int a1, int a2, unsigned __int16 a3, int a4);
int sub_5EDD6(int a1);
void sub_5EE00();
void sub_5EE11();
int sub_5EE22(unsigned int a1, int a2, int a3, __int16 a4, unsigned int a5);
int sub_5F355(unsigned int a1);
int sub_5F398(int a1);
int sub_5F420(unsigned int a1);
int sub_5F529(int a1, unsigned int a2);
int sub_5F7C7(unsigned int a1, int a2, unsigned int a3);
int sub_5F83E(char a1);
void sub_5F913();
void sub_5F924();
__int16 sub_5F935();
__int16 sub_5FD67();
int sub_60199(int a1, unsigned __int16 a2);
int sub_60335();
int sub_6035F(unsigned int a1, unsigned int a2, int a3, int a4, int a5, unsigned int a6);
int sub_6080C(unsigned int a1, int a2);
int sub_6091D(int a1);
void sub_609F4();
unsigned __int64 sub_60BDC(int a1);
// _DWORD sprintf(_DWORD, _DWORD, ...); weak
int sub_60CE0(__int16 a1, __int16 a2, int a3);
int sub_60D18(__int16 a1, __int16 a2, int a3);
// void sub_60D50(__int16 a1, int a2, int a3, char *a4, unsigned __int8 a5, char a6);
// void sub_60D65(__int16 a1, int a2, int a3, char *a4, unsigned __int8 a5, char a6);
int sub_61594(unsigned __int16 a1, unsigned __int16 a2, __int16 a3);
int sub_615D4(unsigned __int16 a1, unsigned __int16 a2, __int16 a3);
int sub_61610(int a1);
void sub_61640(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, unsigned __int16 a5);
void sub_616C0(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, unsigned __int16 a5);
int sub_61740(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5);
int sub_61810(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5);
int sub_618E0(__int16 a1);
int sub_619B8(__int16 a1);
int sub_61A1C(__int16 a1);
int sub_61AB0();
int sub_61B90(unsigned __int8 *a1);
int sub_61C30(unsigned __int8 *a1);
__int16 sub_61CC0(unsigned __int8 *a1, unsigned __int8 a2, char a3);
void sub_61EC8();
// _DWORD stricmp(_DWORD, _DWORD); weak
// _DWORD unknown_libname_1(_DWORD); weak
void sub_61F90();
int sub_62020();
int *sub_62128(int a1);
// void exit(int status); idb
// _DWORD inp(_DWORD); weak
// _DWORD outp(_DWORD, char); weak
// _DWORD chain_intr(_DWORD); weak
// _DWORD dos_getvect(_DWORD); weak
// _DWORD dos_setvect(_DWORD, _DWORD, _DWORD); weak
// __int64 fopen(_DWORD, _DWORD); weak
// _DWORD fprintf(_DWORD, _DWORD, ...); weak
// _DWORD fclose(_DWORD); weak
// _DWORD fscanf(_DWORD, _DWORD, ...); weak
// _DWORD getenv(_DWORD); weak
// _DWORD sscanf(_DWORD, _DWORD, ...); weak
// _DWORD filelength(_DWORD); weak
int sub_62B30(int a1, int a2, char a3);
int sub_62B60(int a1, char *a2);
// char sub_62CF4(int *a1);
// __int16 sub_62CFD(__int16 *a1, int a2);
// __int16 sub_62D40(unsigned __int8 a1, int a2);
// char sub_62DC3(int a1);
int sub_62E60(int a1, int a2, int a3);
int sub_62ED0(int a1, int a2, int a3);
// _DWORD access(_DWORD, _DWORD); weak
// _DWORD mkdir(_DWORD); weak
// _DWORD int386(_DWORD, _DWORD, _DWORD); weak
void sub_62FA8(const void *a1, void *a2, unsigned __int16 a3);
void sub_62FC4(const void *a1, void *a2, unsigned __int16 a3);
int sub_62FF0(int a1);
void sub_63010();
int *sub_63338();
int sub_6342C(unsigned int a1);
_DWORD *sub_634A0(int a1);
int sub_634E0(int a1);
// _DWORD gets(_DWORD); weak
// _DWORD segread(_DWORD); weak
// _DWORD int386x(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD system(_DWORD); weak
void sub_6377B();
char *sub_6378C(int a1);
void sub_637AF();
void sub_637C0();
int sub_637D1(int a1, int a2, unsigned __int16 a3, int a4);
int sub_638E0(int a1, int a2, int a3);
void sub_638F8();
int sub_63910(int a1);
// _DWORD strcmp(_DWORD, _DWORD); weak
void sub_63A8C();
// int sub_63A9D(__int16 a1, int a2, int a3, __int16 a4);
int sub_63C06();
// int sub_63C5A(const void *a1, unsigned int a2, char *a3, __int16 a4, unsigned int a5);
int sub_64248(unsigned int a1, __int16 a2);
void sub_64414();
void sub_64425();
__int16 sub_64436();
__int16 sub_645FB();
int sub_647C0(int a1, unsigned __int16 a2);
int sub_6481C();
// int sub_64846(int a1, int a2, unsigned int a3, unsigned int a4, int a5, unsigned int a6, int a7, unsigned int a8);
int sub_64F78(unsigned int a1, int a2, int a3);
int sub_650FF(__int16 a1, int a2, unsigned int a3, _DWORD *a4);
void sub_651D6();
void sub_651E7();
bool sub_651F8(int a1, int a2);
void sub_6533A();
void sub_6534B();
int sub_6535C(int a1, unsigned int a2);
int sub_65965(int a1, int a2);
void sub_65D57();
unsigned int sub_65D70(unsigned int a1, unsigned int a2, unsigned int a3);
unsigned int *sub_65DC0(unsigned int *a1, unsigned int a2, unsigned int a3);
void sub_65E00();
// _DWORD strncmp(_DWORD, _DWORD, _DWORD); weak
int sub_65EB0(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
void sub_65F10(__int16 a1, __int16 a2);
// _DWORD memmove(_DWORD, _DWORD, _DWORD); weak
void sub_66107();
int sub_66118(int a1, int a2, unsigned __int16 a3);
int sub_661A4(int a1, int a2);
void sub_6623A();
void sub_66250(__int16 a1, __int16 a2, unsigned __int16 a3);
void sub_66313();
int sub_66324(int a1);
void sub_6637C();
unsigned int sub_66390(unsigned int a1, unsigned int a2, unsigned int a3);
unsigned int *sub_66410(unsigned int *a1, unsigned int a2, unsigned int a3);
int sub_664AB(unsigned __int8 *a1, unsigned __int8 **a2, int a3, int a4);
int sub_6660D(unsigned __int8 *a1, unsigned __int8 **a2, int a3);
int sub_66612(unsigned __int8 a1);
__int16 sub_6666C(__int16 result);
// _DWORD open(_DWORD, _DWORD);
// _DWORD sopen(_DWORD, _DWORD, char);
// _DWORD close(_DWORD); weak
// _DWORD read(_DWORD, _DWORD, _DWORD); weak
// _DWORD creat(_DWORD, _DWORD); weak
// _DWORD setmode(_DWORD, _DWORD); weak
// _DWORD _set_errno(_DWORD); weak
void sub_66CAD(); // weak
unsigned __int8 sub_66D24(__int16 a1);
// unsigned __int8 sub_66D6A(int a1, __int16 a2, int a3, __int16 a4);
unsigned __int8 sub_66DF5();
unsigned __int8 sub_66E21();
unsigned __int8 sub_66E4D();
int sub_66EA2();
void sub_66EE5();
unsigned __int64 sub_66EF6(unsigned int a1, __int16 a2);
void sub_66F1A();
void sub_66F2B();
int sub_66F3C();
void sub_67464();
void sub_67475();
bool sub_67486(int a1);
void sub_674B9();
__int16 sub_674CD();
__int16 sub_674FA();
void sub_67527(int a1, int a2, __int16 a3);
int sub_67557(__int16 a1, int a2, int a3);
int sub_67582();
__int16 sub_675C8(int a1, _DWORD *a2);
int sub_6765C(const void *a1, int (*a2)(_DWORD), char a3, __int16 a4, char *a5, __int16 a6);
// int sub_676B0(int a1, int (*a2)(_DWORD), char a3, __int16 a4, int a5, __int16 a6);
int sub_676E5(int (*a1)(_DWORD));
int sub_67710(int (*a1)(_DWORD));
__int16 sub_6773B(int (*a1)(_DWORD));
int sub_67780(int (*a1)(_DWORD));
int sub_677B8(int (*a1)(_DWORD));
// __int16 sub_677E3(int a1, void (*a2)(_DWORD), char a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
int sub_67845(int (*a1)(_DWORD));
int sub_6787E(int (*a1)(_DWORD));
int sub_678AF(int (*a1)(_DWORD));
int sub_678DE(int (*a1)(_DWORD));
__int16 sub_6790D();
__int16 sub_67944();
void sub_6797C();
int *sub_6798D();
int sub_679AE(int a1, unsigned __int16 a2, int a3, int a4);
int sub_679DE();
int sub_679F7();
int sub_67A10();
int sub_67A29(int (*a1)(_DWORD, _DWORD, _DWORD, _DWORD), __int16 a2);
void sub_67A53();
void sub_67A64();
int *sub_67A75();
int sub_67A96(unsigned int a1, int a2, int a3, int a4);
// int sub_67D9D(int a1, int a2, unsigned int a3, int a4, int a5);
int sub_67F1C(int a1, int a2, int a3);
int sub_67F9A();
int sub_67FB3(int a1, __int16 a2, int a3, int a4);
int sub_6813F(int a1, int a2, int a3);
void sub_6815E();
void sub_6816F();
int sub_68180(int a1, int a2);
void sub_681F6();
int sub_68207(int a1, int a2, __int16 a3);
int sub_682CB(int a1);
int sub_68365(int a1, int a2);
int sub_68491(int a1, int a2);
void sub_68600();
void sub_68611();
int sub_68622(__int16 a1, int a2, unsigned int a3, unsigned int a4, int *a5, unsigned int a6);
int sub_68813(unsigned int a1);
void sub_6887D();
void sub_6888E();
void sub_688F5();
void sub_68906();
void sub_689D1();
void sub_689E2();
int *sub_689F3();
// int sub_68A14(int a1, int a2, int a3, unsigned int a4);
int sub_68BDA(int a1, int a2, int a3, __int16 a4);
int sub_68C4B();
int sub_68C69();
int sub_68C82();
void sub_68C9B();
void sub_68CAC();
char sub_68CBD(int a1, int a2, unsigned int a3);
unsigned int sub_68D7F(unsigned int a1, int a2, int a3);
void sub_68F15();
void sub_68F26();
char sub_68F37(int a1, int a2, unsigned int a3);
void sub_6905C();
void sub_6906D();
void sub_6907E(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3);
void sub_6954C();
void sub_6955D();
char sub_6956E(int a1, int a2, unsigned int a3);
int sub_6966D(unsigned int a1);
int sub_69716(unsigned int a1);
void sub_6979E();
void sub_697AF();
void sub_697C0(int a1, int a2, unsigned int a3);
void sub_6999B();
void sub_699AC();
char sub_699BD();
void sub_69A83();
void sub_69A94();
int sub_69AA5(int a1, int a2, int a3, __int16 a4);
int sub_69BFE(int a1);
void sub_69DFE();
void sub_69E0F();
char sub_69E20();
void sub_69E63();
void sub_69E74();
char sub_69E85(int a1, int a2, unsigned int a3);
void sub_69ECB();
void sub_69EDC();
int sub_69EED(unsigned int a1, __int16 a2, int a3, int a4);
int sub_69F1C(int a1, int a2, int a3, int a4);
int sub_69F57();
int sub_69F75();
int sub_69F93(int a1, __int16 a2, int a3, int a4);
void sub_69FC2();
void sub_69FD3();
char sub_69FE4(unsigned int a1);
void sub_6A063();
void sub_6A074();
char sub_6A085(unsigned __int8 a1, __int16 a2);
void sub_6A0F9();
void sub_6A10A();
char sub_6A11B();
void sub_6A1B3();
void sub_6A1C4();
char sub_6A1D5(unsigned __int8 a1, __int16 a2);
void sub_6A275();
void sub_6A286();
char sub_6A297(unsigned __int8 a1);
void sub_6A2F5();
void sub_6A306();
char sub_6A317();
void sub_6A3E3();
void sub_6A3F4();
char sub_6A405(int a1, int a2, unsigned __int8 a3);
void sub_6A5EC();
void sub_6A5FD();
char sub_6A60E();
void sub_6A62D();
unsigned __int8 sub_6A640(unsigned __int8 a1, unsigned __int8 a2);
// _DWORD fstrcpy(_DWORD, _DWORD, _DWORD, _DWORD); weak
__int16 sub_6A737(void (*a1)(_DWORD), unsigned int a2, int a3, int a4, __int16 a5);
int sub_6B260(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5, __int16 a6);
int sub_6B378(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5, __int16 a6);
int sub_6B47C(unsigned __int8 *a1);
// _DWORD tolower(_DWORD); weak
int sub_6B87A();
// _DWORD lseek(_DWORD, _DWORD, char); weak
// _DWORD free(_DWORD); weak
int sub_6BCA3(int a1, unsigned __int8 *a2, int *a3);
unsigned __int8 *sub_6BEBB(unsigned __int8 *a1, int a2);
int sub_6BF98(int a1);
int sub_6BFCF(_WORD *a1, int a2, int *a3);
// void sub_6C05C(_BYTE *a1, int a2, int *a3);
int *sub_6C175(int a1, int *a2, int a3);
_BYTE *sub_6C1E0(_BYTE *a1, int a2);
// void sub_6C224(_BYTE *a1, int a2, int *a3, _BYTE **a4);
void sub_6C32A(int a1, int *a2);
void sub_6C66D(int a1, int *a2, int a3, int a4);
int sub_6C896(int a1);
int sub_6C8C5(int a1);
// _DWORD write(_DWORD, _DWORD, _DWORD); weak
// _DWORD malloc(_DWORD); weak
// _DWORD expand(_DWORD, _DWORD); weak
// _DWORD qsort(_DWORD, _DWORD, _DWORD, _DWORD); weak
int sub_6D35C(unsigned __int16 a1);
int sub_6D5EC(int a1, int a2);
// _DWORD strcpy(_DWORD, _DWORD); weak
// _DWORD strcat(_DWORD, _DWORD); weak
void sub_6DD6C();
int sub_6DD7D(int a1, int a2, __int16 a3);
void sub_6DE12();
void sub_6DE23();
int sub_6DE34(__int16 a1, int a2, unsigned int a3, unsigned int a4, int *a5, unsigned int a6);
int sub_6E030(unsigned int a1);
int sub_6E09A(__int16 a1, int a2, unsigned int a3, int *a4, unsigned int a5);
int sub_6E23C(int a1, __int16 a2);
void sub_6E295();
void sub_6E2A6();
void sub_6E33D();
void sub_6E34E();
void sub_6E3B9();
void *sub_6E5A0();
void *sub_6E5A6();
int sub_6E5B2();
unsigned int __stdcall sub_6E65B(unsigned __int16 a1, unsigned __int16 a2);
int __stdcall sub_6E6BF(unsigned __int16 a1);
void __stdcall sub_6E727(unsigned __int16 a1, unsigned __int16 a2);
int __stdcall sub_6E7A0(unsigned __int16 a1);
void __stdcall sub_6E822(int a1, __int16 a2, __int16 a3);
int __stdcall sub_6E976(unsigned __int16 a1, unsigned __int16 a2);
int __stdcall sub_6E9A4(int a1, unsigned __int16 a2, unsigned __int16 a3);
int __stdcall sub_6EA0F(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4);
int __stdcall sub_6ED47(unsigned __int16 a1);
int __stdcall sub_6ED75(__int16 a1);
int sub_6EDD0(int a1, int a2, int a3, int a4, unsigned __int16 a5, int a6, int a7);
void __stdcall sub_6F3B3(int a1, __int16 a2, unsigned __int16 a3);
void sub_6F4CB(int a1, int a2, int a3, int a4, unsigned __int16 a5, unsigned __int16 a6, unsigned __int16 a7);
void __stdcall sub_6F502(__int16 a1, unsigned __int16 a2);
void __stdcall sub_6F536(__int16 a1, unsigned __int16 a2);
void __stdcall sub_6F55F(__int16 a1, unsigned __int16 a2);
void __stdcall sub_6F588(char a1, unsigned __int16 a2);
int __stdcall sub_6F5A8(unsigned __int8 a1, unsigned __int16 a2);
int __stdcall sub_6F6AF(char a1, unsigned __int16 a2);
int __stdcall sub_6F6D8(unsigned __int16 a1, unsigned __int16 a2);
void __stdcall sub_6F77A(unsigned __int16 a1, unsigned __int16 a2);
int __stdcall sub_6F824(unsigned __int8 a1, unsigned __int16 a2);
void __stdcall sub_6F850(int a1, unsigned __int16 a2);
int __stdcall sub_6F872(__int16 a1, unsigned __int16 a2);
int __stdcall sub_6F8F1(__int16 a1, unsigned __int16 a2);
void __stdcall sub_6F963(int a1, __int16 a2);
void __stdcall sub_6F9F9(int a1, __int16 a2);
int __stdcall sub_6FA53(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3);
void __stdcall sub_6FC44(unsigned __int16 a1, __int16 a2);
void __stdcall sub_6FDA4(int a1, int a2, int a3);
void __stdcall sub_6FDAC(unsigned __int16 a1, __int16 a2);
int __stdcall sub_6FDEC(unsigned __int8 a1, unsigned __int8 a2, __int16 a3);
int __stdcall sub_6FEBF(unsigned __int16 a1);
int __stdcall sub_6FF53(unsigned __int16 a1);
char __stdcall sub_70044(__int16 a1);
_BOOL1 sub_7008A();
unsigned int __stdcall sub_70113(__int16 a1);
unsigned int sub_70148();
void sub_7024E();
unsigned int sub_702F6();
void sub_706CC();
void sub_70812();
int sub_70AA0();
int sub_70B3E();
char sub_70B8B(unsigned int a1, unsigned __int8 a2);
unsigned __int8 sub_70D55(unsigned __int8 a1);
int sub_70E1C(int a1, int a2, unsigned int a3);
char *sub_71012();
void sub_7101B();
// int _FDFS(void); weak
void sub_71524();
int sub_71B53();
void sub_71BC9(int a1, const void *a2, void *a3);
int sub_724C0(__int16 a1, __int16 a2);
void sub_725C8(__int16 a1, unsigned __int16 a2, __int16 a3);
// __int16 sub_72652(__int16 a1, int a2, int a3, __int16 a4);
// __int16 sub_726E7(__int16 a1, int a2, int a3, __int16 a4);
char sub_72807(unsigned __int8 *a1, _BYTE *a2);
void sub_729A3(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void sub_79495(int a1, int a2, int a3, int a4, int a5);
void sub_79906(int a1);
void sub_79A1B(int a1);
int sub_79A70(int result, _BYTE *a2, _BYTE *a3, int a4, int a5, int a6);
void sub_79B2D();
// int gettextposition(_DWORD); weak
// _DWORD settextposition(_DWORD, _DWORD); weak
// _DWORD outtext(_DWORD); weak
int sub_7B444();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_10080; // weak
_UNKNOWN loc_13880; // weak
_UNKNOWN loc_1FFFE; // weak
_UNKNOWN loc_270FA; // weak
_UNKNOWN loc_27FFC; // weak
_UNKNOWN loc_2809F; // weak
_UNKNOWN loc_2F945; // weak
_UNKNOWN loc_30D40; // weak
char byte_385D3[] = { '\x80' }; // weak
char byte_385D7[] = { '\0' }; // weak
char algn_385D8[8] = { '\x8D', '\x92', '\0', '\0', '\0', '\0', '\x8B', '\xC0' }; // weak
char byte_385E3[28] =
{
  '\xFF',
  '\xFF',
  '\x89',
  '\xC3',
  '\x89',
  '\x04',
  '$',
  '\x85',
  '\xC0',
  '\x0F',
  '\x84',
  '\x9E',
  '\0',
  '\0',
  '\0',
  '\xB9',
  ')',
  '\0',
  '\0',
  '\0',
  '\x89',
  '\xC7',
  '\x89',
  '\xEE',
  '\xF3',
  '\xA5',
  '\x8B',
  '\r'
}; // weak
char byte_38647[] = { '\xC1' }; // weak
char byte_38C93[] = { '\0' }; // weak
char byte_38C95[] = { '\0' }; // weak
char byte_38C97[8] = { 'S', '\x04', 'f', '\x89', 'C', '~', 'i', '\xC2' }; // weak
int dword_38C9F = 9377; // weak
int dword_38CA3[] = { 2416389 }; // weak
__int16 word_38D03 = 21642; // weak
int dword_38D05 = -695727103; // weak
_UNKNOWN loc_3FFFE; // weak
__int16 word_41104[] = { 1 }; // weak
_UNKNOWN locret_455C0; // weak
int dword_4A12C = 0; // weak
__int16 word_4A130[] = { 0 }; // weak
int dword_4A17C[6] = { 21037056, -16777216, 255, 1912602624, 138477568, 0 }; // weak
int dword_4A1C0[2] = { 172032000, 0 }; // weak
int dword_4A1E4[2] = { 172032000, 0 }; // weak
int dword_4A1FC[2] = { 89063424, 0 }; // weak
int dword_4A568[2] = { 88145920, 0 }; // weak
int dword_4A5D8[2] = { 172032000, 0 }; // weak
int dword_4A620[2] = { 172032000, 0 }; // weak
int dword_4A638[2] = { 138477568, 0 }; // weak
char *off_4A66C[22] =
{
  (char*)"No sound",
  (char*)"NONE",
  (char*)"Soundblaster",
  (char*)"SBLAST",
  (char*)"Soundblaster pro",
  (char*)"SBPRO",
  (char*)"Soundblaster 16",
  (char*)"SB16",
  (char*)"Adlib gold",
  (char*)"ADLIBG",
  (char*)"Microsoft 8",
  (char*)"MICROSOFT8",
  (char*)"Microsoft 16",
  (char*)"MICROSOFT16",
  (char*)"Pro audio spectrum 8",
  (char*)"PAS8",
  (char*)"Pro audio spectrum 16",
  (char*)"PAS16",
  (char*)"Sound master II",
  (char*)"SOUNDMASTERII",
  (char*)"Soundblaster compatible",
  (char*)"COMPATIBLE"
}; // weak
char *off_4A670[21] =
{
  (char*)"NONE",
  (char*)"Soundblaster",
  (char*)"SBLAST",
  (char*)"Soundblaster pro",
  (char*)"SBPRO",
  (char*)"Soundblaster 16",
  (char*)"SB16",
  (char*)"Adlib gold",
  (char*)"ADLIBG",
  (char*)"Microsoft 8",
  (char*)"MICROSOFT8",
  (char*)"Microsoft 16",
  (char*)"MICROSOFT16",
  (char*)"Pro audio spectrum 8",
  (char*)"PAS8",
  (char*)"Pro audio spectrum 16",
  (char*)"PAS16",
  (char*)"Sound master II",
  (char*)"SOUNDMASTERII",
  (char*)"Soundblaster compatible",
  (char*)"COMPATIBLE"
}; // weak
char *off_4A6CC[24] =
{
  (char*)"No music",
  (char*)"NONE",
  (char*)"Adlib fm",
  (char*)"ADLIB",
  (char*)"Adlib gold fm",
  (char*)"ADLIBG",
  (char*)"Soundblaster fm",
  (char*)"SBLAST",
  (char*)"Soundblaster pro fm",
  (char*)"SBPRO",
  (char*)"Soundblaster 16 fm",
  (char*)"SB16FM",
  (char*)"Soundblaster AWE 32",
  (char*)"SBAWE32",
  (char*)"Wave blaster",
  (char*)"WBLAST",
  (char*)"Roland mt32",
  (char*)"ROLAND",
  (char*)"General midi",
  (char*)"GENERAL",
  (char*)"Pro audio spectrum fm",
  (char*)"PASFM",
  (char*)"Soundblaster compatible",
  (char*)"COMPATIBLE"
}; // weak
char *off_4A6D0[23] =
{
  (char*)"NONE",
  (char*)"Adlib fm",
  (char*)"ADLIB",
  (char*)"Adlib gold fm",
  (char*)"ADLIBG",
  (char*)"Soundblaster fm",
  (char*)"SBLAST",
  (char*)"Soundblaster pro fm",
  (char*)"SBPRO",
  (char*)"Soundblaster 16 fm",
  (char*)"SB16FM",
  (char*)"Soundblaster AWE 32",
  (char*)"SBAWE32",
  (char*)"Wave blaster",
  (char*)"WBLAST",
  (char*)"Roland mt32",
  (char*)"ROLAND",
  (char*)"General midi",
  (char*)"GENERAL",
  (char*)"Pro audio spectrum fm",
  (char*)"PASFM",
  (char*)"Soundblaster compatible",
  (char*)"COMPATIBLE"
}; // weak

__int16 word_A9990 = 48; // weak

char *off_4A734[4] = { (char*)"220", (char*)"220", (char*)"240", (char*)"240" }; // weak
char *off_4A738[3] = { (char*)"220", (char*)"240", (char*)"240" }; // weak
char *off_4A74C[2] = { (char*)"2", (char*)"2" }; // weak
char *off_4A750 = (char*)"2"; // weak
__int16 *off_4A77C[2] = { &word_A9990, &word_A9990 }; // weak
__int16 *off_4A780 = &word_A9990; // weak
void *off_4A79C = &unk_A9998; // weak
void *off_4A7A0 = &unk_A9998; // weak
int *off_4A7B4[2] = { &dword_A99A0, &dword_A99A0 }; // weak
int *off_4A7B8 = &dword_A99A0; // weak
__int16 word_4A7CC[] = { 51 }; // weak
__int16 word_4A7CE[] = { 47 }; // weak
int dword_4A7EC[] = { 170 }; // weak
int dword_4A7F0[] = { 0 }; // weak
int dword_4A7F4[] = { 150 }; // weak
int dword_4A7F8[] = { 36 }; // weak
char byte_4A84B[] = { '\0' }; // weak
char byte_4A884[] = { '\0' }; // weak
__int16 word_4A8BE[] = { 177 }; // weak
__int16 word_4A8C0[] = { 48 }; // weak
__int16 word_4A8C2[] = { 9 }; // weak
__int16 word_4A8C4[] = { 4 }; // weak
//wchar_t asc_4A8F4[5] = L"\n=-=_"; // weak
char asc_4A8F4[5] = { '\n','=','-','=','_'};// L"\n=-=_"; // weak
char byte_4A905[] = { '\0' }; // weak
char byte_4A93E[] = { ' ' }; // weak
_UNKNOWN loc_4AFFD; // weak
_UNKNOWN loc_4E200; // weak
_UNKNOWN sub_5BE6C; // weak
// extern _UNKNOWN _GETDS; weak
int dword_74F95[] = { 0 }; // weak
int dword_80000; // weak
int dword_80010; // weak
int dword_80120; // weak
char byte_90000[4] = { '\x01', '\x01', '\x01', '\0' }; // weak
int dword_90004 = 0; // weak
int dword_90008 = 0; // weak
__int16 word_9000C = 0; // weak
__int16 word_9000E = 0; // weak
__int16 word_90010 = 0; // weak
__int16 word_90012 = 0; // weak
__int16 word_90016 = 0; // weak
int dword_9001C = 0; // weak
__int16 word_90024 = 1; // weak
__int16 word_90026 = 0; // weak
int dword_90028 = 0; // weak
char byte_9002C = '\0'; // weak
__int16 word_90030 = 0; // weak
__int16 word_90034[24] =
{
  2,
  1,
  32,
  10,
  1,
  0,
  0,
  4,
  400,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  40,
  600,
  0,
  1,
  4,
  2,
  3,
  4
}; // weak
__int16 word_90064 = 0; // weak
int dword_90066 = 0; // weak
int dword_9006A = 0; // weak
int dword_9006E = 0; // weak
int dword_90072 = 0; // weak
char byte_90076 = '\0'; // weak
_UNKNOWN unk_90078; // weak
char byte_90084 = '\0'; // weak
char byte_90085 = '\0'; // weak
char byte_90086 = '\0'; // weak
char byte_90087 = '\0'; // weak
char byte_90088 = '\0'; // weak
char byte_90089 = '\0'; // weak
char byte_9008C = '\0'; // weak
char byte_9008D = '\x01'; // weak
char byte_9008E = '\0'; // weak
char byte_9008F = '\xFE'; // weak
char byte_90090 = '\0'; // weak
char byte_90091 = '\0'; // weak
char byte_90094 = 'c'; // weak
char byte_90096 = '('; // weak
int dword_90098 = 0; // weak
char byte_9009E = '\0'; // weak
int dword_900A0 = 0; // weak
int dword_900A4[8] = { 256, 512, 1024, 2048, 4096, 9192, 18384, 36768 }; // weak
char byte_900C4[164] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_90168[] = { '\0' }; // weak
char byte_9020C[164] =
{
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
int dword_902B0 = 0; // weak
_UNKNOWN unk_902B4; // weak
_UNKNOWN unk_902DC; // weak
char byte_906DC[] = { '\0' }; // weak
char byte_906E2[] = { '\x01' }; // weak
char byte_906E8[16] =
{
  '\0',
  '\x01',
  '\x01',
  '\x02',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x04',
  '\x03',
  '\x03',
  '\x02',
  '\x02',
  '\x01',
  '\x01',
  '\0'
}; // weak
char byte_906F8[16] =
{
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0'
}; // weak
char byte_90708 = '\0'; // weak
int dword_9070C = 20; // weak
int dword_90710 = 0; // weak
int dword_90714 = 0; // weak
int dword_9074C[] = { 0 }; // weak
char byte_90754 = '\0'; // weak
int dword_90758 = 1; // weak
_UNKNOWN unk_9075C; // weak
_UNKNOWN unk_909AC; // weak
_UNKNOWN unk_909BC; // weak
_UNKNOWN unk_909EC; // weak
_UNKNOWN unk_909FC; // weak
_UNKNOWN unk_90A2C; // weak
char byte_90AD4 = '\0'; // weak
char byte_90AD5 = '\0'; // weak
char byte_90AD8[42] =
{
  '\x01',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
__int16 word_90B02[] = { 0 }; // weak
_UNKNOWN unk_90B04; // weak
__int16 word_90B0C[4] = { 0, 0, 0, 0 }; // weak
int dword_90B14 = 0; // weak
int dword_90B18 = 0; // weak
__int16 word_90B1C = 0; // weak
__int16 word_90B1E = 0; // weak
char byte_90B20 = '\0'; // weak
char byte_90B21 = '\0'; // weak
char byte_90B22 = '\0'; // weak
char byte_90B23 = '\0'; // weak
__int16 word_90B24 = 394; // weak
__int16 word_90B26 = 226; // weak
__int16 word_90B2C = 394; // weak
__int16 word_90B2E = 224; // weak
__int16 word_90B34 = 394; // weak
__int16 word_90B36 = 228; // weak
char byte_90B48 = '\0'; // weak
int dword_90B4C[256] =
{
  0,
  201,
  402,
  603,
  804,
  1005,
  1206,
  1407,
  1608,
  1809,
  2010,
  2211,
  2412,
  2613,
  2814,
  3015,
  3216,
  3417,
  3617,
  3818,
  4019,
  4219,
  4420,
  4621,
  4821,
  5022,
  5222,
  5422,
  5623,
  5823,
  6023,
  6224,
  6424,
  6624,
  6824,
  7024,
  7224,
  7423,
  7623,
  7823,
  8022,
  8222,
  8421,
  8621,
  8820,
  9019,
  9218,
  9417,
  9616,
  9815,
  10014,
  10212,
  10411,
  10609,
  10808,
  11006,
  11204,
  11402,
  11600,
  11798,
  11996,
  12193,
  12391,
  12588,
  12785,
  12983,
  13180,
  13376,
  13573,
  13770,
  13966,
  14163,
  14359,
  14555,
  14751,
  14947,
  15143,
  15338,
  15534,
  15729,
  15924,
  16119,
  16314,
  16508,
  16703,
  16897,
  17091,
  17285,
  17479,
  17673,
  17867,
  18060,
  18253,
  18446,
  18639,
  18832,
  19024,
  19216,
  19409,
  19600,
  19792,
  19984,
  20175,
  20366,
  20557,
  20748,
  20939,
  21129,
  21320,
  21510,
  21699,
  21889,
  22078,
  22268,
  22457,
  22645,
  22834,
  23022,
  23210,
  23398,
  23586,
  23774,
  23961,
  24148,
  24335,
  24521,
  24708,
  24894,
  25080,
  25265,
  25451,
  25636,
  25821,
  26005,
  26190,
  26374,
  26558,
  26742,
  26925,
  27108,
  27291,
  27474,
  27656,
  27838,
  28020,
  28202,
  28383,
  28564,
  28745,
  28926,
  29106,
  29286,
  29466,
  29645,
  29824,
  30003,
  30182,
  30360,
  30538,
  30716,
  30893,
  31071,
  31248,
  31424,
  31600,
  31776,
  31952,
  32127,
  32303,
  32477,
  32652,
  32826,
  33000,
  33173,
  33347,
  33520,
  33692,
  33865,
  34037,
  34208,
  34380,
  34551,
  34721,
  34892,
  35062,
  35231,
  35401,
  35570,
  35738,
  35907,
  36075,
  36243,
  36410,
  36577,
  36744,
  36910,
  37076,
  37241,
  37407,
  37572,
  37736,
  37900,
  38064,
  38228,
  38391,
  38554,
  38716,
  38878,
  39040,
  39201,
  39362,
  39523,
  39683,
  39843,
  40002,
  40161,
  40320,
  40478,
  40636,
  40794,
  40951,
  41108,
  41264,
  41420,
  41576,
  41731,
  41886,
  42040,
  42194,
  42348,
  42501,
  42654,
  42806,
  42958,
  43110,
  43261,
  43412,
  43562,
  43713,
  43862,
  44011,
  44160,
  44308,
  44456,
  44604,
  44751,
  44898,
  45044,
  45190,
  45335,
  45480,
  45625,
  45769,
  45912,
  46056,
  46199
}; // weak
int dword_90F4C[256] =
{
  46341,
  46483,
  46624,
  46765,
  46906,
  47046,
  47186,
  47325,
  47464,
  47603,
  47741,
  47878,
  48015,
  48152,
  48288,
  48424,
  48559,
  48694,
  48828,
  48962,
  49095,
  49228,
  49361,
  49493,
  49624,
  49756,
  49886,
  50016,
  50146,
  50275,
  50404,
  50532,
  50660,
  50787,
  50914,
  51041,
  51166,
  51292,
  51417,
  51541,
  51665,
  51789,
  51911,
  52034,
  52156,
  52277,
  52398,
  52519,
  52639,
  52759,
  52878,
  52996,
  53114,
  53232,
  53349,
  53465,
  53581,
  53697,
  53812,
  53926,
  54040,
  54154,
  54267,
  54379,
  54491,
  54603,
  54714,
  54824,
  54934,
  55043,
  55152,
  55260,
  55368,
  55476,
  55582,
  55689,
  55794,
  55900,
  56004,
  56108,
  56212,
  56315,
  56418,
  56520,
  56621,
  56722,
  56823,
  56923,
  57022,
  57121,
  57219,
  57317,
  57414,
  57511,
  57607,
  57703,
  57798,
  57892,
  57986,
  58079,
  58172,
  58265,
  58356,
  58448,
  58538,
  58628,
  58718,
  58807,
  58896,
  58983,
  59071,
  59158,
  59244,
  59330,
  59415,
  59499,
  59583,
  59667,
  59750,
  59832,
  59914,
  59995,
  60075,
  60156,
  60235,
  60314,
  60392,
  60470,
  60547,
  60624,
  60700,
  60776,
  60851,
  60925,
  60999,
  61072,
  61145,
  61217,
  61288,
  61359,
  61429,
  61499,
  61568,
  61637,
  61705,
  61772,
  61839,
  61906,
  61971,
  62036,
  62101,
  62165,
  62228,
  62291,
  62353,
  62415,
  62476,
  62536,
  62596,
  62655,
  62714,
  62772,
  62830,
  62886,
  62943,
  62998,
  63054,
  63108,
  63162,
  63215,
  63268,
  63320,
  63372,
  63423,
  63473,
  63523,
  63572,
  63621,
  63668,
  63716,
  63763,
  63809,
  63854,
  63899,
  63944,
  63987,
  64031,
  64073,
  64115,
  64156,
  64197,
  64237,
  64277,
  64316,
  64354,
  64392,
  64429,
  64465,
  64501,
  64536,
  64571,
  64605,
  64639,
  64672,
  64704,
  64735,
  64766,
  64797,
  64827,
  64856,
  64884,
  64912,
  64940,
  64967,
  64993,
  65018,
  65043,
  65067,
  65091,
  65114,
  65137,
  65159,
  65180,
  65200,
  65220,
  65240,
  65259,
  65277,
  65294,
  65311,
  65328,
  65343,
  65358,
  65373,
  65387,
  65400,
  65413,
  65425,
  65436,
  65447,
  65457,
  65467,
  65476,
  65484,
  65492,
  65499,
  65505,
  65511,
  65516,
  65521,
  65525,
  65528,
  65531,
  65533,
  65535,
  65536
}; // weak
void (*off_9134C[2])() = { &sub_10000, &sub_10000 }; // weak
int dword_9334C[148] =
{
  0,
  32,
  64,
  96,
  128,
  160,
  192,
  224,
  8192,
  8224,
  8256,
  8288,
  8320,
  8352,
  8384,
  8416,
  16384,
  16416,
  16448,
  16480,
  16512,
  16544,
  16576,
  16608,
  24576,
  24608,
  24640,
  24672,
  24704,
  24736,
  24768,
  24800,
  32768,
  32800,
  32832,
  32864,
  32896,
  32928,
  32960,
  32992,
  40960,
  40992,
  41024,
  41056,
  41088,
  41120,
  41152,
  41184,
  49152,
  49184,
  49216,
  49248,
  49280,
  49312,
  49344,
  49376,
  57344,
  57376,
  57408,
  57440,
  57472,
  57504,
  57536,
  57568,
  65536,
  65568,
  65600,
  65632,
  65664,
  65696,
  65728,
  65760,
  73728,
  73760,
  73792,
  73824,
  73856,
  73888,
  73920,
  73952,
  81920,
  81952,
  81984,
  82016,
  82048,
  82080,
  82112,
  82144,
  90112,
  90144,
  90176,
  90208,
  90240,
  90272,
  90304,
  90336,
  98304,
  98336,
  98368,
  98400,
  98432,
  98464,
  98496,
  98528,
  106496,
  106528,
  106560,
  106592,
  106624,
  106656,
  106688,
  106720,
  114688,
  114720,
  114752,
  114784,
  114816,
  114848,
  114880,
  114912,
  122880,
  122912,
  122944,
  122976,
  123008,
  123040,
  123072,
  123104,
  131072,
  131104,
  131136,
  131168,
  131200,
  131232,
  131264,
  131296,
  139264,
  139296,
  139328,
  139360,
  139392,
  139424,
  139456,
  139488,
  147456,
  147488,
  147520,
  147552
}; // weak
void *off_9359C = &loc_24080; // weak
__int16 word_9374C[258] =
{
  0,
  1,
  2,
  3,
  5,
  6,
  7,
  8,
  10,
  11,
  12,
  13,
  15,
  16,
  17,
  19,
  20,
  21,
  22,
  24,
  25,
  26,
  27,
  29,
  30,
  31,
  32,
  34,
  35,
  36,
  38,
  39,
  40,
  41,
  43,
  44,
  45,
  46,
  48,
  49,
  50,
  51,
  53,
  54,
  55,
  56,
  57,
  59,
  60,
  61,
  62,
  64,
  65,
  66,
  67,
  68,
  70,
  71,
  72,
  73,
  75,
  76,
  77,
  78,
  79,
  81,
  82,
  83,
  84,
  85,
  87,
  88,
  89,
  90,
  91,
  92,
  94,
  95,
  96,
  97,
  98,
  99,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  118,
  119,
  120,
  121,
  122,
  123,
  124,
  125,
  126,
  127,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  198,
  199,
  200,
  201,
  202,
  203,
  203,
  204,
  205,
  206,
  207,
  208,
  208,
  209,
  210,
  211,
  212,
  212,
  213,
  214,
  215,
  216,
  216,
  217,
  218,
  219,
  220,
  220,
  221,
  222,
  223,
  223,
  224,
  225,
  226,
  226,
  227,
  228,
  229,
  229,
  230,
  231,
  232,
  232,
  233,
  234,
  235,
  235,
  236,
  237,
  237,
  238,
  239,
  239,
  240,
  241,
  242,
  242,
  243,
  244,
  244,
  245,
  246,
  246,
  247,
  248,
  248,
  249,
  250,
  250,
  251,
  252,
  252,
  253,
  254,
  254,
  255,
  256,
  0
}; // weak
char byte_93950 = '\0'; // weak
char byte_93954 = '\x01'; // weak
char byte_93958 = '\0'; // weak
char byte_93959 = '\0'; // weak
__int16 word_9395A = -1; // weak
__int16 word_9395C = 0; // weak
int dword_93960 = 0; // weak
int dword_93964 = 0; // weak
int dword_93968[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
__int16 word_93988 = 0; // weak
__int16 word_9398A = 0; // weak
int dword_9398C = 0; // weak
int dword_93990[7] = { 0, 0, 0, 0, 0, 0, 0 }; // weak
char byte_939AF[] = { '\0' }; // weak
char byte_939B0[] = { '\0' }; // weak
char aTester[7] = "TESTER"; // weak
char byte_939CC = '\x01'; // weak
char byte_939CD = '\x01'; // weak
__int16 word_939D0 = 0; // weak
__int16 word_939D2 = 0; // weak
char byte_939D4 = '\0'; // weak
__int16 word_939D6 = 0; // weak
char byte_939E4 = '\x01'; // weak
char byte_939E5 = '\x01'; // weak
char byte_939E6 = '\x01'; // weak
char byte_939EC = '\0'; // weak
char byte_939ED = '\0'; // weak
int dword_939F0 = 0; // weak
__int16 word_939F4 = 0; // weak
int dword_939F8 = 0; // weak
__int16 word_939FC = 0; // weak
__int16 word_93A00 = 32767; // weak
__int16 word_93A02 = 4096; // weak
__int16 word_93A0C = 0; // weak
__int16 word_93A22 = 0; // weak
_UNKNOWN unk_93A44; // weak
int dword_93A54 = 0; // weak
int dword_93A60 = 0; // weak
__int16 word_93A64 = 0; // weak
char byte_93A84 = '\0'; // weak
int dword_93A88 = 16; // weak
int dword_93A8C = -80; // weak
int dword_93A90 = 80; // weak
int dword_93A94 = -4; // weak
__int16 word_93AA8 = 16; // weak
int dword_93AAC = -80; // weak
int dword_93AB0 = 80; // weak
__int16 word_93AB4 = -4; // weak
int dword_93AC8 = 0; // weak
int dword_93ACC = 0; // weak
int dword_93AD0 = 0; // weak
int dword_93AD4 = 0; // weak
int dword_93AD8 = 0; // weak
int dword_93ADC = 0; // weak
_UNKNOWN unk_93AE0; // weak
_UNKNOWN unk_96000; // weak
char byte_967E0 = 'p'; // weak
char byte_967E1 = '\0'; // weak
char byte_967E4 = '\0'; // weak
int dword_96860[] = { 83894304 }; // weak
char *off_96864[5] =
{
  (char*)"Game One            ",
  (char*)"Game Two            ",
  (char*)"Game Three          ",
  (char*)"Game Four           ",
  (char*)"Game Five           "
}; // weak
char byte_9687C = '\x01'; // weak
int dword_96880 = 0; // weak
int dword_96884 = 0; // weak
char byte_96888 = '\x01'; // weak
char byte_9688A = '\0'; // weak
int dword_9688C = 0; // weak
char byte_96890 = '\x01'; // weak
char byte_96892 = '\0'; // weak
int dword_96894 = 0; // weak
__int16 word_96898 = 16; // weak
char byte_9689C[] = { '\x01' }; // weak
char byte_9689D[] = { '\0' }; // weak
char byte_9689E[22] =
{
  '\x03',
  '\x01',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\x03'
}; // weak
__int16 word_968B4[8] = { 17, 18, 23, 24, 25, 26, 28, 25970 }; // weak
int dword_968C4 = 0; // weak
int dword_968C8 = 0; // weak
int dword_968CC = 0; // weak
int dword_968D0 = 0; // weak
int dword_968D4 = 0; // weak
__int16 word_968D8 = 0; // weak
char byte_968E0 = '\x7F'; // weak
char byte_968E1 = '\0'; // weak
char byte_968E4 = '\0'; // weak
char byte_968E8 = '\0'; // weak
int dword_968EC = -1; // weak
char byte_968F0 = '\x01'; // weak
int dword_96902 = 0; // weak
int dword_96906 = 0; // weak
int (*off_97D12)(int) = (int(*)(int))&sub_3A490; // weak
int (*off_987DE)(int) = &sub_3C090; // weak
__int16 word_989C6 = 5; // weak
_UNKNOWN unk_98F38; // weak
_UNKNOWN unk_98F58; // weak
_UNKNOWN unk_98F78; // weak
void *off_98F98 = &unk_110003; // weak
void *off_98FB8 = &unk_B0004; // weak
void *off_98FD8 = &loc_50005; // weak
_UNKNOWN unk_98FF8; // weak
_UNKNOWN unk_99018; // weak
_UNKNOWN unk_99038; // weak
_UNKNOWN unk_99058; // weak
_UNKNOWN unk_99078; // weak
_UNKNOWN unk_990B8; // weak
_UNKNOWN unk_990D8; // weak
_UNKNOWN unk_990F8; // weak
_UNKNOWN unk_99158; // weak
_UNKNOWN unk_99178; // weak
_UNKNOWN unk_991B8; // weak
_UNKNOWN unk_991D8; // weak
_UNKNOWN unk_991F8; // weak
_UNKNOWN unk_99218; // weak
_UNKNOWN unk_99238; // weak
_UNKNOWN unk_99258; // weak
char aSearchd[9] = "*SearchD"; // weak
char aDataEtextDat[15] = "data/etext.dat"; // weak
char aDataFtextDat[15] = "data/ftext.dat"; // weak
char aDataGtextDat[15] = "data/gtext.dat"; // weak
char aDataItextDat[15] = "data/itext.dat"; // weak
char aDataBlk00Dat[16] = "data/blk0-0.dat"; // weak
char aDataBlk01Dat[16] = "data/blk0-1.dat"; // weak
char aWscreen[9] = "*WScreen"; // weak
char aWscreen_0[9] = "*WScreen"; // weak
int *off_99974 = &dword_AE450; // weak
int dword_999B8[] = { 0 }; // weak
char *off_99A84[20] =
{
  (char*)"Bussorah",
  (char*)"Bisnagar",
  (char*)"Tartary",
  (char*)"Akkania",
  (char*)"Ryahn",
  (char*)"Zhullor",
  (char*)"Dombren",
  (char*)"Xushtan",
  (char*)"Wazzad",
  (char*)"Phiria",
  (char*)"Moussul",
  (char*)"Aleppo",
  (char*)"Schiraz",
  (char*)"Ispahan",
  (char*)"Coam",
  (char*)"Rei",
  (char*)"Buddoor",
  (char*)"Jehoun",
  (char*)"Nurrir",
  (char*)"Comari"
}; // weak
char byte_99B58[] = { '\xB7' }; // weak
char byte_99B59[15] =
{
  'q',
  '}',
  'z',
  '\x9D',
  '\x9A',
  '\a',
  'Z',
  '\x1D',
  '\x1B',
  '\xDD',
  '\xDA',
  '<',
  '9',
  '\x10',
  '\x0E'
}; // weak
char *off_99B68[8] =
{
  (char*)"Zanzamar",
  (char*)"Vodor",
  (char*)"Gryshnak",
  (char*)"Mahmoud",
  (char*)"Syed",
  (char*)"Raschid",
  (char*)"Alhabbal",
  (char*)"Scheherazade"
}; // weak
char byte_99B88[24] =
{
  '\0',
  '\x03',
  '\x02',
  '\x10',
  '\x01',
  '\x0E',
  '\x04',
  '\f',
  '\x06',
  '\t',
  '\a',
  '\b',
  '\x0F',
  '\x12',
  '\x11',
  '\x13',
  '\r',
  '\x05',
  '\v',
  '\n',
  '\x14',
  '\x15',
  '\x16',
  '\x17'
}; // weak
_UNKNOWN unk_99BA0; // weak
__int16 word_99BA6[] = { 0 }; // weak
__int16 word_99BA8[] = { 250 }; // weak
char byte_99BAC[] = { '\0' }; // weak
char *off_9AB44[2] = { (char*)"             Designed by", (char*)"BULLFROG PRODUCTIONS LTD" }; // weak
char byte_9AD04 = '\0'; // weak
char byte_9AD08 = '\0'; // weak
char byte_9AD09 = '\0'; // weak
char byte_9AD0C[] = { '\0' }; // weak
int dword_9AD88 = 0; // weak
__int16 word_9AD8C = 320; // weak
__int16 word_9AD8E = 200; // weak
int dword_9AD90 = 13107520; // weak
char byte_9AD96 = '\0'; // weak
int dword_9AD98 = 0; // weak
__int16 word_9AD9C = 0; // weak
int dword_9AD9E = 0; // weak
__int16 word_9ADA2 = 0; // weak
int dword_9ADA4 = 0; // weak
__int16 word_9ADA8 = 0; // weak
__int16 word_9ADB4 = 0; // weak
int dword_9ADBC = 0; // weak
int dword_9ADC0 = 0; // weak
int dword_9ADC4 = 5; // weak
_UNKNOWN unk_9ADC8; // weak
__int16 word_9ADFA = 0; // weak
__int16 word_9ADFC = 0; // weak
char aDataMusic00Dat[18] = "data/music0-0.dat"; // weak
char aDataMusic00Tab[18] = "data/music0-0.tab"; // weak
char aDataSnds00Dat[17] = "data/snds0-0.dat"; // weak
char aDataSnds00Tab[17] = "data/snds0-0.tab"; // weak
int dword_9AF08 = 0; // weak
int dword_9AF0C = 0; // weak
int dword_9AF10 = 0; // weak
int dword_9AF14 = 0; // weak
_UNKNOWN unk_9AF18; // weak
char byte_9AF9C = '\0'; // weak
int dword_9AFA0 = 0; // weak
__int16 word_9AFA4 = 0; // weak
char byte_9AFA8 = '\0'; // weak
__int16 word_9AFC0[64] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int16 word_9B040[64] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int16 word_9B0C0[64] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_9B140 = 0; // weak
int dword_9B144 = 0; // weak
__int16 word_9B14A = 0; // weak
__int16 word_9B14C = 0; // weak
__int16 word_9B14E = 0; // weak
char byte_9B150 = '\0'; // weak
char byte_9B151 = '\0'; // weak
int dword_9B15C = 0; // weak
__int16 word_9B160[] = { 0 }; // weak
int dword_9B17A[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_9B18E[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_9B1A2[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_9B1B6[6] = { 0, 0, 0, 0, 0, 0 }; // weak
char byte_9B1F2[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_9B7F2[256] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_9BBF2[256] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_9BFF2 = 0; // weak
__int16 word_9BFF6[] = { 0 }; // weak
int dword_9C022[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_9C042[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
char byte_9C062[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
char byte_9C068[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
char byte_9C06E[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
char byte_9C074[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
_DWORD byte_9C07A[39] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_9C116[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_9C136[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
char byte_9C156[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  '\x03',
  '\x02',
  '\x03',
  '\x02',
  '\x02',
  '\x03',
  '\0'
}; // weak
char byte_9C166[] = { '\0' }; // weak
char byte_9C176[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_9C1A6[8] = { -1, -1, -1, -1, -1, -1, -1, -1 }; // weak
char aHmimdrv386[12] = "hmimdrv.386"; // weak
_UNKNOWN unk_9C1D2; // weak
int dword_9C1F2 = 0; // weak
_UNKNOWN unk_9C1FE; // weak
int dword_9C222 = 0; // weak
int dword_9C226 = 0; // weak
int dword_9C22A = 0; // weak
int (*byte_9C22E)(_DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int dword_9C234[] = { 0 }; // weak
int dword_9C238 = 0; // weak
__int16 word_9C23C = 0; // weak
int dword_9C9B4[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_9C9C8[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_9C9DC[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_9C9F0[5] = { 0, 0, 0, 0, 0 }; // weak
char byte_9CA04[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
char byte_9D904[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_9D922[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_9D936[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_9D94A[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_9D95E[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_9D972[5] = { 0, 0, 0, 0, 0 }; // weak
char byte_9D986[] = { 'H' }; // weak
int dword_9D98F[] = { 0 }; // weak
__int16 word_9D993 = 0; // weak
char byte_9DF8F[640] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // weak
char byte_9E20F[80] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // weak
char byte_9E25F[80] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // weak
char byte_9E2AF[80] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // weak
char byte_9E2FF[] = { '\xFF' }; // weak
char byte_9E300[] = { '\xFF' }; // weak
char byte_9E301[] = { '\xFF' }; // weak
char byte_9E302[] = { '\xFF' }; // weak
char byte_9E303[1596] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // weak
char byte_9E93F[640] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // weak
char byte_9EBBF = '\0'; // weak
char byte_9EBC0 = '\0'; // weak
char byte_9EBC1 = '\0'; // weak
int dword_9EBC9 = 1; // weak
char byte_9EBDD = '\x01'; // weak
char byte_9EBE7 = '\x01'; // weak
char byte_9EBE8 = '\x01'; // weak
char byte_9EBE9 = '\x01'; // weak
char byte_9EBEA = '\x01'; // weak
char byte_9EBEB = '\x01'; // weak
char byte_9EBEC = '\x01'; // weak
char byte_9EBED = '\x01'; // weak
char byte_9EBF7 = '\x01'; // weak
char byte_9EBF8 = '\x01'; // weak
char byte_9EBF9 = '\x01'; // weak
char byte_9EBFA = '\x01'; // weak
char byte_9EBFB = '\x01'; // weak
char byte_9EBFC = '\x01'; // weak
char byte_9EC0D = '\0'; // weak
char byte_9EC17 = '\0'; // weak
char byte_9EC18 = '\0'; // weak
char byte_9EC19 = '\0'; // weak
char byte_9EC1A = '\0'; // weak
char byte_9EC1B = '\0'; // weak
char byte_9EC1C = '\0'; // weak
char byte_9EC5D[80] =
{
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01'
}; // weak
char byte_9ECAD = '\x7F'; // weak
char byte_9ECAE[] = { '\x7F' }; // weak
char byte_9ECB7[71] =
{
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F',
  '\x7F'
}; // weak
char byte_9ECFE = '\0'; // weak
char byte_9ECFF[] = { 'H' }; // weak
_UNKNOWN unk_9ED08; // weak
_UNKNOWN unk_9EE07; // weak
int dword_9EF06 = 0; // weak
__int16 word_9EF0A = 0; // weak
int dword_9EF0C = 0; // weak
char *off_9EF10[20] =
{
  (char*)"Error Code Does Not Indicate An Error",
  (char*)"Specified Driver Is Not Loaded",
  (char*)"Specified Pointer Is NULL",
  (char*)"Detection System Is Already Initialized",
  (char*)"File Open Failure",
  (char*)"Memory Allocation Failure",
  (char*)"Invalid Driver ID",
  (char*)"Driver Not Found",
  (char*)"Detection System Failed To Find Hardware",
  (char*)"Driver Already Loaded Using Specified Handle",
  (char*)"Invalid Handle",
  (char*)"No Handles Available",
  (char*)"Hardware Already Paused",
  (char*)"Hardware Not Paused",
  (char*)"Data Is Not Valid",
  (char*)"HMI*.386 File Open Failure",
  (char*)"Incorrect Port",
  (char*)"Incorrect IRQ",
  (char*)"Incorrect DMA",
  (char*)"Incorrect DMA/IRQ"
}; // weak
int dword_9EF60 = 0; // weak
int dword_9EF64 = 0; // weak
int dword_9EF6C[] = { 0 }; // weak
int dword_9EF80 = 0; // weak
int dword_9F19C = 0; // weak
int dword_9F1A0 = 0; // weak
char byte_9F1A8[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
__int16 word_9F1B0 = 0; // weak
__int16 word_9F1B6 = 0; // weak
_UNKNOWN unk_A0000; // weak
__int16 word_A01C2 = 0; // weak
int dword_A01C4 = 0; // weak
int dword_A01CC = 0; // weak
__int16 word_A01D0[13] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_A01EA[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_A01FE = 0; // weak
__int16 word_A0202[13] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_A021C[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_A0230[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_A0244[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_A0258[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_A0280[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_A0294 = 0; // weak
__int16 word_A0298[] = { 0 }; // weak
int dword_A02B2[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_A02C6[5] = { 0, 0, 0, 0, 0 }; // weak
int dword_A02DA = 0; // weak
__int16 word_A02DE[28] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_A0316 = 0; // weak
__int16 word_A031A[] = { 0 }; // weak
int dword_A0338[6] = { 0, 0, 0, 0, 0, 0 }; // weak
char byte_A0350[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_A0374[8] = { 1, 3, 5, 7, 194, 198, 202, 206 }; // weak
char byte_A0394[9] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_A039D = -1; // weak
char byte_A03A1[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_A03FB = 0; // weak
__int16 word_A03FF = 0; // weak
int dword_A0401[15] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_A043D = 0; // weak
int dword_A0441[15] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_A047D = 0; // weak
int dword_A0481[] = { 0 }; // weak
char byte_A04C1[16] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // weak
char byte_A04D1 = '\0'; // weak
char byte_A04D2 = '\0'; // weak
_UNKNOWN unk_A05D1; // weak
int dword_A06DC = 0; // weak
int dword_A06E0 = 0; // weak
int dword_A06E4 = 0; // weak
int dword_A06E8 = 904; // weak
int dword_A06EC = 904; // weak
int dword_A06F0 = 904; // weak
char byte_A0704[32] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_A0724[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_A0734[9] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
char byte_A073D[27] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_A0758 = '\0'; // weak
char byte_A0759[11] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
char byte_A0764[11] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_A076F = 0; // weak
char byte_A0773 = '\0'; // weak
char byte_A0774 = '\0'; // weak
char byte_A0775[] = { '\0' }; // weak
char byte_A0776[18] =
{
  '\x03',
  '\x01',
  '\x04',
  '\x02',
  '\x05',
  '\b',
  '\v',
  '\t',
  '\f',
  '\n',
  '\r',
  '\x10',
  '\x13',
  '\x11',
  '\x14',
  '\x12',
  '\x15',
  '\0'
}; // weak
int dword_A0788 = 0; // weak
int dword_A078C = 0; // weak
char byte_A0794[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_A079A = 0; // weak
__int16 word_A079E = 0; // weak
int dword_A07A0 = 0; // weak
__int16 word_A07A4 = 0; // weak
int dword_A07A6 = 0; // weak
int dword_A07AA = 0; // weak
__int16 word_A07AE = 0; // weak
int dword_A07B0 = 0; // weak
__int16 word_A07B4 = 0; // weak
int dword_A07B6 = 0; // weak
__int16 word_A07BA = 0; // weak
int dword_A07BC = 0; // weak
int dword_A07C4 = 1; // weak
int dword_A07C8[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_A0808[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_A082C[16] = { 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64 }; // weak
int dword_A086C[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_A08AC[16] = { 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 }; // weak
int dword_A08EC = 0; // weak
int dword_A08F0[16] =
{
  127,
  127,
  127,
  127,
  127,
  127,
  127,
  127,
  127,
  127,
  127,
  127,
  127,
  127,
  127,
  127
}; // weak
int dword_A0930[9] = { 127, 127, 127, 127, 127, 127, 127, 127, 127 }; // weak
int dword_A0954[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_A0994[18] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 875770417, 943142453 }; // weak
char byte_A09DE = '\0'; // weak
char byte_A09DF = '\0'; // weak
char byte_A09E0 = '\0'; // weak
char byte_A09E1 = '\0'; // weak
char byte_A09E2 = '\0'; // weak
char byte_A09E3 = '\0'; // weak
char byte_A09E4 = '\0'; // weak
char byte_A09E5 = '\0'; // weak
char byte_A09E6 = '\0'; // weak
char byte_A09E7 = '\0'; // weak
int dword_A09E8 = 0; // weak
__int16 word_A09EC = 0; // weak
char byte_A09EE = '\0'; // weak
char byte_A09EF = '\0'; // weak
int dword_A09F0 = 0; // weak
char byte_A09F4[] = { '\0' }; // weak
char byte_A09F5[] = { '\0' }; // weak

char byte_A09F6[46] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_A0A24[20] =
{
  '?',
  ':',
  '5',
  '0',
  ',',
  ')',
  '%',
  '$',
  '#',
  '\"',
  '!',
  ' ',
  '\x1F',
  '\x1E',
  '\x1D',
  '\x1C',
  '\x1B',
  '\x1A',
  '\x19',
  '\x18'
}; // weak
int dword_A0A38[12] =
{
  336926231,
  269554195,
  219024911,
  185338893,
  151652875,
  117966857,
  101058055,
  67437829,
  50594820,
  33686275,
  65794,
  0
}; // weak
int dword_A0A68[102] =
{
  343,
  363,
  385,
  408,
  432,
  458,
  485,
  514,
  544,
  577,
  611,
  647,
  1367,
  1387,
  1409,
  1432,
  1456,
  1482,
  1509,
  1538,
  1568,
  1601,
  1635,
  1671,
  2391,
  2411,
  2433,
  2456,
  2480,
  2506,
  2533,
  2562,
  2592,
  2625,
  2659,
  2695,
  3415,
  3435,
  3457,
  3480,
  3504,
  3530,
  3557,
  3586,
  3616,
  3649,
  3683,
  3719,
  4439,
  4459,
  4481,
  4504,
  4528,
  4554,
  4581,
  4610,
  4640,
  4673,
  4707,
  4743,
  5463,
  5483,
  5505,
  5528,
  5552,
  5578,
  5605,
  5634,
  5664,
  5697,
  5731,
  5767,
  6487,
  6507,
  6529,
  6552,
  6576,
  6602,
  6629,
  6658,
  6688,
  6721,
  6755,
  6791,
  7511,
  7531,
  7553,
  7576,
  7600,
  7626,
  7653,
  7682,
  7712,
  7745,
  7779,
  7815,
  7854,
  7863,
  7938,
  7984,
  8032,
  8084
}; // weak
int dword_A0C00[] = { 8138 }; // weak
int dword_A0C04[36] =
{
  324,
  306,
  289,
  272,
  257,
  248,
  229,
  216,
  204,
  193,
  182,
  172,
  161,
  144,
  153,
  134,
  129,
  124,
  115,
  108,
  102,
  96,
  91,
  86,
  686,
  726,
  770,
  816,
  864,
  916,
  990,
  1028,
  1088,
  1154,
  1222,
  1294
}; // weak
int dword_A0CA4 = 0; // weak
int dword_A0CA8 = 0; // weak
char byte_A0CC6 = '\0'; // weak
_UNKNOWN unk_A0E84; // weak
__int16 word_A0F00[128] =
{
  -18023,
  23756,
  15838,
  11878,
  9503,
  7919,
  6788,
  5939,
  5279,
  4751,
  4319,
  3959,
  3655,
  3394,
  3168,
  2970,
  2795,
  2640,
  2501,
  2376,
  2263,
  2160,
  2066,
  1980,
  1901,
  1827,
  1760,
  1697,
  1638,
  1584,
  1533,
  1485,
  1397,
  1320,
  1250,
  1188,
  1131,
  1080,
  1033,
  990,
  950,
  914,
  880,
  848,
  819,
  792,
  766,
  742,
  699,
  660,
  625,
  594,
  566,
  540,
  516,
  495,
  475,
  457,
  440,
  424,
  410,
  396,
  383,
  371,
  349,
  330,
  313,
  297,
  283,
  270,
  258,
  247,
  238,
  228,
  220,
  212,
  205,
  198,
  192,
  186,
  175,
  165,
  156,
  148,
  141,
  135,
  129,
  124,
  119,
  114,
  110,
  106,
  102,
  99,
  96,
  93,
  87,
  82,
  78,
  74,
  71,
  67,
  65,
  62,
  59,
  57,
  55,
  53,
  51,
  49,
  48,
  46,
  44,
  41,
  39,
  37,
  35,
  34,
  32,
  31,
  30,
  29,
  27,
  27,
  26,
  25,
  24,
  23
}; // weak
char byte_A1000[128] =
{
  '2',
  '1',
  '0',
  '/',
  '.',
  '-',
  ',',
  '+',
  '*',
  '*',
  ')',
  '(',
  '\'',
  '&',
  '%',
  '$',
  '$',
  '#',
  '\"',
  '!',
  '!',
  ' ',
  '\x1F',
  '\x1E',
  '\x1E',
  '\x1D',
  '\x1C',
  '\x1C',
  '\x1B',
  '\x1A',
  '\x1A',
  '\x19',
  '\x19',
  '\x18',
  '\x18',
  '\x17',
  '\x16',
  '\x16',
  '\x15',
  '\x15',
  '\x14',
  '\x14',
  '\x13',
  '\x13',
  '\x13',
  '\x12',
  '\x12',
  '\x11',
  '\x11',
  '\x10',
  '\x10',
  '\x10',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0E',
  '\x0E',
  '\x0E',
  '\r',
  '\r',
  '\r',
  '\f',
  '\f',
  '\f',
  '\v',
  '\v',
  '\v',
  '\v',
  '\n',
  '\n',
  '\n',
  '\n',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_A1080[128] =
{
  'c',
  'c',
  'c',
  'c',
  'c',
  'c',
  'c',
  'c',
  'c',
  'c',
  'c',
  '+',
  ')',
  '(',
  '\'',
  '&',
  '%',
  '$',
  '#',
  '\"',
  '!',
  ' ',
  '\x1F',
  '\x1E',
  '\x1E',
  '\x1D',
  '\x1C',
  '\x1B',
  '\x1B',
  '\x1A',
  '\x19',
  '\x19',
  '\x18',
  '\x17',
  '\x17',
  '\x16',
  '\x16',
  '\x15',
  '\x15',
  '\x14',
  '\x14',
  '\x13',
  '\x13',
  '\x13',
  '\x12',
  '\x12',
  '\x11',
  '\x11',
  '\x11',
  '\x10',
  '\x10',
  '\x10',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\r',
  '\r',
  '\r',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\v',
  '\v',
  '\v',
  '\v',
  '\n',
  '\n',
  '\n',
  '\n',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\a',
  '\a',
  '\a',
  '\a',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_A1100[128] =
{
  '\x7F',
  'l',
  'b',
  'Z',
  'T',
  'P',
  'K',
  'H',
  'E',
  'B',
  '@',
  '=',
  ';',
  '9',
  '8',
  '6',
  '4',
  '3',
  '1',
  '0',
  '/',
  '-',
  ',',
  '+',
  '*',
  ')',
  '(',
  '\'',
  '&',
  '%',
  '$',
  '$',
  '#',
  '\"',
  '!',
  '!',
  ' ',
  '\x1F',
  '\x1E',
  '\x1E',
  '\x1D',
  '\x1D',
  '\x1C',
  '\x1B',
  '\x1B',
  '\x1A',
  '\x1A',
  '\x19',
  '\x18',
  '\x18',
  '\x17',
  '\x17',
  '\x16',
  '\x16',
  '\x15',
  '\x15',
  '\x15',
  '\x14',
  '\x14',
  '\x13',
  '\x13',
  '\x12',
  '\x12',
  '\x11',
  '\x11',
  '\x11',
  '\x10',
  '\x10',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0E',
  '\x0E',
  '\x0E',
  '\r',
  '\r',
  '\r',
  '\f',
  '\f',
  '\f',
  '\v',
  '\v',
  '\v',
  '\n',
  '\n',
  '\n',
  '\t',
  '\t',
  '\t',
  '\t',
  '\b',
  '\b',
  '\b',
  '\a',
  '\a',
  '\a',
  '\a',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x05',
  '\x05',
  '\x05',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
__int16 word_A1180[] = { -6656 }; // weak
__int16 word_A1182[] = { 1014 }; // weak
__int16 word_A1184[] = { -17364 }; // weak
int dword_A1186 = 0; // weak
int dword_A118A = 109; // weak
char byte_A11F0[28] =
{
  '\x03',
  '\x05',
  '\x7F',
  '\a',
  '4',
  '6',
  '\x0F',
  '\x17',
  '\x1F',
  '\'',
  '/',
  '7',
  '=',
  '?',
  'A',
  'C',
  '\t',
  '\v',
  '\x11',
  '\x13',
  '\x19',
  '\x1B',
  '!',
  '#',
  ')',
  '+',
  '1',
  '3'
}; // weak
__int16 word_A120C[224] =
{
  -19320,
  -23472,
  -27312,
  -31563,
  14394,
  16053,
  29428,
  29348,
  29268,
  29188,
  29188,
  29188,
  17430,
  17686,
  -23408,
  -23152,
  -31702,
  -31446,
  -31702,
  -31446,
  -31703,
  -31447,
  -31703,
  -31447,
  -31704,
  -31448,
  -31704,
  -31448,
  -19320,
  -23464,
  -27304,
  -31563,
  14394,
  16053,
  29316,
  29268,
  29220,
  29220,
  29268,
  29316,
  17480,
  17736,
  -23488,
  -23232,
  -31702,
  -31446,
  -31702,
  -31446,
  -31703,
  -31447,
  -31703,
  -31447,
  -31704,
  -31448,
  -31704,
  -31448,
  -19320,
  -23456,
  -27296,
  -31563,
  14394,
  16053,
  29316,
  29268,
  29220,
  29220,
  29268,
  29316,
  17430,
  17686,
  -23408,
  -23152,
  -31700,
  -31444,
  -31700,
  -31444,
  -31701,
  -31445,
  -31701,
  -31445,
  -31702,
  -31446,
  -31702,
  -31446,
  -19320,
  -23440,
  -27280,
  -31563,
  14394,
  16053,
  29316,
  29268,
  29220,
  29220,
  29268,
  29316,
  17480,
  17736,
  -23488,
  -23232,
  -31701,
  -31445,
  -31701,
  -31445,
  -31702,
  -31446,
  -31702,
  -31446,
  -31703,
  -31447,
  -31703,
  -31447,
  -19320,
  -23440,
  -27280,
  -31563,
  14394,
  16053,
  29268,
  29236,
  29220,
  29268,
  29284,
  29332,
  17603,
  17859,
  -23548,
  -23292,
  -31702,
  -31446,
  -31702,
  -31446,
  -31703,
  -31447,
  -31703,
  -31447,
  -31704,
  -31448,
  -31704,
  -31448,
  -19201,
  -23440,
  -27280,
  -31563,
  14394,
  16053,
  29236,
  29236,
  29236,
  29236,
  29236,
  29236,
  17480,
  17736,
  -23488,
  -23232,
  -31702,
  -31446,
  -31702,
  -31446,
  -31703,
  -31447,
  -31703,
  -31447,
  -31704,
  -31448,
  -31704,
  -31448,
  -19201,
  -23440,
  -27392,
  -31563,
  13114,
  14773,
  29188,
  29188,
  29188,
  29188,
  29188,
  29428,
  17408,
  17664,
  -23297,
  -23041,
  -31712,
  -31456,
  -31712,
  -31456,
  -31712,
  -31456,
  -31712,
  -31456,
  -31712,
  -31456,
  -31712,
  -31456,
  -19201,
  -23408,
  -27248,
  -31628,
  13114,
  14773,
  29188,
  29188,
  29188,
  29188,
  29188,
  29428,
  17408,
  17664,
  -23297,
  -23041,
  -31712,
  -31456,
  -31712,
  -31456,
  -31712,
  -31456,
  -31712,
  -31456,
  -31712,
  -31456,
  -31712,
  -31456
}; // weak
__int16 word_A1400[128] =
{
  1023,
  48,
  2047,
  304,
  3071,
  560,
  4095,
  816,
  5119,
  1072,
  6143,
  1328,
  7167,
  1584,
  8191,
  1840,
  9215,
  2096,
  10239,
  2352,
  11263,
  2608,
  12287,
  2864,
  13311,
  3120,
  14335,
  3376,
  15359,
  3632,
  16383,
  3888,
  17407,
  48,
  18431,
  304,
  19455,
  560,
  20479,
  816,
  21503,
  1072,
  22527,
  1328,
  23551,
  1584,
  24575,
  1840,
  25599,
  2096,
  26623,
  2352,
  27647,
  2608,
  28671,
  2864,
  29695,
  3120,
  30719,
  3376,
  31743,
  3632,
  32767,
  3888,
  -31745,
  48,
  -30721,
  304,
  -29697,
  560,
  -28673,
  816,
  -27649,
  1072,
  -26625,
  1328,
  -25601,
  1584,
  -24577,
  1840,
  -23553,
  2096,
  -22529,
  2352,
  -21505,
  2608,
  -20481,
  2864,
  -19457,
  3120,
  -18433,
  3376,
  -17409,
  3632,
  -16385,
  3888,
  -15361,
  48,
  -14337,
  304,
  -13313,
  560,
  -12289,
  816,
  -11265,
  1072,
  -10241,
  1328,
  -9217,
  1584,
  -8193,
  1840,
  -7169,
  2096,
  -6145,
  2352,
  -5121,
  2608,
  -4097,
  2864,
  -3073,
  3120,
  -2049,
  3376,
  -1025,
  3632,
  -1,
  3888
}; // weak
__int16 word_A1500[128] =
{
  3088,
  -31632,
  5374,
  -19320,
  5759,
  -23440,
  6375,
  -31563,
  7022,
  -31702,
  7965,
  -31446,
  3491,
  3964,
  5758,
  29268,
  0,
  -31702,
  1,
  -31446,
  6374,
  2986,
  7021,
  29236,
  8863,
  -31703,
  10054,
  -31447,
  7964,
  1767,
  8862,
  29220,
  3492,
  -31703,
  11305,
  -31447,
  10053,
  2038,
  11304,
  29268,
  14395,
  -31704,
  12815,
  -31448,
  12814,
  3842,
  4929,
  29284,
  16054,
  -31704,
  16057,
  -31448,
  14394,
  4009,
  16053,
  29332,
  16055,
  -31628,
  16058,
  -31371,
  16056,
  17603,
  16059,
  17859,
  0,
  -23548,
  1,
  -23292,
  5151,
  1649,
  5373,
  647,
  16060,
  -6640,
  16072,
  3195,
  794,
  2022,
  16072,
  -30985,
  16064,
  -32226,
  16062,
  -11648,
  16061,
  543,
  16074,
  902,
  16065,
  3075,
  16073,
  798,
  16074,
  -29620,
  16063,
  3157,
  16073,
  -15744,
  16068,
  -17276,
  16072,
  3757,
  16072,
  -11392,
  16066,
  -28802,
  16075,
  537,
  16075,
  -11546,
  16069,
  799,
  16070,
  -15488,
  16067,
  12927,
  16073,
  613,
  16073,
  -31975,
  4930,
  -11290,
  16071,
  13183,
  0,
  -31899,
  5152,
  -27280
}; // weak
__int16 word_A1608 = 30; // weak
__int16 word_A160A = 1568; // weak
int dword_A160C = 262144; // weak
int (__stdcall *dword_A1728)(_DWORD) = NULL; // weak
int (__stdcall *dword_A172C)(_DWORD, _DWORD) = NULL; // weak
int (__stdcall *dword_A1730)(_DWORD, _DWORD, _DWORD) = NULL; // weak
int dword_A1734[64] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int16 word_A1834[] = { 0 }; // weak
__int16 word_A1836[63] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int16 word_A18B4[] = { 0 }; // weak
char byte_A18B8[] = { '\0' }; // weak
__int16 word_A18BA[] = { 0 }; // weak
__int16 word_A18BC[] = { 0 }; // weak
__int16 word_A18BE[] = { 0 }; // weak
__int16 word_A18C0[] = { 0 }; // weak
__int16 word_A18C2[] = { 0 }; // weak
int dword_A18C4[156] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int16 word_A1B34[] = { 0 }; // weak
char byte_A1B36[] = { '\0' }; // weak
char byte_A1B37[] = { '\0' }; // weak
char byte_A1B38[] = { '\0' }; // weak
char byte_A1B39[] = { '\0' }; // weak
char byte_A1B3A[] = { '\0' }; // weak
char byte_A1B3B[] = { '\0' }; // weak
__int16 word_A1B3C[] = { 0 }; // weak
__int16 word_A1B3E[] = { 0 }; // weak
__int16 word_A1B40[] = { 0 }; // weak
__int16 word_A1B42[] = { 0 }; // weak
__int16 word_A1B44[] = { 0 }; // weak
__int16 word_A1B46[] = { 0 }; // weak
__int16 word_A1B48[] = { 0 }; // weak
__int16 word_A1B4A[] = { 0 }; // weak
__int16 word_A1B4C[] = { 0 }; // weak
__int16 word_A1B4E[] = { 0 }; // weak
__int16 word_A1B50[] = { 0 }; // weak
_UNKNOWN unk_A1D34; // weak
__int16 word_A1D44 = 0; // weak
int dword_A1F24 = 0; // weak
int dword_A1F28 = 0; // weak
int dword_A1F2C = 0; // weak
int dword_A1F30 = 0; // weak
int dword_A1F34 = 0; // weak
int dword_A1F38 = 0; // weak
int dword_A1F3C = 0; // weak
_UNKNOWN unk_A1F48; // weak
void *off_A2150 = (void *)0x20000; // weak
_UNKNOWN unk_A22BC; // weak
char *off_A282F = (char*)&byte_90000; // weak
void *off_A2995 = &loc_70000; // weak
_UNKNOWN unk_A2F5F; // weak
_UNKNOWN unk_A59DD; // weak
int (*off_A6368)(_DWORD, _DWORD) = (int (*)(uint32,uint32))&_no_support_loaded; // weak
__int16 word_A636C = 0; // weak
int dword_A8874 = 16; // weak
char aColour256[11] = "COLOUR256 "; // weak
char aSs2[5] = "SS2 "; // weak
char aColour[8] = "COLOUR "; // weak
char aLc[4] = "LC "; // weak
char aBlack[7] = "BLACK "; // weak
char aBrun[6] = "BRUN "; // weak
char aCopy[6] = "COPY "; // weak
char aPstamp[8] = "PSTAMP "; // weak
char aDataSearchDat[16] = "data/search.dat"; // weak
char aPaused[8] = "PAUSED!"; // weak
char aCursorUpMoveFo[31] = "Cursor up       Move forwards."; // weak
char aCursorUpMoveFo_0[31] = "Cursor up       Move forwards."; // weak
char aCursorDownMove[32] = "Cursor down     Move backwards."; // weak
char aCursorDownMove_0[32] = "Cursor down     Move backwards."; // weak
char aCursorLeftMove[27] = "Cursor left     Move left."; // weak
char aCursorRightMov[28] = "Cursor right    Move right."; // weak
char aLeftButtonUseS[39] = "Left button     Use spell to the left."; // weak
char aLeftButtonUseS_0[39] = "Left button     Use spell to the left."; // weak
char aRightButtonUse[40] = "Right button    Use spell to the right."; // weak
char aRightButtonUse_0[40] = "Right button    Use spell to the right."; // weak
char a10SelectAssign[40] = "1 - 0           Select assigned spells."; // weak
char a10SelectAssign_0[40] = "1 - 0           Select assigned spells."; // weak
char aSpaceRebirth[25] = "Space           Rebirth."; // weak
char aShiftQExitToDo[29] = "Shift Q         Exit to dos."; // weak
char aF5ReflectionsT[36] = "F5              Reflections toggle."; // weak
char aF5ReflectionsT_0[36] = "F5              Reflections toggle."; // weak
char aF6SkyToggle[28] = "F6              Sky toggle."; // weak
char aF7ShadowsToggl[32] = "F7              Shadows toggle."; // weak
char aF7ShadowsToggl_0[32] = "F7              Shadows toggle."; // weak
char aF8IconsToggle[30] = "F8              Icons toggle."; // weak
char aF8IconsToggle_0[30] = "F8              Icons toggle."; // weak
char aF9SpeedBlurTog[35] = "F9              Speed blur toggle."; // weak
char aF9SpeedBlurTog_0[35] = "F9              Speed blur toggle."; // weak
char aF10StereoModes[37] = "F10             Stereo modes toggle."; // weak
char aF10StereoModes_0[37] = "F10             Stereo modes toggle."; // weak
char aReturn[17] = "Return          "; // weak
char aLeftAndRightSp[33] = "Left and Right  Spell selection."; // weak
char aLeftAndRightSp_0[33] = "Left and Right  Spell selection."; // weak
char aIfYouAreExperi[57] = "If you are experiencing slowness, try Pressing F5,F6,F7."; // weak
char aIfYouAreExperi_0[57] = "If you are experiencing slowness, try Pressing F5,F6,F7."; // weak
char aMagicCarpetCom[57] = "Magic Carpet comes to you from Bullfrog Productions Ltd."; // weak
char aMagicCarpetCom_0[57] = "Magic Carpet comes to you from Bullfrog Productions Ltd."; // weak
char aAndWillBeRelea[48] = "And will be released on the 15th November 1994."; // weak
char aAndWillBeRelea_0[48] = "And will be released on the 15th November 1994."; // weak
char aCopyright1994B[41] = "Copyright 1994 Bullfrog Productions Ltd."; // weak
char aCopyright1994B_0[41] = "Copyright 1994 Bullfrog Productions Ltd."; // weak
char aGoodLuck[11] = "Good Luck!"; // weak
char aCCarpetCdSaveS[30] = "c:/carpet.cd/save/scanned.rmd"; // weak
char aDataSmatitleDa[18] = "data/smatitle.dat"; // weak
char aDataSmatitlePa[18] = "data/smatitle.pal"; // weak
char aDataPal00Dat[16] = "data/pal0-0.dat"; // weak
char aLoadAllDataFil[20] = "Load all data files"; // weak
char aInitialiseColo[25] = "Initialise Colour Lookup"; // weak
char aDigijoy[8] = "digijoy"; // weak
char aAnojoy[7] = "anojoy"; // weak
char aAnojoy4[8] = "anojoy4"; // weak
char aVfx[4] = "vfx"; // weak
char aHelp[5] = "help"; // weak
char aDebug[6] = "debug"; // weak
char aNetwork[8] = "network"; // weak
char aCustom[7] = "custom"; // weak
char aSetsound[9] = "setsound"; // weak
char aDemo[5] = "demo"; // weak
char aDetail[7] = "detail"; // weak
char aCheat[6] = "cheat"; // weak
char aName[5] = "name"; // weak
char aLevel[6] = "level"; // weak
char aMovie[6] = "movie"; // weak
char aRoll[5] = "roll"; // weak
char aTime[5] = "time"; // weak
char aPassword[9] = "password"; // weak
char aPlayers[8] = "players"; // weak
char aSession[8] = "session"; // weak
char byte_A9058 = '\0'; // weak
char aInitialiseMusi[17] = "Initialise Music"; // weak
char aInitialiseSoun[17] = "Initialise Sound"; // weak
char aSoundDisabled[15] = "Sound Disabled"; // weak
char aCarpetCd_2[11] = "\\carpet.cd"; // weak
char aSc[4] = "sC:"; // weak
_UNKNOWN unk_A90B8; // weak
_UNKNOWN unk_A90BC; // weak
char aSoundfxNone000[22] = "SOUNDFX = none 0 0 0\n"; // weak
char aMusicNone38800[22] = "MUSIC = none 388 0 0\n"; // weak
char aBfMusic[9] = "BF_MUSIC"; // weak
char aNone_0[5] = "none"; // weak
char aAdlib[6] = "ADLIB"; // weak
char aSblast[7] = "SBLAST"; // weak
char aSbpro[6] = "SBPRO"; // weak
char aAdlibg[7] = "ADLIBG"; // weak
char aSb16fm[7] = "SB16FM"; // weak
char aGravis[7] = "GRAVIS"; // weak
char aPasfm[6] = "PASFM"; // weak
char aCompatible[11] = "COMPATIBLE"; // weak
char aRoland_0[7] = "ROLAND"; // weak
char aSbawe32_0[8] = "SBAWE32"; // weak
char aGeneral_0[8] = "GENERAL"; // weak
char aWblast_0[7] = "WBLAST"; // weak
char aCarpetCd_3[11] = "\\carpet.cd"; // weak
_UNKNOWN unk_A91B4; // weak
_UNKNOWN unk_A91B8; // weak
char aSoundfxNone000_0[22] = "SOUNDFX = none 0 0 0\n"; // weak
char aMusicNone38800_0[22] = "MUSIC = none 388 0 0\n"; // weak
char aBfSound[9] = "BF_SOUND"; // weak
char aNone_1[5] = "none"; // weak
char aLevels_0[7] = "levels"; // weak
char aCarpetCd_0[11] = "\\carpet.cd"; // weak
char aLc_0[4] = "lC:"; // weak
char aLevelsLevelsDa[18] = "levels/levels.dat"; // weak
char aLevelsLevelsTa[18] = "levels/levels.tab"; // weak
char aMovie_0[6] = "movie"; // weak
char aSave_0[5] = "save"; // weak
char aEs_0[4] = "es/"; // weak
char aTmaps00[9] = "tmaps0-0"; // weak
char aData_0[5] = "data"; // weak
char aCreatingSetupD[29] = "Creating Setup Directories.."; // weak
char aAp[5] = "ap%\n"; // weak
char aSetupLevels[15] = "Setup levels.."; // weak
char aSave[5] = "save"; // weak
char aCarpetCd[11] = "\\carpet.cd"; // weak
char aData[5] = "data"; // weak
char aLevels[7] = "levels"; // weak
char aLoadLevel[11] = "Load Level"; // weak
char aGenerateMap[13] = "Generate map"; // weak
char aGenerateFeatur[18] = "Generate features"; // weak
char aInitialiseMode[18] = "Initialise Models"; // weak
char asc_A95F4[2] = " "; // weak
char aNetbios[8] = "netbios"; // weak
_UNKNOWN unk_A9608; // weak
char aDataInstBnk[14] = "data\\inst.bnk"; // weak
char aDataDrumBnk[14] = "data\\drum.bnk"; // weak
char aSblast_0[7] = "SBLAST"; // weak
char aSbpro_0[6] = "SBPRO"; // weak
char aSb16[5] = "SB16"; // weak
char aAdlibg_0[7] = "ADLIBG"; // weak
char aMicrosoft8[11] = "MICROSOFT8"; // weak
char aMicrosoft16[12] = "MICROSOFT16"; // weak
char aPas8[5] = "PAS8"; // weak
char aPas16[6] = "PAS16"; // weak
char aGravis_0[7] = "GRAVIS"; // weak
char aSoundmasterii[14] = "SOUNDMASTERII"; // weak
char aCompatible_0[11] = "COMPATIBLE"; // weak
char asc_A970B[2] = "l"; // weak
char aDataTablesDat[16] = "data/tables.dat"; // weak
char aNone[5] = "NONE"; // weak
char aSbawe32[8] = "SBAWE32"; // weak
char aWblast[7] = "WBLAST"; // weak
char aRoland[7] = "ROLAND"; // weak
char aGeneral[8] = "GENERAL"; // weak

int dword_A99A0 = 5457241; // weak
char aCarpetCd_1[11] = "\\carpet.cd"; // weak
char aC[3] = "C:"; // weak
char aE388[5] = "e388"; // weak
char aNewt[5] = "newt"; // weak
char aDataScreensGco[25] = "data/screens/gconfig.dat"; // weak
char aDataScreensGco_0[25] = "data\\screens\\gconfig.pal"; // weak
char aDataScreensMai[26] = "data\\screens\\mainmenu.dat"; // weak
char aDataScreensMai_0[26] = "data\\screens\\mainmenu.pal"; // weak
char aIntroScrollDat[17] = "intro\\scroll.dat"; // weak
char asc_A9ACC[3] = "--"; // weak
char aIntroIntroDat[16] = "intro\\intro.dat"; // weak
char aIntroOutroDat[16] = "intro\\outro.dat"; // weak
char aDataScreensPmu_0[24] = "data\\screens\\pmulti.pal"; // weak
char aDataScreensPmu_1[24] = "data\\screens\\pmulti.dat"; // weak
char aIntroLevelw2Da[18] = "intro\\levelw2.dat"; // weak
char aIntroLevelw1Da[18] = "intro\\levelw1.dat"; // weak
char aIntroLeveloseD[19] = "intro\\levelose.dat"; // weak
char aDataScreensPpe[23] = "data/screens/pperf.pal"; // weak
char aDataScreensPpe_0[23] = "data\\screens\\pperf.dat"; // weak
char aIntroLogoDat[15] = "intro\\logo.dat"; // weak
char aIntroIntelDat[16] = "intro\\intel.dat"; // weak
char aIntroTitle01Da[19] = "intro\\title-01.dat"; // weak
char aDataScreensLan[26] = "data\\screens\\language.pal"; // weak
char aDataScreensLan_0[26] = "data\\screens\\language.dat"; // weak
char aTmaps00_0[9] = "tmaps0-0"; // weak
char aData_1[5] = "data"; // weak
char aCarpetCd_4[11] = "\\carpet.cd"; // weak
char aProductName[13] = "Product name"; // weak
char aMagicCarpet[13] = "Magic Carpet"; // weak
char aVersionNumber[15] = "Version number"; // weak
char aBetaV80[10] = "Beta v8.0"; // weak
char aVersionDate[13] = "Version date"; // weak
char aJun051995[12] = "Jun 05 1995"; // weak
char a162618[9] = "16:26:18"; // weak
char aProgrammer[11] = "Programmer"; // weak
char aBullfrogSeanCo[23] = "Bullfrog, Sean Cooper."; // weak
char aSuppliedTo[12] = "Supplied to"; // weak
char aPublic[7] = "PUBLIC"; // weak
char aLevelNumber[13] = "Level Number"; // weak
char aTransferRate[15] = "Transfer rate:"; // weak
char aGameturn[10] = "GameTurn:"; // weak
char aSoundNumber[13] = "Sound Number"; // weak
char aGameTurn[10] = "Game turn"; // weak
char aThing[6] = "Thing"; // weak
char aMemoryUsedFree[19] = "Memory (Used/Free)"; // weak
void *off_ABCE0 = &unk_A7325; // weak
char aVipport[8] = "VIPPORT"; // weak
char aVfx1Cyberpuck[15] = "VFX1 CyberPuck"; // weak
char aVesa[5] = "VESA"; // weak
char aHmidet386[11] = "hmidet.386"; // weak
char aHmidrv386[11] = "hmidrv.386"; // weak
char IsTable[256] =
{
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\n',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  'X',
  'X',
  'X',
  'X',
  'X',
  'X',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\x98',
  '\x98',
  '\x98',
  '\x98',
  '\x98',
  '\x98',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\f',
  '\f',
  '\f',
  '\f',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_AC16C[8] = { '\x01', '\x02', '\x04', '\b', '\x10', ' ', '@', '\x80' }; // weak
int dword_AC1A0 = 0; // weak
__int16 word_AC1A4 = 0; // weak
__int16 word_AC1A6 = 0; // weak
int dword_AC1B0 = 0; // weak
char byte_AC1B8[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
unsigned __int8 byte_AC2B8[772] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
int dword_AC5BC = 0; // weak
int dword_AC5C0 = 0; // weak
int (*dword_AC5C4)(_DWORD) = NULL; // weak
_UNKNOWN unk_AC5C8; // weak
__int16 word_AC5CE = 0; // weak
__int16 word_AC5D0 = 0; // weak
__int16 word_AC5D2 = 0; // weak
int dword_AC5D4 = 0; // weak
__int16 word_AC5DA = 0; // weak
__int16 word_AC5DC = 0; // weak
__int16 word_AC5DE = 0; // weak
int dword_AC5E0[] = { 0 }; // weak
int dword_AC5F0[] = { 0 }; // weak
int dword_AC5F4[] = { 0 }; // weak
int dword_AC5F8[] = { 0 }; // weak
int dword_AC5FC[] = { 0 }; // weak
int dword_AC600[] = { 0 }; // weak
int dword_AC604[595] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_ACF50 = 0; // weak
char byte_ACFF0 = '\0'; // weak
char byte_ACFF1 = '\0'; // weak
char byte_ACFF2 = '\0'; // weak
int dword_AD008; // weak
__int16 word_AD00C[173]; // weak
char byte_AD167[9999]; // weak
char byte_AD168[9999]; // weak
char byte_AD177; // weak
char byte_AD258; // weak
char byte_AE068; // weak
char byte_AE077; // weak
char byte_AE167; // weak
int dword_AE238[17]; // weak
int dword_AE27C; // weak
int dword_AE280; // weak
int dword_AE294; // weak
int dword_AE298; // weak
int dword_AE29C; // weak
int dword_AE2A0; // weak
int dword_AE2C0; // weak
int dword_AE2C4; // weak
int dword_AE2C8; // weak
int dword_AE2CC; // weak
int dword_AE2D0; // weak
int dword_AE2D4; // weak
int dword_AE2D8; // weak
int dword_AE2DC; // weak
int dword_AE2E0; // weak
int dword_AE2E4; // weak
int dword_AE2E8; // weak
int dword_AE2EC; // weak
int dword_AE2F0; // weak
int dword_AE2FC; // weak
int dword_AE300; // weak
int dword_AE304; // weak
int dword_AE310; // weak
int dword_AE324; // weak
int dword_AE328; // weak
int dword_AE32C; // weak
int dword_AE330; // weak
int dword_AE334; // weak
int dword_AE338; // weak
int dword_AE33C; // weak
int dword_AE340; // weak
int dword_AE344; // weak
int dword_AE348; // weak
int dword_AE34C; // weak
int dword_AE35C; // weak
int dword_AE360; // weak
int dword_AE364; // weak
int dword_AE368; // weak
int dword_AE36C; // weak
int dword_AE370; // weak
int dword_AE374; // weak
int dword_AE3B8[9999]; // weak
int dword_AE3D8; // weak
int dword_AE3E0; // weak
int dword_AE3EC; // weak
int dword_AE3F0; // weak
int dword_AE3F4; // weak
int dword_AE3FC; // weak
int dword_AE400; // weak
int dword_AE404; // weak
int dword_AE408; // weak
int dword_AE410; // weak
int dword_AE418; // weak
int dword_AE41C; // weak
int dword_AE424; // weak
int dword_AE428; // weak
int dword_AE42C; // weak
int dword_AE440; // weak
int dword_AE44C; // weak
int dword_AE450; // weak
__int16 word_AE454; // weak
__int16 word_AE456; // weak
__int16 word_AE458; // weak
char byte_AE45A; // weak
_BYTE byte_AE460[6]; // weak
char byte_AE466; // weak
_UNKNOWN unk_AE89E; // weak
_UNKNOWN unk_B0000; // weak
_DWORD dword_B3288; // weak
int dword_B3294; // weak
__int16 word_B329C; // weak
char byte_B32A0[256]; // weak
char byte_B33A0[256]; // weak
char byte_B34A0[256]; // weak
char byte_B35A0[256]; // weak
char byte_B36A0[256]; // weak
char byte_B37A0[256]; // weak
char byte_B38A0[256]; // weak
char byte_B39A0[256]; // weak
_UNKNOWN unk_B3AA0; // weak
_UNKNOWN unk_B3CA0; // weak
_UNKNOWN unk_B3EA0; // weak
int dword_B5CA0; // weak
int dword_B5CA4; // weak
int dword_B5CA8; // weak
int dword_B5CAC; // weak
int dword_B5CB0; // weak
int dword_B5CB4; // weak
int dword_B5CB8; // weak
int dword_B5CBC; // weak
int dword_B5CC0; // weak
int dword_B5CC4; // weak
int dword_B5CC8; // weak
int dword_B5CCC; // weak
int dword_B5CD0; // weak
int dword_B5CD4; // weak
int dword_B5CD8; // weak
int dword_B5CDC; // weak
int dword_B5CE0; // weak
int dword_B5CE4; // weak
int dword_B5CE8; // weak
int dword_B5CEC; // weak
int dword_B5CF0; // weak
int dword_B5CF4; // weak
int dword_B5CF8; // weak
int dword_B5CFC; // weak
int dword_B5D00; // weak
int dword_B5D04; // weak
int dword_B5D08; // weak
int dword_B5D0C; // weak
int dword_B5D10; // weak
int dword_B5D14; // weak
int dword_B5D18; // weak
int dword_B5D1C; // weak
int dword_B5D20; // weak
int dword_B5D24; // weak
int dword_B5D28; // weak
int dword_B5D2C; // weak
int dword_B5D30; // weak
int dword_B5D34; // weak
__int16 word_B5D38; // weak
__int16 word_B5D3A; // weak
__int16 word_B5D3C; // weak
char byte_B5D3E; // weak
char byte_B5D3F; // weak
char byte_B5D40[9999]; // weak
char byte_B5D41[4812]; // weak
char byte_B700D[9999]; // weak
char byte_B700E[9999]; // weak
char byte_B700F[9999]; // weak
char byte_B7010[9999]; // weak
char byte_B7011[767]; // weak
int dword_B7310; // weak
__int16 word_B7314; // weak
__int16 word_B7316; // weak
__int16 word_B7318; // weak
int dword_B7320; // weak
__int16 word_B7324; // weak
_UNKNOWN unk_B7330; // weak
int dword_B76F0; // weak
char byte_B7700; // weak
char byte_B7701; // weak
__int16 word_B7702; // weak
__int16 word_B7704; // weak
__int16 word_B7706; // weak
__int16 word_B7708; // weak
__int16 word_B770A; // weak
__int16 word_B770C; // weak
__int16 word_B770E; // weak
__int16 word_B7710; // weak
__int16 word_B7712; // weak
__int16 word_B7714; // weak
__int16 word_B7716; // weak
__int16 word_B7718; // weak
__int16 word_B771A; // weak
__int16 word_B771C; // weak
__int16 word_B771E; // weak
__int16 word_B7720; // weak
__int16 word_B7722; // weak
__int16 word_B7724; // weak
__int16 word_B7726; // weak
__int16 word_B7728; // weak
char byte_B772A; // weak
char byte_B7934[9999]; // weak
char byte_BB934[18124]; // weak
char byte_CB934[768]; // weak
char byte_CBC34[768]; // weak
_UNKNOWN unk_CBF34; // weak
_UNKNOWN unk_CBF40; // weak
int dword_CBF44; // weak
__int16 word_CBF48; // weak
int dword_CBF60; // weak
int dword_CBF64; // weak
int dword_CBF68; // weak
int dword_CBF6C; // weak
int dword_CBF70; // weak
_UNKNOWN unk_CBF74; // weak
int dword_CBFD8; // weak
int dword_CBFDC; // weak
int dword_CBFE2; // weak
__int16 word_CBFE6; // weak
int dword_CBFE8; // weak
__int16 word_CBFEC; // weak
char byte_CBFEE; // weak
char byte_CBFEF; // weak
__int16 word_CBFF0[9999]; // weak
__int16 word_CBFF2[63]; // weak
__int16 word_CC070[9999]; // weak
char byte_CC0C2[29]; // weak
char byte_CC0DF[9999]; // weak
char byte_CC0E0[70]; // weak
int dword_CC126; // weak
int dword_CC130; // weak
int dword_CC134; // weak
int dword_CC138; // weak
int dword_CC13C; // weak
int dword_CC140; // weak
int dword_CC144; // weak
int dword_CC148; // weak
int dword_CC14C; // weak
int dword_CC150; // weak
int dword_CC154; // weak
_UNKNOWN unk_CC158; // weak
int dword_CC1BC; // weak
int dword_CC1C0; // weak
__int16 word_CC1C4; // weak
__int16 word_CC1C6; // weak
char byte_CC1DF[9999]; // weak
char byte_CC1E0[15914]; // weak
char byte_DC1E0[65536]; // weak
char byte_EC1E0[15904]; // weak
_UNKNOWN unk_F4240; // weak
char byte_FC1E0[15903]; // weak
_UNKNOWN unk_100000; // weak
__int16 word_10C1E0[7953]; // weak
_UNKNOWN unk_123333; // weak
_UNKNOWN unk_1234DC; // weak
__int16 word_12C1E0; // weak
__int16 word_12C1F0[9999]; // weak
__int16 word_12C1F2[959]; // weak
int dword_12C970; // weak
int dword_12C974; // weak
int dword_12C978; // weak
int dword_12C97C; // weak
int dword_12C980; // weak
int dword_12C984; // weak
_UNKNOWN unk_12C988; // weak
char byte_12C9A0[32]; // weak
__int16 word_12C9C0; // weak
__int16 word_12C9E0; // weak
char byte_12CA00[32]; // weak
__int16 word_12CA20; // weak
_UNKNOWN unk_12CA60; // weak
int dword_12CA78; // weak
int dword_12CA7C; // weak
__int16 word_12CA80[5]; // weak
__int16 word_12CA8A[5]; // weak
__int16 word_12CA94[5]; // weak
__int16 word_12CA9E[5]; // weak
__int16 word_12CAA8[5]; // weak
__int16 word_12CAB2[5]; // weak
int dword_12CABC; // weak
__int16 word_12CAC6; // weak
__int16 word_12CAD0[6]; // weak
int dword_12CADC; // weak
__int16 word_12CAE0; // weak
__int16 word_12CAE2; // weak
char byte_12CAE4; // weak
char byte_12CAE5; // weak
char byte_12CAE6; // weak
char byte_12CAE7; // weak
char byte_12CAE8; // weak
int dword_12CAEC; // weak
int dword_12CAF0; // weak
int dword_12CAF4; // weak
int dword_12CAF8; // weak
int dword_12CAFC; // weak
int dword_12CB00; // weak
int dword_12CB04; // weak
int dword_12CB08; // weak
int dword_12CB0C; // weak
int dword_12CB10; // weak
int dword_12CB14; // weak
int dword_12CB18; // weak
_DWORD dword_12CB28; // weak
_DWORD dword_12CB34; // weak
int dword_12CB40; // weak
int dword_12CB44; // weak
int dword_12CB48; // weak
int dword_12CB58; // weak
int dword_12CB5C; // weak
int dword_12CB60; // weak
int dword_12CB64; // weak
int dword_12CB68; // weak
int dword_12CB6C; // weak
__int16 word_12CB70; // weak
int dword_12CB72; // weak
int dword_12CB76; // weak
int dword_12CB7A; // weak
__int16 word_12CB7E; // weak
int dword_12CB80; // weak
int dword_12CB84; // weak
int dword_12CB88; // weak
__int16 word_12CB8C; // weak
int dword_12CB9C; // weak
int dword_12CBA0; // weak
int dword_12CBA4; // weak
int dword_12CBA8; // weak
int dword_12CBAC; // weak
int dword_12CBB0; // weak
int dword_12CBB4; // weak
int dword_12CBB8; // weak
__int16 word_12CBBC; // weak
__int16 word_12CBBE; // weak
__int16 word_12CBC0; // weak
__int16 word_12CBC2; // weak
__int16 word_12CBC4; // weak
char byte_12CBC6; // weak
char byte_12CBC9; // weak
char byte_12CBCA; // weak
char byte_12CBCB; // weak
char byte_12CBCC; // weak
char byte_12CBCD; // weak
char byte_12CBCE; // weak
char byte_12CBCF; // weak
char byte_12CBD0; // weak
char byte_12CBD1; // weak
char byte_12CBD2; // weak
char byte_12CBD3; // weak
char byte_12CBD4; // weak
char byte_12CBD5; // weak
char byte_12CBD6; // weak
__int16 word_12CBD8; // weak
__int16 word_12CBDA; // weak
char byte_12CBDC; // weak
char byte_12CC20[9999]; // weak
__int16 word_12CC40[9999]; // weak
__int16 word_12CC80[9999]; // weak
char byte_12CCC0[9999]; // weak
__int16 word_12CCE0[32]; // weak
__int16 word_12CD20[9999]; // weak
__int16 word_12CD22[9999]; // weak
__int16 word_12CD24[9999]; // weak
__int16 word_12CD26[9999]; // weak
__int16 word_12CD28[236]; // weak
int dword_12CF00[529]; // weak
int dword_12D744; // weak
int dword_12D748[529]; // weak
int dword_12DF8C[529]; // weak
char byte_12E7D0[529]; // weak
char byte_12E9E1[9999]; // weak
int dword_12EC00; // weak
__int16 word_12EC04; // weak
char byte_12EC10[9999]; // weak
char byte_12EC11[255]; // weak
_BYTE byte_12ED10[256]; // weak
int dword_12EE10; // weak
int dword_12EE14; // weak
int dword_12EE18; // weak
int dword_12EE1C; // weak
int dword_12EE24; // weak
int dword_12EE28; // weak
int dword_12EE2C; // weak
int dword_12EE30; // weak
int dword_12EE38; // weak
int dword_12EE3C; // weak
int dword_12EE40; // weak
char byte_12EE44[6]; // weak
int dword_12EE68; // weak
char byte_12EE6E[6]; // weak
int dword_12EE94; // weak
int dword_12EE98; // weak
__int16 word_12EE9C; // weak
__int16 word_12EE9E; // weak
__int16 word_12EEA0; // weak
_UNKNOWN unk_12EEA4; // weak
int dword_12EEB4; // weak
int dword_12EEB8; // weak
int dword_12EEBC; // weak
int dword_12EEC0; // weak
__int16 word_12EEC6; // weak
__int16 word_12EED6; // weak
__int16 word_12EED8; // weak
__int16 word_12EEDA; // weak
__int16 word_12EEDC; // weak
__int16 word_12EEDE; // weak
char byte_12EEE0; // weak
char byte_12EEE1; // weak
char byte_12EEF0[9999]; // weak
char byte_12EEF1; // weak
char byte_12EEFF; // weak
char byte_12EF04; // weak
char byte_12EF0C; // weak
char byte_12EF0D; // weak
char byte_12EF16; // weak
char byte_12EF1A; // weak
char byte_12EF26; // weak
char byte_12EF28; // weak
char byte_12EF29; // weak
char byte_12EF2B; // weak
char byte_12EF37; // weak
char byte_12EF38; // weak
char byte_12EF39; // weak
char byte_12EF3B; // weak
char byte_12EF3D; // weak
char byte_12EF3F; // weak
char byte_12EF40; // weak
char byte_12EF41; // weak
char byte_12EF70; // weak
char byte_12EF71; // weak
_UNKNOWN unk_12EF7E; // weak
int dword_12EF80; // weak
_UNKNOWN unk_12EF84; // weak
__int16 word_12EF86; // weak
int dword_12EF88; // weak
int dword_12EF8C; // weak
int dword_12EF90; // weak
int dword_12EF94; // weak
int dword_12EF98; // weak
int dword_12EF9C; // weak
int dword_12EFA0; // weak
int dword_12EFA4; // weak
int dword_12EFA8; // weak
int dword_12EFAC; // weak
int dword_12EFB4; // weak
__int16 word_12EFC4; // weak
__int16 word_12EFC6; // weak
int dword_12EFC8; // weak
int dword_12EFCC; // weak
__int16 word_12EFD0; // weak
__int16 word_12EFD2; // weak
__int16 word_12EFD4; // weak
__int16 word_12EFDA; // weak
__int16 word_12EFDC; // weak
__int16 word_12EFDE; // weak
__int16 word_12EFE0; // weak
__int16 word_12EFE2; // weak
__int16 word_12EFE4; // weak
int dword_12EFF0; // weak
int dword_12EFF4; // weak
int dword_12EFF8; // weak
int dword_12EFFC; // weak
int dword_12F000; // weak
int dword_12F004; // weak
int dword_12F008; // weak
int dword_12F00C; // weak
int dword_12F010; // weak
int dword_12F014; // weak
int dword_12F018; // weak
int dword_12F01C; // weak
int dword_12F020; // weak
int dword_12F024; // weak
int dword_12F028; // weak
__int16 word_12F02C; // weak
__int16 word_12F02E; // weak
int dword_12F030; // weak
__int16 word_12F034; // weak
int dword_12F038; // weak
__int16 word_12F03C; // weak
int dword_12F040; // weak
int dword_12F074; // weak
int dword_12F07A; // weak
int dword_12F080; // weak
__int16 word_12F084; // weak
char byte_12F090[768]; // weak
_UNKNOWN unk_12F390; // weak
_UNKNOWN unk_12F68E; // weak
__int16 word_12F690; // weak
int dword_12F6A0[9999]; // weak
int dword_12F6A4[9999]; // weak
int dword_12F6A8[9999]; // weak
int dword_1302A0; // weak
int dword_1302A4; // weak
int dword_1302A8; // weak
int dword_1302AC; // weak
char byte_1302B0[9999]; // weak
char byte_1302B1[4591]; // weak
int dword_1314A0; // weak
int dword_1314A4; // weak
int dword_1314A8; // weak
int dword_1314AC; // weak
int dword_1314B0; // weak
int dword_1314C8; // weak
__int16 word_1314CC[9999]; // weak
int dword_1314CE; // weak
__int16 word_1314D2; // weak
int dword_1314D4; // weak
__int16 word_1314D8; // weak
int dword_1314DA; // weak
__int16 word_1314DE; // weak
int dword_1314E0; // weak
__int16 word_1314E4; // weak
int dword_1314E6; // weak
__int16 word_1314EA[9999]; // weak
int dword_1314EC; // weak
__int16 word_1314F0; // weak
int dword_1314F2; // weak
__int16 word_1314F6; // weak
int dword_1314F8; // weak
__int16 word_1314FC; // weak
int dword_1314FE; // weak
__int16 word_131502; // weak
int dword_131504; // weak
__int16 word_131508[9999]; // weak
int dword_13150A; // weak
__int16 word_13150E; // weak
int dword_131510; // weak
__int16 word_131514; // weak
int dword_131516; // weak
__int16 word_13151A; // weak
int dword_13151C; // weak
__int16 word_131520; // weak
int dword_131522; // weak
__int16 word_131526[9999]; // weak
int dword_131528; // weak
__int16 word_13152C; // weak
int dword_13152E; // weak
__int16 word_131532; // weak
int dword_131534; // weak
__int16 word_131538; // weak
int dword_13153A; // weak
__int16 word_13153E; // weak
_UNKNOWN unk_131540; // weak
int dword_131564; // weak
int dword_131568; // weak
char byte_13156D; // weak
int dword_131570; // weak
int dword_131574; // weak
int dword_131578; // weak
int dword_131580; // weak
int dword_131584; // weak
_UNKNOWN unk_131588; // weak
int dword_1315A8; // weak
int dword_1315B4; // weak
__int16 word_1315B8; // weak
int dword_1315BC; // weak
__int16 word_1315C0; // weak
int dword_1315C4; // weak
__int16 word_1315C8; // weak
int dword_1315CC; // weak
__int16 word_1315D0; // weak
int dword_1315E4[9999]; // weak
int dword_1315E8; // weak
__int16 word_1315EC; // weak
int dword_1315F0[9999]; // weak
int dword_1315F4[9999]; // weak
int dword_1315F8[9999]; // weak
int dword_1315FC[9999]; // weak
int dword_131600; // weak
__int16 word_131604; // weak
int dword_131608; // weak
__int16 word_13160C; // weak
int dword_131614; // weak
__int16 word_131618; // weak
int dword_131620[65]; // weak
char byte_131724[6]; // weak
int dword_131AEC; // weak
_UNKNOWN unk_131B80; // weak
int dword_131BA4; // weak
int dword_131BA8; // weak
char byte_131BAD; // weak
_UNKNOWN unk_131BB0; // weak
int dword_131BD0; // weak
_UNKNOWN unk_131BDC; // weak
_UNKNOWN unk_131BE0; // weak

//---------------- fixproc
int nullsub_3(_DWORD a) { return 0; }; // weak
int nullsub_19(_DWORD a) { return 0; }; // weak
_DWORD dos_getdiskfree(_DWORD a, uint32 b) { return 0; };// weak
_DWORD dos_getdrive(_DWORD a) { return 0; };// weak
_DWORD dos_getvect(_DWORD a) { return 0; };// weak
_DWORD dos_setvect(_DWORD a, _DWORD b, _DWORD c) { return 0; };// weak
_DWORD expand(_DWORD a, _DWORD b) { return 0; };// weak
int gettextposition(_DWORD a) { return 0; };// weak
_DWORD int386(_DWORD a, _DWORD b, _DWORD c) { return 0; };// weak
_DWORD int386x(_DWORD a, _DWORD b, _DWORD c, _DWORD d) { return 0; };// weak
void JUMPOUT(int adress) {};
void memset32(char* v32, int v35, int v25) {};

int nullsub_11(_DWORD a) { return 0; }; // weak
int nullsub_1(_DWORD a, _DWORD b) { return 0; }; // weak
int nullsub_2(void) { return 0; }; // weak
_DWORD outtext(_DWORD a) { return 0; };// weak
void qmemcpy(int a, int b, char c) {};
_DWORD segread(_DWORD a) { return 0; };// weak
_DWORD settextposition(_DWORD a, _DWORD b) { return 0; };// weak
void sub_111B0(int a1, int a2) {};
void sub_193EE(__int16 a1) {};
_WORD * sub_27690(_WORD *result, int a2) { return 0; };
void sub_10000() {}; // weak

unsigned __int16 sub_2DCB0(int a1, int a2) { return 0; };
unsigned __int16 sub_2F170(int a1, int a2) { return 0; };
unsigned __int16 sub_2FC50(int a1, int a2) { return 0; };
unsigned __int16 sub_32B90(int a1, int a2) { return 0; };
char sub_33800(char a1, char a2, unsigned __int16 a3, unsigned __int8 a4) { return 0; };
__int16 sub_34DD0(__int16 a1, unsigned __int16 a2, int a3) { return 0; };
char sub_35F30(int a1, char a2, char a3, int a4, int a5, unsigned __int8 a6) { return 0; };
int sub_38D09() { return 0; };// weak
unsigned __int8 sub_3F76D(int a1) { return 0; };
char sub_3F820(__int16 a1, __int16 a2, int a3, int a4, int a5, char a6) { return 0; };
char sub_3FCA0(int a1, __int16 a2, __int16 a3, __int16 a4, char a5, __int16 a6, __int16 a7, __int16 a8, __int16 a9, __int16 a10, __int16 a11) { return 0; };
__int16 sub_41DD0(__int16 result, int a2) { return 0; };
char sub_43B20(int a1, unsigned int a2) { return 0; };
void sub_4AB20(__int16 a1, const char *a2, const char *a3, __int16 a4, __int16 a5) {};
void sub_4AC70(const char *a1, const char *a2) {};
int sub_4CC00() { return 0; };// weak	
void sub_4EFC0(__int16 a1) {};
void sub_4F3F0(__int16 a1) {};
char sub_50770(__int16 a1, __int16 a2, __int16 a3, __int16 a4) { return 0; };
void sub_60D50(__int16 a1, int a2, int a3, char *a4, unsigned __int8 a5, char a6) {};
void sub_60D65(__int16 a1, int a2, int a3, char *a4, unsigned __int8 a5, char a6) {};
char sub_62CF4(int *a1) { return 0; };
__int16 sub_62CFD(__int16 *a1, int a2) { return 0; };
__int16 sub_62D40(unsigned __int8 a1, int a2) { return 0; };
char sub_62DC3(int a1) { return 0; };
__int16 sub_677E3(int a1, void (*a2)(_DWORD), char a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10) { return 0; };
void sub_6C05C(_BYTE *a1, int a2, int *a3) {};
void sub_6C224(_BYTE *a1, int a2, int *a3, _BYTE **a4) {};
__int16 sub_72652(__int16 a1, int a2, int a3, __int16 a4) { return 0; };
__int16 sub_726E7(__int16 a1, int a2, int a3, __int16 a4) { return 0; };
_DWORD unknown_libname_1(_DWORD a) { return 0; };// weak

void _disable() {};
void _enable() {};
int _FDFS(void) { return 0; };// weak	
int __readgsbyte(int a) { return 0; };
int __readgsdword(int a) { return 0; };
int __readgsword(int a) { return 0; };
int __ROL2__(int a, int b) { return 0; };
int __ROL4__(int a, int b) { return 0; };
int __ROR2__(int a, int b) { return 0; };
void __writegsbyte(int a, int b) {};
void __writegsdword(int a, int b) {};
void __writegsword(int a, int b) {};

int __readeflags() { return 0; };
void __writeeflags(int a) {};
_DWORD access(_DWORD a, _DWORD b) { return 0; };// weak
_DWORD gets(_DWORD a) { return 0; };// weak
_DWORD mkdir(_DWORD a) { return 0; };// weak
void __outbyte(int a, int b) {};
_DWORD outp(_DWORD a, char b) { return 0; };// weak
_DWORD read(_DWORD a, _DWORD b, _DWORD c) { return 0; };// weak
_DWORD close(_DWORD a) { return 0; };// weak
_DWORD creat(_DWORD a, _DWORD b) { return 0; };// weak
_DWORD setmode(_DWORD a, _DWORD b) { return 0; };// weak
_DWORD sopen(_DWORD a, _DWORD b, char c) { return 0; };
_DWORD lseek(_DWORD a, _DWORD b, char c) { return 0; };// weak
_DWORD open(_DWORD a, _DWORD b) { return 0; };
int __inbyte(int a) { return 0; };
_DWORD write(_DWORD a, _DWORD b, _DWORD c) { return 0; };// weak
void __inbytestring(int a, int b, int c) {};
_DWORD tolower(_DWORD a) { return 0; };// weak
void __outword(int a, int b) {};
int __inword(int a) { return 0; };

int filelength(int a) { return 0; };

//---------------- fixproc

//----- (00010010) --------------------------------------------------------
void sub_10010(__int16 a1, __int16 a2)
{
  word_9000E = a1;
  word_90010 = a2;
}
// 9000E: using guessed type __int16 word_9000E;
// 90010: using guessed type __int16 word_90010;

//----- (0001002D) --------------------------------------------------------
int sub_1002D(int a1, int a2)
{
  dword_90008 = a1;
  dword_90004 = a2;
  while ( 1 )
  {
    qmemcpy(&word_90012, (const void *)dword_90008, 4u);
    dword_90008 += 4;
    qmemcpy(&word_9000C, (const void *)dword_90008, sizeof(word_9000C));
    dword_90008 += 2;
    if ( word_9000C != -20718 )
      break;
    sub_10166();
  }
  if ( word_9000C != -3590 )
    return 0;
  sub_100B8();
  return dword_90008;
}
// 90004: using guessed type int dword_90004;
// 90008: using guessed type int dword_90008;
// 9000C: using guessed type __int16 word_9000C;
// 90012: using guessed type __int16 word_90012;

//----- (000100B8) --------------------------------------------------------
__int16 sub_100B8()
{
  __int16 result; // ax

  qmemcpy(&word_90016, (const void *)dword_90008, sizeof(word_90016));
  dword_90008 += 2;
  dword_90008 += 8;
  while ( word_90016 )
  {
    --word_90016;
    qmemcpy(&word_90012, (const void *)dword_90008, 4u);
    dword_90008 += 4;
    qmemcpy(&word_9000C, (const void *)dword_90008, sizeof(word_9000C));
    dword_90008 += 2;
    if ( word_9000C == 7 )
    {
      result = sub_101A1();
    }
    else if ( word_9000C == 15 )
    {
      result = sub_10254();
    }
    else
    {
      result = sub_10190();
    }
  }
  return result;
}
// 90008: using guessed type int dword_90008;
// 9000C: using guessed type __int16 word_9000C;
// 90012: using guessed type __int16 word_90012;
// 90016: using guessed type __int16 word_90016;

//----- (00010166) --------------------------------------------------------
__int16 sub_10166()
{
  __int16 result; // ax

  word_9000E = *(_WORD *)(dword_90008 + 2);
  result = *(_WORD *)(dword_90008 + 4);
  word_90010 = result;
  dword_90008 += 6;
  return result;
}
// 90008: using guessed type int dword_90008;
// 9000E: using guessed type __int16 word_9000E;
// 90010: using guessed type __int16 word_90010;

//----- (00010190) --------------------------------------------------------
int sub_10190()
{
  int result; // eax

  result = (unsigned __int16)word_90012 - 6;
  dword_90008 += result;
  return result;
}
// 90008: using guessed type int dword_90008;
// 90012: using guessed type __int16 word_90012;

//----- (000101A1) --------------------------------------------------------
__int16 sub_101A1()
{
  _WORD *v0; // edi
  __int16 *v1; // esi
  __int16 result; // ax
  _BYTE *v3; // edi
  _BYTE *v4; // esi
  char v5; // dl
  _WORD *v6; // [esp-4h] [ebp-14h]
  _WORD *v7; // [esp+0h] [ebp-10h]
  __int16 i; // [esp+6h] [ebp-Ah]
  __int16 v9; // [esp+8h] [ebp-8h]
  int v10; // [esp+Ch] [ebp-4h]

  v10 = (unsigned __int16)word_9000E;
  v0 = (_WORD *)dword_90004;
  v1 = (__int16 *)(dword_90008 + 2);
  v9 = *(_WORD *)dword_90008;
  do
  {
    while ( 1 )
    {
      result = *v1++;
      v7 = v0;
      if ( result >= 0 )
        goto LABEL_10;
      if ( (result & 0x4000) == 0 )
        break;
      v0 = (_WORD *)((char *)v0 + v10 * -result);
    }
    v6 = v0;
    v3 = (uint8*)((char *)v0 + v10 - 1);
    if ( byte_967E4 == 1 )
    {
      if ( (_BYTE)result )
        *v3 = result;
    }
    else
    {
      *v3 = result;
    }
    v0 = v6;
LABEL_10:
    for ( i = result; i; --i )
    {
      while ( 1 )
      {
        LOBYTE(result) = *(_BYTE *)v1;
        v4 = (uint8*)((char *)v1 + 1);
        result = (unsigned __int8)result;
        v0 = (_WORD *)((char *)v0 + (unsigned __int8)result);
        v5 = *v4;
        v1 = (__int16 *)(v4 + 1);
        if ( v5 > 0 )
          break;
        result = *v1++;
        do
        {
          *v0++ = result;
          ++v5;
        }
        while ( v5 );
        if ( !--i )
          goto LABEL_18;
      }
      do
      {
        *v0++ = *v1++;
        --v5;
      }
      while ( v5 );
    }
LABEL_18:
    v0 = (_WORD *)((char *)v7 + v10);
    --v9;
  }
  while ( v9 );
  dword_90008 = (int)v1;
  return result;
}
// 90004: using guessed type int dword_90004;
// 90008: using guessed type int dword_90008;
// 9000E: using guessed type __int16 word_9000E;
// 90010: using guessed type __int16 word_90010;
// 90012: using guessed type __int16 word_90012;
// 967E4: using guessed type char byte_967E4;

//----- (00010254) --------------------------------------------------------
int sub_10254()
{
  _BYTE *v0; // edi
  char *v1; // esi
  __int16 v2; // bx
  __int16 v3; // cx
  char v4; // dl
  __int16 v5; // ax
  char v6; // dh
  char v7; // dh
  int result; // eax
  int v9; // [esp-8h] [ebp-Ch]
  int v10; // [esp-4h] [ebp-8h]
  __int16 v11; // [esp+2h] [ebp-2h]

  v11 = word_9000E;
  v0 = (_BYTE *)dword_90004;
  v1 = (char *)dword_90008;
  v10 = (unsigned __int16)word_90012 - 6;
  v9 = dword_90008;
  v2 = word_90010;
  do
  {
    ++v1;
    v3 = v11;
    do
    {
      v4 = *v1++;
      if ( v4 > 0 )
      {
        v3 -= (unsigned __int8)v4;
      }
      else
      {
        HIBYTE(v5) = -1;
        LOBYTE(v5) = v4;
        v3 += v5;
      }
      if ( v4 > 0 )
      {
        v7 = *v1++;
        do
        {
          if ( byte_967E4 == 1 )
          {
            if ( v7 )
              *v0 = v7;
          }
          else
          {
            *v0 = v7;
          }
          ++v0;
          --v4;
        }
        while ( v4 );
      }
      else
      {
        do
        {
          v6 = *v1++;
          if ( byte_967E4 == 1 )
          {
            if ( v6 )
              *v0 = v6;
          }
          else
          {
            *v0 = v6;
          }
          ++v0;
          ++v4;
        }
        while ( v4 );
      }
    }
    while ( v3 );
    --v2;
  }
  while ( v2 );
  result = v10;
  dword_90008 = v10 + v9;
  return result;
}
// 90004: using guessed type int dword_90004;
// 90008: using guessed type int dword_90008;
// 9000E: using guessed type __int16 word_9000E;
// 90010: using guessed type __int16 word_90010;
// 90012: using guessed type __int16 word_90012;
// 967E4: using guessed type char byte_967E4;

//----- (00010300) --------------------------------------------------------
void sub_10300()
{
  if ( word_90026 && sub_35710() )
  {
    word_AC5DC = 1;
  }
  else if ( word_AC5DE && (byte_12EF70 || word_12EFDE || word_12EFDC) )
  {
    word_AC5DC = 1;
  }
  else
  {
    while ( dword_AC5D4 < (unsigned int)dword_9ADC4 )
    {
      if ( word_90026 && sub_35710() )
      {
        word_AC5DC = 1;
        return;
      }
      if ( word_AC5DE && (byte_12EF70 || word_12EFDE || word_12EFDE != word_12EFDC) )
      {
        word_AC5DC = 1;
        return;
      }
    }
    dword_AC5D4 = 0;
  }
}
// 90026: using guessed type __int16 word_90026;
// 9ADC4: using guessed type int dword_9ADC4;
// AC5D4: using guessed type int dword_AC5D4;
// AC5DC: using guessed type __int16 word_AC5DC;
// AC5DE: using guessed type __int16 word_AC5DE;
// 12EF70: using guessed type char byte_12EF70;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;

//----- (000103C0) --------------------------------------------------------
unsigned int sub_103C0(void *a1, unsigned int a2)
{
  unsigned int result; // eax

  if ( a1 )
  {
    result = a2;
    qmemcpy(a1, (const void *)dword_AC5BC, a2);
  }
  dword_AC5BC += a2;
  return result;
}
// AC5BC: using guessed type int dword_AC5BC;

//----- (000103F0) --------------------------------------------------------
int sub_103F0()
{
  int result; // eax

  dword_AC1B0 = dword_90028;
  sub_5CBD0(dword_AC5C0, (int)&dword_AC1A0, 16);
  while ( word_AC1A4 != -3590 )
    printf("ERROR UNKNOWN FRAME TYPE\n");
  while ( (unsigned int)dword_AC1A0 >= 0xFA00 )
    printf("PAGE SIZE IS > BSCREEN\n");
  sub_5CBD0(dword_AC5C0, dword_AE3FC, dword_AC1A0 - 16);
  result = dword_AC1A0;
  dword_90028 += dword_AC1A0;
  return result;
}
// 5CC03: using guessed type _DWORD printf(const char *, ...);
// 90028: using guessed type int dword_90028;
// AC1A0: using guessed type int dword_AC1A0;
// AC1A4: using guessed type __int16 word_AC1A4;
// AC1B0: using guessed type int dword_AC1B0;
// AC5C0: using guessed type int dword_AC5C0;
// AE3FC: using guessed type int dword_AE3FC;

//----- (000104D0) --------------------------------------------------------
void sub_104D0()
{
  int v0; // eax
  int v1; // eax
  unsigned int i; // ebx
  int v3; // ebp
  char *v4; // esi
  char *v5; // edi
  char v6; // al
  char v7; // al
  char *v8; // esi
  char *v9; // esi
  char *v10; // edi
  char v11; // al
  char v12; // al
  char *v13; // esi
  char *v14; // edi
  char v15; // al
  char v16; // al
  char *v17; // edi
  char v18; // al
  char v19; // al
  unsigned __int8 v20; // al
  int v21; // [esp+0h] [ebp-1Ch] BYREF
  int v22; // [esp+4h] [ebp-18h]
  char v23; // [esp+8h] [ebp-14h]

  //fix
  v22 = 0;
  //fix

  v23 = 0;
  byte_AC1B8[0] = 0;
  v0 = dword_AE3FC;
  dword_AC5BC = dword_AE3FC;
  if ( word_AC1A4 == -3840 )
  {
    sub_103C0(0, dword_AC1A0 - 16);
    v1 = sub_103F0();
    //v0 = sub_104D0(v1);
    //fix !!!
    sub_104D0();
    //fix !!!
  }
  else if ( word_AC1A4 == -3590 )
  {
    for ( i = 0; ; ++i )
    {
      v0 = (unsigned __int16)word_AC1A6;
      if ( i >= (unsigned __int16)word_AC1A6 )
        break;
      v3 = dword_AC5BC;
      sub_103C0(&v21, 6u);
      switch ( (__int16)v22 )
      {
        case 4:
          sub_108C0();
          v4 = aColour256;
          v5 = &byte_AC1B8[strlen(byte_AC1B8)];
          do
          {
            v6 = *v4;
            *v5 = *v4;
            if ( !v6 )
              break;
            v7 = v4[1];
            v4 += 2;
            v5[1] = v7;
            v5 += 2;
          }
          while ( v7 );
          v23 = 1;
          break;
        case 7:
          v8 = aSs2;
          sub_10960();
          goto LABEL_23;
        case 11:
          v9 = aColour;
          sub_108C0();
          v10 = &byte_AC1B8[strlen(byte_AC1B8)];
          do
          {
            v11 = *v9;
            *v10 = *v9;
            if ( !v11 )
              break;
            v12 = v9[1];
            v9 += 2;
            v10[1] = v12;
            v10 += 2;
          }
          while ( v12 );
          v23 = 1;
          break;
        case 12:
          v8 = aLc;
          sub_10AB0();
          goto LABEL_23;
        case 13:
          memset((void*)dword_9001C, 0, (unsigned __int16)word_AC5D2 * (unsigned __int16)word_AC5D0);
          v8 = aBlack;
          goto LABEL_23;
        case 15:
          v8 = aBrun;
          sub_10BD0();
          goto LABEL_23;
        case 16:
          sub_103C0((void *)dword_9001C, (unsigned __int16)word_AC5D0 * (unsigned __int16)word_AC5D2);
          v13 = aCopy;
          v14 = &byte_AC1B8[strlen(byte_AC1B8)];
          do
          {
            v15 = *v13;
            *v14 = *v13;
            if ( !v15 )
              break;
            v16 = v13[1];
            v13 += 2;
            v14[1] = v16;
            v14 += 2;
          }
          while ( v16 );
          v21 = (unsigned __int16)word_AC5D2 * (unsigned __int16)word_AC5D0;
          break;
        case 18:
          sub_103C0(0, v21 - 6);
          v8 = aPstamp;
LABEL_23:
          v17 = &byte_AC1B8[strlen(byte_AC1B8)];
          do
          {
            v18 = *v8;
            *v17 = *v8;
            if ( !v18 )
              break;
            v19 = v8[1];
            v8 += 2;
            v17[1] = v19;
            v17 += 2;
          }
          while ( v19 );
          break;
        default:
          break;
      }
      dword_AC5BC = v3 + v21;
    }
  }
  if ( dword_AC5C4 )
    dword_AC5C4(v0);
  sub_10300();
  if ( v23 )
  {
    sub_5CC54();
    if ( word_90024 )
    {
      sub_319A0(byte_AC2B8);
      v20 = sub_5CC70(byte_AC2B8, 0x3Fu, 0x3Fu, 0x3Fu);
      sub_24BF0(v20);
    }
  }
  if ( byte_90091 )
  {
    dword_12EFF4 += 6720;
    sub_5CDA0();
    dword_12EFF4 -= 6720;
  }
  else
  {
    sub_5CDA0();
  }
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 9001C: using guessed type int dword_9001C;
// 90024: using guessed type __int16 word_90024;
// 90091: using guessed type char byte_90091;
// AC1A0: using guessed type int dword_AC1A0;
// AC1A4: using guessed type __int16 word_AC1A4;
// AC1A6: using guessed type __int16 word_AC1A6;
// AC2B8: using guessed type unsigned __int8 byte_AC2B8[772];
// AC5BC: using guessed type int dword_AC5BC;
// AC5C4: using guessed type int (*dword_AC5C4)(_DWORD);
// AC5D0: using guessed type __int16 word_AC5D0;
// AC5D2: using guessed type __int16 word_AC5D2;
// AE3FC: using guessed type int dword_AE3FC;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (000107C0) --------------------------------------------------------
int sub_107C0(__int16 a1, __int16 a2, int a3)
{
  word_90024 = a2;
  word_90030 = 0;
  word_AC5DA = 0;
  LOWORD(dword_AC5E0[0]) = 0;
  dword_9001C = dword_12EFF4;
  dword_AC5C0 = sub_5CDE0((int)&unk_9ADC8, 512);
  sub_5CBD0(dword_AC5C0, (int)&unk_AC5C8, 12);
  word_12EFDC = 0;
  word_12EFDE = 0;
  dword_90028 += 12;
  byte_12EF70 = 0;
  word_AC5DC = 0;
  sub_356E0();
  for ( word_AC5DE = a1; !word_AC5DC; ++LOWORD(dword_AC5E0[0]) )
  {
    if ( SLOWORD(dword_AC5E0[0]) >= (unsigned __int16)word_AC5CE - 1 )
      break;
    sub_111B0((int)0, (int)a3);
    sub_103F0();
    sub_104D0();
  }
  return sub_5CE50(dword_AC5C0);
}
// 9001C: using guessed type int dword_9001C;
// 90024: using guessed type __int16 word_90024;
// 90028: using guessed type int dword_90028;
// 90030: using guessed type __int16 word_90030;
// AC5C0: using guessed type int dword_AC5C0;
// AC5CE: using guessed type __int16 word_AC5CE;
// AC5DA: using guessed type __int16 word_AC5DA;
// AC5DC: using guessed type __int16 word_AC5DC;
// AC5DE: using guessed type __int16 word_AC5DE;
// AC5E0: using guessed type int dword_AC5E0[];
// 12EF70: using guessed type char byte_12EF70;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (000108C0) --------------------------------------------------------
unsigned int sub_108C0()
{
  unsigned int result; // eax
  char *v1; // ebx
  int i; // edi
  int v3; // esi
  unsigned int v4; // [esp+0h] [ebp-1Ch] BYREF
  int v5; // [esp+4h] [ebp-18h] BYREF
  char v6[20]; // [esp+8h] [ebp-14h] BYREF

  result = sub_103C0(&v5, 2u);
  v1 = (char *)&unk_AC2B8;
  for ( i = 0; (unsigned __int16)i < (unsigned __int16)v5; ++i )
  {
    sub_103C0(v6, 1u);
    v1 += 3 * (unsigned __int8)v6[0];
    v4 = 0;
    sub_103C0(&v4, 1u);
    if ( !(_WORD)v4 )
      v4 = 256;
    v3 = 0;
    do
    {
      sub_103C0(v1, 3u);
      ++v3;
      result = v4;
      v1 += 3;
    }
    while ( (unsigned __int16)v3 < (unsigned __int16)v4 );
  }
  return result;
}
// 10930: conditional instruction was optimized away because %var_1C.2!=0
// 108C0: using guessed type char var_14[20];

//----- (00010960) --------------------------------------------------------
__int16 sub_10960()
{
  __int16 result; // ax
  int v1; // ebp
  char *v2; // ebx
  unsigned __int16 v3; // di
  int j; // esi
  unsigned __int16 k; // cx
  int i; // [esp+0h] [ebp-28h]
  int v7; // [esp+4h] [ebp-24h] BYREF
  int v8; // [esp+8h] [ebp-20h] BYREF
  int v9; // [esp+Ch] [ebp-1Ch] BYREF
  char v10[4]; // [esp+10h] [ebp-18h] BYREF
  char v11[20]; // [esp+14h] [ebp-14h] BYREF

  result = sub_103C0(&v7, 2u);
  v1 = dword_9001C;
  for ( i = 0; (unsigned __int16)i < (unsigned __int16)v7; v1 += (unsigned __int16)word_AC5D0 )
  {
    sub_103C0(&v9, 2u);
    v2 = (char *)v1;
    if ( (v9 & 0x8000) == 0 )
    {
      v3 = v9;
      for ( j = 0; (unsigned __int16)j < v3; ++j )
      {
        sub_103C0(v11, 1u);
        v2 += (unsigned __int8)v11[0];
        sub_103C0(v10, 1u);
        if ( v10[0] >= 0 )
        {
          if ( v10[0] > 0 )
          {
            sub_103C0(v2, 2 * v10[0]);
            v2 += 2 * v10[0];
          }
        }
        else
        {
          sub_103C0(&v8, 2u);
          for ( k = 0; k < (int)abs8(v10[0]); ++k )
          {
            v2 += 2;
            *((_WORD *)v2 - 1) = v8;
          }
        }
      }
    }
    else if ( (v9 & 0x4000) != 0 )
    {
      v1 += (unsigned __int16)word_AC5D0 * (abs16(v9) - 1);
      --i;
    }
    else
    {
      *(_BYTE *)((unsigned __int16)word_AC5D0 + v1 - 1) = v9;
    }
    result = word_AC5D0;
    ++i;
  }
  return result;
}
// 9001C: using guessed type int dword_9001C;
// AC5D0: using guessed type __int16 word_AC5D0;
// 10960: using guessed type char var_14[20];
// 10960: using guessed type char var_18[4];

//----- (00010AB0) --------------------------------------------------------
__int16 sub_10AB0()
{
  int v0; // edi
  __int16 result; // ax
  char *v2; // ebx
  unsigned __int16 v3; // si
  int v4; // eax
  int i; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h] BYREF
  char v7[4]; // [esp+8h] [ebp-20h] BYREF
  char v8[4]; // [esp+Ch] [ebp-1Ch] BYREF
  char v9[4]; // [esp+10h] [ebp-18h] BYREF
  char v10[20]; // [esp+14h] [ebp-14h] BYREF

  sub_103C0(&v6, 2u);
  v0 = (unsigned __int16)v6 * (unsigned __int16)word_AC5D0 + dword_9001C;
  result = sub_103C0(&v6, 2u);
  for ( i = 0; (unsigned __int16)i < (unsigned __int16)v6; v0 += (unsigned __int16)word_AC5D0 )
  {
    v2 = (char *)v0;
    v3 = 0;
    sub_103C0(v10, 1u);
    while ( v3 < (int)(unsigned __int8)v10[0] )
    {
      sub_103C0(v7, 1u);
      v2 += (unsigned __int8)v7[0];
      sub_103C0(v9, 1u);
      if ( v9[0] >= 0 )
      {
        if ( v9[0] <= 0 )
          goto LABEL_8;
        sub_103C0(v2, v9[0]);
        v4 = v9[0];
      }
      else
      {
        sub_103C0(v8, 1u);
        memset(v2, (unsigned __int8)v8[0], abs8(v9[0]));
        v4 = abs8(v9[0]);
      }
      v2 += v4;
LABEL_8:
      ++v3;
    }
    result = word_AC5D0;
    ++i;
  }
  return result;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 9001C: using guessed type int dword_9001C;
// AC5D0: using guessed type __int16 word_AC5D0;
// 10AB0: using guessed type char var_14[20];
// 10AB0: using guessed type char var_20[4];
// 10AB0: using guessed type char var_18[4];
// 10AB0: using guessed type char var_1C[4];

//----- (00010BD0) --------------------------------------------------------
__int16 sub_10BD0()
{
  int v0; // edi
  char *v1; // ebx
  int v2; // esi
  unsigned int v3; // eax
  __int16 result; // ax
  int i; // [esp+0h] [ebp-1Ch]
  char v6[4]; // [esp+4h] [ebp-18h] BYREF
  char v7[20]; // [esp+8h] [ebp-14h] BYREF

  v0 = dword_9001C;
  for ( i = 0; (unsigned __int16)i < (unsigned __int16)word_AC5D2; v0 += (unsigned __int16)word_AC5D0 )
  {
    v1 = (char *)v0;
    v2 = 0;
    sub_103C0(0, 1u);
    if ( word_AC5D0 )
    {
      do
      {
        v3 = sub_103C0(v7, 1u);
        if ( v7[0] >= 0 )
        {
          if ( v7[0] > 0 )
          {
            sub_103C0(v6, 1u);
            v3 = (int)memset(v1, (unsigned __int8)v6[0], v7[0]);
          }
        }
        else
        {
          v7[0] = abs8(v7[0]);
          v3 = sub_103C0(v1, v7[0]);
        }
        LOWORD(v3) = v7[0];
        v2 += v3;
        v1 += v7[0];
      }
      while ( (unsigned __int16)v2 < (unsigned __int16)word_AC5D0 );
    }
    result = word_AC5D0;
    ++i;
  }
  return result;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 9001C: using guessed type int dword_9001C;
// AC5D0: using guessed type __int16 word_AC5D0;
// AC5D2: using guessed type __int16 word_AC5D2;
// 10BD0: using guessed type char var_14[20];
// 10BD0: using guessed type char var_18[4];

//----- (00010CB0) --------------------------------------------------------
int sub_10CB0(unsigned __int16 a1)
{
  unsigned __int16 v1; // bx
  int v2; // edi
  int v3; // esi
  int v4; // eax
  int v5; // eax

  v1 = a1;
  sub_42530(9);
  v2 = sub_42540(6);
  v3 = v2;
  if ( v2 && (v4 = sub_42540(28 * a1), (*(_DWORD *)(v2 + 2) = v4) != 0) )
  {
    *(_WORD *)v2 = a1;
    while ( --v1 != 0xFFFF )
    {
      v5 = 28 * v1;
      *(_DWORD *)(*(_DWORD *)(v2 + 2) + v5 + 4) = 0;
      *(_DWORD *)(*(_DWORD *)(v2 + 2) + v5) = 0;
    }
  }
  else if ( v2 )
  {
    sub_426E0(v2);
    v3 = 0;
  }
  sub_42530(10);
  return v3;
}

//----- (00010D40) --------------------------------------------------------
int sub_10D40(unsigned __int16 *a1, int *a2, __int16 a3)
{
  __int16 v3; // si
  __int16 v4; // di
  __int16 i; // ax
  _DWORD *v6; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // edx
  __int16 v11; // [esp+8h] [ebp-14h]

  v3 = -1;
  v4 = -1;
  if ( !*a1 )
    return 0;
  for ( i = 0; i < (int)*a1; ++i )
  {
    v6 = (_DWORD *)(28 * i + *(_DWORD *)(a1 + 1));
    if ( v6[1] )
    {
      if ( !*v6 )
        v4 = i;
    }
    else
    {
      v3 = i;
    }
  }
  if ( v3 <= 0 )
    v3 = v4;
  if ( v3 <= -1 )
    return 0;
  v7 = *a2;
  v8 = *(unsigned __int16 *)(*a2 + 4) * *(unsigned __int16 *)(*a2 + 2);
  v11 = *(_WORD *)(*a2 + v8 + 6);
  v9 = 28 * v3;
  *(_DWORD *)(v9 + *(_DWORD *)(a1 + 1) + 4) = (uint32)a2;
  *(_WORD *)(v9 + *(_DWORD *)(a1 + 1) + 12) = 6;
  *(_WORD *)(v9 + *(_DWORD *)(a1 + 1) + 14) = v8 + 6;
  *(_WORD *)(v9 + *(_DWORD *)(a1 + 1) + 16) = v11;
  *(_WORD *)(v9 + *(_DWORD *)(a1 + 1) + 18) = *(_WORD *)(v7 + 2);
  *(_WORD *)(v9 + *(_DWORD *)(a1 + 1) + 20) = *(_WORD *)(v7 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 1) + v9 + 8) = v8 + 6;
  *(_WORD *)(v9 + *(_DWORD *)(a1 + 1) + 22) = 1;
  *(_DWORD *)(v9 + *(_DWORD *)(a1 + 1)) = 1;
  *(_WORD *)(v9 + *(_DWORD *)(a1 + 1) + 24) = v3;
  *(_WORD *)(v9 + *(_DWORD *)(a1 + 1) + 26) = a3;
  return *(_DWORD *)(a1 + 1) + v9;
}

//----- (00010EB0) --------------------------------------------------------
int sub_10EB0(int a1)
{
  int v1; // esi
  int v2; // edi
  int v3; // eax
  __int16 v4; // cx
  int result; // eax

  if ( *(_WORD *)(a1 + 22) > *(_WORD *)(a1 + 16) )
  {
    *(_WORD *)(a1 + 22) = 1;
    *(_DWORD *)(a1 + 8) = *(unsigned __int16 *)(a1 + 14);
  }
  v1 = **(_DWORD **)(a1 + 4);
  v2 = *(_DWORD *)(a1 + 8);
  sub_10010(*(_WORD *)(a1 + 18), 0);
  v1 += 6;
  v3 = sub_1002D(v1 + v2, v1);
  v4 = *(_WORD *)(a1 + 22);
  result = v3 - v1;
  *(_DWORD *)(a1 + 8) = result;
  *(_WORD *)(a1 + 22) = v4 + 1;
  return result;
}

//----- (00010F10) --------------------------------------------------------
_DWORD *sub_10F10(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  if ( a1 )
  {
    *a1 = 0;
    a1[1] = 0;
  }
  return result;
}

//----- (00010FD0) --------------------------------------------------------
int sub_10FD0(int a1, __int16 a2)
{
  int result; // eax
  int v3; // edx

  HIWORD(v3) = HIWORD(a1);
  result = *(_DWORD *)(a1 + 2);
  LOWORD(v3) = *(_WORD *)a1;
  if ( !*(_WORD *)a1 )
    return 0;
  while ( !*(_DWORD *)(result + 4) || a2 != *(_WORD *)(result + 26) )
  {
    --v3;
    result += 28;
    if ( !(_WORD)v3 )
      return 0;
  }
  return result;
}

//----- (00011010) --------------------------------------------------------
int *sub_11010(int *a1)
{
  int *result; // eax

  //fix
  result = 0;
  //fix

  if ( *a1 )
  {
    sub_426E0(*(_DWORD *)(*a1 + 2));
    *(_DWORD *)(*a1 + 2) = 0;
    result = sub_426E0(*a1);
    *a1 = 0;
  }
  return result;
}

//----- (00011050) --------------------------------------------------------
__int16 sub_11050()
{
  __int16 v0; // bx
  __int16 v2[2]; // [esp+0h] [ebp-14h] BYREF
  int v3; // [esp+4h] [ebp-10h]
  int v4[3]; // [esp+8h] [ebp-Ch] BYREF

  //fix
  v3 = 0;
  //fix

  v0 = 0;
  if ( byte_9002C )
    return 1;
  dos_getdrive((uint32)v4);
  if ( !dos_getdiskfree(v4[0], (uint32)v2) && v2[0] == -1 && !v2[1] && v3 == 134217729 )
  {
    v0 = 1;
    byte_9002C = 1;
  }
  return v0;
}
// 5CE76: using guessed type _DWORD dos_getdrive(_DWORD);
// 5CEAC: using guessed type _DWORD dos_getdiskfree(_DWORD, _DWORD);
// 9002C: using guessed type char byte_9002C;
// 11050: using guessed type int var_C[3];

//----- (000111B0) --------------------------------------------------------
void sub_111B0fix(int a1, int a2)
{
  int v2; // eax
  __int16 v3; // bx
  char v4; // al

  LOWORD(a1) = word_90030;
  while ( 1 )
  {
    v2 = a2 + 7 * (__int16)a1;
    if ( LOWORD(dword_AC5E0[0]) != *(_WORD *)v2 )
      break;
    v3 = *(_WORD *)(v2 + 3);
    v4 = *(_BYTE *)(v2 + 2) - 65;
    word_90030 = a1;
    switch ( v4 )
    {
      case 0:
      case 32:
        dword_9ADC4 = v3;
        LOWORD(a1) = word_90030;
        ++a1;
        continue;
      case 1:
      case 33:
        sub_20E60();
        sub_5CEF0(v3);
        LOWORD(a1) = word_90030;
        ++a1;
        continue;
      case 4:
      case 36:
        sub_5D010();
        sub_5D070(v3);
        LOWORD(a1) = word_90030;
        ++a1;
        continue;
      case 10:
        sub_24B80();
        LOWORD(a1) = word_90030;
        ++a1;
        continue;
      case 11:
      case 43:
        if ( dword_9AF08 )
          sub_5D230(dword_9ADC0, dword_9AF08, v3);
        goto LABEL_9;
      case 12:
      case 44:
LABEL_9:
        sub_5D290(v3);
        word_AC5DA = 0;
        LOWORD(a1) = word_90030;
        ++a1;
        continue;
      case 14:
        if ( !byte_90090 )
          goto LABEL_26;
        sub_24AB0();
        LOWORD(a1) = word_90030;
        ++a1;
        continue;
      case 15:
        sub_24BB0();
        LOWORD(a1) = word_90030;
        ++a1;
        continue;
      case 16:
        sub_24B50((unsigned __int8 *)dword_AE238[v3]);
        LOWORD(a1) = word_90030;
        ++a1;
        continue;
      case 17:
      case 49:
        if ( !byte_939E4 )
          goto LABEL_26;
        sub_5D460(0, v3, -1);
        LOWORD(a1) = word_90030;
        ++a1;
        continue;
      case 18:
      case 50:
        if ( !byte_939E4 )
          goto LABEL_26;
        if ( !v3 )
          goto LABEL_21;
        sub_5D610(0, v3);
        LOWORD(a1) = word_90030;
        ++a1;
        break;
      case 19:
      case 51:
        if ( !byte_939E4 )
          goto LABEL_26;
        if ( v3 )
        {
          sub_5D750(0, v3);
          LOWORD(a1) = word_90030;
          ++a1;
        }
        else
        {
LABEL_21:
          sub_5D010();
          LOWORD(a1) = word_90030;
          ++a1;
        }
        break;
      case 23:
      case 55:
        sub_20E60();
        word_AC5DA = 0;
        goto LABEL_26;
      case 25:
      case 57:
        sub_5D290(v3);
        word_AC5DA = v3 + 1;
        LOWORD(a1) = word_90030;
        ++a1;
        continue;
      default:
LABEL_26:
        LOWORD(a1) = word_90030;
        ++a1;
        break;
    }
  }
  word_90030 = a1;
  if ( word_AC5DA && sub_5D7F0(dword_CBFD8) )
  {
    sub_20E60();
    sub_5D290(word_AC5DA - 1);
  }
}
// 90030: using guessed type __int16 word_90030;
// 90090: using guessed type char byte_90090;
// 939E4: using guessed type char byte_939E4;
// 9ADC0: using guessed type int dword_9ADC0;
// 9ADC4: using guessed type int dword_9ADC4;
// 9AF08: using guessed type int dword_9AF08;
// AC5DA: using guessed type __int16 word_AC5DA;
// AC5E0: using guessed type int dword_AC5E0[];
// AE238: using guessed type int dword_AE238[17];
// CBFD8: using guessed type int dword_CBFD8;

//----- (00011410) --------------------------------------------------------
int sub_11410(int a1, int a2)
{
  int v2; // edx
  int i; // eax
  int v4; // eax
  int v5; // ecx
  int *v6; // ebx

  v2 = 1;
  for ( i = 6; i < 600; i += 6 )
  {
    if ( dword_AC5F8[i] == -1 )
      break;
    ++v2;
  }
  v4 = 3 * v2;
  dword_AC5F0[2 * v4] = a1;
  dword_AC5F8[2 * v4] = a1;
  dword_AC5FC[2 * v4] = 0;
  v5 = dword_AC5F8[6 * v2];
  dword_AC5F4[2 * v4] = a2;
  v6 = (int *)((char *)&dword_AD008 + 6 * v5);
  dword_AC600[2 * v4] = (int)v6;
  dword_AC604[2 * v4] = *v6;
  return v2;
}
// AC5F0: using guessed type int dword_AC5F0[];
// AC5F4: using guessed type int dword_AC5F4[];
// AC5F8: using guessed type int dword_AC5F8[];
// AC5FC: using guessed type int dword_AC5FC[];
// AC600: using guessed type int dword_AC600[];
// AC604: using guessed type int dword_AC604[595];
// AD008: using guessed type int dword_AD008;

//----- (00011490) --------------------------------------------------------
int sub_11490(int a1)
{
  dword_AC5F8[6 * a1] = -1;
  return 1;
}
// AC5F8: using guessed type int dword_AC5F8[];

//----- (000114B0) --------------------------------------------------------
int sub_114B0(int a1, _DWORD *a2, _DWORD *a3)
{
  int *v3; // eax
  char *v4; // edx
  int v5; // ecx
  int v6; // ebx
  int v7; // esi
  int v8; // edi
  int v9; // ebp

  v3 = &dword_AC5F0[6 * a1];
  v4 = (char *)v3[5];
  v5 = v3[4];
  *a2 = *v4;
  *a3 = v4[1];
  v6 = v3[3] + 1;
  v3[5] += 4;
  v3[3] = v6;
  if ( *(unsigned __int16 *)(v5 + 4) > v6 )
    return 1;
  v7 = v3[4];
  v3[3] = 0;
  v8 = v3[2];
  v3[4] = v7 + 6;
  ++v8;
  v9 = v3[1];
  v3[2] = v8;
  if ( v8 <= v9 )
    return 1;
  else
    return 2;
}
// AC5F0: using guessed type int dword_AC5F0[];

//----- (00011540) --------------------------------------------------------
int sub_11540()
{
  int i; // edx
  _BYTE *v1; // edx
  unsigned __int8 j; // bl
  int v3; // esi
  __int16 v4; // cx
  int result; // eax
  char v6; // bh
  int v7; // [esp+0h] [ebp-18h]
  char v8; // [esp+4h] [ebp-14h]
  char v9; // [esp+8h] [ebp-10h]

  v7 = dword_12EFF4;
  sub_3EEA0(aDataSearchDat, (char *)dword_12EFF4);
  for ( i = 6; i != 600; dword_AC5E0[i] = -1 )
    i += 6;
  v1 = (_BYTE *)dword_AE3F4;
  for ( j = 0; j < 0x20u; ++j )
  {
    v3 = 3 * j;
    v4 = 0;
    *(int *)((char *)&dword_AD008 + v3 * 2) = (int)v1;
    word_AD00C[v3] = 0;
    do
    {
      result = 0;
      do
      {
        v6 = *(_BYTE *)(v7 + (__int16)result + 32 * v4);
        if ( j == v6 )
        {
          if ( !v6 && v1 == (_BYTE *)dword_AE3F4 )
          {
            v8 = result;
            v9 = v4;
          }
          *v1 = result - v8;
          v1[1] = v4 - v9;
          v1[2] = j;
          v1 += 4;
          ++word_AD00C[3 * j];
        }
        ++result;
      }
      while ( (__int16)result < 32 );
      ++v4;
    }
    while ( v4 < 32 );
  }
  return result;
}
// 115EC: variable 'v8' is possibly undefined
// 115F4: variable 'v9' is possibly undefined
// AC5E0: using guessed type int dword_AC5E0[];
// AD008: using guessed type int dword_AD008;
// AD00C: using guessed type __int16 word_AD00C[173];
// AE3F4: using guessed type int dword_AE3F4;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (00011640) --------------------------------------------------------
int sub_11640(int a1, __int16 *a2, char a3)
{
  int v3; // edi
  int result; // eax
  int v5; // edi
  int v6; // edi
  __int16 v7; // si
  __int16 v8; // ax
  int v9; // ebx
  int v10; // ebx

  if ( (a3 & 2) != 0 )
  {
    v3 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 12);
    if ( a2[2] < v3 + (__int16)sub_11F50(a2) )
      return 1;
    v5 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 10);
    if ( a2[2] > v5 + (__int16)sub_11F50(a2) )
      return 1;
  }
  if ( (a3 & 1) == 0 || (v6 = *(_DWORD *)(*(_DWORD *)(a1 + 156) + 20), (result = ~v6 & sub_11810(a2)) == 0) )
  {
    if ( (a3 & 4) != 0 )
    {
      v7 = sub_42180((_WORD *)(a1 + 72), (uint16*)a2);
      v8 = sub_42240(0, v7);
      if ( v8 < 0 )
      {
        if ( v8 == -1 )
        {
          v10 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 16);
          if ( (unsigned __int16)sub_42210(0, v7) > v10 )
            return 1;
        }
      }
      else if ( v8 > 0 && v8 == 1 )
      {
        v9 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 18);
        if ( (unsigned __int16)sub_42210(0, v7) > v9 )
          return 1;
      }
    }
    return 0;
  }
  return result;
}

//----- (00011760) --------------------------------------------------------
int sub_11760(int a1)
{
  unsigned __int16 v1; // ax

  LOBYTE(v1) = *(_BYTE *)(a1 + 1);
  HIBYTE(v1) = *(_BYTE *)(a1 + 3);
  return 1 << (byte_FC1E0[v1] & 0xF);
}

//----- (00011810) --------------------------------------------------------
int sub_11810(__int16 *a1)
{
  int v1; // edx
  int result; // eax

  v1 = *a1 >> 8;
  result = 0;
  BYTE1(v1) = HIBYTE(a1[1]);
  switch ( byte_CC1E0[(unsigned __int16)v1] )
  {
    case 0:
      result = 1;
      break;
    case 1:
      result = 2;
      break;
    case 2:
      result = 4;
      break;
    case 3:
      result = 8;
      break;
    case 4:
      result = 16;
      break;
    case 5:
      result = 32;
      break;
    case 8:
      result = 256;
      break;
    case 9:
      result = 512;
      break;
    case 10:
      result = (int)&unk_100000;
      break;
    case 11:
      result = 0x200000;
      break;
    case 12:
      result = 0x400000;
      break;
    case 13:
    case 14:
      return result;
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
      result = 1024;
      break;
    case 21:
    case 22:
    case 24:
      result = (int)&loc_1FFFE + 2;
      break;
    case 23:
      result = 0x40000;
      break;
    case 25:
    case 27:
      result = (int)&dword_80000;
      break;
    case 26:
      result = (int)sub_10000;
      break;
    default:
      result = 0x800000;
      break;
  }
  return result;
}
// 10000: using guessed type int sub_10000();
// 80000: using guessed type int dword_80000;

//----- (000118C0) --------------------------------------------------------
bool sub_118C0(_WORD *a1, __int16 *a2, _WORD *a3, __int16 *a4)
{
  __int64 v4; // rax
  bool result; // eax

  result = 0;
  if ( abs16(*a3 - *a1) < a2[1] + a4[1] )
  {
    v4 = (__int16)(a3[1] - a1[1]);
    if ( (int)((HIDWORD(v4) ^ v4) - HIDWORD(v4)) < a2[2] + a4[2]
      && (int)abs32((__int16)a1[2] + *a2 - ((__int16)a3[2] + *a4)) < a2[3] + a4[3] )
    {
      return 1;
    }
  }
  return result;
}

//----- (00011950) --------------------------------------------------------
bool sub_11950(int a1, int a2)
{
  return sub_118C0((_WORD *)(a1 + 72), (__int16 *)(a1 + 78), (_WORD *)(a2 + 72), (__int16 *)(a2 + 78));
}

//----- (00011980) --------------------------------------------------------
int sub_11980(int a1)
{
  int v1; // edx
  int v2; // ebp
  int v3; // edi
  int i; // ebx
  int v6; // ebx
  int v7; // [esp+0h] [ebp-1Ch] BYREF
  int v8; // [esp+4h] [ebp-18h] BYREF
  int v9; // [esp+8h] [ebp-14h]

  v1 = *(__int16 *)(a1 + 80) + 255;
  v9 = (*(__int16 *)(a1 + 72) + 128) >> 8;
  v2 = (*(__int16 *)(a1 + 74) + 128) >> 8;
  v3 = sub_11410(0, (v1 - (__CFSHL__(v1 >> 31, 8) + (v1 >> 31 << 8))) >> 8);
  if ( !v3 )
    return 0;
  while ( sub_114B0(v3, (uint32*)&v8, (uint32*)&v7) == 1 )
  {
    for ( i = 164 * word_10C1E0[256 * (unsigned __int8)(v2 + v7) + (unsigned __int8)(v8 + v9)];
          ;
          i = 164 * *(unsigned __int16 *)(v6 + 20) )
    {
      v6 = dword_AE400 + 29795 + i;
      if ( v6 == dword_AE400 + 29795 )
        break;
      if ( (*(_BYTE *)(v6 + 16) & 8) != 0
        && (*(char *)(a1 + 66) == -1
         || *(_BYTE *)(a1 + 66) == *(_BYTE *)(v6 + 64) && *(char *)(a1 + 67) == -1
         || *(_BYTE *)(a1 + 66) == *(_BYTE *)(v6 + 64) && *(_BYTE *)(a1 + 67) == *(_BYTE *)(v6 + 65))
        && *(_WORD *)(a1 + 24) != *(_WORD *)(v6 + 24)
        && sub_11950(a1, v6) )
      {
        sub_11490(v3);
        return v6;
      }
    }
  }
  sub_11490(v3);
  return 0;
}
// AE400: using guessed type int dword_AE400;
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (00011AC0) --------------------------------------------------------
int sub_11AC0(_WORD *a1)
{
  int v1; // edx
  int v2; // ebp
  int v3; // edi
  int i; // ebx
  char v6; // dh
  __int16 v7; // ax
  int v8; // ebx
  int v9; // [esp+0h] [ebp-1Ch] BYREF
  int v10; // [esp+4h] [ebp-18h] BYREF
  int v11; // [esp+8h] [ebp-14h]

  v1 = (__int16)a1[40] + 255;
  v11 = ((__int16)a1[37] + 128) >> 8;
  v2 = ((__int16)a1[36] + 128) >> 8;
  v3 = sub_11410(0, (v1 - (__CFSHL__(v1 >> 31, 8) + (v1 >> 31 << 8))) >> 8);
  if ( !v3 )
    return 0;
  while ( sub_114B0(v3, (uint32*)&v10, (uint32*)&v9) == 1 )
  {
    for ( i = 164 * word_10C1E0[256 * (unsigned __int8)(v11 + v9) + (unsigned __int8)(v2 + v10)];
          ;
          i = 164 * *(unsigned __int16 *)(v8 + 20) )
    {
      v8 = dword_AE400 + 29795 + i;
      if ( v8 == dword_AE400 + 29795 )
        break;
      if ( (*(_BYTE *)(v8 + 16) & 8) != 0 && *(_BYTE *)(v8 + 64) == 10 )
      {
        v6 = *(_BYTE *)(v8 + 65);
        if ( v6 == 39 || v6 == 40 || v6 == 45 )
        {
          v7 = a1[12];
          if ( v7 != *(_WORD *)(v8 + 24) && v7 != *(unsigned __int16 *)(v8 + 144) && sub_11950((int)a1, v8) )
          {
            sub_11490(v3);
            return v8;
          }
        }
      }
    }
  }
  sub_11490(v3);
  return 0;
}
// AE400: using guessed type int dword_AE400;
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (00011C00) --------------------------------------------------------
int sub_11C00(__int16 *a1)
{
  int v1; // edx
  int v2; // ebp
  int v3; // edi
  int i; // eax
  int v6; // ebx
  int v7; // [esp+0h] [ebp-1Ch] BYREF
  int v8; // [esp+4h] [ebp-18h] BYREF
  int v9; // [esp+8h] [ebp-14h]

  v1 = a1[40] + 255;
  v9 = (a1[37] + 128) >> 8;
  v2 = (a1[36] + 128) >> 8;
  v3 = sub_11410(0, (v1 - (__CFSHL__(v1 >> 31, 8) + (v1 >> 31 << 8))) >> 8);
  if ( !v3 )
    return 0;
  while ( sub_114B0(v3, (uint32*)&v8, (uint32*)&v7) == 1 )
  {
    for ( i = word_10C1E0[256 * (unsigned __int8)(v7 + v9) + (unsigned __int8)(v2 + v8)];
          ;
          i = *(unsigned __int16 *)(v6 + 20) )
    {
      v6 = dword_AE400 + 29795 + 164 * i;
      if ( v6 == dword_AE400 + 29795 )
        break;
      if ( (*(_BYTE *)(v6 + 16) & 8) != 0
        && *(_BYTE *)(v6 + 64) == 10
        && *(_BYTE *)(v6 + 65) == 39
        && sub_11950((int)a1, v6) )
      {
        sub_11490(v3);
        return v6;
      }
    }
  }
  sub_11490(v3);
  return 0;
}
// AE400: using guessed type int dword_AE400;
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (00011D10) --------------------------------------------------------
int sub_11D10(int a1)
{
  int v1; // edx
  int v2; // ebp
  int v3; // edi
  int i; // ebx
  int v6; // ebx
  int v7; // [esp+0h] [ebp-1Ch] BYREF
  int v8; // [esp+4h] [ebp-18h] BYREF
  int v9; // [esp+8h] [ebp-14h]

  v1 = *(__int16 *)(a1 + 80) + 255;
  v9 = (*(__int16 *)(a1 + 72) + 128) >> 8;
  v2 = (*(__int16 *)(a1 + 74) + 128) >> 8;
  v3 = sub_11410(0, (v1 - (__CFSHL__(v1 >> 31, 8) + (v1 >> 31 << 8))) >> 8);
  if ( !v3 )
    return 0;
  while ( sub_114B0(v3, (uint32*)&v8, (uint32*)&v7) == 1 )
  {
    for ( i = 164 * word_10C1E0[256 * (unsigned __int8)(v2 + v7) + (unsigned __int8)(v8 + v9)];
          ;
          i = 164 * *(unsigned __int16 *)(v6 + 20) )
    {
      v6 = dword_AE400 + 29795 + i;
      if ( v6 == dword_AE400 + 29795 )
        break;
      if ( (*(char *)(a1 + 66) == -1
         || *(_BYTE *)(a1 + 66) == *(_BYTE *)(v6 + 64) && *(char *)(a1 + 67) == -1
         || *(_BYTE *)(a1 + 66) == *(_BYTE *)(v6 + 64) && *(_BYTE *)(a1 + 67) == *(_BYTE *)(v6 + 65))
        && *(_WORD *)(a1 + 24) != *(_WORD *)(v6 + 24)
        && sub_11950(a1, v6) )
      {
        sub_11490(v3);
        return v6;
      }
    }
  }
  sub_11490(v3);
  return 0;
}
// AE400: using guessed type int dword_AE400;
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (00011E50) --------------------------------------------------------
int sub_11E50(__int16 *a1, char a2, char a3)
{
  int v3; // ebp
  __int16 i; // di
  int v5; // ebx
  char v6; // al
  int result; // eax
  unsigned int v8; // ebx
  int v9; // [esp+0h] [ebp-1Ch]
  __int16 v10; // [esp+4h] [ebp-18h]
  int v11; // [esp+8h] [ebp-14h]

  v3 = dword_AE400;
  v11 = (*a1 - 128) >> 8;
  v10 = 0;
  v9 = (a1[1] - 128) >> 8;
  do
  {
    for ( i = 0; i < 2; ++i )
    {
      v5 = 164 * word_10C1E0[256 * (unsigned __int8)(v10 + v9) + (unsigned __int8)(i + v11)];
      while ( 1 )
      {
        v8 = v3 + 29795 + v5;
        if ( v8 <= v3 + 29795 )
          break;
        v6 = *(_BYTE *)(v8 + 64);
        dword_AE400 = v3;
        if ( v6 == a2 && a3 == *(_BYTE *)(v8 + 65) && sub_42340((uint16*)a1, (_WORD *)(v8 + 72)) <= 0x80 )
        {
          result = 1;
          v3 = dword_AE400;
          goto LABEL_13;
        }
        v5 = 164 * *(unsigned __int16 *)(v8 + 20);
        v3 = dword_AE400;
      }
    }
    ++v10;
  }
  while ( v10 < 2 );
  result = 0;
LABEL_13:
  dword_AE400 = v3;
  return result;
}
// AE400: using guessed type int dword_AE400;
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (00011F50) --------------------------------------------------------
int sub_11F50(__int16 *a1)
{
  return sub_724C0(*a1, a1[1]);
}

//----- (000120B0) --------------------------------------------------------
int sub_120B0(int a1, unsigned __int8 a2, unsigned __int16 a3)
{
  unsigned int i; // esi
  int result; // eax
  int v5; // ebp
  int j; // esi
  int v7; // esi
  int v8; // ebp
  int v9; // eax
  int v10; // esi
  char v11; // cl
  int v12; // eax
  int v13; // esi
  int v14; // [esp+0h] [ebp-48h]
  int v15; // [esp+4h] [ebp-44h]
  int v16; // [esp+8h] [ebp-40h]
  int v17; // [esp+Ch] [ebp-3Ch]
  int v18; // [esp+14h] [ebp-34h]
  int v19; // [esp+18h] [ebp-30h]
  int v20; // [esp+1Ch] [ebp-2Ch]
  int v21; // [esp+20h] [ebp-28h]
  int v22; // [esp+28h] [ebp-20h]
  unsigned __int8 v23; // [esp+2Ch] [ebp-1Ch]
  int v24; // [esp+30h] [ebp-18h]

  v24 = 1 << a2;
  if ( a2 )
  {
    v14 = (*(__int16 *)(a1 + 72) + 128) >> 8;
    v22 = (*(__int16 *)(a1 + 80)
         + 255
         - (__CFSHL__((*(__int16 *)(a1 + 80) + 255) >> 31, 8)
          + ((*(__int16 *)(a1 + 80) + 255) >> 31 << 8))) >> 8;
    result = -v22;
    v20 = -v22;
    if ( -v22 <= v22 )
    {
      v17 = ((*(__int16 *)(a1 + 74) + 128) >> 8) - v22;
      do
      {
        v8 = -v22;
        if ( -v22 <= v22 )
        {
          v23 = v14 - v22;
          do
          {
            v9 = 164 * word_10C1E0[256 * (unsigned __int8)v17 + v23];
            v10 = dword_AE400 + 29795;
            while ( 1 )
            {
              v13 = v9 + v10;
              if ( v13 == dword_AE400 + 29795 )
                break;
              if ( *(_WORD *)(a1 + 24) != *(_WORD *)(v13 + 24) )
              {
                v11 = *(_BYTE *)(v13 + 64);
                if ( v11 )
                {
                  if ( (*(_BYTE *)(v13 + 16) & 8) != 0
                    && ((unsigned __int16)v24 & *(_WORD *)(v13 + 28)) != 0
                    && (*(char *)(a1 + 66) == -1
                     || v11 == *(_BYTE *)(a1 + 66) && *(char *)(a1 + 67) == -1
                     || *(_BYTE *)(a1 + 66) == *(_BYTE *)(v13 + 64) && *(_BYTE *)(a1 + 67) == *(_BYTE *)(v13 + 65))
                    && sub_11950(a1, v13) )
                  {
                    v12 = v13 + 6 * a2;
                    if ( *(_WORD *)(v12 + 94) )
                      *(_DWORD *)(v12 + 90) += a3;
                    else
                      *(_DWORD *)(v12 + 90) = a3;
                    *(_WORD *)(v13 + 6 * a2 + 94) = *(_WORD *)(a1 + 24);
                  }
                }
              }
              v10 = 164 * *(unsigned __int16 *)(v13 + 20);
              v9 = dword_AE400 + 29795;
            }
            ++v8;
            ++v23;
          }
          while ( v8 <= v22 );
        }
        result = ++v17;
        ++v20;
      }
      while ( v20 <= v22 );
    }
  }
  else
  {
    for ( i = *(_DWORD *)(dword_AE408 + 36462); i > dword_AE400 + 29795; i = *(_DWORD *)i )
    {
      if ( *(_BYTE *)(i + 65) == 2 && *(_WORD *)(i + 24) != *(_WORD *)(a1 + 24) && sub_11950(a1, i) )
      {
        if ( *(_WORD *)(i + 94) )
          *(_DWORD *)(i + 90) += a3;
        else
          *(_DWORD *)(i + 90) = a3;
        *(_WORD *)(i + 94) = *(_WORD *)(a1 + 24);
      }
    }
    v18 = (*(__int16 *)(a1 + 72)
         - 128
         - (__CFSHL__((*(__int16 *)(a1 + 72) - 128) >> 31, 8)
          + ((*(__int16 *)(a1 + 72) - 128) >> 31 << 8))) >> 8;
    v16 = (*(__int16 *)(a1 + 80)
         + 255
         - (__CFSHL__((*(__int16 *)(a1 + 80) + 255) >> 31, 8)
          + ((*(__int16 *)(a1 + 80) + 255) >> 31 << 8))) >> 8;
    result = -v16;
    v15 = -v16;
    if ( -v16 <= v16 )
    {
      v19 = ((*(__int16 *)(a1 + 74)
            - 128
            - (__CFSHL__((*(__int16 *)(a1 + 74) - 128) >> 31, 8)
             + ((*(__int16 *)(a1 + 74) - 128) >> 31 << 8))) >> 8)
          - v16;
      do
      {
        v5 = -v16;
        if ( -v16 <= v16 )
        {
          v21 = v18 - v16;
          do
          {
            for ( j = 164 * word_10C1E0[256 * (unsigned __int8)v19 + (unsigned __int8)v21];
                  ;
                  j = 164 * *(unsigned __int16 *)(v7 + 20) )
            {
              v7 = dword_AE400 + 29795 + j;
              if ( v7 == dword_AE400 + 29795 )
                break;
              if ( *(_WORD *)(a1 + 24) != *(_WORD *)(v7 + 24)
                && sub_11950(a1, v7)
                && ((unsigned __int16)v24 & *(_WORD *)(v7 + 28)) != 0
                && (*(_BYTE *)(v7 + 16) & 8) != 0
                && (*(_BYTE *)(v7 + 64) != 3 || *(_BYTE *)(v7 + 65) != 2)
                && (*(char *)(a1 + 66) == -1
                 || *(_BYTE *)(a1 + 66) == *(_BYTE *)(v7 + 64) && *(char *)(a1 + 67) == -1
                 || *(_BYTE *)(a1 + 66) == *(_BYTE *)(v7 + 64) && *(_BYTE *)(a1 + 67) == *(_BYTE *)(v7 + 65)) )
              {
                if ( *(_WORD *)(v7 + 94) )
                  *(_DWORD *)(v7 + 90) += a3;
                else
                  *(_DWORD *)(v7 + 90) = a3;
                *(_WORD *)(v7 + 94) = *(_WORD *)(a1 + 24);
              }
            }
            result = v21 + 1;
            ++v5;
            ++v21;
          }
          while ( v5 <= v16 );
        }
        LOBYTE(v19) = v19 + 1;
        ++v15;
      }
      while ( v15 <= v16 );
    }
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (000124F0) --------------------------------------------------------
int sub_124F0(int a1, char a2, unsigned __int16 a3)
{
  int result; // eax
  unsigned int i; // ebx
  int v5; // ebp
  int j; // eax
  int v7; // ebx
  int v8; // [esp+0h] [ebp-34h]
  unsigned __int8 v9; // [esp+4h] [ebp-30h]
  int v10; // [esp+8h] [ebp-2Ch]
  int v11; // [esp+10h] [ebp-24h]
  int v12; // [esp+14h] [ebp-20h]

  result = 1 << a2;
  if ( !a2 )
  {
    for ( i = *(_DWORD *)(dword_AE408 + 36462); i > dword_AE400 + 29795; i = *(_DWORD *)i )
    {
      if ( *(_BYTE *)(i + 65) == 2 && *(_WORD *)(i + 24) != *(_WORD *)(a1 + 24) && sub_11950(a1, i) )
      {
        if ( *(_WORD *)(i + 94) )
          *(_DWORD *)(i + 90) += a3;
        else
          *(_DWORD *)(i + 90) = a3;
        *(_WORD *)(i + 94) = *(_WORD *)(a1 + 24);
      }
    }
    v12 = (*(__int16 *)(a1 + 72)
         - 128
         - (__CFSHL__((*(__int16 *)(a1 + 72) - 128) >> 31, 8)
          + ((*(__int16 *)(a1 + 72) - 128) >> 31 << 8))) >> 8;
    v11 = (*(__int16 *)(a1 + 80)
         + 255
         - (__CFSHL__((*(__int16 *)(a1 + 80) + 255) >> 31, 8)
          + ((*(__int16 *)(a1 + 80) + 255) >> 31 << 8))) >> 8;
    result = -v11;
    v8 = -v11;
    if ( -v11 <= v11 )
    {
      v10 = ((*(__int16 *)(a1 + 74)
            - 128
            - (__CFSHL__((*(__int16 *)(a1 + 74) - 128) >> 31, 8)
             + ((*(__int16 *)(a1 + 74) - 128) >> 31 << 8))) >> 8)
          - v11;
      do
      {
        v5 = -v11;
        if ( -v11 <= v11 )
        {
          v9 = v12 - v11;
          do
          {
            for ( j = word_10C1E0[256 * (unsigned __int8)v10 + v9]; ; j = *(unsigned __int16 *)(v7 + 20) )
            {
              v7 = dword_AE400 + 29795 + 164 * j;
              if ( v7 == dword_AE400 + 29795 )
                break;
              if ( *(_WORD *)(a1 + 24) != *(_WORD *)(v7 + 24)
                && sub_11950(a1, v7)
                && ((unsigned __int16)(1 << a2) & *(_WORD *)(v7 + 28)) != 0
                && (*(_BYTE *)(v7 + 16) & 8) != 0
                && (*(_BYTE *)(v7 + 64) != 3 || *(_BYTE *)(v7 + 65) != 2)
                && (*(char *)(a1 + 66) == -1
                 || *(_BYTE *)(a1 + 66) == *(_BYTE *)(v7 + 64) && *(char *)(a1 + 67) == -1
                 || *(_BYTE *)(a1 + 66) == *(_BYTE *)(v7 + 64) && *(_BYTE *)(a1 + 67) == *(_BYTE *)(v7 + 65)) )
              {
                if ( *(_BYTE *)(v7 + 64) != 2 || *(_BYTE *)(v7 + 65) )
                {
                  if ( *(_WORD *)(v7 + 94) )
                    *(_DWORD *)(v7 + 90) += a3;
                  else
                    *(_DWORD *)(v7 + 90) = a3;
                  *(_WORD *)(v7 + 94) = *(_WORD *)(a1 + 24);
                }
                else
                {
                  if ( *(_WORD *)(v7 + 94) )
                    *(_DWORD *)(v7 + 90) += a3 / 10;
                  else
                    *(_DWORD *)(v7 + 90) = a3 / 10;
                  *(_WORD *)(v7 + 94) = *(_WORD *)(a1 + 24);
                }
              }
            }
            ++v5;
            ++v9;
          }
          while ( v5 <= v11 );
        }
        result = v8 + 1;
        LOBYTE(v10) = v10 + 1;
        v8 = result;
      }
      while ( result <= v11 );
    }
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (000127E0) --------------------------------------------------------
int sub_127E0(int a1, char a2, unsigned __int16 a3)
{
  int result; // eax
  unsigned int i; // ebx
  int v5; // ebp
  int v6; // eax
  int v7; // ebx
  int v8; // ebx
  int v9; // [esp+0h] [ebp-30h]
  int v10; // [esp+4h] [ebp-2Ch]
  int v11; // [esp+Ch] [ebp-24h]
  unsigned __int8 v12; // [esp+10h] [ebp-20h]
  int v13; // [esp+14h] [ebp-1Ch]

  result = 1 << a2;
  if ( !a2 )
  {
    for ( i = *(_DWORD *)(dword_AE408 + 36462); i > dword_AE400 + 29795; i = *(_DWORD *)i )
    {
      if ( *(_BYTE *)(i + 65) == 2 && sub_11950(a1, i) )
      {
        *(_WORD *)(i + 50) = 30;
        if ( *(_WORD *)(i + 24) != *(_WORD *)(a1 + 24) )
        {
          if ( *(_WORD *)(i + 94) )
            *(_DWORD *)(i + 90) += a3;
          else
            *(_DWORD *)(i + 90) = a3;
          *(_WORD *)(i + 94) = *(_WORD *)(a1 + 24);
        }
      }
    }
    v11 = (*(__int16 *)(a1 + 72)
         - 128
         - (__CFSHL__((*(__int16 *)(a1 + 72) - 128) >> 31, 8)
          + ((*(__int16 *)(a1 + 72) - 128) >> 31 << 8))) >> 8;
    v13 = (*(__int16 *)(a1 + 80)
         + 255
         - (__CFSHL__((*(__int16 *)(a1 + 80) + 255) >> 31, 8)
          + ((*(__int16 *)(a1 + 80) + 255) >> 31 << 8))) >> 8;
    result = -v13;
    v10 = -v13;
    if ( -v13 <= v13 )
    {
      v9 = ((*(__int16 *)(a1 + 74)
           - 128
           - (__CFSHL__((*(__int16 *)(a1 + 74) - 128) >> 31, 8)
            + ((*(__int16 *)(a1 + 74) - 128) >> 31 << 8))) >> 8)
         - v13;
      do
      {
        v5 = -v13;
        if ( -v13 <= v13 )
        {
          v12 = v11 - v13;
          do
          {
            v6 = 164 * word_10C1E0[256 * (unsigned __int8)v9 + v12];
            v7 = dword_AE400 + 29795;
            while ( 1 )
            {
              v8 = v6 + v7;
              if ( v8 == dword_AE400 + 29795 )
                break;
              if ( *(_WORD *)(a1 + 24) != *(_WORD *)(v8 + 24)
                && sub_11950(a1, v8)
                && ((unsigned __int16)(1 << a2) & *(_WORD *)(v8 + 28)) != 0
                && (*(_BYTE *)(v8 + 16) & 8) != 0
                && (*(_BYTE *)(v8 + 64) != 3 || *(_BYTE *)(v8 + 65) != 2)
                && (*(char *)(a1 + 66) == -1
                 || *(_BYTE *)(a1 + 66) == *(_BYTE *)(v8 + 64) && *(char *)(a1 + 67) == -1
                 || *(_BYTE *)(a1 + 66) == *(_BYTE *)(v8 + 64) && *(_BYTE *)(a1 + 67) == *(_BYTE *)(v8 + 65)) )
              {
                if ( *(_WORD *)(v8 + 94) )
                  *(_DWORD *)(v8 + 90) += a3;
                else
                  *(_DWORD *)(v8 + 90) = a3;
                *(_WORD *)(v8 + 94) = *(_WORD *)(a1 + 24);
              }
              v7 = 164 * *(unsigned __int16 *)(v8 + 20);
              v6 = dword_AE400 + 29795;
            }
            ++v5;
            ++v12;
          }
          while ( v5 <= v13 );
        }
        result = v10 + 1;
        LOBYTE(v9) = v9 + 1;
        v10 = result;
      }
      while ( result <= v13 );
    }
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (00012B50) --------------------------------------------------------
int sub_12B50(int a1, int a2, unsigned __int8 a3, unsigned __int16 a4)
{
  int v4; // eax
  int result; // eax

  v4 = a2 + 6 * a3;
  if ( *(_WORD *)(v4 + 94) )
    *(_DWORD *)(v4 + 90) = a4;
  else
    *(_DWORD *)(v4 + 90) += a4;
  result = a2 + 6 * a3;
  *(_WORD *)(result + 94) = *(_WORD *)(a1 + 24);
  return result;
}

//----- (00012C50) --------------------------------------------------------
unsigned int sub_12C50(_WORD *a1)
{
  unsigned int v1; // ebx
  __int16 v2; // di
  int v3; // esi
  int v4; // ebp
  __int16 v6; // [esp+0h] [ebp-14h]

  sub_37150(a1, a1[13] + 1);
  v1 = *(_DWORD *)(dword_AE408 + 36470);
  v2 = a1[36];
  v3 = (__int16)a1[40] + 256;
  v4 = (__int16)a1[41] + 256;
  v6 = a1[37];
  while ( v1 > dword_AE400 + 29795 )
  {
    if ( abs16(*(_WORD *)(v1 + 72) - v2) <= v3 + *(__int16 *)(v1 + 80)
      && abs16(*(_WORD *)(v1 + 74) - v6) <= v4 + *(__int16 *)(v1 + 82) )
    {
      *(_DWORD *)(v1 + 12) = -1;
    }
    v1 = *(_DWORD *)v1;
  }
  return sub_37150(a1, a1[13]);
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00012D10) --------------------------------------------------------
char sub_12D10(_WORD *a1)
{
  unsigned int i; // ebx
  __int16 v3; // si
  unsigned __int16 v4; // ax
  __int16 v5; // dx
  __int16 v6; // si
  unsigned __int16 v7; // ax
  __int16 v8; // dx
  __int16 v9; // si
  unsigned __int16 v10; // ax
  __int16 v11; // dx
  __int16 v12; // si
  unsigned __int16 v13; // ax
  __int16 v14; // dx
  __int16 v15; // [esp+0h] [ebp-28h]
  unsigned __int16 v16; // [esp+8h] [ebp-20h]
  __int16 v17; // [esp+Ch] [ebp-1Ch]
  __int16 v18; // [esp+10h] [ebp-18h]
  __int16 v19; // [esp+10h] [ebp-18h]
  __int16 v20; // [esp+18h] [ebp-10h]
  __int16 v21; // [esp+18h] [ebp-10h]

  v20 = (__int16)a1[40] >> 8;
  v18 = (__int16)a1[41] >> 8;
  sub_37150(a1, a1[13] + 1);
  for ( i = *(_DWORD *)(dword_AE408 + 36462); i > dword_AE400 + 29795; i = *(_DWORD *)i )
  {
    if ( *(_BYTE *)(i + 65) == 2 && (_WORD *)i != a1 && sub_11950(i, (int)a1) )
      goto LABEL_5;
  }
  v15 = (__int16)a1[40] >> 8;
  v17 = (__int16)a1[41] >> 8;
  LOBYTE(v16) = ((unsigned __int16)(a1[36] + 128) >> 8) - v15;
  HIBYTE(v16) = ((unsigned __int16)(a1[37] + 128) >> 8) - v17;
  v21 = v15 - v20;
  v19 = v17 - v18;
  v3 = v19;
  v4 = v16;
  if ( v19 )
  {
    while ( 1 )
    {
      v5 = 2 * v15;
      if ( 2 * v15 )
        break;
LABEL_13:
      LOBYTE(v4) = ((unsigned __int16)(a1[36] + 128) >> 8) - v15;
      ++HIBYTE(v4);
      if ( !--v3 )
        goto LABEL_14;
    }
    while ( byte_FC1E0[v4] >= 0 )
    {
      LOBYTE(v4) = v4 + 1;
      if ( !--v5 )
        goto LABEL_13;
    }
    goto LABEL_5;
  }
LABEL_14:
  LOBYTE(v7) = ((unsigned __int16)(a1[36] + 128) >> 8) - v15;
  v6 = v19;
  HIBYTE(v7) = HIBYTE(v16) + 2 * v17 - v19;
  if ( v19 )
  {
    while ( 1 )
    {
      v8 = 2 * v15;
      if ( 2 * v15 )
        break;
LABEL_18:
      LOBYTE(v7) = ((unsigned __int16)(a1[36] + 128) >> 8) - v15;
      ++HIBYTE(v7);
      if ( !--v6 )
        goto LABEL_19;
    }
    while ( byte_FC1E0[v7] >= 0 )
    {
      LOBYTE(v7) = v7 + 1;
      if ( !--v8 )
        goto LABEL_18;
    }
    goto LABEL_5;
  }
LABEL_19:
  LOBYTE(v10) = ((unsigned __int16)(a1[36] + 128) >> 8) - v15;
  v9 = v19;
  HIBYTE(v10) = v19 + HIBYTE(v16);
  if ( v19 )
  {
    while ( 1 )
    {
      v11 = v21;
      if ( v21 )
        break;
LABEL_23:
      LOBYTE(v10) = ((unsigned __int16)(a1[36] + 128) >> 8) - v15;
      ++HIBYTE(v10);
      if ( !--v9 )
        goto LABEL_24;
    }
    while ( byte_FC1E0[v10] >= 0 )
    {
      LOBYTE(v10) = v10 + 1;
      if ( !--v11 )
        goto LABEL_23;
    }
    goto LABEL_5;
  }
LABEL_24:
  LOBYTE(v13) = ((unsigned __int16)(a1[36] + 128) >> 8) - v21;
  v12 = v19;
  HIBYTE(v13) = v19 + HIBYTE(v16);
  if ( v19 )
  {
    while ( 1 )
    {
      v14 = v21;
      if ( v21 )
        break;
LABEL_29:
      LOBYTE(v13) = ((unsigned __int16)(a1[36] + 128) >> 8) - v15;
      ++HIBYTE(v13);
      if ( !--v12 )
        goto LABEL_30;
    }
    while ( byte_FC1E0[v13] >= 0 )
    {
      LOBYTE(v13) = v13 + 1;
      if ( !--v14 )
        goto LABEL_29;
    }
LABEL_5:
    sub_37150(a1, a1[13]);
    return 0;
  }
LABEL_30:
  sub_37150(a1, a1[13]);
  return 1;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00012F70) --------------------------------------------------------
_BOOL1 sub_12F70(_WORD *a1)
{
  _BOOL1 v1; // bl
  unsigned int v2; // ecx
  unsigned __int16 v3; // ax
  __int16 v4; // dx
  __int16 v5; // si
  unsigned __int16 v7; // [esp+4h] [ebp-14h]

  v1 = 0;
  v2 = *(_DWORD *)(dword_AE408 + 36462);
  do
  {
    if ( v2 <= dword_AE400 + 29795 )
      break;
    if ( *(_BYTE *)(v2 + 65) == 2
      && abs16(*(_WORD *)(v2 + 72) - *a1) <= *(__int16 *)(v2 + 80) + 2048
      && abs16(*(_WORD *)(v2 + 74) - a1[1]) <= *(__int16 *)(v2 + 82) + 2048 )
    {
      v1 = 1;
    }
    v2 = *(_DWORD *)v2;
  }
  while ( !v1 );
  if ( !v1 )
  {
    LOBYTE(v7) = HIBYTE(*a1) - 8;
    HIBYTE(v7) = HIBYTE(a1[1]) - 8;
    v5 = 8;
    v3 = v7;
    do
    {
      if ( v1 )
        break;
      v4 = 8;
      do
      {
        if ( v1 )
          break;
        v1 = byte_FC1E0[v3] < 0;
        LOBYTE(v3) = v3 + 1;
        --v4;
      }
      while ( v4 );
      LOBYTE(v3) = HIBYTE(*a1) - 8;
      ++HIBYTE(v3);
      --v5;
    }
    while ( v5 );
  }
  return !v1;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00013170) --------------------------------------------------------
int sub_13170(int a1)
{
  int result; // eax

  sub_132B0(a1);
  switch ( *(_BYTE *)(*(_DWORD *)(a1 + 160) + 415) )
  {
    case 0:
      sub_136C0(a1);
      result = sub_136C0(a1);
      break;
    case 1:
      sub_13800(a1);
      result = sub_136C0(a1);
      break;
    case 2:
    case 5:
      sub_138E0();
      result = sub_136C0(a1);
      break;
    case 3:
      sub_138F0(a1);
      result = sub_136C0(a1);
      break;
    case 4:
      sub_13990((_WORD *)a1);
      result = sub_136C0(a1);
      break;
    case 6:
      sub_13BA0(a1);
      result = sub_136C0(a1);
      break;
    case 7:
      sub_13CA0(a1);
      result = sub_136C0(a1);
      break;
    case 8:
    case 9:
      sub_13DC0(a1);
      result = sub_136C0(a1);
      break;
    case 0xB:
      sub_13A70(a1);
      result = sub_136C0(a1);
      break;
    case 0xC:
      sub_13A10(a1);
      result = sub_136C0(a1);
      break;
    case 0xD:
      sub_13DC0(a1);
      goto LABEL_13;
    default:
LABEL_13:
      result = sub_136C0(a1);
      break;
  }
  return result;
}

//----- (000132B0) --------------------------------------------------------
int sub_132B0(int a1)
{
  int v1; // edx
  __int16 v2; // cx
  unsigned __int16 i; // ax
  int v4; // edx
  __int16 v5; // di
  unsigned __int16 j; // ax
  int v7; // ecx
  int v8; // esi
  unsigned __int16 v9; // di
  int v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // edx
  unsigned __int16 v14; // si
  int v16; // edx
  unsigned __int8 v17; // cl
  int v18; // ecx
  int v19; // edi
  int v20; // edx
  unsigned int v21; // ebp
  int v22; // edi
  int v23; // eax
  int v24; // esi
  int v25; // edx
  int v26; // eax
  int v27; // eax
  char v29; // [esp+0h] [ebp-14h]

  v29 = 0;
  sub_16990();
  v1 = *(_DWORD *)(a1 + 160);
  v2 = *(_WORD *)(v1 + 404);
  if ( v2 < 0 )
    *(_WORD *)(v1 + 404) = v2 + 1;
  for ( i = 0; i < 0x18u; ++i )
  {
    v4 = *(_DWORD *)(a1 + 160) + 2 * i;
    v5 = *(_WORD *)(v4 + 724);
    if ( v5 > 0 )
      *(_WORD *)(v4 + 724) = v5 - 1;
  }
  for ( j = 0; j < 8u; ++j )
  {
    v7 = *(_DWORD *)(a1 + 160);
    v8 = 8 * j;
    v9 = *(_WORD *)(v7 + v8 + 460);
    if ( v9 < 0x601Fu )
    {
      *(_WORD *)(v7 + v8 + 460) = *(_WORD *)(v7 + 522) + 1 + v9;
      v10 = v8 + *(_DWORD *)(a1 + 160);
      if ( *(_WORD *)(v10 + 460) > 0x601Fu )
        *(_WORD *)(v10 + 460) = 24607;
    }
    v11 = *(_DWORD *)(a1 + 160);
    v12 = v11 + 8 * j;
    if ( *(_WORD *)(v12 + 460) > 0x601Fu )
    {
      if ( !*(_WORD *)(v12 + 462) )
        *(_WORD *)(v12 + 460) -= 256 - *(_WORD *)(v11 + 522);
      v13 = *(_DWORD *)(a1 + 160) + 8 * j;
      if ( *(_WORD *)(v13 + 460) < 0x601Fu )
        *(_WORD *)(v13 + 460) = 24607;
    }
  }
  sub_45C10(a1);
  v14 = *(_WORD *)(*(_DWORD *)(a1 + 160) + 50);
  if ( v14 && sub_11950(a1, 164 * v14 + dword_AE400 + 29795) )
    v29 = 1;
  if ( v29 )
    *(_WORD *)(*(_DWORD *)(a1 + 160) + 331) = 2;
  if ( *(_WORD *)(*(_DWORD *)(a1 + 160) + 331) )
  {
    memset((void*)(a1 + 90), 0, 36);
    --*(_WORD *)(*(_DWORD *)(a1 + 160) + 331);
  }
  else if ( sub_46540(a1) == 2 )
  {
    *(_BYTE *)(a1 + 70) = 2;
    return 0;
  }
  sub_14EB0(a1);
  v16 = *(_DWORD *)(a1 + 160);
  v17 = *(_BYTE *)(v16 + 326);
  if ( v17 < 0xC8u )
    *(_BYTE *)(v16 + 326) = v17 + 1;
  *(_DWORD *)(a1 + 140) += *(_DWORD *)(a1 + 132);
  v18 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 341) + *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v18;
  if ( v18 < -1 )
    *(_DWORD *)(a1 + 12) = -1;
  v19 = *(_DWORD *)(a1 + 8);
  if ( *(_DWORD *)(a1 + 12) > v19 )
    *(_DWORD *)(a1 + 12) = v19;
  v20 = *(_DWORD *)(a1 + 160);
  v21 = *(_DWORD *)(v20 + 351);
  if ( v21 )
    *(_DWORD *)(v20 + 351) = v21 - 1;
  if ( v29 || (*(_BYTE *)(a1 + 17) & 0x10) != 0 )
  {
    *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 136) / 200;
    *(_WORD *)(*(_DWORD *)(a1 + 160) + 341) = *(_DWORD *)(a1 + 8) / 200;
    if ( *(int *)(a1 + 132) < 1000 )
      *(_DWORD *)(a1 + 132) = 1000;
    *(_BYTE *)(a1 + 17) &= ~0x10u;
  }
  else
  {
    *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 136) / 2000;
    *(_WORD *)(*(_DWORD *)(a1 + 160) + 341) = *(_DWORD *)(a1 + 8) / 500;
    if ( *(int *)(a1 + 132) < 100 )
      *(_DWORD *)(a1 + 132) = 100;
  }
  if ( *(int *)(a1 + 140) < 0 )
    *(_DWORD *)(a1 + 140) = 0;
  v22 = *(_DWORD *)(a1 + 136);
  if ( *(_DWORD *)(a1 + 140) > v22 )
    *(_DWORD *)(a1 + 140) = v22;
  sub_15EC0(a1);
  v23 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 526);
  if ( !(*(unsigned __int8 *)(a1 + 63) % (64 - ((v23 - (__CFSHL__(v23 >> 31, 2) + 4 * (v23 >> 31))) >> 2))) )
  {
    v24 = sub_16800(v21, a1);
    if ( v24 )
    {
      sub_16870(a1);
      sub_16890(a1, v24);
    }
    if ( *(_DWORD *)(a1 + 12) < *(_DWORD *)(a1 + 8) )
      sub_155F0(a1, 1u);
  }
  v25 = (__int16)sub_11F50((__int16 *)(a1 + 72));
  v26 = *(_DWORD *)(a1 + 156);
  if ( *(__int16 *)(a1 + 76) > v25 + *(__int16 *)(v26 + 10) )
    *(_WORD *)(a1 + 76) = *(_WORD *)(v26 + 10) + v25;
  v27 = *(_DWORD *)(a1 + 156);
  if ( *(__int16 *)(a1 + 76) < v25 + *(__int16 *)(v27 + 12) )
    *(_WORD *)(a1 + 76) = *(_WORD *)(v27 + 12) + v25;
  return 1;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// AE400: using guessed type int dword_AE400;

//----- (000136C0) --------------------------------------------------------
int sub_136C0(int a1)
{
  int v2; // eax

  if ( sub_13F00(a1) )
  {
    sub_14C80(a1);
    return 1;
  }
  else if ( sub_14310(a1) )
  {
    sub_14DA0(a1);
    return 1;
  }
  else
  {
    v2 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 526);
    if ( *(unsigned __int8 *)(a1 + 63) % (64 - ((v2 - (__CFSHL__(v2 >> 31, 2) + 4 * (v2 >> 31))) >> 2)) )
    {
      return 1;
    }
    else if ( sub_14120(a1) )
    {
      sub_14C40(a1);
      return 1;
    }
    else if ( sub_143A0(a1) )
    {
      sub_14D00(a1);
      return 1;
    }
    else if ( sub_145B0(a1) )
    {
      sub_14D60(a1);
      return 1;
    }
    else if ( sub_147E0(a1) )
    {
      sub_14D40(a1);
      return 1;
    }
    else if ( sub_14230(a1) )
    {
      sub_14CE0(a1);
      return 1;
    }
    else
    {
      if ( sub_14B10(a1) )
        sub_14D20(a1);
      else
        sub_14DC0(a1);
      return 1;
    }
  }
}

//----- (00013800) --------------------------------------------------------
bool sub_13800(int a1)
{
  int v1; // ebx
  bool result; // eax
  int v3; // ebx
  int v4; // eax

  v1 = 164 * *(unsigned __int16 *)(a1 + 146) + dword_AE400 + 29795;
  result = sub_15440(a1, v1);
  if ( result )
  {
    *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v1 + 72));
    if ( sub_15470(a1, v1, 512, 2048) )
    {
      if ( sub_155F0(a1, 0x10u) )
        return 0;
      v3 = *(__int16 *)(a1 + 76) - (*(__int16 *)(v1 + 76) + 512);
      if ( v3 )
        v4 = v3 / (int)abs32(v3);
      else
        LOWORD(v4) = 0;
      *(_WORD *)(a1 + 76) += v4 * *(_WORD *)(*(_DWORD *)(a1 + 156) + 14);
    }
    return 1;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (000138E0) --------------------------------------------------------
int sub_138E0()
{
  return 0;
}

//----- (000138F0) --------------------------------------------------------
int sub_138F0(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(a1 + 150));
  result = sub_15470(a1, 0, 2048, 3072);
  if ( result )
  {
    if ( sub_155F0(a1, 0x10u) )
    {
      return 0;
    }
    else
    {
      v2 = *(__int16 *)(a1 + 76) - (*(__int16 *)(a1 + 154) + 512);
      if ( v2 )
        v3 = v2 / (int)abs32(v2);
      else
        LOWORD(v3) = 0;
      *(_WORD *)(a1 + 76) += v3 * *(_WORD *)(*(_DWORD *)(a1 + 156) + 14);
      return 1;
    }
  }
  return result;
}

//----- (00013990) --------------------------------------------------------
bool sub_13990(_WORD *a1)
{
  int v1; // esi
  bool result; // eax

  v1 = 164 * (unsigned __int16)a1[73] + dword_AE400 + 29795;
  result = sub_15440((int)a1, v1);
  if ( result )
  {
    a1[17] = sub_42150(a1 + 36, (_WORD *)(v1 + 72));
    return sub_15470((int)a1, v1, 256, 2048) == 0;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00013A10) --------------------------------------------------------
int sub_13A10(int a1)
{
  if ( !sub_15E60(a1, 2u) )
  {
    if ( sub_15A00(a1, 2u) )
    {
      sub_155F0(a1, 2u);
      return 0;
    }
    *(_WORD *)(*(_DWORD *)(a1 + 160) + 12) = *(_WORD *)(a1 + 128);
    *(_WORD *)(*(_DWORD *)(a1 + 160) + 14) = 1;
  }
  return 0;
}

//----- (00013A70) --------------------------------------------------------
bool sub_13A70(int a1)
{
  unsigned int v1; // esi

  v1 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 50);
  if ( v1 <= dword_AE400 + 29795 )
  {
    if ( sub_15A00(a1, 0xCu) )
      sub_155F0(a1, 0xCu);
    if ( !sub_15E60(a1, 2u) )
    {
      if ( sub_15A00(a1, 2u) )
      {
        sub_155F0(a1, 2u);
        return 0;
      }
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 12) = *(_WORD *)(a1 + 128);
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 14) = 1;
    }
    return 0;
  }
  if ( sub_42410((_WORD *)(a1 + 72), (_WORD *)(v1 + 72)) > 104857600 && sub_155F0(a1, 0x13u) )
    return 1;
  sub_155F0(a1, 0xCu);
  if ( !sub_15440(a1, v1) )
    return 0;
  *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v1 + 72));
  return !sub_15470(a1, v1, 256, 2048);
}
// AE400: using guessed type int dword_AE400;

//----- (00013BA0) --------------------------------------------------------
bool sub_13BA0(int a1)
{
  _WORD *v1; // esi
  bool result; // eax
  __int16 v3; // ax
  int v4; // ecx
  int v5; // eax

  v1 = (_WORD *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 146));
  result = sub_15440(a1, (int)v1);
  if ( result )
  {
    *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), v1 + 36);
    if ( sub_15470(a1, (int)v1, 1024, 3072) )
    {
      if ( sub_155F0(a1, 3u) )
      {
        v3 = sub_42150((_WORD *)(a1 + 72), v1 + 36);
        if ( (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), v3) < 0x1Cu )
          v1[72] = *(_WORD *)(a1 + 24);
      }
      v4 = *(__int16 *)(a1 + 76) - ((__int16)v1[38] + 512);
      if ( v4 )
        v5 = v4 / (int)abs32(v4);
      else
        LOWORD(v5) = 0;
      *(_WORD *)(a1 + 76) += v5 * *(_WORD *)(*(_DWORD *)(a1 + 156) + 14);
    }
    return 1;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00013CA0) --------------------------------------------------------
bool sub_13CA0(int a1)
{
  int v1; // esi
  bool result; // eax
  int v3; // eax
  signed __int8 v4; // al
  int v5; // ecx
  int v6; // eax

  v1 = 164 * *(unsigned __int16 *)(a1 + 146) + dword_AE400 + 29795;
  result = sub_15440(a1, v1);
  if ( result )
  {
    *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v1 + 72));
    if ( sub_15470(a1, v1, 2048, 3584) )
    {
      v3 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 526);
      if ( !(*(unsigned __int8 *)(a1 + 63) % (64 - ((v3 - (__CFSHL__(v3 >> 31, 2) + 4 * (v3 >> 31))) >> 2))) )
      {
        v4 = sub_16310((_DWORD *)a1);
        if ( v4 != -1 && sub_155F0(a1, v4) )
          return 0;
        v5 = *(__int16 *)(a1 + 76) - (*(__int16 *)(v1 + 76) + 512);
        if ( v5 )
          v6 = v5 / (int)abs32(v5);
        else
          LOWORD(v6) = 0;
        *(_WORD *)(a1 + 76) += v6 * *(_WORD *)(*(_DWORD *)(a1 + 156) + 14);
      }
    }
    return 1;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00013DC0) --------------------------------------------------------
bool sub_13DC0(int a1)
{
  return sub_13DD0(a1);
}

//----- (00013DD0) --------------------------------------------------------
bool sub_13DD0(int a1)
{
  int v1; // esi
  bool result; // eax
  signed __int8 v3; // al
  unsigned __int8 v4; // di
  int v5; // eax

  v1 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 146);
  result = sub_15440(a1, v1);
  if ( !result )
    return result;
  *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v1 + 72));
  if ( !sub_15470(a1, v1, 3072, 4096) || *(__int16 *)(*(_DWORD *)(a1 + 160) + 404) < 0 )
    return 1;
  v3 = sub_16030(a1);
  if ( v3 == -1 || (v4 = v3, !sub_15A00(a1, v3)) || !sub_155F0(a1, v4) )
  {
    v5 = *(__int16 *)(a1 + 76) - (*(__int16 *)(v1 + 76) + 512);
    if ( v5 )
      v5 /= (int)abs32(v5);
    *(_WORD *)(a1 + 76) += v5 * *(_WORD *)(*(_DWORD *)(a1 + 156) + 14);
    return 1;
  }
  if ( *(_BYTE *)(v1 + 65) <= 1u )
    *(_WORD *)(*(_DWORD *)(a1 + 160) + 8 * *(__int16 *)(*(_DWORD *)(v1 + 160) + 48) + 462) = 0;
  return 0;
}
// AE400: using guessed type int dword_AE400;

//----- (00013F00) --------------------------------------------------------
int sub_13F00(int a1)
{
  _WORD *v1; // esi
  __int16 v2; // bx
  unsigned int v3; // eax
  _WORD *v4; // esi
  int result; // eax
  unsigned int v6; // eax
  _WORD *v7; // esi
  int v8; // [esp+0h] [ebp-28h]
  __int16 v9; // [esp+4h] [ebp-24h]
  int v10; // [esp+8h] [ebp-20h]

  v1 = (_WORD *)(dword_AE400 + 29795);
  if ( !*(_WORD *)(*(_DWORD *)(a1 + 160) + 50) && sub_14E60(a1, 0x10u) && sub_15E90(a1, 0x10u) )
  {
    v1[12] = *(_WORD *)(a1 + 24);
    v8 = (int)(*(__int16 *)(a1 + 72)
             - (__CFSHL__((unsigned __int64)*(__int16 *)(a1 + 72) >> 32, 14)
              + ((unsigned __int64)*(__int16 *)(a1 + 72) >> 32 << 14))) >> 14;
    v10 = (int)(*(__int16 *)(a1 + 74)
              - (__CFSHL__((unsigned __int64)*(__int16 *)(a1 + 74) >> 32, 14)
               + ((unsigned __int64)*(__int16 *)(a1 + 74) >> 32 << 14))) >> 14;
    v9 = v10 + 4;
    do
    {
      v2 = v8;
      do
      {
        v1[36] = (v2 & 3) << 14;
        v1[37] = (v10 & 3) << 14;
        v3 = sub_15260((int)v1, 2u);
        if ( !v3 || sub_42300((_WORD *)(v3 + 72), v1 + 36) > 12288 )
        {
          v4 = v1 + 36;
          result = 1;
          *(_DWORD *)(a1 + 150) = *(_DWORD *)v4;
          *(_WORD *)(a1 + 154) = v4[2];
          return result;
        }
        v1[36] = (((v2 & 3) << 6) + 31) << 8;
        v1[37] = (((v10 & 3) << 6) + 31) << 8;
        v6 = sub_15260((int)v1, 2u);
        if ( !v6 || sub_42300((_WORD *)(v6 + 72), v1 + 36) > 12288 )
        {
          v7 = v1 + 36;
          result = 1;
          *(_DWORD *)(a1 + 150) = *(_DWORD *)v7;
          *(_WORD *)(a1 + 154) = v7[2];
          return result;
        }
        ++v2;
      }
      while ( v2 < (__int16)(v8 + 4) );
      LOWORD(v10) = v10 + 1;
    }
    while ( (__int16)v10 < v9 );
  }
  return 0;
}
// AE400: using guessed type int dword_AE400;

//----- (00014120) --------------------------------------------------------
int sub_14120(int a1)
{
  unsigned int v1; // esi
  unsigned int v2; // eax
  unsigned int v3; // ebx
  int v4; // eax

  v1 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 50);
  if ( v1 <= dword_AE400 + 29795 )
    return 0;
  v2 = sub_14E60(a1, 0x10u);
  v3 = v2;
  if ( !v2 )
    return 0;
  if ( *(_WORD *)(v2 + 48) )
    return 0;
  v4 = *(_DWORD *)(a1 + 160);
  if ( *(_WORD *)(v4 + 756)
    || !sub_12D10((_WORD *)(164 * *(unsigned __int16 *)(v4 + 50) + dword_AE400 + 29795))
    || *(_DWORD *)(a1 + 136) < *(_DWORD *)(v3 + 136)
    || *(_BYTE *)(v1 + 70) != 4 )
  {
    return 0;
  }
  *(_WORD *)(a1 + 146) = (int)(v1 - (dword_AE400 + 29795)) / 164;
  *(_WORD *)(a1 + 148) = sub_15420(v1);
  return 1;
}
// AE400: using guessed type int dword_AE400;

//----- (00014230) --------------------------------------------------------
unsigned int sub_14230(int a1)
{
  unsigned int result; // eax
  unsigned int v2; // eax
  unsigned int v3; // eax
  int v4; // ecx

  result = sub_14E60(a1, 3u);
  if ( result )
  {
    v2 = sub_14E60(a1, 0x10u);
    if ( v2 )
    {
      if ( *(_DWORD *)(a1 + 136) <= *(_DWORD *)(v2 + 136) )
      {
        v3 = sub_15080(a1);
        v4 = v3;
        if ( v3 )
          goto LABEL_5;
      }
    }
    else
    {
      v3 = sub_15080(a1);
      v4 = v3;
      if ( v3 )
      {
LABEL_5:
        *(_WORD *)(a1 + 146) = (int)(v3 - (dword_AE400 + 29795)) / 164;
        *(_WORD *)(a1 + 148) = sub_15420(v4);
        return 1;
      }
    }
    return 0;
  }
  return result;
}
// 142B6: conditional instruction was optimized away because eax.4==0
// AE400: using guessed type int dword_AE400;

//----- (00014310) --------------------------------------------------------
int sub_14310(int a1)
{
  unsigned int v1; // ecx

  if ( *(_DWORD *)(a1 + 8) / 2 <= *(_DWORD *)(a1 + 12) )
    return 0;
  v1 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 50);
  if ( v1 <= dword_AE400 + 29795 )
    return 0;
  *(_WORD *)(a1 + 146) = 164 * *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 50) / 164;
  *(_WORD *)(a1 + 148) = sub_15420(v1);
  return 1;
}
// AE400: using guessed type int dword_AE400;

//----- (000143A0) --------------------------------------------------------
int sub_143A0(int a1)
{
  unsigned int i; // ebx
  int v2; // edi
  unsigned int v3; // eax
  int v4; // ebx
  int v6; // [esp+8h] [ebp-1Ch]
  unsigned int v7; // [esp+Ch] [ebp-18h]

  v7 = -1;
  if ( !sub_16920(a1) || !*(_WORD *)(*(_DWORD *)(a1 + 160) + 50) && sub_14E60(a1, 0x10u) )
    return 0;
  v6 = 0;
  for ( i = *(_DWORD *)(dword_AE408 + 36462); i > dword_AE400 + 29795; i = *(_DWORD *)i )
  {
    if ( *(_WORD *)(i + 24) != *(_WORD *)(a1 + 24) && *(_BYTE *)(i + 65) == 2 )
    {
      if ( (v2 = 164 * *(__int16 *)(i + 24),
            50000 - *(_DWORD *)(dword_AE400 + v2 + 29931) / 10 * *(__int16 *)(*(_DWORD *)(a1 + 160) + 522) / 255 < *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 8 * *(__int16 *)(*(_DWORD *)(dword_AE400 + v2 + 29955) + 48) + 460))
        && sub_42410((_WORD *)(dword_AE400 + 29795 + v2 + 72), (_WORD *)(i + 72)) > 58982400
        && !sub_11950(dword_AE400 + 29795 + 164 * *(__int16 *)(i + 24), i)
        || *(_DWORD *)(i + 140) + 640 * (255 - *(__int16 *)(*(_DWORD *)(a1 + 160) + 522)) < *(_DWORD *)(164 * *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 50) + dword_AE400 + 29935) )
      {
        v3 = sub_42410((_WORD *)(a1 + 72), (_WORD *)(i + 72));
        if ( v3 < v7 )
        {
          v6 = i;
          v7 = v3;
        }
      }
    }
  }
  if ( !v6 )
    return 0;
  v4 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 28);
  if ( sub_42410((_WORD *)(v6 + 72), (_WORD *)(a1 + 72)) >= v4 * v4 )
    return 0;
  *(_WORD *)(a1 + 146) = (v6 - (dword_AE400 + 29795)) / 164;
  *(_WORD *)(a1 + 148) = sub_15420(v6);
  return 1;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (000145B0) --------------------------------------------------------
int sub_145B0(int a1)
{
  unsigned int v1; // ebp
  unsigned int i; // ebx
  int v3; // ecx
  int v4; // eax
  int v5; // edx
  unsigned int v7; // eax
  int v8; // ebx
  int v9; // [esp+8h] [ebp-18h]

  v1 = -1;
  if ( !sub_16920(a1) || !*(_WORD *)(*(_DWORD *)(a1 + 160) + 50) && sub_14E60(a1, 0x10u) )
    return 0;
  v9 = 0;
  for ( i = *(_DWORD *)(dword_AE408 + 36462); i > dword_AE400 + 29795; i = *(_DWORD *)i )
  {
    if ( *(_WORD *)(i + 24) != *(_WORD *)(a1 + 24) && *(_BYTE *)(i + 65) <= 1u && !sub_16000(i, 0xCu) )
    {
      v3 = *(_DWORD *)(i + 160);
      v4 = *(_DWORD *)(a1 + 160);
      v5 = v4 + 8 * *(__int16 *)(v3 + 48);
      if ( *(_WORD *)(v5 + 462) == 1 )
      {
        *(_WORD *)(a1 + 146) = (int)(i - (dword_AE400 + 29795)) / 164;
        *(_WORD *)(a1 + 148) = sub_15420(i);
        return 1;
      }
      if ( 50000 - *(__int16 *)(v4 + 522) * (*(_DWORD *)(i + 136) / 10) / 255 <= *(unsigned __int16 *)(v5 + 460)
        || !*(_WORD *)(v3 + 50)
        && sub_14E60(i, 0x10u)
        && *(_DWORD *)(i + 140) + 32 * (255 - *(__int16 *)(*(_DWORD *)(a1 + 160) + 522)) < *(_DWORD *)(a1 + 140) )
      {
        v7 = sub_42410((_WORD *)(a1 + 72), (_WORD *)(i + 72));
        if ( v7 < v1 )
        {
          v9 = i;
          v1 = v7;
        }
      }
    }
  }
  if ( !v9 )
    return 0;
  v8 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 28) + 10;
  if ( sub_42410((_WORD *)(v9 + 72), (_WORD *)(a1 + 72)) >= v8 * v8 )
    return 0;
  *(_WORD *)(a1 + 146) = (v9 - (dword_AE400 + 29795)) / 164;
  *(_WORD *)(a1 + 148) = sub_15420(v9);
  return 1;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (000147E0) --------------------------------------------------------
int sub_147E0(int a1)
{
  unsigned int i; // ebx
  int v2; // edx
  int v3; // edi
  int v4; // ecx
  int v5; // ecx
  unsigned int v6; // eax
  int v7; // ebx
  _WORD *v9; // [esp+0h] [ebp-24h]
  unsigned int v10; // [esp+4h] [ebp-20h]
  int v11; // [esp+8h] [ebp-1Ch]
  int v12; // [esp+Ch] [ebp-18h]

  v10 = -1;
  if ( !sub_16920(a1) )
    return 0;
  v12 = 0;
  v9 = (_WORD *)(a1 + 72);
  for ( i = *(_DWORD *)(dword_AE408 + 36462); i > dword_AE400 + 29795; i = *(_DWORD *)i )
  {
    if ( *(_WORD *)(i + 24) != *(_WORD *)(a1 + 24) && *(_BYTE *)(i + 65) == 3 )
    {
      v2 = dword_AE400 + 164 * *(__int16 *)(i + 24);
      v3 = *(_DWORD *)(v2 + 29955);
      v4 = *(_DWORD *)(a1 + 160);
      v11 = *(unsigned __int16 *)(v4 + 8 * *(__int16 *)(v3 + 48) + 460);
      v5 = *(__int16 *)(v4 + 522);
      if ( 50000 - v5 * (*(_DWORD *)(v2 + 29931) / 10) / 255 < v11
        && 10 * (275 - v5) < *(_DWORD *)(i + 140)
        && !sub_11950(i, dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(v3 + 50)) )
      {
        v6 = sub_42410(v9, (_WORD *)(i + 72));
        if ( v6 < v10 )
        {
          v12 = i;
          v10 = v6;
        }
      }
    }
  }
  if ( !v12 )
    return 0;
  v7 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 28);
  if ( sub_42410((_WORD *)(v12 + 72), v9) >= v7 * v7 )
    return 0;
  *(_WORD *)(a1 + 146) = (v12 - (dword_AE400 + 29795)) / 164;
  *(_WORD *)(a1 + 148) = sub_15420(v12);
  return 1;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00014B10) --------------------------------------------------------
int sub_14B10(int a1)
{
  unsigned int v1; // esi
  int v2; // ebp
  int v3; // eax
  unsigned int j; // ebx
  unsigned int v5; // eax
  int i; // [esp+0h] [ebp-18h]
  _WORD *v8; // [esp+4h] [ebp-14h]

  v1 = -1;
  v2 = 0;
  if ( !sub_16920(a1) )
    return 0;
  v3 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 50);
  if ( v3 == dword_AE400 + 29795 )
    v3 = a1;
  v8 = (_WORD *)(v3 + 72);
  for ( i = 0; i != 80; i += 4 )
  {
    for ( j = *(_DWORD *)(i + dword_AE408 + 36382); j > dword_AE400 + 29795; j = *(_DWORD *)j )
    {
      if ( *(_WORD *)(j + 24) != *(_WORD *)(a1 + 24) && *(int *)(j + 140) > 0 )
      {
        v5 = sub_42410(v8, (_WORD *)(j + 72));
        if ( v5 < v1 )
        {
          v2 = j;
          v1 = v5;
        }
      }
    }
  }
  if ( !v2 )
    return 0;
  *(_WORD *)(a1 + 146) = (v2 - (dword_AE400 + 29795)) / 164;
  *(_WORD *)(a1 + 148) = sub_15420(v2);
  return 1;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00014C40) --------------------------------------------------------
int sub_14C40(int a1)
{
  *(_BYTE *)(*(_DWORD *)(a1 + 160) + 415) = 1;
  return 1;
}

//----- (00014C80) --------------------------------------------------------
int sub_14C80(int a1)
{
  *(_BYTE *)(*(_DWORD *)(a1 + 160) + 415) = 3;
  return 1;
}

//----- (00014CE0) --------------------------------------------------------
int sub_14CE0(int a1)
{
  *(_BYTE *)(*(_DWORD *)(a1 + 160) + 415) = 6;
  return 1;
}

//----- (00014D00) --------------------------------------------------------
int sub_14D00(int a1)
{
  *(_BYTE *)(*(_DWORD *)(a1 + 160) + 415) = 7;
  return 1;
}

//----- (00014D20) --------------------------------------------------------
int sub_14D20(int a1)
{
  *(_BYTE *)(*(_DWORD *)(a1 + 160) + 415) = 13;
  return 1;
}

//----- (00014D40) --------------------------------------------------------
int sub_14D40(int a1)
{
  *(_BYTE *)(*(_DWORD *)(a1 + 160) + 415) = 9;
  return 1;
}

//----- (00014D60) --------------------------------------------------------
int sub_14D60(int a1)
{
  *(_BYTE *)(*(_DWORD *)(a1 + 160) + 415) = 8;
  return 1;
}

//----- (00014DA0) --------------------------------------------------------
int sub_14DA0(int a1)
{
  *(_BYTE *)(*(_DWORD *)(a1 + 160) + 415) = 11;
  return 1;
}

//----- (00014DC0) --------------------------------------------------------
int sub_14DC0(int a1)
{
  unsigned int v1; // ecx

  if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 8)
    || (v1 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 50), v1 <= dword_AE400 + 29795) )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 160) + 415) = 12;
  }
  else
  {
    *(_WORD *)(a1 + 146) = 164 * *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 50) / 164;
    *(_WORD *)(a1 + 148) = sub_15420(v1);
    *(_BYTE *)(*(_DWORD *)(a1 + 160) + 415) = 11;
  }
  return 1;
}
// AE400: using guessed type int dword_AE400;

//----- (00014E60) --------------------------------------------------------
unsigned int sub_14E60(int a1, unsigned __int8 a2)
{
  unsigned int result; // eax

  result = dword_AE400 + 29795 + 164 * *(__int16 *)(*(_DWORD *)(a1 + 160) + 2 * a2 + 676);
  if ( result <= dword_AE400 + 29795 )
    return 0;
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00014EB0) --------------------------------------------------------
int sub_14EB0(int a1)
{
  __int16 *v1; // eax
  __int16 v2; // ax
  unsigned __int16 v3; // ax
  int v4; // ecx
  __int16 v5; // dx
  __int16 *v6; // edi
  int v7; // eax
  __int16 v8; // ax
  int v9; // eax
  __int16 v10; // ax
  unsigned __int16 v11; // cx
  __int64 v12; // rax
  int v13; // eax
  int v14; // ecx
  __int16 v15; // si
  __int16 v16; // si
  unsigned int v17; // eax
  unsigned __int16 v18; // si
  unsigned __int16 v19; // dx
  int v21; // [esp-Ch] [ebp-18h]
  int v22; // [esp-8h] [ebp-14h]
  int v23; // [esp-4h] [ebp-10h]

  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  v1 = *(__int16 **)(a1 + 156);
  v23 = v1[7];
  v22 = v1[5];
  v21 = v1[6];
  v2 = sub_11F50(&word_AE454);
  sub_42000((int)&word_AE454, v2, v21, v22, v23);
  sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), 0, *(_WORD *)(a1 + 126));
  v3 = *(_WORD *)(a1 + 30);
  HIBYTE(v3) += 2;
  sub_41EC0((uint16*)&word_AE454, v3, 0, *(_WORD *)(*(_DWORD *)(a1 + 160) + 16));
  v4 = *(_DWORD *)(a1 + 160);
  v5 = *(_WORD *)(v4 + 16);
  v6 = (__int16 *)(v4 + 16);
  if ( v5 )
    v7 = v5 / (int)abs16(v5);
  else
    LOWORD(v7) = 0;
  v8 = *v6 - 4 * v7;
  *v6 = v8;
  sub_41C70(v8, a1, (int)&word_AE454);
  v9 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 12) - *(__int16 *)(a1 + 126);
  if ( v9 )
    v9 /= (int)abs32(v9);
  *(_WORD *)(a1 + 126) += 16 * v9;
  v10 = *(_WORD *)(a1 + 34);
  HIBYTE(v10) &= 7u;
  v11 = sub_42210(*(_WORD *)(a1 + 30), v10);
  v12 = 255 - *(__int16 *)(*(_DWORD *)(a1 + 160) + 526);
  v13 = v11 / (int)(unsigned __int16)(((int)(v12 - (__CFSHL__(HIDWORD(v12), 4) + 16 * HIDWORD(v12))) >> 4) + 8);
  v14 = *(_DWORD *)(a1 + 156);
  v15 = v13;
  if ( (__int16)v13 <= *(__int16 *)(v14 + 2) )
  {
    if ( (__int16)v13 < *(__int16 *)(v14 + 4) )
      v15 = *(_WORD *)(v14 + 4);
  }
  else
  {
    v15 = *(_WORD *)(v14 + 2);
  }
  v16 = sub_42240(*(unsigned __int16 *)(a1 + 30), *(_WORD *)(a1 + 34)) * v15;
  v17 = *(unsigned __int16 *)(a1 + 30);
  v18 = (v17 + v16) & 0x7FF;
  v19 = *(_WORD *)(a1 + 34);
  *(_WORD *)(a1 + 30) = v18;
  if ( (unsigned __int16)v17 < (unsigned int)v19 && v18 > v19
    || (v19 = *(_WORD *)(a1 + 34), v17 > v19) && v19 > *(_WORD *)(a1 + 30) )
  {
    *(_WORD *)(a1 + 30) = v19;
  }
  return 1;
}
// AE454: using guessed type __int16 word_AE454;

//----- (00015080) --------------------------------------------------------
unsigned int sub_15080(int a1)
{
  unsigned int v1; // esi
  unsigned int v2; // ebx
  int v3; // eax
  int v4; // edx
  unsigned int v5; // eax
  unsigned int v6; // eax
  int v7; // ebp
  unsigned int v9; // [esp+8h] [ebp-24h]
  _WORD *v10; // [esp+Ch] [ebp-20h]
  unsigned int v11; // [esp+10h] [ebp-1Ch]
  unsigned int v12; // [esp+18h] [ebp-14h]

  v1 = -1;
  v2 = *(_DWORD *)(dword_AE408 + 36466);
  v9 = 164 * *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 50) + dword_AE400 + 29795;
  v12 = 0;
  v10 = (_WORD *)(a1 + 72);
  while ( v2 > dword_AE400 + 29795 )
  {
    v3 = *(unsigned __int16 *)(v2 + 144);
    v4 = 164 * (unsigned __int16)v3 + dword_AE400;
    if ( *(_BYTE *)(v4 + 29859) != 3 )
    {
      v5 = sub_42410(v10, (_WORD *)(v2 + 72));
      if ( v5 >= v1 )
        goto LABEL_19;
      goto LABEL_18;
    }
    if ( v3 == *(__int16 *)(a1 + 24) )
      goto LABEL_19;
    if ( 50000 - *(_DWORD *)(v4 + 29931) / 10 * *(__int16 *)(*(_DWORD *)(a1 + 160) + 522) / 255 < *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 8 * *(__int16 *)(*(_DWORD *)(v4 + 29955) + 48) + 460) )
    {
      v5 = sub_42410((_WORD *)(v9 + 72), (_WORD *)(v2 + 72));
      if ( v5 >= v1 )
        goto LABEL_19;
LABEL_18:
      v12 = v2;
      v1 = v5;
      goto LABEL_19;
    }
    v11 = sub_15340(v2, a1);
    if ( v11 )
    {
      v6 = dword_AE400 + 29795 >= v9 ? sub_15260(v2, 2u) : sub_153B0(v2, v9);
      v7 = v6;
      if ( (*(_WORD *)(a1 + 24) == *(_WORD *)(v11 + 24) || sub_42410((_WORD *)(v2 + 72), (_WORD *)(v11 + 72)) > 26214400)
        && (!v7 || !sub_11950(v2, v7)) )
      {
        v5 = sub_42410(v10, (_WORD *)(v2 + 72));
        if ( v5 < v1 )
          goto LABEL_18;
      }
    }
LABEL_19:
    v2 = *(_DWORD *)v2;
  }
  return v12;
}
// 15222: conditional instruction was optimized away because cl.1!=3
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00015260) --------------------------------------------------------
unsigned int sub_15260(int a1, unsigned __int8 a2)
{
  unsigned int v2; // esi
  unsigned int v3; // edi
  unsigned int i; // ebx
  unsigned int v5; // eax
  unsigned int j; // ebx
  unsigned int v7; // eax

  v2 = -1;
  v3 = 0;
  if ( a2 < 2u )
  {
    if ( a2 )
      return v3;
  }
  else if ( a2 > 3u )
  {
    if ( a2 == 0xFF )
    {
      for ( i = *(_DWORD *)(dword_AE408 + 36462); i > dword_AE400 + 29795; i = *(_DWORD *)i )
      {
        if ( *(_WORD *)(i + 24) != *(_WORD *)(a1 + 24) )
        {
          v5 = sub_42410((_WORD *)(a1 + 72), (_WORD *)(i + 72));
          if ( v5 < v2 )
          {
            v3 = i;
            v2 = v5;
          }
        }
      }
    }
    return v3;
  }
  for ( j = *(_DWORD *)(dword_AE408 + 36462); j > dword_AE400 + 29795; j = *(_DWORD *)j )
  {
    if ( *(_WORD *)(j + 24) != *(_WORD *)(a1 + 24) && *(char *)(j + 65) == a2 )
    {
      v7 = sub_42410((_WORD *)(a1 + 72), (_WORD *)(j + 72));
      if ( v7 < v2 )
      {
        v3 = j;
        v2 = v7;
      }
    }
  }
  return v3;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00015340) --------------------------------------------------------
unsigned int sub_15340(int a1, int a2)
{
  unsigned int v2; // esi
  unsigned int v3; // edi
  unsigned int i; // ebx
  __int16 v5; // ax
  unsigned int v6; // eax

  v2 = -1;
  v3 = 0;
  for ( i = *(_DWORD *)(dword_AE408 + 36462); i > dword_AE400 + 29795; i = *(_DWORD *)i )
  {
    v5 = *(_WORD *)(i + 24);
    if ( v5 != *(_WORD *)(a1 + 24) && v5 != *(_WORD *)(a2 + 24) && *(_BYTE *)(i + 65) <= 1u )
    {
      v6 = sub_42410((_WORD *)(a1 + 72), (_WORD *)(i + 72));
      if ( v6 < v2 )
      {
        v3 = i;
        v2 = v6;
      }
    }
  }
  return v3;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (000153B0) --------------------------------------------------------
unsigned int sub_153B0(int a1, int a2)
{
  unsigned int v2; // esi
  unsigned int v3; // edi
  unsigned int i; // ebx
  __int16 v5; // ax
  unsigned int v6; // eax

  v2 = -1;
  v3 = 0;
  for ( i = *(_DWORD *)(dword_AE408 + 36462); i > dword_AE400 + 29795; i = *(_DWORD *)i )
  {
    v5 = *(_WORD *)(i + 24);
    if ( v5 != *(_WORD *)(a1 + 24) && v5 != *(_WORD *)(a2 + 24) && *(_BYTE *)(i + 65) == 2 )
    {
      v6 = sub_42410((_WORD *)(a1 + 72), (_WORD *)(i + 72));
      if ( v6 < v2 )
      {
        v3 = i;
        v2 = v6;
      }
    }
  }
  return v3;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00015420) --------------------------------------------------------
__int16 sub_15420(int a1)
{
  return *(_WORD *)(a1 + 24) + *(char *)(a1 + 65) + (*(char *)(a1 + 64) << 7);
}

//----- (00015440) --------------------------------------------------------
bool sub_15440(int a1, int a2)
{
  return sub_15420(a2) == *(_WORD *)(a1 + 148);
}

//----- (00015470) --------------------------------------------------------
int sub_15470(int a1, int a2, signed int a3, signed int a4)
{
  signed int v4; // eax
  signed int v5; // esi
  signed int v6; // esi

  *(_WORD *)(*(_DWORD *)(a1 + 160) + 14) = 0;
  v4 = sub_42340((_WORD *)(a1 + 72), (_WORD *)(a2 + 72));
  v5 = v4;
  if ( a2 )
  {
    if ( v4 > a3 )
    {
      if ( sub_15E60(a1, 2u) )
        return 0;
      if ( v5 > a4 && sub_15A00(a1, 2u) )
      {
        sub_155F0(a1, 2u);
        return 0;
      }
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 12) = *(_WORD *)(a1 + 128);
      goto LABEL_15;
    }
LABEL_8:
    *(_WORD *)(*(_DWORD *)(a1 + 160) + 12) = 0;
    *(_WORD *)(*(_DWORD *)(a1 + 160) + 14) = 1;
    return 1;
  }
  v6 = sub_423D0((_WORD *)(a1 + 72), (_WORD *)(a1 + 150));
  if ( v6 <= a3 )
    goto LABEL_8;
  if ( !sub_15E60(a1, 2u) )
  {
    if ( v6 > a4 && sub_15A00(a1, 2u) )
    {
      sub_155F0(a1, 2u);
      return 0;
    }
    *(_WORD *)(*(_DWORD *)(a1 + 160) + 12) = *(_WORD *)(a1 + 128);
LABEL_15:
    *(_WORD *)(*(_DWORD *)(a1 + 160) + 14) = 1;
  }
  return 0;
}

//----- (000155F0) --------------------------------------------------------
int sub_155F0(int a1, unsigned __int8 a2)
{
  unsigned int v2; // esi
  int v3; // ebx
  int result; // eax
  unsigned int v5; // esi
  unsigned int v6; // eax
  int v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // eax

  if ( !sub_15A00(a1, a2) )
    return 0;
  *(_BYTE *)(a1 + 17) &= ~1u;
  switch ( a2 )
  {
    case 0u:
    case 0xFu:
      v2 = sub_14E60(a1, a2);
      if ( !v2
        || *(__int16 *)(*(_DWORD *)(a1 + 160) + 404) < 0
        || *(_DWORD *)(a1 + 140) < *(_DWORD *)(v2 + 136)
        || (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), *(_WORD *)(a1 + 34)) >= 0xAAu )
      {
        return 0;
      }
      *(_WORD *)(2 * a2 + *(_DWORD *)(a1 + 160) + 724) = word_90034[a2];
      *(_WORD *)(a1 + 32) = sub_42180(
                              (_WORD *)(a1 + 72),
                              (_WORD *)(164 * *(unsigned __int16 *)(a1 + 146) + dword_AE400 + 29795 + 72));
      *(_WORD *)(v2 + 48) = *(_WORD *)(v2 + 50);
      ++*(_WORD *)(*(_DWORD *)(a1 + 160) + 404);
      v3 = *(_DWORD *)(a1 + 160);
      if ( *(__int16 *)(v3 + 404) >= 8 )
        *(_WORD *)(v3 + 404) = ((*(__int16 *)(v3 + 526)
                               - 255
                               - (__CFSHL__((*(__int16 *)(v3 + 526) - 255) >> 31, 3)
                                + 8 * ((*(__int16 *)(v3 + 526) - 255) >> 31))) >> 3)
                             - 1;
      result = 1;
      break;
    case 1u:
    case 4u:
    case 5u:
    case 0xEu:
      v9 = sub_14E60(a1, a2);
      if ( !v9 || *(_DWORD *)(a1 + 140) < *(_DWORD *)(v9 + 136) )
        return 0;
      *(_WORD *)(v9 + 48) = *(_WORD *)(v9 + 50);
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 2 * a2 + 724) = word_90034[a2];
      result = 1;
      break;
    case 2u:
      v8 = sub_14E60(a1, a2);
      if ( !v8 || *(_WORD *)(v8 + 48) || *(_DWORD *)(a1 + 140) < *(_DWORD *)(v8 + 136) )
        return 0;
      *(_WORD *)(v8 + 48) = *(_WORD *)(v8 + 50);
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 2 * a2 + 724) = word_90034[a2];
      result = 1;
      break;
    case 3u:
    case 7u:
    case 8u:
    case 0xBu:
    case 0xDu:
    case 0x11u:
    case 0x14u:
      v5 = sub_14E60(a1, a2);
      if ( !v5
        || *(_DWORD *)(a1 + 140) < *(_DWORD *)(v5 + 136)
        || (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), *(_WORD *)(a1 + 34)) >= 0xE3u )
      {
        return 0;
      }
      *(_WORD *)(2 * a2 + *(_DWORD *)(a1 + 160) + 724) = word_90034[a2];
      *(_WORD *)(a1 + 32) = sub_42180(
                              (_WORD *)(a1 + 72),
                              (_WORD *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 146) + 72));
      *(_WORD *)(v5 + 48) = *(_WORD *)(v5 + 50);
      result = 1;
      break;
    case 6u:
    case 9u:
    case 0xAu:
    case 0xCu:
      v10 = sub_14E60(a1, a2);
      if ( !v10 || *(_DWORD *)(a1 + 140) < *(_DWORD *)(v10 + 136) )
        return 0;
      *(_WORD *)(v10 + 48) = *(_WORD *)(v10 + 50);
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 2 * a2 + 724) = word_90034[a2];
      result = 1;
      break;
    case 0x10u:
      v6 = sub_14E60(a1, a2);
      if ( !v6 || *(_WORD *)(v6 + 48) || *(_DWORD *)(a1 + 140) < *(_DWORD *)(v6 + 136) )
        return 0;
      if ( *(_WORD *)(*(_DWORD *)(a1 + 160) + 50) )
      {
        *(_WORD *)(v6 + 48) = *(_WORD *)(v6 + 50);
        *(_WORD *)(*(_DWORD *)(a1 + 160) + 2 * a2 + 724) = word_90034[a2];
        result = 1;
      }
      else
      {
        v7 = sub_373F0(a1 + 150, 3, 2);
        if ( v7 )
        {
          *(_WORD *)(v7 + 24) = *(_WORD *)(a1 + 24);
          *(_WORD *)(*(_DWORD *)(a1 + 160) + 50) = (v7 - (dword_AE400 + 29795)) / 164;
        }
        result = 1;
      }
      break;
    default:
      return 0;
  }
  return result;
}
// 90034: using guessed type __int16 word_90034[24];
// AE400: using guessed type int dword_AE400;

//----- (00015A00) --------------------------------------------------------
int sub_15A00(int a1, unsigned __int8 a2)
{
  unsigned int v2; // eax
  int result; // eax
  unsigned int v4; // eax
  unsigned int v5; // eax
  int v6; // edx
  __int64 v7; // rax
  unsigned int v8; // esi
  int v9; // eax
  int v10; // edx
  __int64 v11; // rax
  unsigned int v12; // eax
  int v13; // edx
  __int64 v14; // rax
  unsigned int v15; // eax

  switch ( a2 )
  {
    case 0u:
    case 0xBu:
    case 0xDu:
    case 0xFu:
      v12 = sub_14E60(a1, a2);
      if ( !v12 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a1 + 160);
      if ( *(_WORD *)(v13 + 2 * a2 + 724) )
        goto LABEL_37;
      if ( *(_DWORD *)(a1 + 140) < *(_DWORD *)(v12 + 136) )
        goto LABEL_37;
      v14 = 255 - *(__int16 *)(v13 + 524);
      if ( (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), *(_WORD *)(a1 + 34)) >= ((((int)(v14
                                                                                           - (__CFSHL__(HIDWORD(v14), 2)
                                                                                            + 4 * HIDWORD(v14))) >> 2)
                                                                                    + 20) << 11)
                                                                                  / 360 )
        goto LABEL_37;
      result = 1;
      break;
    case 2u:
      v2 = sub_14E60(a1, a2);
      if ( !v2 || *(_DWORD *)(a1 + 140) < *(_DWORD *)(v2 + 136) )
        goto LABEL_37;
      result = 1;
      break;
    case 3u:
    case 7u:
    case 8u:
    case 0x11u:
    case 0x14u:
      v5 = sub_14E60(a1, a2);
      if ( !v5 )
        goto LABEL_37;
      if ( *(_WORD *)(v5 + 48) )
        goto LABEL_37;
      v6 = *(_DWORD *)(a1 + 160);
      if ( *(_WORD *)(v6 + 2 * a2 + 724) )
        goto LABEL_37;
      if ( *(_DWORD *)(a1 + 140) < *(_DWORD *)(v5 + 136) )
        goto LABEL_37;
      v7 = 255 - *(__int16 *)(v6 + 524);
      if ( (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), *(_WORD *)(a1 + 34)) >= ((((int)(v7
                                                                                           - (__CFSHL__(HIDWORD(v7), 2)
                                                                                            + 4 * HIDWORD(v7))) >> 2)
                                                                                    + 20) << 11)
                                                                                  / 360 )
        goto LABEL_37;
      result = 1;
      break;
    case 4u:
    case 0xCu:
    case 0xEu:
      v4 = sub_14E60(a1, a2);
      if ( !v4
        || *(_WORD *)(v4 + 48)
        || *(_WORD *)(*(_DWORD *)(a1 + 160) + 2 * a2 + 724)
        || *(_DWORD *)(a1 + 140) < *(_DWORD *)(v4 + 136) )
      {
        goto LABEL_37;
      }
      result = 1;
      break;
    case 0x10u:
      v8 = sub_14E60(a1, a2);
      if ( !v8 )
        goto LABEL_37;
      v9 = *(_DWORD *)(a1 + 160);
      v10 = v9 + 2 * a2;
      if ( *(_WORD *)(v9 + 50) )
      {
        if ( *(_WORD *)(v8 + 48) )
          goto LABEL_37;
        if ( *(_WORD *)(v10 + 724) )
          goto LABEL_37;
        if ( !sub_12D10((_WORD *)(164 * *(unsigned __int16 *)(v9 + 50) + dword_AE400 + 29795)) )
          goto LABEL_37;
        if ( *(_DWORD *)(a1 + 140) < *(_DWORD *)(v8 + 136) )
          goto LABEL_37;
        v11 = 255 - *(__int16 *)(*(_DWORD *)(a1 + 160) + 524);
        if ( (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), *(_WORD *)(a1 + 34)) >= ((((int)(v11
                                                                                             - (__CFSHL__(
                                                                                                  HIDWORD(v11),
                                                                                                  2)
                                                                                              + 4 * HIDWORD(v11))) >> 2)
                                                                                      + 20) << 11)
                                                                                    / 360 )
          goto LABEL_37;
        result = 1;
      }
      else
      {
        if ( *(_WORD *)(v10 + 724) || *(_DWORD *)(a1 + 140) < *(_DWORD *)(v8 + 136) )
          goto LABEL_37;
        result = 1;
      }
      break;
    default:
      if ( a2 >= 0x18u
        || (v15 = sub_14E60(a1, a2)) == 0
        || *(_WORD *)(*(_DWORD *)(a1 + 160) + 2 * a2 + 724)
        || *(_DWORD *)(a1 + 140) < *(_DWORD *)(v15 + 136) )
      {
LABEL_37:
        result = 0;
      }
      else
      {
        result = 1;
      }
      break;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00015E60) --------------------------------------------------------
bool sub_15E60(int a1, unsigned __int8 a2)
{
  unsigned int v2; // eax
  bool result; // eax

  result = 0;
  if ( a2 < 0x18u )
  {
    v2 = sub_14E60(a1, a2);
    if ( v2 )
    {
      if ( *(__int16 *)(v2 + 48) > 0 )
        return 1;
    }
  }
  return result;
}

//----- (00015E90) --------------------------------------------------------
bool sub_15E90(int a1, unsigned __int8 a2)
{
  return *(_DWORD *)(sub_14E60(a1, a2) + 136) <= *(_DWORD *)(a1 + 136);
}

//----- (00015EC0) --------------------------------------------------------
int sub_15EC0(int a1)
{
  int v1; // esi
  int v2; // eax
  __int16 v3; // bx
  int v4; // ecx
  int v5; // edx
  int v6; // eax
  int v7; // ebp
  int result; // eax
  unsigned int i; // [esp+4h] [ebp-1Ch]
  int v10; // [esp+8h] [ebp-18h]

  for ( i = *(_DWORD *)(dword_AE408 + 36462); ; i = *(_DWORD *)i )
  {
    result = dword_AE400 + 29795;
    if ( dword_AE400 + 29795 >= i )
      break;
    if ( !*(_BYTE *)(i + 65) )
    {
      v1 = 0;
      v10 = 0;
      do
      {
        v2 = v1 + *(_DWORD *)(a1 + 160);
        if ( !*(_WORD *)(v2 + 676) )
        {
          v3 = *(_WORD *)(v2 + 628);
          if ( v3 > 0 )
          {
            *(_WORD *)(v2 + 628) = v3 - 1;
            if ( v3 == 1 )
            {
              v4 = (*(int (**)(int))((char *)&off_987DE + v10))(a1 + 72);
              if ( v4 )
              {
                v5 = *(_DWORD *)(a1 + 160);
                v6 = 0;
                while ( *(_DWORD *)(v5 + 532) )
                {
                  ++v6;
                  v5 += 4;
                  if ( v6 >= 24 )
                    goto LABEL_12;
                }
                v7 = dword_AE400 + 29795;
                *(_BYTE *)(v4 + 16) |= 1u;
                *(_WORD *)(v4 + 42) = (a1 - v7) / 164;
                *(_DWORD *)(*(_DWORD *)(a1 + 160) + 4 * v6 + 532) = (v4 - v7) / 164;
              }
            }
          }
        }
LABEL_12:
        v1 += 2;
        v10 += 14;
      }
      while ( v1 != 48 );
    }
  }
  return result;
}
// 987DE: using guessed type int (*off_987DE)(int);
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00016000) --------------------------------------------------------
unsigned int sub_16000(int a1, unsigned __int8 a2)
{
  unsigned int result; // eax

  result = sub_14E60(a1, a2);
  if ( !result || *(__int16 *)(result + 48) <= 0 )
    return 0;
  return result;
}

//----- (00016030) --------------------------------------------------------
char sub_16030(int a1)
{
  int v1; // eax
  int v2; // ecx
  int v3; // eax
  int v4; // esi
  int v6; // esi

  v1 = (*(_DWORD *)(a1 + 136) - (__CFSHL__(*(int *)(a1 + 136) >> 31, 2) + 4 * (*(int *)(a1 + 136) >> 31))) >> 2;
  if ( v1 > *(_DWORD *)(a1 + 140) )
  {
    *(_WORD *)(*(_DWORD *)(a1 + 160) + 406) = 1;
    goto LABEL_9;
  }
  v2 = *(_DWORD *)(a1 + 160);
  if ( *(_WORD *)(v2 + 406) )
  {
    v3 = v1 + 6000;
    v4 = *(_DWORD *)(a1 + 136);
    if ( v3 >= v4 )
    {
      if ( v4 / 2 > *(_DWORD *)(a1 + 140) )
        goto LABEL_9;
    }
    else if ( v3 > *(_DWORD *)(a1 + 140) )
    {
      goto LABEL_9;
    }
    *(_WORD *)(v2 + 406) = 0;
  }
LABEL_9:
  if ( !*(_WORD *)(*(_DWORD *)(a1 + 160) + 406) )
  {
    if ( !sub_14E60(a1, 0x11u) )
      goto LABEL_50;
    if ( sub_15A00(a1, 0x11u) )
      return 17;
    if ( !sub_15E90(a1, 0x11u) || *(_WORD *)(*(_DWORD *)(a1 + 160) + 758) )
    {
LABEL_50:
      if ( !sub_14E60(a1, 8u) )
        goto LABEL_49;
      if ( sub_15A00(a1, 8u) )
        return 8;
      if ( !sub_15E90(a1, 8u) || *(_WORD *)(*(_DWORD *)(a1 + 160) + 740) )
      {
LABEL_49:
        if ( sub_16000(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 146), 0xEu)
          && (v6 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 524), rand() % 255 < v6) )
        {
          if ( sub_14E60(a1, 0xFu) )
          {
            if ( sub_15A00(a1, 0xFu) )
              return 15;
            if ( sub_15E90(a1, 0xFu) )
              return -1;
          }
        }
        else
        {
          if ( !sub_14E60(a1, 7u) )
            goto LABEL_52;
          if ( sub_15A00(a1, 7u) )
            return 7;
          if ( !sub_15E90(a1, 7u) || *(_WORD *)(*(_DWORD *)(a1 + 160) + 738) )
          {
LABEL_52:
            if ( !sub_14E60(a1, 0x14u) )
              goto LABEL_53;
            if ( sub_15A00(a1, 0x14u) )
              return 20;
            if ( !sub_15E90(a1, 0x14u) || *(_WORD *)(*(_DWORD *)(a1 + 160) + 764) )
            {
LABEL_53:
              if ( !sub_14E60(a1, 0) )
                goto LABEL_51;
              if ( sub_15A00(a1, 0) )
                return 0;
              if ( !sub_15E90(a1, 0) || *(_WORD *)(*(_DWORD *)(a1 + 160) + 724) )
              {
LABEL_51:
                if ( sub_14E60(a1, 0xFu) )
                {
                  if ( sub_15A00(a1, 0xFu) )
                    return 15;
                  sub_15E90(a1, 0xFu);
                }
              }
            }
          }
        }
      }
    }
  }
  return -1;
}
// 5D840: using guessed type int rand(void);
// AE400: using guessed type int dword_AE400;

//----- (00016310) --------------------------------------------------------
char sub_16310(_DWORD *a1)
{
  int v1; // eax
  int v2; // ecx
  int v3; // eax
  int v4; // esi

  v1 = (a1[34] - (__CFSHL__((int)a1[34] >> 31, 2) + 4 * ((int)a1[34] >> 31))) >> 2;
  if ( v1 > a1[35] )
  {
    *(_WORD *)(a1[40] + 406) = 1;
    goto LABEL_9;
  }
  v2 = a1[40];
  if ( *(_WORD *)(v2 + 406) )
  {
    v3 = v1 + 6000;
    v4 = a1[34];
    if ( v3 >= v4 )
    {
      if ( v4 / 2 > a1[35] )
        goto LABEL_9;
    }
    else if ( v3 > a1[35] )
    {
      goto LABEL_9;
    }
    *(_WORD *)(v2 + 406) = 0;
  }
LABEL_9:
  if ( !*(_WORD *)(a1[40] + 406) )
  {
    if ( !sub_14E60((int)a1, 0x11u) )
      goto LABEL_46;
    if ( sub_15A00((int)a1, 0x11u) )
      return 17;
    if ( !sub_15E90((int)a1, 0x11u) || *(_WORD *)(a1[40] + 758) )
    {
LABEL_46:
      if ( !sub_14E60((int)a1, 8u) )
        goto LABEL_45;
      if ( sub_15A00((int)a1, 8u) )
        return 8;
      if ( !sub_15E90((int)a1, 8u) || *(_WORD *)(a1[40] + 740) )
      {
LABEL_45:
        if ( !sub_14E60((int)a1, 7u) )
          goto LABEL_44;
        if ( sub_15A00((int)a1, 7u) )
          return 7;
        if ( !sub_15E90((int)a1, 7u) || *(_WORD *)(a1[40] + 738) )
        {
LABEL_44:
          if ( !sub_14E60((int)a1, 0x14u) )
            goto LABEL_43;
          if ( sub_15A00((int)a1, 0x14u) )
            return 20;
          if ( !sub_15E90((int)a1, 0x14u) || *(_WORD *)(a1[40] + 764) )
          {
LABEL_43:
            if ( !sub_14E60((int)a1, 0) )
              goto LABEL_42;
            if ( sub_15A00((int)a1, 0) )
              return 0;
            if ( !sub_15E90((int)a1, 0) || *(_WORD *)(a1[40] + 724) )
            {
LABEL_42:
              if ( sub_14E60((int)a1, 0xFu) )
              {
                if ( sub_15A00((int)a1, 0xFu) )
                  return 15;
                sub_15E90((int)a1, 0xFu);
              }
            }
          }
        }
      }
    }
  }
  return -1;
}

//----- (00016540) --------------------------------------------------------
int sub_16540(int result)
{
  unsigned int i; // edi
  unsigned int v2; // esi
  unsigned int v3; // ecx
  int v4; // ebx
  unsigned __int8 v5; // al
  int v6; // ebp
  int v7; // ebx
  unsigned __int8 v8; // al
  int v9; // edx
  int v10; // eax
  unsigned int v11; // ebp
  int v12; // edx
  unsigned int v13; // ebx

  for ( i = *(_DWORD *)(dword_AE408 + 36474); ; i = *(_DWORD *)i )
  {
    v12 = dword_AE400;
    v13 = dword_AE400 + 29795;
    if ( i <= dword_AE400 + 29795 )
      break;
    if ( (*(_BYTE *)(i + 17) & 0x20) != 0 )
      continue;
    result = 164 * *(__int16 *)(i + 24);
    v2 = v13 + result;
    if ( v13 + result <= v13 )
      continue;
    if ( *(_BYTE *)(v2 + 64) != 3 )
      continue;
    result = 164 * *(unsigned __int16 *)(i + 146);
    v3 = v13 + result;
    if ( v13 + result <= v13 )
      continue;
    *(_BYTE *)(i + 17) |= 0x20u;
    LOBYTE(result) = *(_BYTE *)(v3 + 64);
    if ( (unsigned __int8)result < 3u )
      continue;
    if ( (unsigned __int8)result <= 3u )
    {
      if ( *(_BYTE *)(v3 + 65) != 2 )
      {
        v7 = *(unsigned __int16 *)(*(_DWORD *)(v12 + 164 * *(__int16 *)(v3 + 24) + 29955)
                                 + 8 * *(__int16 *)(*(_DWORD *)(v2 + 160) + 48)
                                 + 460);
        v8 = *(_BYTE *)(i + 65);
        if ( v8 < 0xAu )
        {
          if ( v8 >= 3u && v8 <= 4u )
            goto LABEL_33;
LABEL_34:
          v7 += 500;
        }
        else if ( v8 > 0xAu )
        {
          if ( v8 > 0xBu && v8 != 16 )
            goto LABEL_34;
LABEL_33:
          v7 += 3000;
        }
        if ( v7 < 0 )
          v7 = 0;
        if ( v7 > 0xFFFF )
          LOWORD(v7) = -1;
        v9 = *(_DWORD *)(dword_AE400 + 164 * *(__int16 *)(v3 + 24) + 29955);
        v10 = *(_DWORD *)(v2 + 160);
        goto LABEL_49;
      }
      v4 = *(unsigned __int16 *)(*(_DWORD *)(v12 + 164 * *(__int16 *)(v3 + 24) + 29955)
                               + 8 * *(__int16 *)(*(_DWORD *)(v2 + 160) + 48)
                               + 460);
      v5 = *(_BYTE *)(i + 65);
      if ( v5 < 0xAu )
      {
        if ( v5 >= 3u && v5 <= 4u )
          goto LABEL_18;
LABEL_19:
        v4 += 1000;
      }
      else if ( v5 > 0xAu )
      {
        if ( v5 > 0xBu && v5 != 16 )
          goto LABEL_19;
LABEL_18:
        v4 += 5000;
      }
      if ( v4 < 0 )
        v4 = 0;
      if ( v4 > 0xFFFF )
        v4 = 0xFFFF;
      v6 = dword_AE400;
      *(_WORD *)(*(_DWORD *)(164 * *(__int16 *)(v3 + 24) + dword_AE400 + 29955)
               + 8 * *(__int16 *)(*(_DWORD *)(v2 + 160) + 48)
               + 460) = v4;
      result = *(_DWORD *)(v2 + 136) / 10 * *(__int16 *)(*(_DWORD *)(v3 + 160) + 522) / 255;
      if ( v4 > 50000 - result )
      {
        result = *(__int16 *)(*(_DWORD *)(v2 + 160) + 48);
        *(_WORD *)(*(_DWORD *)(164 * *(__int16 *)(v3 + 24) + v6 + 29955) + 8 * result + 462) = 1;
      }
      continue;
    }
    if ( (_BYTE)result == 10 && *(_BYTE *)(i + 65) == 1 )
    {
      LOBYTE(result) = *(_BYTE *)(v3 + 65);
      if ( (_BYTE)result == 39 )
      {
        result = 164 * *(unsigned __int16 *)(v3 + 144);
        v11 = v13 + result;
        if ( v13 + result > v13 && *(_BYTE *)(v11 + 64) == 3 )
        {
          v7 = ((*(_DWORD *)(v3 + 140) - (__CFSHL__(*(int *)(v3 + 140) >> 31, 2) + 4 * (*(int *)(v3 + 140) >> 31))) >> 2)
             + *(unsigned __int16 *)(*(_DWORD *)(v11 + 160) + 8 * *(__int16 *)(*(_DWORD *)(v2 + 160) + 48) + 460);
          if ( v7 < 0 )
            v7 = 0;
          if ( v7 > 0xFFFF )
            LOWORD(v7) = -1;
          v10 = *(_DWORD *)(v2 + 160);
          v9 = *(_DWORD *)(v11 + 160);
LABEL_49:
          result = *(__int16 *)(v10 + 48);
          *(_WORD *)(v9 + 8 * result + 460) = v7;
          continue;
        }
      }
    }
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00016800) --------------------------------------------------------
unsigned int sub_16800(unsigned int a1, int a2)
{
  unsigned int v2; // esi
  unsigned int i; // ebx
  unsigned int v4; // eax

  v2 = -1;
  for ( i = *(_DWORD *)(dword_AE408 + 36474); i > dword_AE400 + 29795; i = *(_DWORD *)i )
  {
    if ( *(unsigned __int16 *)(i + 146) == *(__int16 *)(a2 + 24) )
    {
      v4 = sub_42410((_WORD *)(a2 + 72), (_WORD *)(i + 72));
      if ( v4 < v2 )
      {
        v2 = v4;
        a1 = i;
      }
    }
  }
  if ( v2 >= 0x1900000 )
    return 0;
  else
    return a1;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00016870) --------------------------------------------------------
int sub_16870(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 160);
  *(_WORD *)(result + 16) = 80;
  return result;
}

//----- (00016890) --------------------------------------------------------
char sub_16890(int a1, int a2)
{
  int v2; // eax

  v2 = sub_42410((_WORD *)(a1 + 72), (_WORD *)(a2 + 72));
  if ( v2 < (int)&unk_100000 )
  {
    LOBYTE(v2) = *(_BYTE *)(a2 + 65);
    if ( (unsigned __int8)v2 < 4u )
    {
      if ( !(_BYTE)v2 || (_BYTE)v2 == 3 )
      {
LABEL_10:
        if ( sub_15A00(a1, 0xEu) )
        {
          LOBYTE(v2) = sub_155F0(a1, 0xEu);
          return v2;
        }
        v2 = sub_15A00(a1, 4u);
        if ( !v2 )
          return v2;
LABEL_15:
        LOBYTE(v2) = sub_155F0(a1, 4u);
      }
    }
    else
    {
      if ( (unsigned __int8)v2 <= 4u )
        goto LABEL_14;
      if ( (unsigned __int8)v2 >= 9u )
      {
        if ( (unsigned __int8)v2 > 9u )
        {
          if ( (_BYTE)v2 != 16 )
            return v2;
          goto LABEL_10;
        }
LABEL_14:
        v2 = sub_15A00(a1, 4u);
        if ( !v2 )
          return v2;
        goto LABEL_15;
      }
    }
  }
  return v2;
}

//----- (00016920) --------------------------------------------------------
_BOOL1 sub_16920(int a1)
{
  return sub_14E60(a1, 0)
      || sub_14E60(a1, 0xFu)
      || sub_14E60(a1, 8u)
      || sub_14E60(a1, 0x11u)
      || sub_14E60(a1, 0x14u)
      || sub_14E60(a1, 7u);
}

//----- (00016990) --------------------------------------------------------
char sub_16990()
{
  int v0; // ecx
  unsigned int i; // eax
  char result; // al

  v0 = dword_ACF50;
  for ( i = *(_DWORD *)(dword_AE408 + 36462); i > dword_AE400 + 29795; i = *(_DWORD *)i )
  {
    if ( !*(_BYTE *)(i + 65) )
      v0 = i;
  }
  result = 1;
  dword_ACF50 = v0;
  return result;
}
// ACF50: using guessed type int dword_ACF50;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (000169E0) --------------------------------------------------------
int sub_169E0()
{
  int result; // eax
  int v1; // ebx
  int v2; // ecx
  int v3; // edx

  result = dword_AE408;
  if ( !*(_BYTE *)(dword_AE408 + 150) )
  {
    v1 = ((word_9AD90 << 7) - 40960) / 320;
    if ( word_12F02E == 1 )
      v2 = (25600 - (word_9AD92 << 7)) / 200;
    else
      v2 = ((word_9AD92 << 7) - 30720) / -240;
    if ( v1 < -127 )
      v1 = -127;
    if ( v1 > 127 )
      LOBYTE(v1) = 127;
    if ( v2 < -127 )
      v2 = -127;
    if ( v2 > 127 )
      LOBYTE(v2) = 127;
    v3 = dword_AE400;
    *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29718) = v1;
    result = *(__int16 *)(v3 + 8);
    *(_BYTE *)(v3 + 10 * result + 29719) = v2;
  }
  return result;
}
// 9AD90: using guessed type __int16 word_9AD90;
// 9AD92: using guessed type __int16 word_9AD92;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00016B00) --------------------------------------------------------
char sub_16B00()
{
  int v0; // edx
  int v1; // eax
  int v2; // edx
  int v3; // edx
  int v4; // eax
  int v5; // esi
  int v6; // esi
  int v7; // eax
  int v8; // esi
  int v9; // esi
  int v10; // edx
  char v11; // bh
  int v12; // edx
  char *v13; // edi
  char *v14; // esi
  char v15; // al
  char v16; // al
  int v17; // edx
  char *v18; // edi
  char *v19; // esi
  char v20; // al
  char v21; // al
  char *v22; // edi
  char *v23; // esi
  char v24; // al
  char v25; // al
  int v26; // edx
  int v27; // edx
  int v28; // ebx
  int v29; // esi
  int v30; // edx
  char *v31; // edi
  char *v32; // esi
  char v33; // al
  char v34; // al
  int v35; // eax
  int v36; // ebx
  _BOOL1 v37; // zf
  int v38; // edx
  char *v39; // edi
  char *v40; // esi
  char v41; // al
  char v42; // al
  int v43; // edx
  int v44; // eax
  int v45; // edx
  char *v46; // edi
  char *v47; // esi
  char v48; // al
  char v49; // al
  int v50; // eax
  char *v51; // edi
  char *v52; // esi
  char v53; // al
  char v54; // al
  int v55; // edx
  int v56; // esi
  int v57; // edi
  char *v58; // edi
  char *v59; // esi
  char v60; // al
  char v61; // al
  int v62; // edx
  int v63; // esi
  char v64; // al
  char *v65; // edi
  char *v66; // esi
  char v67; // al
  char v68; // al
  int v69; // edx
  int v70; // edx
  int v71; // ebx
  char *v72; // esi
  char *v73; // edi
  char v74; // al
  char v75; // al
  int v76; // eax
  int v77; // edx
  int v78; // ecx
  char *v79; // edi
  char *v80; // esi
  char v81; // al
  char v82; // al
  int v83; // edx
  char *v84; // edi
  char *v85; // esi
  char v86; // al
  char v87; // al
  int v88; // edx
  unsigned __int8 v89; // dl
  __int16 v91; // [esp-4h] [ebp-10h]

  v0 = dword_AE400;
  v1 = *(__int16 *)(dword_AE400 + 8);
  if ( *(_BYTE *)(dword_AE400 + 10 * v1 + 29715) )
    return v1;
  if ( byte_12EF28 )
  {
    LOBYTE(v1) = byte_12EF70;
    if ( (unsigned __int8)byte_12EF70 < 0x3Cu )
    {
      if ( (unsigned __int8)byte_12EF70 < 0x26u )
      {
        if ( byte_12EF70 == 31 )
        {
          LOBYTE(v1) = dword_AE408;
          if ( (*(_BYTE *)dword_AE408 & 0x10) == 0 )
          {
            sub_593B0();
            v2 = dword_AE400;
            *(__int16 *)((char *)&word_38D03 + dword_AE400) = *(_WORD *)(dword_AE408 + 17);
            *(int *)((char *)&dword_38D05 + v2) = dword_AC5D4;
            sub_3E750(199);
            sub_3E8C0(199);
            sub_37220();
            v3 = *(__int16 *)(dword_AE400 + 8);
            *(_DWORD *)(dword_AE400 + 4593) = -1;
            v4 = dword_AE400;
            *(_WORD *)(2049 * v3 + dword_AE400 + 68 * *(__int16 *)(dword_AE400 + 8) + 13415) = 100;
            v5 = 2049 * *(__int16 *)(v4 + 8);
            v1 = dword_AE400;
            *(_WORD *)(dword_AE400 + v5 + 68 * *(__int16 *)(dword_AE400 + 8) + 13417) = 0;
            v6 = 2049 * *(__int16 *)(v1 + 8);
            LOWORD(v1) = *(_WORD *)(dword_AE400 + 8);
            strcpy((char *)(v6 + dword_AE400 + 68 * (__int16)v1 + 13351), "Game saved.");
          }
          byte_12EF70 = 0;
        }
      }
      else if ( (unsigned __int8)byte_12EF70 <= 0x26u )
      {
        LOBYTE(v1) = dword_AE408;
        if ( (*(_BYTE *)dword_AE408 & 0x10) == 0 )
        {
          sub_3E690(199);
          sub_3E7F0(199);
          *(_WORD *)(dword_AE408 + 17) = *(__int16 *)((char *)&word_38D03 + dword_AE400);
          dword_AC5D4 = *(int *)((char *)&dword_38D05 + dword_AE400);
          sub_59420();
          sub_356E0();
          v7 = dword_AE400;
          *(_WORD *)(2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 68 * *(__int16 *)(dword_AE400 + 8) + 13415) = 100;
          v8 = 2049 * *(__int16 *)(v7 + 8);
          v1 = dword_AE400;
          *(_WORD *)(v8 + dword_AE400 + 68 * *(__int16 *)(dword_AE400 + 8) + 13417) = 0;
          v9 = 2049 * *(__int16 *)(v1 + 8);
          LOWORD(v1) = *(_WORD *)(dword_AE400 + 8);
          strcpy((char *)(v9 + dword_AE400 + 68 * (__int16)v1 + 13351), "Game loaded.");
        }
        byte_12EF70 = 0;
      }
      else if ( (unsigned __int8)byte_12EF70 >= 0x2Fu )
      {
        if ( (unsigned __int8)byte_12EF70 <= 0x2Fu )
        {
          LOBYTE(v1) = dword_AE408;
          if ( *(char *)(dword_AE408 + 1) < 0 )
            LOBYTE(v1) = sub_188A0(4, 8);
          byte_12EF70 = 0;
        }
        else if ( byte_12EF70 == 59 )
        {
          LOBYTE(v1) = sub_188A0(30, 1);
          byte_12EF70 = 0;
        }
      }
    }
    else if ( (unsigned __int8)byte_12EF70 <= 0x3Cu )
    {
      LOBYTE(v1) = sub_188A0(30, 2);
      byte_12EF70 = 0;
    }
    else if ( (unsigned __int8)byte_12EF70 < 0x3Fu )
    {
      if ( (unsigned __int8)byte_12EF70 <= 0x3Du )
        LOBYTE(v1) = sub_188A0(30, 3);
      else
        LOBYTE(v1) = sub_188A0(30, 4);
      byte_12EF70 = 0;
    }
    else if ( (unsigned __int8)byte_12EF70 <= 0x3Fu )
    {
      LOBYTE(v1) = sub_188A0(30, 5);
      byte_12EF70 = 0;
    }
    else if ( (unsigned __int8)byte_12EF70 <= 0x40u )
    {
      LOBYTE(v1) = sub_188A0(30, 6);
      byte_12EF70 = 0;
    }
    else if ( byte_12EF70 == 65 )
    {
      LOBYTE(v1) = sub_188A0(30, 7);
      byte_12EF70 = 0;
    }
  }
  else
  {
    if ( !byte_12EF1A && !byte_12EF26 )
    {
      if ( (*(_BYTE *)dword_AE408 & 0x10) == 0 && byte_12EF70 == 25 )
      {
        v11 = *(_BYTE *)(dword_AE408 + 2) ^ 1;
        *(_BYTE *)(dword_AE408 + 2) = v11;
        if ( (v11 & 1) != 0 )
        {
          if ( byte_939E5 )
            sub_5D010();
          if ( byte_939CD )
            sub_20E60();
        }
        else if ( byte_939CD )
        {
          sub_5D290(*(_WORD *)(v0 + 576));
        }
        byte_12EF70 = 0;
      }
      if ( byte_12EF70 == 19 )
      {
        if ( *(_BYTE *)(dword_AE400 + 8631) && !*(_BYTE *)(dword_AE400 + 8603) )
          sub_34C80();
        byte_12EF70 = 0;
      }
      if ( byte_12EF70 == 57 )
      {
        sub_188A0(15, 0);
        sub_188A0(27, 0);
        byte_12EF70 = 0;
      }
      LOBYTE(v1) = byte_12EF70 - 59;
      switch ( byte_12EF70 )
      {
        case ';':
          if ( byte_939E4 )
          {
            byte_939E5 ^= 1u;
            if ( byte_939E5 )
              v12 = dword_AE364;
            else
              v12 = dword_AE368;
            v13 = (char *)(dword_AE400
                         + 13323
                         + 2049 * *(__int16 *)(dword_AE400 + 8)
                         + 28
                         + 68 * *(__int16 *)(dword_AE400 + 8));
            v14 = (char *)v12;
            do
            {
              v15 = *v14;
              *v13 = *v14;
              if ( !v15 )
                break;
              v16 = v14[1];
              v14 += 2;
              v13[1] = v16;
              v13 += 2;
            }
            while ( v16 );
            sub_5D010();
            v17 = dword_AE400;
            *(_WORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 68 * *(__int16 *)(dword_AE400 + 8) + 13415) = 50;
            *(_WORD *)(2049 * *(__int16 *)(v17 + 8) + v17 + 68 * *(__int16 *)(v17 + 8) + 13417) = 2;
          }
          LOBYTE(v1) = 0;
          byte_12EF70 = 0;
          return v1;
        case '<':
          if ( !byte_939CC )
            goto LABEL_180;
          if ( byte_939CD )
          {
            sub_20E60();
            v22 = (char *)(68 * *(__int16 *)(dword_AE400 + 8)
                         + dword_AE400
                         + 13323
                         + 2049 * *(__int16 *)(dword_AE400 + 8)
                         + 28);
            v23 = (char *)dword_AE370;
            do
            {
              v24 = *v23;
              *v22 = *v23;
              if ( !v24 )
                break;
              v25 = v23[1];
              v23 += 2;
              v22[1] = v25;
              v22 += 2;
            }
            while ( v25 );
            byte_939CD = 0;
          }
          else
          {
            v91 = *(_WORD *)(dword_AE400 + 576);
            byte_939CD = 1;
            sub_5D290(v91);
            v18 = (char *)(68 * *(__int16 *)(dword_AE400 + 8)
                         + dword_AE400
                         + 13323
                         + 2049 * *(__int16 *)(dword_AE400 + 8)
                         + 28);
            v19 = (char *)dword_AE36C;
            do
            {
              v20 = *v19;
              *v18 = *v19;
              if ( !v20 )
                break;
              v21 = v19[1];
              v19 += 2;
              v18[1] = v21;
              v18 += 2;
            }
            while ( v21 );
          }
          v26 = dword_AE400;
          v1 = 2049 * *(__int16 *)(dword_AE400 + 8);
          *(_WORD *)(dword_AE400 + v1 + 68 * *(__int16 *)(dword_AE400 + 8) + 13415) = 50;
          *(_WORD *)(2049 * *(__int16 *)(v26 + 8) + v26 + 68 * *(__int16 *)(v26 + 8) + 13417) = 2;
          byte_12EF70 = 0;
          return v1;
        case '=':
          LOBYTE(v1) = dword_AE408;
          if ( (*(_BYTE *)dword_AE408 & 0x10) != 0 )
            goto LABEL_110;
          v27 = (*(unsigned __int8 *)(dword_AE408 + 150) + 1) % 3;
          *(_BYTE *)(dword_AE408 + 150) = v27;
          if ( (_BYTE)v27 )
          {
            if ( (unsigned __int8)v27 <= 1u )
            {
              v28 = dword_AE400 + 13323 + 2049 * *(__int16 *)(dword_AE400 + 8) + 28;
              v29 = 68 * *(__int16 *)(dword_AE400 + 8);
              v30 = dword_AE338;
            }
            else
            {
              if ( (_BYTE)v27 != 2 )
                goto LABEL_109;
              v28 = dword_AE400 + 13323 + 2049 * *(__int16 *)(dword_AE400 + 8) + 28;
              v29 = 68 * *(__int16 *)(dword_AE400 + 8);
              v30 = dword_AE33C;
            }
          }
          else
          {
            v28 = dword_AE400 + 13323 + 2049 * *(__int16 *)(dword_AE400 + 8) + 28;
            v29 = 68 * *(__int16 *)(dword_AE400 + 8);
            v30 = dword_AE334;
          }
          v31 = (char *)(v28 + v29);
          v32 = (char *)v30;
          do
          {
            v33 = *v32;
            *v31 = *v32;
            if ( !v33 )
              break;
            v34 = v32[1];
            v32 += 2;
            v31[1] = v34;
            v31 += 2;
          }
          while ( v34 );
LABEL_109:
          v35 = dword_AE400;
          *(_WORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 68 * *(__int16 *)(dword_AE400 + 8) + 13415) = 50;
          v36 = *(__int16 *)(v35 + 8);
          v1 = 2049 * v36 + v35;
          *(_WORD *)(v1 + 68 * v36 + 13417) = 2;
LABEL_110:
          byte_12EF70 = 0;
          return v1;
        case '>':
          v1 = dword_AE400;
          if ( *(_BYTE *)(dword_AE400 + 8629) )
          {
            v37 = *(_BYTE *)(dword_AE400 + 8605) == 1;
            *(_BYTE *)(dword_AE400 + 8605) ^= 1u;
            if ( v37 )
              v38 = dword_AE2E0;
            else
              v38 = dword_AE2DC;
            v39 = (char *)(dword_AE400 + 13323 + 2049 * *(__int16 *)(v1 + 8) + 28 + 68 * *(__int16 *)(dword_AE400 + 8));
            v40 = (char *)v38;
            do
            {
              v41 = *v40;
              *v39 = *v40;
              if ( !v41 )
                break;
              v42 = v40[1];
              v40 += 2;
              v39[1] = v42;
              v39 += 2;
            }
            while ( v42 );
            v43 = dword_AE400;
            *(_WORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 68 * *(__int16 *)(dword_AE400 + 8) + 13415) = 50;
            v1 = 2049 * *(__int16 *)(v43 + 8);
            *(_WORD *)(v1 + v43 + 68 * *(__int16 *)(v43 + 8) + 13417) = 2;
          }
          byte_12EF70 = 0;
          return v1;
        case '?':
          v44 = dword_AE400;
          if ( *(_BYTE *)(dword_AE400 + 8621) )
          {
            v37 = *(_BYTE *)(dword_AE400 + 8597) == 1;
            *(_BYTE *)(dword_AE400 + 8597) ^= 1u;
            if ( v37 )
              v45 = dword_AE2D8;
            else
              v45 = dword_AE2D4;
            v46 = (char *)(dword_AE400 + 13323 + 2049 * *(__int16 *)(v44 + 8) + 28 + 68 * *(__int16 *)(dword_AE400 + 8));
            v47 = (char *)v45;
            do
            {
              v48 = *v47;
              *v46 = *v47;
              if ( !v48 )
                break;
              v49 = v47[1];
              v47 += 2;
              v46[1] = v49;
              v46 += 2;
            }
            while ( v49 );
            v50 = dword_AE400;
            *(_WORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 68 * *(__int16 *)(dword_AE400 + 8) + 13415) = 50;
            *(_WORD *)(2049 * *(__int16 *)(v50 + 8) + v50 + 68 * *(__int16 *)(v50 + 8) + 13417) = 2;
          }
          LOBYTE(v1) = 0;
          byte_12EF70 = 0;
          return v1;
        case '@':
          v1 = dword_AE400;
          if ( !*(_BYTE *)(dword_AE400 + 8623) || !dword_AE3D8 )
            goto LABEL_180;
          v37 = *(_BYTE *)(dword_AE400 + 8599) == 1;
          *(_BYTE *)(dword_AE400 + 8599) ^= 1u;
          if ( v37 )
          {
            v51 = (char *)(68 * *(__int16 *)(dword_AE400 + 8) + 2049 * *(__int16 *)(v1 + 8) + dword_AE400 + 13323 + 28);
            v52 = (char *)dword_AE2E8;
          }
          else
          {
            v51 = (char *)(dword_AE400
                         + 13323
                         + 2049 * *(__int16 *)(dword_AE400 + 8)
                         + 28
                         + 68 * *(__int16 *)(dword_AE400 + 8));
            v52 = (char *)dword_AE2E4;
          }
          do
          {
            v53 = *v52;
            *v51 = *v52;
            if ( !v53 )
              break;
            v54 = v52[1];
            v52 += 2;
            v51[1] = v54;
            v51 += 2;
          }
          while ( v54 );
          v55 = dword_AE400;
          *(_WORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 68 * *(__int16 *)(dword_AE400 + 8) + 13415) = 50;
          v1 = 2049 * *(__int16 *)(v55 + 8);
          *(_WORD *)(v1 + v55 + 68 * *(__int16 *)(v55 + 8) + 13417) = 2;
          byte_12EF70 = 0;
          return v1;
        case 'A':
          v56 = dword_AE400;
          if ( *(_BYTE *)(dword_AE400 + 8622) )
          {
            v57 = dword_AE400 + 13323;
            v37 = *(_BYTE *)(dword_AE400 + 8598) == 1;
            *(_BYTE *)(dword_AE400 + 8598) ^= 1u;
            v58 = (char *)(68 * *(__int16 *)(v56 + 8) + 2049 * *(__int16 *)(v56 + 8) + v57 + 28);
            if ( v37 )
              v59 = (char *)dword_AE2D0;
            else
              v59 = (char *)dword_AE2CC;
            do
            {
              v60 = *v59;
              *v58 = *v59;
              if ( !v60 )
                break;
              v61 = v59[1];
              v59 += 2;
              v58[1] = v61;
              v58 += 2;
            }
            while ( v61 );
            v62 = dword_AE400;
            v1 = dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8);
            *(_WORD *)(v1 + 68 * *(__int16 *)(dword_AE400 + 8) + 13415) = 50;
            *(_WORD *)(2049 * *(__int16 *)(v62 + 8) + v62 + 68 * *(__int16 *)(v62 + 8) + 13417) = 2;
          }
          byte_12EF70 = 0;
          return v1;
        case 'B':
          v63 = dword_AE400;
          v64 = *(_BYTE *)(dword_AE400 + 8602) ^ 1;
          *(_BYTE *)(dword_AE400 + 8601) ^= 1u;
          *(_BYTE *)(v63 + 8602) = v64;
          v65 = (char *)(2049 * *(__int16 *)(v63 + 8) + v63 + 13323 + 28 + 68 * *(__int16 *)(v63 + 8));
          if ( *(_BYTE *)(v63 + 8601) )
            v66 = (char *)dword_AE2EC;
          else
            v66 = (char *)dword_AE2F0;
          do
          {
            v67 = *v66;
            *v65 = *v66;
            if ( !v67 )
              break;
            v68 = v66[1];
            v66 += 2;
            v65[1] = v68;
            v65 += 2;
          }
          while ( v68 );
          v69 = dword_AE400;
          *(_WORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 68 * *(__int16 *)(dword_AE400 + 8) + 13415) = 50;
          v1 = *(__int16 *)(v69 + 8);
          *(_WORD *)(2049 * v1 + v69 + 68 * v1 + 13417) = 2;
          byte_12EF70 = 0;
          return v1;
        case 'C':
          if ( !*(_BYTE *)(dword_AE400 + 8628) )
            goto LABEL_169;
          LOBYTE(v1) = *(_BYTE *)(dword_AE400 + 8604);
          v70 = dword_AE400 + 13323;
          if ( (_BYTE)v1 )
          {
            if ( (unsigned __int8)v1 <= 1u )
            {
              v78 = *(__int16 *)(dword_AE400 + 8);
              *(_BYTE *)(dword_AE400 + 8604) = v1 + 1;
              v79 = (char *)(2049 * v78 + v70 + 28 + 68 * v78);
              v80 = (char *)dword_AE300;
              do
              {
                v81 = *v80;
                *v79 = *v80;
                if ( !v81 )
                  break;
                v82 = v80[1];
                v80 += 2;
                v79[1] = v82;
                v79 += 2;
              }
              while ( v82 );
              v83 = dword_AE400;
              *(_WORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 68 * *(__int16 *)(dword_AE400 + 8) + 13415) = 50;
              v1 = 2049 * *(__int16 *)(v83 + 8);
              *(_WORD *)(v1 + v83 + 68 * *(__int16 *)(v83 + 8) + 13417) = 2;
              byte_12EF70 = 0;
              return v1;
            }
            if ( (_BYTE)v1 == 2 )
            {
              v84 = (char *)(2049 * *(__int16 *)(dword_AE400 + 8) + v70 + 28 + 68 * *(__int16 *)(dword_AE400 + 8));
              v85 = (char *)dword_AE304;
              do
              {
                v86 = *v85;
                *v84 = *v85;
                if ( !v86 )
                  break;
                v87 = v85[1];
                v85 += 2;
                v84[1] = v87;
                v84 += 2;
              }
              while ( v87 );
              v88 = dword_AE400;
              *(_WORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 68 * *(__int16 *)(dword_AE400 + 8) + 13415) = 50;
              v1 = v88 + 2049 * *(__int16 *)(v88 + 8);
              *(_WORD *)(v1 + 68 * *(__int16 *)(v88 + 8) + 13417) = 2;
              *(_BYTE *)(v88 + 8604) = 0;
            }
          }
          else if ( dword_AE404 )
          {
            v71 = *(__int16 *)(dword_AE400 + 8);
            *(_BYTE *)(dword_AE400 + 8604) = 1;
            v72 = (char *)dword_AE2FC;
            v73 = (char *)(68 * v71 + v70 + 2049 * v71 + 28);
            do
            {
              v74 = *v72;
              *v73 = *v72;
              if ( !v74 )
                break;
              v75 = v72[1];
              v72 += 2;
              v73[1] = v75;
              v73 += 2;
            }
            while ( v75 );
            v76 = dword_AE400;
            *(_WORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 68 * *(__int16 *)(dword_AE400 + 8) + 13415) = 50;
            v77 = *(__int16 *)(v76 + 8);
            v1 = 2049 * v77 + v76;
            *(_WORD *)(v1 + 68 * v77 + 13417) = 2;
            byte_12EF70 = 0;
            return v1;
          }
LABEL_169:
          byte_12EF70 = 0;
          return v1;
        case 'D':
          LOBYTE(v1) = dword_AE400;
          if ( *(_BYTE *)(2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 14421) || !*(_BYTE *)(dword_AE400 + 8627) )
            goto LABEL_180;
          v89 = *(_BYTE *)(dword_AE400 + 8603);
          if ( v89 )
          {
            if ( v89 <= 1u )
            {
              sub_315C0();
              LOBYTE(v1) = dword_AE400;
              *(_BYTE *)(dword_AE400 + 8603) = 2;
              byte_12EF70 = 0;
            }
            else
            {
              if ( v89 == 2 )
              {
                *(_BYTE *)(dword_AE400 + 8603) = 0;
                goto LABEL_180;
              }
              byte_12EF70 = 0;
            }
          }
          else
          {
            if ( !dword_AE404 )
              goto LABEL_180;
            sub_31600();
            v1 = dword_AE400;
            *(_BYTE *)(dword_AE400 + 8603) = 1;
            *(_BYTE *)(v1 + 8600) = 40;
            byte_12EF70 = 0;
          }
          return v1;
        default:
          return v1;
      }
    }
    LOBYTE(v1) = byte_12EF70;
    if ( (unsigned __int8)byte_12EF70 < 0x13u )
    {
      if ( (unsigned __int8)byte_12EF70 >= 0x10u )
      {
        if ( (unsigned __int8)byte_12EF70 <= 0x10u )
        {
          sub_188A0(2, 0);
          LOBYTE(v1) = 0;
          byte_12EF70 = 0;
        }
        else if ( byte_12EF70 == 18 )
        {
          LOBYTE(v1) = dword_AE408;
          if ( *(char *)(dword_AE408 + 1) < 0 )
            LOBYTE(v1) = sub_188A0(26, 0);
          byte_12EF70 = 0;
        }
      }
    }
    else if ( (unsigned __int8)byte_12EF70 <= 0x13u )
    {
      LOBYTE(v1) = dword_AE408;
      if ( (*(_BYTE *)dword_AE408 & 0x10) == 0 )
      {
        v10 = dword_AE400;
        *(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13325) |= 0xCu;
        v1 = 2049 * *(__int16 *)(v10 + 8);
        *(_WORD *)(v10 + v1 + 14476) = 0;
      }
      byte_12EF70 = 0;
    }
    else if ( (unsigned __int8)byte_12EF70 >= 0x21u )
    {
      if ( (unsigned __int8)byte_12EF70 <= 0x21u )
      {
        LOBYTE(v1) = dword_AE408;
        if ( *(char *)(dword_AE408 + 1) < 0 )
        {
          v1 = 2049 * *(__int16 *)(dword_AE400 + 8);
          *(_BYTE *)(dword_AE400 + v1 + 13325) |= 4u;
        }
        byte_12EF70 = 0;
      }
      else if ( byte_12EF70 == 46 )
      {
        LOBYTE(v1) = dword_AE408;
        if ( *(char *)(dword_AE408 + 1) >= 0 )
        {
LABEL_180:
          byte_12EF70 = 0;
        }
        else
        {
          LOBYTE(v1) = dword_AE400;
          *(_BYTE *)(2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 13325) |= 2u;
          byte_12EF70 = 0;
        }
      }
    }
  }
  return v1;
}
// 38D03: using guessed type __int16 word_38D03;
// 38D05: using guessed type int dword_38D05;
// 939CC: using guessed type char byte_939CC;
// 939CD: using guessed type char byte_939CD;
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// AC5D4: using guessed type int dword_AC5D4;
// AE2CC: using guessed type int dword_AE2CC;
// AE2D0: using guessed type int dword_AE2D0;
// AE2D4: using guessed type int dword_AE2D4;
// AE2D8: using guessed type int dword_AE2D8;
// AE2DC: using guessed type int dword_AE2DC;
// AE2E0: using guessed type int dword_AE2E0;
// AE2E4: using guessed type int dword_AE2E4;
// AE2E8: using guessed type int dword_AE2E8;
// AE2EC: using guessed type int dword_AE2EC;
// AE2F0: using guessed type int dword_AE2F0;
// AE2FC: using guessed type int dword_AE2FC;
// AE300: using guessed type int dword_AE300;
// AE304: using guessed type int dword_AE304;
// AE334: using guessed type int dword_AE334;
// AE338: using guessed type int dword_AE338;
// AE33C: using guessed type int dword_AE33C;
// AE364: using guessed type int dword_AE364;
// AE368: using guessed type int dword_AE368;
// AE36C: using guessed type int dword_AE36C;
// AE370: using guessed type int dword_AE370;
// AE3D8: using guessed type int dword_AE3D8;
// AE400: using guessed type int dword_AE400;
// AE404: using guessed type int dword_AE404;
// AE408: using guessed type int dword_AE408;
// 12EF1A: using guessed type char byte_12EF1A;
// 12EF26: using guessed type char byte_12EF26;
// 12EF28: using guessed type char byte_12EF28;
// 12EF70: using guessed type char byte_12EF70;

//----- (00017C20) --------------------------------------------------------
char sub_17C20(__int16 a1, __int16 a2, __int16 a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // eax
  _BYTE *v6; // edx
  int v7; // ebx
  char v8; // cl
  char v9; // al
  char v10; // ch
  int v11; // edx
  int v12; // eax
  int v13; // eax
  int v14; // edx
  int v15; // eax
  int v16; // eax
  int v17; // esi
  int v18; // edx
  int v19; // edx
  int v20; // edx
  int v21; // edx
  int v22; // edx
  int v23; // edx

  v3 = dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8);
  if ( *(_BYTE *)(v3 + 13332) == 1 )
  {
    if ( byte_12EF2B )
      LOBYTE(v3) = sub_188A0(2, 0);
    return v3;
  }
  LOBYTE(v3) = *(_BYTE *)(v3 + 14421);
  switch ( (char)v3 )
  {
    case 0:
    case 4:
      v4 = *(__int16 *)(dword_AE400 + 8);
      LOBYTE(v3) = 5 * v4;
      if ( *(_BYTE *)(dword_AE400 + 10 * v4 + 29715) )
      {
        word_12EFDE = 0;
        word_12EFDC = 0;
        return v3;
      }
      LOBYTE(v5) = sub_16B00();
      sub_3FCA0(v5, a1, a2, a3, 0, 256, 160, 640, 400, 16, 8);
      v6 = (_BYTE *)dword_AE400;
      v7 = 164 * *(unsigned __int16 *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13333) + dword_AE400 + 29795;
      v8 = byte_12EF0D;
      *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29720) = 0;
      if ( v8 )
      {
        switch ( byte_12EF70 )
        {
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
            sub_188A0(25, byte_12EF70 - 2);
            byte_12EF70 = 0;
            break;
          default:
            goto LABEL_54;
        }
        goto LABEL_54;
      }
      if ( byte_12EF28 )
      {
        if ( (unsigned __int8)byte_12EF70 < 0x3Bu )
        {
          if ( (unsigned __int8)byte_12EF70 < 0x21u )
          {
            if ( (unsigned __int8)byte_12EF70 >= 0x13u )
            {
              if ( (unsigned __int8)byte_12EF70 <= 0x13u )
              {
                sub_188A0(12, 0);
                byte_12EF70 = 0;
                LOBYTE(v3) = sub_169E0();
                return v3;
              }
              if ( byte_12EF70 == 31 )
              {
                sub_188A0(10, 0);
                byte_12EF70 = 0;
              }
            }
          }
          else
          {
            if ( (unsigned __int8)byte_12EF70 <= 0x21u )
            {
              sub_188A0(4, 32);
              byte_12EF70 = 0;
              LOBYTE(v3) = sub_169E0();
              return v3;
            }
            if ( (unsigned __int8)byte_12EF70 < 0x2Fu )
            {
              if ( byte_12EF70 == 35 )
              {
                v6[8606] ^= 1u;
                byte_12EF70 = 0;
              }
            }
            else
            {
              if ( (unsigned __int8)byte_12EF70 <= 0x2Fu )
              {
                sub_188A0(4, 8);
                byte_12EF70 = 0;
                LOBYTE(v3) = sub_169E0();
                return v3;
              }
              if ( byte_12EF70 == 50 )
              {
                sub_188A0(4, 16);
                byte_12EF70 = 0;
              }
            }
          }
          goto LABEL_54;
        }
        if ( (unsigned __int8)byte_12EF70 <= 0x3Bu )
        {
          sub_188A0(30, 1);
          byte_12EF70 = 0;
          LOBYTE(v3) = sub_169E0();
          return v3;
        }
        if ( (unsigned __int8)byte_12EF70 >= 0x3Eu )
        {
          if ( (unsigned __int8)byte_12EF70 <= 0x3Eu )
          {
            sub_188A0(30, 4);
            byte_12EF70 = 0;
            LOBYTE(v3) = sub_169E0();
            return v3;
          }
          if ( (unsigned __int8)byte_12EF70 < 0x40u )
          {
            sub_188A0(30, 5);
            byte_12EF70 = 0;
            LOBYTE(v3) = sub_169E0();
            return v3;
          }
          if ( (unsigned __int8)byte_12EF70 <= 0x40u )
          {
            sub_188A0(30, 6);
            byte_12EF70 = 0;
            LOBYTE(v3) = sub_169E0();
            return v3;
          }
          if ( byte_12EF70 == 65 )
          {
            sub_188A0(30, 7);
            byte_12EF70 = 0;
          }
          goto LABEL_54;
        }
        if ( (unsigned __int8)byte_12EF70 <= 0x3Cu )
          sub_188A0(30, 2);
        else
          sub_188A0(30, 3);
LABEL_64:
        byte_12EF70 = 0;
        LOBYTE(v3) = sub_169E0();
        return v3;
      }
      if ( byte_12EF1A || byte_12EF26 )
      {
        if ( (unsigned __int8)byte_12EF70 < 0x25u )
        {
          if ( (unsigned __int8)byte_12EF70 >= 0x10u )
          {
            if ( (unsigned __int8)byte_12EF70 <= 0x10u )
            {
              sub_188A0(2, 0);
              byte_12EF70 = 0;
              LOBYTE(v3) = sub_169E0();
              return v3;
            }
            if ( byte_12EF70 == 18 )
            {
              if ( *(char *)(dword_AE408 + 1) < 0 )
                sub_188A0(26, 0);
              goto LABEL_64;
            }
          }
        }
        else
        {
          if ( (unsigned __int8)byte_12EF70 <= 0x25u )
          {
            if ( (*(_BYTE *)dword_AE408 & 0x10) == 0 )
              *(_DWORD *)(v7 + 12) = -1;
            goto LABEL_64;
          }
          if ( (unsigned __int8)byte_12EF70 <= 0x26u )
          {
            sub_188A0(6, 48);
            byte_12EF70 = 0;
            LOBYTE(v3) = sub_169E0();
            return v3;
          }
          if ( byte_12EF70 == 46 )
          {
            if ( *(char *)(dword_AE408 + 1) < 0 )
              sub_188A0(27, 0);
            goto LABEL_64;
          }
        }
LABEL_54:
        LOBYTE(v3) = sub_169E0();
        return v3;
      }
      if ( byte_12EF70 == 26 )
      {
        if ( !v6[8603] )
        {
          v9 = v6[8600];
          if ( v9 < 40 )
            v6[8600] = v9 + 1;
        }
        byte_12EF70 = 0;
      }
      if ( byte_12EF70 == 27 )
      {
        if ( !*(_BYTE *)(dword_AE400 + 8603) )
        {
          v10 = *(_BYTE *)(dword_AE400 + 8600);
          if ( v10 > 17 )
            *(_BYTE *)(dword_AE400 + 8600) = v10 - 1;
        }
        byte_12EF70 = 0;
      }
      switch ( byte_12EF70 )
      {
        case 23:
          LOBYTE(v3) = sub_188A0(16, 0);
          goto LABEL_177;
        case 1:
          sub_188A0(27, 0);
          LOBYTE(v3) = sub_188A0(29, 0);
          byte_12EF70 = 0;
          return v3;
        case 19:
          if ( *(_BYTE *)(dword_AE400 + 8631) )
            sub_34C80();
          byte_12EF70 = 0;
          break;
      }
      if ( byte_12EF70 == 57 )
      {
        sub_188A0(15, 0);
        sub_188A0(27, 0);
        sub_188A0(28, 0);
        byte_12EF70 = 0;
      }
      if ( word_12EFDE && word_12EFDC )
      {
        if ( (*(_BYTE *)(dword_AE408 + 1) & 2) == 0 && *(int *)(v7 + 12) >= 0 )
          sub_188A0(20, 2);
        word_12EFDC = 0;
        word_12EFDE = 0;
      }
      if ( (unsigned __int8)byte_12EF70 >= 2u )
      {
        if ( (unsigned __int8)byte_12EF70 <= 0xBu )
        {
          sub_188A0(24, byte_12EF70 - 2);
          byte_12EF70 = 0;
        }
        else if ( byte_12EF70 == 28 )
        {
          if ( *(int *)(v7 + 12) >= 0 )
            sub_188A0(20, 2);
          byte_12EF70 = 0;
        }
      }
      if ( byte_12EF38 )
        sub_188A0(6, 1);
      if ( byte_12EF40 )
        sub_188A0(6, 2);
      if ( byte_12EF3B )
        sub_188A0(6, 4);
      if ( byte_12EF3D )
        sub_188A0(6, 8);
      v11 = *(_DWORD *)(v7 + 160);
      v12 = *(__int16 *)(v11 + 940);
      if ( v12 == -1 )
      {
        word_12EFDE = 0;
LABEL_119:
        v14 = *(_DWORD *)(v7 + 160);
        v15 = *(__int16 *)(v14 + 944);
        if ( v15 == -1 )
        {
          word_12EFDC = 0;
          LOBYTE(v3) = sub_169E0();
          return v3;
        }
        v16 = 164 * *(_DWORD *)(v14 + 4 * v15 + 532) + dword_AE400 + 29795;
        if ( *(_BYTE *)(v16 + 60) == 1 )
        {
          if ( word_12EFDC )
          {
            sub_188A0(6, 32);
            word_12EFDC = 0;
            LOBYTE(v3) = sub_169E0();
            return v3;
          }
        }
        else if ( word_12EFDC
               || word_12EFE2 && *(__int16 *)(v16 + 48) > 0
               || word_12EFE2 && *(_BYTE *)(v16 + 62) && *(char *)(v16 + 61) > 0 )
        {
          sub_188A0(6, 32);
          word_12EFDC = 0;
        }
        goto LABEL_54;
      }
      v13 = dword_AE400 + 29795 + 164 * *(_DWORD *)(v11 + 4 * v12 + 532);
      if ( *(_BYTE *)(v13 + 60) == 1 )
      {
        if ( !word_12EFDE )
          goto LABEL_119;
      }
      else if ( !word_12EFDE
             && (!word_12EFE4 || *(__int16 *)(v13 + 48) <= 0)
             && (!word_12EFE4 || !*(_BYTE *)(v13 + 62) || *(char *)(v13 + 61) <= 0) )
      {
        goto LABEL_119;
      }
      sub_188A0(6, 16);
      word_12EFDE = 0;
      goto LABEL_119;
    case 1:
      LOBYTE(v3) = sub_16B00();
      if ( word_12EFDE && word_12EFDC || byte_12EF70 == 28 )
      {
        byte_12EF70 = 0;
        word_12EFDC = 0;
        word_12EFDE = 0;
        LOBYTE(v3) = sub_188A0(20, 0);
      }
      return v3;
    case 2:
      sub_3FCA0(
        (__int16)(640 - 4 * *(unsigned __int8 *)(dword_AE42C + 22)),
        a1,
        a2,
        a3,
        1,
        640 - 4 * *(unsigned __int8 *)(dword_AE42C + 22),
        162,
        640 - *(unsigned __int8 *)(dword_AE42C + 22),
        5 * *(unsigned __int8 *)(dword_AE42C + 23) + 162,
        *(unsigned __int8 *)(dword_AE42C + 22),
        *(unsigned __int8 *)(dword_AE42C + 23));
      sub_16B00();
      v3 = 164 * *(unsigned __int16 *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13333);
      v17 = dword_AE400 + 29795 + v3;
      if ( *(int *)(v17 + 12) < 0 )
        LOBYTE(v3) = sub_188A0(20, 0);
      if ( (unsigned __int8)byte_12EF70 >= 2u && (unsigned __int8)byte_12EF70 <= 0xBu )
      {
        v3 = *(char *)(dword_AE408 + 22);
        if ( v3 != -1 )
        {
          v18 = dword_AE400;
          *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = 23;
          *(_BYTE *)(v18 + 10 * *(__int16 *)(v18 + 8) + 29716) = byte_12EF70 - 2;
          *(_BYTE *)(v18 + 10 * *(__int16 *)(v18 + 8) + 29717) = -1;
          v3 = 0;
          v19 = *(_DWORD *)(v17 + 160);
          while ( *(__int16 *)(*(_DWORD *)(v17 + 160)
                             + 2 * (unsigned __int8)byte_99B88[*(char *)(dword_AE408 + 22)]
                             + 676) != *(_DWORD *)(v19 + 532) )
          {
            ++v3;
            v19 += 4;
            if ( v3 >= 24 )
              goto LABEL_146;
          }
          *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29717) = v3;
        }
LABEL_146:
        byte_12EF70 = 0;
      }
      if ( word_12EFDE && word_12EFDC || byte_12EF70 == 28 )
      {
        byte_12EF70 = 0;
        word_12EFDC = 0;
        word_12EFDE = 0;
        LOBYTE(v3) = sub_188A0(20, 0);
LABEL_164:
        byte_12EF70 = 0;
        return v3;
      }
      if ( word_12EFDE )
      {
        v3 = *(char *)(dword_AE408 + 22);
        word_12EFDE = 0;
        if ( v3 == -1 )
          goto LABEL_164;
        v20 = dword_AE400;
        *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = 21;
        *(_BYTE *)(v20 + 10 * *(__int16 *)(v20 + 8) + 29716) = -1;
        v3 = 0;
        v21 = *(_DWORD *)(v17 + 160);
        do
        {
          if ( *(__int16 *)(*(_DWORD *)(v17 + 160) + 2 * (unsigned __int8)byte_99B88[*(char *)(dword_AE408 + 22)] + 676) == *(_DWORD *)(v21 + 532) )
          {
            *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29716) = v3;
            byte_12EF70 = 0;
            return v3;
          }
          ++v3;
          v21 += 4;
        }
        while ( v3 < 24 );
        byte_12EF70 = 0;
      }
      else
      {
        if ( !word_12EFDC )
          goto LABEL_164;
        v3 = *(char *)(dword_AE408 + 22);
        word_12EFDC = word_12EFDE;
        if ( v3 == -1 )
          goto LABEL_164;
        v22 = dword_AE400;
        *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = 22;
        *(_BYTE *)(v22 + 10 * *(__int16 *)(v22 + 8) + 29716) = -1;
        v3 = 0;
        v23 = *(_DWORD *)(v17 + 160);
        while ( *(__int16 *)(*(_DWORD *)(v17 + 160) + 2 * (unsigned __int8)byte_99B88[*(char *)(dword_AE408 + 22)] + 676) != *(_DWORD *)(v23 + 532) )
        {
          ++v3;
          v23 += 4;
          if ( v3 >= 24 )
            goto LABEL_164;
        }
        *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29716) = v3;
        byte_12EF70 = 0;
      }
      return v3;
    case 3:
      if ( byte_12EF70 > 0 )
      {
        LOBYTE(v3) = byte_9AD0C[(unsigned __int8)byte_12EF70];
        if ( byte_12EF70 == 28 )
        {
          LOBYTE(v3) = sub_188A0(19, 0);
        }
        else if ( (unsigned __int8)v3 >= 0x41u && (unsigned __int8)v3 <= 0x5Au
               || (unsigned __int8)v3 >= 0x61u && (unsigned __int8)v3 <= 0x7Au
               || (unsigned __int8)v3 >= 0x30u && (unsigned __int8)v3 <= 0x39u
               || (_BYTE)v3 == 8
               || (_BYTE)v3 == 32 )
        {
          LOBYTE(v3) = sub_188A0(17, byte_9AD0C[(unsigned __int8)byte_12EF70]);
        }
      }
LABEL_177:
      byte_12EF70 = 0;
      return v3;
    default:
      return v3;
  }
}
// 17CB9: variable 'v5' is possibly undefined
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE42C: using guessed type int dword_AE42C;
// 12EF0D: using guessed type char byte_12EF0D;
// 12EF1A: using guessed type char byte_12EF1A;
// 12EF26: using guessed type char byte_12EF26;
// 12EF28: using guessed type char byte_12EF28;
// 12EF2B: using guessed type char byte_12EF2B;
// 12EF38: using guessed type char byte_12EF38;
// 12EF3B: using guessed type char byte_12EF3B;
// 12EF3D: using guessed type char byte_12EF3D;
// 12EF40: using guessed type char byte_12EF40;
// 12EF70: using guessed type char byte_12EF70;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;
// 12EFE2: using guessed type __int16 word_12EFE2;
// 12EFE4: using guessed type __int16 word_12EFE4;

//----- (000188A0) --------------------------------------------------------
int sub_188A0(int a1, char a2)
{
  int v2; // edx
  int result; // eax
  int v4; // ebx
  int v5; // ebx
  int v6; // ebx
  int v7; // ecx
  int v8; // ebx
  int v9; // ebx
  int v10; // ebx
  int v11; // esi
  int v12; // esi
  int v13; // esi
  _BYTE *v14; // ebx
  int v15; // ebx

  v2 = dword_AE400;
  result = a1;
  switch ( (__int16)a1 )
  {
    case 0:
    case 1:
    case 2:
    case 26:
      *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = a1;
      dword_AE400 = v2;
      return result;
    case 4:
      if ( *(char *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) != (_WORD)a1
        && *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) )
      {
        goto LABEL_80;
      }
      *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = a1;
      result = *(__int16 *)(v2 + 8);
      *(_BYTE *)(v2 + 10 * result + 29716) |= a2;
      dword_AE400 = v2;
      return result;
    case 6:
      if ( *(char *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) != (_WORD)a1
        && *(_BYTE *)(10 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 29715) )
      {
        goto LABEL_80;
      }
      *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = a1;
      result = *(__int16 *)(v2 + 8);
      *(_BYTE *)(v2 + 10 * result + 29720) |= a2;
      dword_AE400 = v2;
      return result;
    case 10:
      if ( *(char *)(10 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 29715) != (_WORD)a1
        && *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) )
      {
        goto LABEL_80;
      }
      *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = a1;
      dword_AE400 = v2;
      return result;
    case 11:
      if ( *(char *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) != (_WORD)a1
        && *(_BYTE *)(10 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 29715) )
      {
        goto LABEL_80;
      }
      *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = a1;
      dword_AE400 = v2;
      return result;
    case 12:
      if ( *(char *)(10 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 29715) != (_WORD)a1
        && *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) )
      {
        goto LABEL_80;
      }
      *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = a1;
      dword_AE400 = v2;
      return result;
    case 14:
      if ( *(char *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) != (_WORD)a1
        && *(_BYTE *)(10 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 29715) )
      {
        goto LABEL_80;
      }
      *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = a1;
      dword_AE400 = v2;
      return result;
    case 15:
      if ( *(char *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) != (_WORD)a1
        && *(_BYTE *)(10 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 29715) )
      {
        goto LABEL_80;
      }
      v4 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13333);
      if ( *(int *)(v4 + 12) >= 0 || *(_BYTE *)(v4 + 70) != 3 )
        goto LABEL_80;
      *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = a1;
      dword_AE400 = v2;
      return result;
    case 16:
      if ( *(char *)(10 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 29715) != (_WORD)a1
        && *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) )
      {
        goto LABEL_80;
      }
      *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = a1;
      dword_AE400 = v2;
      return result;
    case 17:
      if ( *(char *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) != (_WORD)a1
        && *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) )
      {
        goto LABEL_80;
      }
      *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29716) = a2;
      *(_BYTE *)(v2 + 10 * *(__int16 *)(v2 + 8) + 29715) = a1;
      dword_AE400 = v2;
      return result;
    case 18:
      if ( *(char *)(10 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 29715) != (_WORD)a1
        && *(_BYTE *)(10 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 29715) )
      {
        goto LABEL_80;
      }
      *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = a1;
      dword_AE400 = v2;
      return result;
    case 19:
      if ( *(char *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) != (_WORD)a1
        && *(_BYTE *)(10 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 29715) )
      {
        goto LABEL_80;
      }
      *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = a1;
      dword_AE400 = v2;
      return result;
    case 20:
      v8 = dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8);
      if ( *(char *)(v8 + 29715) != (_WORD)a1 && *(_BYTE *)(v8 + 29715) )
        goto LABEL_80;
      goto LABEL_79;
    case 21:
      v9 = dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8);
      if ( *(char *)(v9 + 29715) == (_WORD)a1 || !*(_BYTE *)(v9 + 29715) )
        goto LABEL_79;
      goto LABEL_80;
    case 22:
      v10 = dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8);
      if ( *(char *)(v10 + 29715) == (_WORD)a1 || !*(_BYTE *)(v10 + 29715) )
        goto LABEL_79;
      goto LABEL_80;
    case 23:
      v11 = dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8);
      if ( *(char *)(v11 + 29715) == (_WORD)a1 || !*(_BYTE *)(v11 + 29715) )
        goto LABEL_79;
      goto LABEL_80;
    case 24:
      v12 = dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8);
      if ( *(char *)(v12 + 29715) == (_WORD)a1 || !*(_BYTE *)(v12 + 29715) )
        goto LABEL_79;
      goto LABEL_80;
    case 25:
      v13 = dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8);
      if ( *(char *)(v13 + 29715) == (_WORD)a1 || !*(_BYTE *)(v13 + 29715) )
        goto LABEL_79;
      goto LABEL_80;
    case 27:
      v5 = dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8);
      if ( *(char *)(v5 + 29715) != (_WORD)a1 && *(_BYTE *)(v5 + 29715)
        || (*(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13325) & 2) == 0 )
      {
        goto LABEL_80;
      }
      *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = a1;
      dword_AE400 = v2;
      return result;
    case 28:
      v6 = dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8);
      if ( *(char *)(v6 + 29715) != (_WORD)a1 && *(_BYTE *)(v6 + 29715)
        || (*(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13325) & 4) == 0 )
      {
        goto LABEL_80;
      }
      *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = a1;
      dword_AE400 = v2;
      return result;
    case 29:
      v7 = dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8);
      if ( *(char *)(v7 + 29715) != (_WORD)a1 && *(_BYTE *)(v7 + 29715) )
        goto LABEL_80;
      *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = a1;
      dword_AE400 = v2;
      return result;
    case 30:
      if ( *(char *)(dword_AE408 + 1) < 0
        || (v14 = (_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8)), v14[14357] == 99)
        && v14[14358] == 104
        && v14[14359] == 114
        && v14[14360] == 111
        && v14[14361] == 110
        && v14[14362] == 105
        && v14[14363] == 99
        && v14[14364] == 108
        && v14[14365] == 101 )
      {
        v15 = dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8);
        if ( *(char *)(v15 + 29715) == (_WORD)a1 || !*(_BYTE *)(v15 + 29715) )
        {
LABEL_79:
          *(_BYTE *)(dword_AE400 + 10 * *(__int16 *)(dword_AE400 + 8) + 29715) = a1;
          result = *(__int16 *)(v2 + 8);
          *(_BYTE *)(v2 + 10 * result + 29716) = a2;
        }
      }
      goto LABEL_80;
    default:
LABEL_80:
      dword_AE400 = v2;
      return result;
  }
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (000192D8) --------------------------------------------------------
void sub_192D8(char a1, _BOOL1 a2, char a3, char a4, __int16 a5)
{
  unsigned int v5; // kr00_4

  v5 = __readeflags();
  sub_192F3(a1, a2, a3, a4);
  sub_193EE(a5);
  __writeeflags(v5);
}

//----- (000192F3) --------------------------------------------------------
int sub_192F3(char _CF, _BOOL1 _ZF, char _SF, char _OF)
{
  unsigned int v4; // kr00_4
  unsigned int v5; // kr04_4
  int result; // eax
  unsigned int v7; // kr08_4
  unsigned int v8; // kr0C_4
  int *v14; // esi
  _BYTE *v15; // edi
  int v16; // ecx

  //fix
  v14 = 0;
  v15 = 0;
  v16 = 0;
  //fix

  //fix __asm { pushfw }
  v4 = __readeflags();
  __writeeflags(((unsigned int)&loc_3FFFE + 2) ^ v4);
  v5 = __readeflags();
  result = v4 ^ v5;
  byte_90084 = 3;
  if ( v4 != v5 )
  {
    byte_90084 = 4;
    v7 = __readeflags();
    __writeeflags(v7 ^ 0x200000);
    v8 = __readeflags();
    result = v7 ^ v8;
    if ( v7 != v8 )
    {
      //fix
      /*byte_90076 = 1;
      _EAX = 0;
      __asm { cpuid }
      dword_9006A = _EBX;
      dword_9006E = _EDX;
      dword_90072 = _ECX;
      v14 = &dword_9006A;
      v15 = &unk_90078;
      v16 = 1;
      */
      //fix
      do
      {
        if ( !v16 )
          break;
        _ZF = *(_BYTE *)v14 == *v15;
        v14 = (int *)((char *)v14 + 1);
        ++v15;
        --v16;
      }
      while ( _ZF );
      if ( !v16 )
        byte_90085 = 1;
      //fix _EAX = 1;
      __asm { cpuid }
      //fix dword_90066 = _EAX;
      //fix byte_90084 = (unsigned __int16)(_EAX & 0xF00) >> 8;
      //fix byte_90087 = _EAX & 0xF;
      result = dword_90066;
      byte_90086 = (unsigned __int8)(dword_90066 & 0xF0) >> 4;
    }
  }
  return result;
}
// 90066: using guessed type int dword_90066;
// 9006A: using guessed type int dword_9006A;
// 9006E: using guessed type int dword_9006E;
// 90072: using guessed type int dword_90072;
// 90076: using guessed type char byte_90076;
// 90084: using guessed type char byte_90084;
// 90085: using guessed type char byte_90085;
// 90086: using guessed type char byte_90086;
// 90087: using guessed type char byte_90087;

//----- (000193EE) --------------------------------------------------------
void sub_193EEfix(__int16 a1)
{
  __int16 v1; // fps
  double v2; // st6
  _BOOL1 v3; // c0
  char v4; // c2
  _BOOL1 v5; // c3

  __asm { fninit }
  word_90064 = a1;
  if ( (_BYTE)a1 )
  {
    byte_90088 = 0;
  }
  else if ( (word_90064 & 0x103F) == 63 )
  {
    byte_90088 = 1;
    if ( byte_90084 == 3 )
    {
      //fix v2 = -(1.0 / 0.0);
      //fix v3 = v2 < 1.0 / 0.0;
      v4 = 0;
      //fix v5 = v2 == 1.0 / 0.0;
      word_90064 = v1;
      byte_90089 = 2;
      //fix if ( v2 != 1.0 / 0.0 )
      //fix   byte_90089 = 3;
    }
  }
  else
  {
    byte_90088 = 0;
  }
}
// 90064: using guessed type __int16 word_90064;
// 90084: using guessed type char byte_90084;
// 90088: using guessed type char byte_90088;
// 90089: using guessed type char byte_90089;

//----- (00019470) --------------------------------------------------------
int sub_19470(__int16 a1)
{
  char v1; // sf
  int result; // eax

  //fix
  v1 = 0;
  //fix

  sub_192D8(0, 0, v1, 0, a1);
  if ( byte_90084 == 5 && byte_90085 == 1 )
  {
    result = dword_AE408;
    *(_BYTE *)(dword_AE408 + 8) = 1;
  }
  else
  {
    result = dword_AE408;
    *(_BYTE *)(dword_AE408 + 8) = 0;
  }
  return result;
}
// 19473: variable 'v1' is possibly undefined
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 90084: using guessed type char byte_90084;
// 90085: using guessed type char byte_90085;
// 90086: using guessed type char byte_90086;
// 90087: using guessed type char byte_90087;
// 90088: using guessed type char byte_90088;
// AE408: using guessed type int dword_AE408;

//----- (000194F0) --------------------------------------------------------
int sub_194F0()
{
  int v0; // ebx
  int v1; // esi
  __int16 i; // cx
  unsigned int j; // eax
  int result; // eax

  v0 = dword_AE400;
  v1 = dword_AE408;
  for ( i = 0; i < 20; ++i )
  {
    for ( j = *(_DWORD *)(v1 + 4 * i + 36382); j > v0 + 29795; j = *(_DWORD *)j )
      *(_DWORD *)(j + 12) = -1;
  }
  result = *(unsigned __int16 *)(j + 34);
  dword_AE408 = v1;
  dword_AE400 = v0;
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00019550) --------------------------------------------------------
__int16 sub_19550(int a1)
{
  __int16 result; // ax
  int v2; // esi
  int v3; // esi
  __int16 v4; // ax

  result = dword_AE400 + 29795;
  v2 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 52);
  if ( *(_BYTE *)(v2 + 64) != 5 )
    result = sub_41E80(a1);
  if ( *(_BYTE *)(a1 + 58) )
  {
    *(_WORD *)(a1 + 30) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v2 + 72));
    *(_WORD *)(a1 + 32) = sub_42180((_WORD *)(a1 + 72), (_WORD *)(v2 + 72));
    v3 = v2 + 72;
    *(_DWORD *)&word_AE454 = *(_DWORD *)v3;
    *(&word_AE454 + 2) = *(_WORD *)(v3 + 4);
    v4 = (unsigned __int16)sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 32), -*(_WORD *)(a1 + 56));
    result = sub_41C70(v4, a1, (int)&word_AE454);
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      result = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      *(_WORD *)(a1 + 40) = result;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
  }
  else if ( (*(_BYTE *)(a1 + 63) & 3) == 0 )
  {
    sub_41C70(result, a1, v2 + 72);
    result = *(_WORD *)(v2 + 30);
    *(_WORD *)(a1 + 30) = result;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;

//----- (00019650) --------------------------------------------------------
signed int sub_19650(__int16 *a1)
{
  int v1; // eax
  unsigned __int16 v2; // dx
  unsigned __int16 v3; // bx
  unsigned __int8 v4; // cl
  unsigned __int16 v5; // bx
  int v6; // esi
  int v7; // ebx
  signed int v8; // ecx
  signed int v9; // ebx

  v1 = *a1 >> 8;
  BYTE1(v1) = HIBYTE(a1[1]);
  v2 = v1;
  LOBYTE(v1) = v1 + 1;
  v3 = v1;
  ++BYTE1(v1);
  v4 = byte_DC1E0[v3];
  v5 = v1;
  LOBYTE(v2) = byte_DC1E0[v2];
  LOBYTE(v1) = v1 - 1;
  HIBYTE(v2) = byte_DC1E0[v5];
  v6 = (unsigned __int8)byte_DC1E0[(unsigned __int16)v1];
  v7 = (unsigned __int8)v2 + v4 - v6;
  v8 = abs32((unsigned __int8)v2 + v6 - v4 - HIBYTE(v2));
  v9 = abs32(v7 - HIBYTE(v2));
  if ( v8 > v9 )
    return v8;
  return v9;
}

//----- (000196E0) --------------------------------------------------------
int sub_196E0(int a1)
{
  __int16 *v1; // eax
  __int16 v2; // ax
  int v3; // eax
  __int16 v4; // ax
  int result; // eax
  int v6; // esi
  __int16 v7; // ax
  __int16 *v8; // eax
  __int16 v9; // ax
  int v10; // esi
  __int16 v11; // ax
  __int16 *v12; // eax
  __int16 v13; // ax
  int v14; // esi
  __int16 v15; // ax
  __int16 *v16; // eax
  __int16 v17; // ax
  int v18; // esi
  int v19; // [esp-Ch] [ebp-1Ch]
  int v20; // [esp-Ch] [ebp-1Ch]
  int v21; // [esp-Ch] [ebp-1Ch]
  int v22; // [esp-Ch] [ebp-1Ch]
  int v23; // [esp-8h] [ebp-18h]
  int v24; // [esp-8h] [ebp-18h]
  int v25; // [esp-8h] [ebp-18h]
  int v26; // [esp-8h] [ebp-18h]
  int v27; // [esp-4h] [ebp-14h]
  int v28; // [esp-4h] [ebp-14h]
  int v29; // [esp-4h] [ebp-14h]
  int v30; // [esp-4h] [ebp-14h]
  __int16 v31; // [esp+0h] [ebp-10h]

  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  v1 = *(__int16 **)(a1 + 156);
  v27 = v1[7];
  v23 = v1[5];
  v19 = v1[6];
  v2 = sub_11F50(&word_AE454);
  sub_42000((int)&word_AE454, v2, v19, v23, v27);
  sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), 0, *(_WORD *)(a1 + 126));
  if ( *(__int16 *)(a1 + 72) >> 8 == word_AE454 >> 8 )
  {
    v3 = word_AE456 >> 8;
    if ( *(__int16 *)(a1 + 74) >> 8 == v3 )
      goto LABEL_3;
  }
  if ( !sub_11640(a1, &word_AE454, 1) )
  {
    v6 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 16);
    v3 = sub_19650(&word_AE454);
    if ( v3 < v6 )
      goto LABEL_3;
  }
  v31 = *(_WORD *)(a1 + 30);
  LOBYTE(v7) = v31 + 85;
  HIBYTE(v7) = ((unsigned __int16)(v31 + 341) >> 8) & 7;
  *(_WORD *)(a1 + 30) = v7;
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  v8 = *(__int16 **)(a1 + 156);
  v28 = v8[7];
  v24 = v8[5];
  v20 = v8[6];
  v9 = sub_11F50(&word_AE454);
  sub_42000((int)&word_AE454, v9, v20, v24, v28);
  sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), 0, *(_WORD *)(a1 + 126));
  if ( !sub_11640(a1, &word_AE454, 1) )
  {
    v10 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 16);
    v3 = sub_19650(&word_AE454);
    if ( v3 < v10 )
      goto LABEL_3;
  }
  LOBYTE(v11) = v31 - 85;
  HIBYTE(v11) = ((unsigned __int16)(v31 - 341) >> 8) & 7;
  *(_WORD *)(a1 + 30) = v11;
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  v12 = *(__int16 **)(a1 + 156);
  v29 = v12[7];
  v25 = v12[5];
  v21 = v12[6];
  v13 = sub_11F50(&word_AE454);
  sub_42000((int)&word_AE454, v13, v21, v25, v29);
  sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), 0, *(_WORD *)(a1 + 126));
  if ( !sub_11640(a1, &word_AE454, 1) )
  {
    v14 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 16);
    v3 = sub_19650(&word_AE454);
    if ( v3 < v14 )
      goto LABEL_3;
  }
  LOBYTE(v15) = v31;
  HIBYTE(v15) = (HIBYTE(v31) + 4) & 7;
  *(_WORD *)(a1 + 30) = v15;
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  v16 = *(__int16 **)(a1 + 156);
  v30 = v16[7];
  v26 = v16[5];
  v22 = v16[6];
  v17 = sub_11F50(&word_AE454);
  sub_42000((int)&word_AE454, v17, v22, v26, v30);
  sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), 0, *(_WORD *)(a1 + 126));
  if ( sub_11640(a1, &word_AE454, 1)
    || (v18 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 16), v3 = sub_19650(&word_AE454), v3 >= v18) )
  {
    result = 1;
    *(_DWORD *)(a1 + 12) = -1;
  }
  else
  {
LABEL_3:
    sub_41C70(v3, a1, (int)&word_AE454);
    v4 = *(_WORD *)(a1 + 30)
       + sub_422A0(
           *(_WORD *)(a1 + 30),
           *(_WORD *)(a1 + 34),
           *(unsigned __int16 *)(*(_DWORD *)(a1 + 156) + 4),
           *(_WORD *)(*(_DWORD *)(a1 + 156) + 2));
    HIBYTE(v4) &= 7u;
    *(_WORD *)(a1 + 30) = v4;
    return 1;
  }
  return result;
}
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;

//----- (00019B10) --------------------------------------------------------
void sub_19B10(int a1, char a2)
{
  unsigned int v2; // edx
  __int16 v3; // ax
  unsigned __int16 v4; // cx
  int i; // ebx
  int v6; // eax
  unsigned __int8 v7; // al
  int v8; // ebx
  unsigned int v9; // ebx
  unsigned int v10; // ebp
  int v11; // edx
  __int16 v12; // ax
  unsigned int v13; // edi
  __int16 v14; // ax
  unsigned int v15; // [esp+0h] [ebp-20h]
  int v16; // [esp+4h] [ebp-1Ch]
  unsigned int v17; // [esp+8h] [ebp-18h]

  v2 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v3 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v2 = 1;
      *(_WORD *)(a1 + 40) = v3;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v4 = *(_WORD *)(a1 + 54);
    if ( v4 )
    {
      for ( i = dword_AE400 + 29795 + 164 * v4;
            i != dword_AE400 + 29795;
            i = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(i + 54) )
      {
        v6 = *(_DWORD *)(i + 12);
        if ( v6 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v6;
          v2 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(i + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v2 )
  {
    if ( v2 <= 1 )
    {
      if ( *(_BYTE *)(164 * *(unsigned __int16 *)(a1 + 40) + dword_AE400 + 29859) != 3 )
        return;
      *(_WORD *)(a1 + 146) = *(_WORD *)(a1 + 40);
      v7 = a2 + 2;
    }
    else
    {
      v7 = a2 + 4;
    }
    goto LABEL_31;
  }
  v8 = *(_DWORD *)(a1 + 156);
  if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(v8 + 26)) )
  {
    v15 = *(__int16 *)(v8 + 28) * *(__int16 *)(v8 + 28);
    v9 = *(_DWORD *)(dword_AE408 + 4 * *(char *)(a1 + 65) + 36382);
    v17 = 0;
    v10 = -1;
    while ( v9 > dword_AE400 + 29795 )
    {
      if ( !*(_WORD *)(v9 + 52) && v9 != a1 )
      {
        v11 = (__int16)(*(_WORD *)(v9 + 72) - *(_WORD *)(a1 + 72));
        v12 = *(_WORD *)(v9 + 74) - *(_WORD *)(a1 + 74);
        v13 = v11 * v11 + v12 * v12;
        if ( v13 <= v15 )
        {
          v16 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 30);
          v14 = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v9 + 72));
          if ( (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), v14) < v16 && v13 < v10 )
          {
            v17 = v9;
            v10 = v13;
          }
        }
      }
      v9 = *(_DWORD *)v9;
    }
    if ( v17 )
    {
      *(_WORD *)(a1 + 52) = (int)(v17 - (dword_AE400 + 29795)) / 164;
      v7 = a2 + 3;
LABEL_31:
      sub_424F0(a1, v7);
    }
  }
}
// 19BDE: conditional instruction was optimized away because edx.4==2
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00019D70) --------------------------------------------------------
void sub_19D70(int a1, char a2)
{
  unsigned int v2; // ebp
  __int16 v3; // ax
  unsigned __int16 v4; // cx
  int i; // esi
  int v6; // eax
  unsigned __int8 v7; // al
  unsigned int v8; // eax
  int v9; // ebp
  int v10; // eax
  unsigned int v11; // ebp
  unsigned int j; // esi
  int v13; // eax
  unsigned int v14; // edi
  __int16 v15; // ax
  int v16; // eax
  unsigned int v17; // ebp
  unsigned int v18; // esi
  int v19; // eax
  unsigned int v20; // edi
  __int16 v21; // ax
  unsigned int v22; // [esp+4h] [ebp-28h]
  int v23; // [esp+8h] [ebp-24h]
  int v24; // [esp+8h] [ebp-24h]
  unsigned int v25; // [esp+Ch] [ebp-20h]
  unsigned int v26; // [esp+14h] [ebp-18h]
  unsigned int v27; // [esp+18h] [ebp-14h]

  v2 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v3 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v2 = 1;
      *(_WORD *)(a1 + 40) = v3;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v4 = *(_WORD *)(a1 + 54);
    if ( v4 )
    {
      for ( i = 164 * v4 + dword_AE400 + 29795;
            i != dword_AE400 + 29795;
            i = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(i + 54) )
      {
        v6 = *(_DWORD *)(i + 12);
        if ( v6 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v6;
          v2 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(i + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v2 )
  {
    if ( v2 <= 1 )
    {
      if ( *(_BYTE *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 40) + 29859) != 3 )
        return;
      *(_WORD *)(a1 + 146) = *(_WORD *)(a1 + 40);
      v7 = a2 + 2;
    }
    else
    {
      v7 = a2 + 4;
    }
    goto LABEL_42;
  }
  sub_196E0(a1);
  if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26)) )
  {
    v8 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
    *(_DWORD *)(a1 + 4) = v8;
    v9 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 4) = 9377 * v9 + 9439;
    *(_WORD *)(a1 + 34) += ((unsigned __int8)(-95 * v9 - 33) + 85) * (2 * ((int)(v8 % 0x9D) / 79) - 1);
    LOBYTE(v8) = *(_BYTE *)(a1 + 58);
    *(_BYTE *)(a1 + 35) &= 7u;
    if ( (_BYTE)v8 )
    {
      v10 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 28);
      v11 = -1;
      v22 = v10 * v10;
      v26 = 0;
      for ( j = *(_DWORD *)(dword_AE408 + 36462); j > dword_AE400 + 29795; j = *(_DWORD *)j )
      {
        v13 = (__int16)(*(_WORD *)(j + 72) - *(_WORD *)(a1 + 72));
        v14 = v13 * v13
            + (__int16)(*(_WORD *)(j + 74) - *(_WORD *)(a1 + 74)) * (__int16)(*(_WORD *)(j + 74) - *(_WORD *)(a1 + 74));
        if ( v14 <= v22 && (*(_BYTE *)(j + 16) & 0x20) == 0 )
        {
          v23 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 30);
          v15 = sub_42150((_WORD *)(a1 + 72), (_WORD *)(j + 72));
          if ( (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), v15) < v23 && v14 < v11 )
          {
            v26 = j;
            v11 = v14;
          }
        }
      }
      if ( v26 )
      {
        *(_WORD *)(a1 + 146) = (int)(v26 - (dword_AE400 + 29795)) / 164;
        v7 = a2 + 2;
LABEL_42:
        sub_424F0(a1, v7);
        return;
      }
      v16 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 28);
      v17 = -1;
      v25 = v16 * v16;
      v18 = *(_DWORD *)(dword_AE408 + 4 * *(char *)(a1 + 65) + 36382);
      v27 = 0;
      while ( v18 > dword_AE400 + 29795 )
      {
        if ( !*(_WORD *)(v18 + 52) && v18 != a1 )
        {
          v19 = (__int16)(*(_WORD *)(v18 + 72) - *(_WORD *)(a1 + 72));
          v20 = v19 * v19
              + (__int16)(*(_WORD *)(v18 + 74) - *(_WORD *)(a1 + 74))
              * (__int16)(*(_WORD *)(v18 + 74) - *(_WORD *)(a1 + 74));
          if ( v20 <= v25 )
          {
            v24 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 30);
            v21 = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v18 + 72));
            if ( (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), v21) < v24 && v20 < v17 )
            {
              v27 = v18;
              v17 = v20;
            }
          }
        }
        v18 = *(_DWORD *)v18;
      }
      if ( v27 )
      {
        *(_WORD *)(a1 + 52) = (int)(v27 - (dword_AE400 + 29795)) / 164;
        v7 = a2 + 3;
        goto LABEL_42;
      }
    }
  }
}
// 19E3D: conditional instruction was optimized away because ebp.4==2
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (0001A120) --------------------------------------------------------
int sub_1A120(int a1, char a2, unsigned __int16 (*a3)(int, int))
{
  int v3; // esi
  unsigned int v4; // edi
  __int16 v5; // ax
  unsigned __int16 v6; // ax
  int v7; // eax
  int i; // edx
  int v9; // ecx
  char v10; // cl
  int v12; // edi
  int v13; // ecx
  unsigned int v14; // ebp
  int v15; // [esp+0h] [ebp-14h]

  v3 = dword_AE400;
  v4 = 0;
  v15 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v5 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v4 = 1;
      *(_WORD *)(a1 + 40) = v5;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v6 = *(_WORD *)(a1 + 54);
    if ( v6 )
    {
      v7 = 164 * v6 + v3 + 29795;
      for ( i = v3 + 29795; v7 != i; v7 = i + 164 * *(unsigned __int16 *)(v7 + 54) )
      {
        v9 = *(_DWORD *)(v7 + 12);
        if ( v9 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v9;
          v4 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(v7 + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v4 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v4 )
  {
    if ( v4 <= 1 )
    {
      v10 = *(_BYTE *)(v3 + 164 * *(unsigned __int16 *)(a1 + 40) + 29859);
      dword_AE400 = v3;
      if ( v10 == 3 )
      {
        *(_WORD *)(a1 + 146) = *(_WORD *)(a1 + 40);
        return 0;
      }
    }
    else
    {
      dword_AE400 = v3;
      sub_424F0(a1, a2 + 4);
    }
    return v15;
  }
  dword_AE400 = v3;
  sub_196E0(a1);
  v12 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 146);
  if ( (*(_BYTE *)(a1 + 63) & 3) == 0 )
    *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v12 + 72));
  if ( *(int *)(v12 + 12) < 0 || (*(_BYTE *)(v12 + 17) & 4) != 0 )
  {
LABEL_26:
    sub_424F0(a1, a2 + 1);
    return 0;
  }
  v13 = *(_DWORD *)(a1 + 156);
  if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(v13 + 26)) )
  {
    v14 = *(__int16 *)(v13 + 28);
    if ( sub_42340((_WORD *)(a1 + 72), (_WORD *)(v12 + 72)) >= v14 )
      goto LABEL_26;
    if ( a3(a1, v12) )
      return 1;
  }
  return v15;
}
// 1A1F2: conditional instruction was optimized away because edi.4==2
// AE400: using guessed type int dword_AE400;

//----- (0001A390) --------------------------------------------------------
char sub_1A390(int a1, unsigned __int16 a2)
{
  char v2; // al
  int v3; // esi
  __int16 v4; // di
  __int16 v5; // ax
  unsigned __int16 v6; // ax
  int i; // eax
  int v8; // edx
  unsigned __int8 v9; // al
  __int16 v10; // ax
  __int16 v11; // ax
  __int16 v12; // ax
  unsigned int v13; // ecx
  __int64 v14; // rax
  __int64 v15; // rax
  unsigned __int8 v17; // [esp+0h] [ebp-10h]

  if ( !*(_WORD *)(a1 + 52) )
  {
    v2 = a2;
LABEL_34:
    v9 = v2 + 1;
    goto LABEL_35;
  }
  v3 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 52);
  v4 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      v5 = *(_WORD *)(a1 + 94);
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      *(_WORD *)(a1 + 40) = v5;
      *(_WORD *)(a1 + 94) = 0;
      v4 = 1;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v6 = *(_WORD *)(a1 + 54);
    if ( v6 )
    {
      for ( i = 164 * v6 + dword_AE400 + 29795;
            i != dword_AE400 + 29795;
            i = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(i + 54) )
      {
        v8 = *(_DWORD *)(i + 12);
        if ( v8 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v8;
          v4 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(i + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v4 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  v17 = a2 + 2;
  if ( v4 )
  {
    if ( (unsigned __int16)v4 > 1u )
    {
      *(_WORD *)(v3 + 146) = *(_WORD *)(a1 + 40);
      *(_WORD *)(v3 + 52) = 0;
      sub_424F0(v3, v17);
      v9 = a2 + 4;
LABEL_35:
      LOBYTE(v10) = sub_424F0(a1, v9);
      return v10;
    }
    v10 = 41 * *(_WORD *)(a1 + 40);
    if ( *(_BYTE *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 40) + 29859) == 3 )
    {
      v11 = *(_WORD *)(a1 + 40);
      *(_WORD *)(v3 + 52) = 0;
      *(_WORD *)(v3 + 146) = v11;
      sub_424F0(v3, v17);
      v12 = *(_WORD *)(a1 + 40);
      *(_WORD *)(a1 + 52) = 0;
      *(_WORD *)(a1 + 146) = v12;
      LOBYTE(v10) = sub_424F0(a1, v17);
    }
  }
  else
  {
    sub_196E0(a1);
    v10 = *(unsigned __int8 *)(a1 + 63) / *(__int16 *)(*(_DWORD *)(a1 + 156) + 26);
    if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26)) )
    {
      switch ( *(char *)(v3 + 70) - a2 )
      {
        case 0:
        case 1:
          goto LABEL_24;
        case 2:
          *(_WORD *)(a1 + 146) = *(_WORD *)(v3 + 146);
          *(_WORD *)(a1 + 52) = 0;
          LOBYTE(v10) = sub_424F0(a1, v17);
          return v10;
        case 3:
          *(_WORD *)(a1 + 52) = *(_WORD *)(v3 + 52);
LABEL_24:
          *(_WORD *)(a1 + 34) = sub_42150(
                                  (_WORD *)(a1 + 72),
                                  (_WORD *)(164 * *(unsigned __int16 *)(a1 + 52) + dword_AE400 + 29795 + 72));
          v13 = *(_DWORD *)(dword_AE408 + 4 * *(char *)(a1 + 65) + 36382);
          break;
        default:
          v2 = a2;
          *(_WORD *)(a1 + 52) = 0;
          goto LABEL_34;
      }
      while ( v13 > dword_AE400 + 29795 )
      {
        if ( *(_WORD *)(v13 + 24) != *(_WORD *)(a1 + 24) )
        {
          v14 = *(__int16 *)(a1 + 72) - *(__int16 *)(v13 + 72);
          if ( (int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) < 256 )
          {
            v15 = *(__int16 *)(a1 + 74) - *(__int16 *)(v13 + 74);
            if ( (int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) < 256 )
            {
              *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(v13 + 72), (_WORD *)(a1 + 72));
              break;
            }
          }
        }
        v13 = *(_DWORD *)v13;
      }
      v10 = *(_WORD *)(v3 + 130) + *(_WORD *)(v3 + 126);
      *(_WORD *)(a1 + 126) = v10;
    }
  }
  return v10;
}
// 1A4A3: conditional instruction was optimized away because di.2==2
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (0001A6C0) --------------------------------------------------------
int sub_1A6C0(int a1, char a2)
{
  int i; // ebx
  __int16 v3; // cx
  unsigned int v4; // eax
  unsigned int v5; // ebx
  char v6; // cl

  for ( i = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 54);
        ;
        i = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(i + 54) )
  {
    v4 = dword_AE400 + 29795;
    if ( i == dword_AE400 + 29795 )
      break;
    sub_424F0(i, a2 + 5);
    v3 = *(_WORD *)(i + 38);
    if ( v3 )
      *(_WORD *)(a1 + 38) = v3;
  }
  v5 = v4 + 164 * *(unsigned __int16 *)(a1 + 38);
  if ( v5 > v4
    && *(_BYTE *)(v5 + 64) == 3
    && !*(_BYTE *)(v5 + 65)
    && (*(_BYTE *)(a1 + 65) != 9 || !*(_WORD *)(a1 + 144))
    && *(__int16 *)(a1 + 24) == (a1 - (dword_AE400 + 29795)) / 164 )
  {
    v6 = *(_BYTE *)(a1 + 65);
    if ( v6 != 12 && v6 != 13 && v6 != 14 && v6 != 15 && v6 != 9 )
      ++*(_DWORD *)(*(_DWORD *)(v5 + 160) + 359);
  }
  return sub_424F0(a1, a2 + 5);
}
// AE400: using guessed type int dword_AE400;

//----- (0001A800) --------------------------------------------------------
void sub_1A800(int a1)
{
  _WORD *v1; // eax
  int v2; // eax

  if ( (*(_BYTE *)(a1 + 63) & 7) == 0 )
  {
    v1 = (_WORD *)dword_AE408;
    if ( (*(_BYTE *)(dword_AE408 + 1) & 2) != 0 )
      *(_DWORD *)(a1 + 140) = 5000;
    sub_27690(v1, a1);
    v2 = sub_373F0(a1 + 72, 10, 1);
    if ( v2 )
      *(_WORD *)(v2 + 24) = *(_WORD *)(a1 + 24);
    sub_41E80(a1);
  }
}
// AE408: using guessed type int dword_AE408;

//----- (0001A8E0) --------------------------------------------------------
int sub_1A8E0(int a1, int a2)
{
  _WORD *v2; // edi
  int v3; // eax
  int v4; // ebx
  __int16 v5; // ax
  int v7; // [esp+0h] [ebp-14h]

  v2 = (_WORD *)(a1 + 72);
  v7 = 0;
  v3 = sub_373F0(a1 + 72, 9, 0);
  v4 = v3;
  if ( v3 )
  {
    *(_BYTE *)(v3 + 68) = 10;
    *(_BYTE *)(v3 + 69) = 0;
    *(_WORD *)(v3 + 24) = *(_WORD *)(a1 + 24);
    *(_WORD *)(v3 + 30) = sub_42150(v2, (_WORD *)(a2 + 72));
    *(_WORD *)(v4 + 32) = sub_42180(v2, (_WORD *)(a2 + 72));
    *(_WORD *)(v4 + 76) += *(_WORD *)(a1 + 84);
    v5 = *(_WORD *)(a1 + 146);
    *(_DWORD *)(v4 + 156) = (uint32)&unk_98FF8;
    *(_WORD *)(v4 + 146) = v5;
    *(_BYTE *)(v4 + 67) = *(_BYTE *)(a1 + 67);
    LOBYTE(v5) = *(_BYTE *)(a1 + 66);
    *(_WORD *)(v4 + 44) = 500;
    *(_BYTE *)(v4 + 66) = v5;
    return 1;
  }
  return v7;
}

//----- (0001A990) --------------------------------------------------------
int sub_1A990(int a1, int a2)
{
  _WORD *v2; // edi
  int v3; // ebx
  char v4; // al
  int v6; // [esp+0h] [ebp-14h]

  v2 = (_WORD *)(a1 + 72);
  v6 = 0;
  v3 = sub_373F0(a1 + 72, 9, 13);
  if ( v3 )
  {
    *(_WORD *)(v3 + 24) = *(_WORD *)(a1 + 24);
    *(_WORD *)(v3 + 30) = sub_42150(v2, (_WORD *)(a2 + 72));
    *(_WORD *)(v3 + 32) = sub_42180(v2, (_WORD *)(a2 + 72));
    *(_WORD *)(v3 + 76) += *(_WORD *)(a1 + 84);
    *(_WORD *)(v3 + 146) = *(_WORD *)(a1 + 146);
    *(_BYTE *)(v3 + 67) = *(_BYTE *)(a1 + 67);
    v4 = *(_BYTE *)(a1 + 66);
    *(_WORD *)(v3 + 44) = 250;
    *(_BYTE *)(v3 + 66) = v4;
    sub_370A0((_WORD *)v3, 195);
    return 1;
  }
  return v6;
}

//----- (0001AA40) --------------------------------------------------------
int sub_1AA40(int a1, int a2)
{
  _WORD *v2; // edi
  int v3; // ebx
  int v5; // [esp+4h] [ebp-14h]

  v2 = (_WORD *)(a1 + 72);
  v5 = 0;
  v3 = sub_373F0(a1 + 72, 9, 13);
  if ( v3 )
  {
    *(_WORD *)(v3 + 24) = *(_WORD *)(a1 + 24);
    *(_WORD *)(v3 + 30) = sub_42150(v2, (_WORD *)(a2 + 72));
    *(_WORD *)(v3 + 32) = sub_42180(v2, (_WORD *)(a2 + 72));
    *(_WORD *)(v3 + 76) += *(_WORD *)(a1 + 84);
    *(_WORD *)(v3 + 146) = *(_WORD *)(a1 + 146);
    *(_BYTE *)(v3 + 67) = *(_BYTE *)(a1 + 67);
    *(_BYTE *)(v3 + 66) = *(_BYTE *)(a1 + 66);
    if ( *(_WORD *)(a1 + 144) )
      *(_WORD *)(v3 + 44) = 600;
    else
      *(_WORD *)(v3 + 44) = 400;
    sub_370A0((_WORD *)v3, 203);
    return 1;
  }
  return v5;
}

//----- (0001AB10) --------------------------------------------------------
int sub_1AB10(int a1, int a2)
{
  int v2; // ebx

  v2 = 0;
  if ( (int)sub_42340((_WORD *)(a1 + 72), (_WORD *)(a2 + 72)) < 1024 )
  {
    v2 = 1;
    sub_12B50(a1, a2, 0, *(_WORD *)(a1 + 44));
  }
  return v2;
}

//----- (0001AB70) --------------------------------------------------------
int sub_1AB70(int a1, int a2)
{
  unsigned int v2; // eax
  int v3; // edi
  int v4; // ebx
  unsigned __int16 v5; // si
  unsigned __int16 v6; // bx
  int v7; // eax
  __int16 v8; // cx
  unsigned __int16 i; // bx
  int v10; // eax
  __int16 v11; // cx
  int v12; // eax
  __int16 v13; // si
  __int16 v15; // [esp+4h] [ebp-34h]
  __int16 v16; // [esp+8h] [ebp-30h]
  int v17; // [esp+Ch] [ebp-2Ch]
  char v18; // [esp+14h] [ebp-24h]
  __int16 v19; // [esp+18h] [ebp-20h]
  __int16 v20; // [esp+1Ch] [ebp-1Ch]
  __int16 v21; // [esp+20h] [ebp-18h]
  char v22; // [esp+24h] [ebp-14h]

  v20 = *(_WORD *)(a1 + 24);
  v17 = 0;
  v19 = sub_42150((_WORD *)(a1 + 72), (_WORD *)(a2 + 72));
  v21 = sub_42180((_WORD *)(a1 + 72), (_WORD *)(a2 + 72));
  v16 = *(_WORD *)(a1 + 84);
  v15 = *(_WORD *)(a1 + 146);
  v18 = *(_BYTE *)(a1 + 67);
  v22 = *(_BYTE *)(a1 + 66);
  v2 = (unsigned int)(7 * *(_DWORD *)(a1 + 140)) / *(_DWORD *)(a1 + 136);
  v3 = 0;
  LOWORD(v4) = 0;
  v5 = v2;
  if ( (_WORD)v2 )
  {
    *(_DWORD *)(a1 + 4) = 9377 * *(_DWORD *)(a1 + 4) + 9439;
    v4 = (int)(*(_DWORD *)(a1 + 4) % (100 * (unsigned int)(unsigned __int16)v2)) / 100;
  }
  if ( !(_WORD)v2 )
    v5 = 1;
  if ( v5 > 5u )
    v5 = 5;
  switch ( (__int16)v4 )
  {
    case 0:
      v6 = 0;
      do
      {
        v7 = sub_373F0(a1 + 72, 9, 0);
        v3 = v7;
        if ( v7 )
        {
          *(_BYTE *)(v7 + 69) = 0;
          *(_DWORD *)(v7 + 156) = (uint32)((char *)&unk_98F38 + 32 * (6 - v6));
          *(_BYTE *)(v7 + 67) = v18;
          *(_BYTE *)(v7 + 66) = v22;
          *(_BYTE *)(v7 + 68) = 10;
          *(_WORD *)(v7 + 24) = v20;
          *(_WORD *)(v7 + 30) = v19;
          v8 = *(_WORD *)(v7 + 76);
          *(_WORD *)(v7 + 32) = v21;
          *(_WORD *)(v7 + 44) = 400;
          *(_WORD *)(v7 + 76) = v16 + v8;
          *(_WORD *)(v7 + 146) = v15;
        }
        ++v6;
      }
      while ( v6 < v5 );
      break;
    case 1:
    case 2:
      for ( i = 1; i < v5; ++i )
      {
        v10 = sub_373F0(a1 + 72, 9, 9);
        v3 = v10;
        if ( v10 )
        {
          *(_BYTE *)(v10 + 69) = 23;
          *(_DWORD *)(v10 + 156) = (uint32)((char *)&unk_98F38 + 32 * (6 - i));
          *(_BYTE *)(v10 + 67) = v18;
          *(_BYTE *)(v10 + 66) = v22;
          *(_BYTE *)(v10 + 68) = 10;
          *(_WORD *)(v10 + 24) = v20;
          *(_WORD *)(v10 + 30) = v19;
          v11 = *(_WORD *)(v10 + 76);
          *(_WORD *)(v10 + 32) = v21;
          *(_WORD *)(v10 + 44) = 800;
          *(_WORD *)(v10 + 76) = v16 + v11;
          *(_WORD *)(v10 + 146) = v15;
        }
      }
      break;
    case 3:
    case 4:
    case 5:
    case 6:
      v12 = sub_373F0(a1 + 72, 9, 3);
      v3 = v12;
      if ( v12 )
      {
        *(_BYTE *)(v12 + 69) = 17;
        *(_DWORD *)(v12 + 156) = (uint32)&off_98F98;
        *(_BYTE *)(v12 + 67) = v18;
        *(_BYTE *)(v12 + 66) = v22;
        *(_BYTE *)(v12 + 68) = 10;
        *(_WORD *)(v12 + 24) = v20;
        *(_WORD *)(v12 + 30) = v19;
        v13 = *(_WORD *)(v12 + 76);
        *(_WORD *)(v12 + 32) = v21;
        *(_WORD *)(v12 + 44) = 8000;
        *(_WORD *)(v12 + 76) = v16 + v13;
        *(_WORD *)(v12 + 146) = v15;
      }
      break;
    default:
      break;
  }
  if ( v3 )
    return 1;
  return v17;
}
// 1AC69: conditional instruction was optimized away because si.2 is in (1..5)
// 98F98: using guessed type void *off_98F98;

//----- (0001AE30) --------------------------------------------------------
int sub_1AE30(int a1, int a2)
{
  _WORD *v2; // edi
  int v3; // eax
  int v4; // ebx
  __int16 v5; // ax
  int v7; // [esp+0h] [ebp-14h]

  v2 = (_WORD *)(a1 + 72);
  v7 = 0;
  v3 = sub_373F0(a1 + 72, 9, 14);
  v4 = v3;
  if ( v3 )
  {
    *(_BYTE *)(v3 + 68) = 10;
    *(_BYTE *)(v3 + 69) = 0;
    *(_WORD *)(v3 + 24) = *(_WORD *)(a1 + 24);
    *(_WORD *)(v3 + 30) = sub_42150(v2, (_WORD *)(a2 + 72));
    *(_WORD *)(v4 + 32) = sub_42180(v2, (_WORD *)(a2 + 72));
    *(_WORD *)(v4 + 76) += *(_WORD *)(a1 + 84);
    v5 = *(_WORD *)(a1 + 146);
    *(_DWORD *)(v4 + 156) = (uint32)&unk_98FF8;
    *(_WORD *)(v4 + 146) = v5;
    *(_BYTE *)(v4 + 67) = *(_BYTE *)(a1 + 67);
    LOBYTE(v5) = *(_BYTE *)(a1 + 66);
    *(_WORD *)(v4 + 44) = 780;
    *(_BYTE *)(v4 + 66) = v5;
    return 1;
  }
  return v7;
}

//----- (0001AEE0) --------------------------------------------------------
int sub_1AEE0(_WORD *a1, int a2)
{
  _WORD *v2; // esi
  int v3; // edi
  int v4; // eax
  int v5; // ebx
  char v6; // al

  v2 = a1 + 36;
  v3 = 0;
  v4 = sub_373F0((int)(a1 + 36), 9, 9);
  v5 = v4;
  if ( v4 )
  {
    *(_BYTE *)(v4 + 68) = 10;
    *(_BYTE *)(v4 + 69) = 23;
    *(_WORD *)(v4 + 24) = a1[12];
    *(_WORD *)(v4 + 30) = sub_42150(v2, (_WORD *)(a2 + 72));
    *(_WORD *)(v5 + 32) = sub_42180(v2, (_WORD *)(a2 + 72));
    *(_WORD *)(v5 + 76) += a1[42];
    *(_WORD *)(v5 + 146) = a1[73];
    *(_DWORD *)(v5 + 156) = (uint32)&unk_98FF8;
    *(_BYTE *)(v5 + 67) = *(_BYTE *)(a2 + 67);
    v6 = *(_BYTE *)(a2 + 66);
    *(_WORD *)(v5 + 44) = 4000;
    v3 = 1;
    *(_BYTE *)(v5 + 66) = v6;
  }
  return v3;
}

//----- (0001B060) --------------------------------------------------------
void sub_1B060(int a1)
{
  sub_19B10(a1, 0);
}

//----- (0001B070) --------------------------------------------------------
int sub_1B070(_WORD *a1)
{
  sub_19D70((int)a1, 0);
  return sub_1B120(a1);
}

//----- (0001B090) --------------------------------------------------------
int sub_1B090(_WORD *a1)
{
  if ( (unsigned __int16)sub_1A120((int)a1, 0, (unsigned __int16 (*)(int, int))sub_1A8E0) )
    sub_55370(((int)a1 - dword_AE400 - 29795) / 164, -1, 8);
  return sub_1B120(a1);
}
// AE400: using guessed type int dword_AE400;

//----- (0001B0E0) --------------------------------------------------------
int sub_1B0E0(_WORD *a1)
{
  sub_1A390((int)a1, 0);
  return sub_1B120(a1);
}

//----- (0001B100) --------------------------------------------------------
int sub_1B100(int a1)
{
  return sub_1A6C0(a1, 0);
}

//----- (0001B110) --------------------------------------------------------
void sub_1B110(int a1)
{
  sub_1A800(a1);
}

//----- (0001B120) --------------------------------------------------------
int sub_1B120(_WORD *a1)
{
  __int16 v1; // ax
  int v2; // edx
  int result; // eax

  a1[38] += a1[13];
  v1 = sub_11F50((short*)(a1 + 36));
  v2 = (__int16)a1[38];
  result = v1 + 256;
  a1[13] -= 5;
  if ( v2 < result )
    a1[13] = 150;
  return result;
}

//----- (0001B160) --------------------------------------------------------
__int16 sub_1B160(int a1)
{
  __int16 result; // ax
  int v2; // eax

  sub_19B10(a1, 6);
  LOBYTE(result) = sub_196E0(a1);
  HIBYTE(result) = *(_BYTE *)(a1 + 70);
  if ( HIBYTE(result) == 6 )
  {
    result = *(unsigned __int8 *)(a1 + 63) / *(__int16 *)(*(_DWORD *)(a1 + 156) + 26);
    if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26)) )
    {
      v2 = 164 * *(unsigned __int16 *)(a1 + 146) + dword_AE400 + 29795;
      if ( *(_BYTE *)(v2 + 64) )
      {
        result = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v2 + 72));
        *(_WORD *)(a1 + 34) = result;
      }
      else
      {
        *(_WORD *)(a1 + 146) = 0;
        return sub_424F0(a1, 7u);
      }
    }
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (0001B200) --------------------------------------------------------
unsigned int sub_1B200(int a1)
{
  int v1; // esi
  unsigned int result; // eax
  unsigned int v3; // ecx
  unsigned int v4; // edi
  int v5; // esi
  int v6; // edx
  unsigned int v7; // edx
  unsigned int v8; // [esp+0h] [ebp-10h]

  sub_19D70(a1, 6);
  v1 = *(_DWORD *)(a1 + 156);
  result = *(unsigned __int8 *)(a1 + 63) / *(__int16 *)(v1 + 26);
  if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(v1 + 26)) )
  {
    v8 = *(__int16 *)(v1 + 28) * *(__int16 *)(v1 + 28);
    v3 = -1;
    v4 = 0;
    for ( result = *(_DWORD *)(dword_AE408 + 36466); result > dword_AE400 + 29795; result = *(_DWORD *)result )
    {
      if ( *(_BYTE *)(result + 65) == 40 )
      {
        v5 = (__int16)(*(_WORD *)(result + 72) - *(_WORD *)(a1 + 72));
        v6 = (__int16)(*(_WORD *)(result + 74) - *(_WORD *)(a1 + 74));
        v7 = v5 * v5 + v6 * v6;
        if ( v7 <= v8 && v7 < v3 )
        {
          v4 = result;
          v3 = v7;
        }
      }
    }
    if ( v4 )
    {
      *(_WORD *)(a1 + 146) = (int)(v4 - (dword_AE400 + 29795)) / 164;
      return sub_424F0(a1, 6u);
    }
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (0001B2D0) --------------------------------------------------------
void sub_1B2D0(int a1)
{
  if ( (unsigned __int16)sub_1A120(a1, 6, (unsigned __int16 (*)(int, int))sub_1AB10) )
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 7);
}
// AE400: using guessed type int dword_AE400;

//----- (0001B320) --------------------------------------------------------
char sub_1B320(int a1)
{
  return sub_1A390(a1, 6u);
}

//----- (0001B330) --------------------------------------------------------
int sub_1B330(int a1)
{
  return sub_1A6C0(a1, 6);
}

//----- (0001B340) --------------------------------------------------------
void sub_1B340(int a1)
{
  sub_1A800(a1);
}

//----- (0001B350) --------------------------------------------------------
void sub_1B350(int a1)
{
  sub_19B10(a1, 12);
  if ( *(_BYTE *)(a1 + 70) == 14 )
    *(_WORD *)(a1 + 26) = 1;
}

//----- (0001B370) --------------------------------------------------------
void sub_1B370(int a1)
{
  sub_19D70(a1, 12);
  if ( *(_BYTE *)(a1 + 70) == 14 )
  {
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 13);
    *(_WORD *)(a1 + 26) = 1;
  }
}
// AE400: using guessed type int dword_AE400;

//----- (0001B3C0) --------------------------------------------------------
__int16 sub_1B3C0(int a1)
{
  __int16 v1; // dx
  int v2; // ecx
  int v3; // eax
  __int16 result; // ax

  v1 = *(_WORD *)(a1 + 26);
  if ( v1 )
  {
    *(_WORD *)(a1 + 26) = v1 - 1;
    if ( v1 == 1 )
      *(_WORD *)(a1 + 126) = 3 * *(_WORD *)(a1 + 128);
  }
  v2 = *(__int16 *)(a1 + 76) - *(__int16 *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 146) + 29871);
  if ( v2 )
    v3 = v2 / (int)abs32(v2);
  else
    LOWORD(v3) = 0;
  *(_WORD *)(a1 + 76) += v3 * *(_WORD *)(*(_DWORD *)(a1 + 156) + 14);
  result = sub_1A120(a1, 12, (unsigned __int16 (*)(int, int))sub_1AB10);
  if ( result )
  {
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 13);
    *(_WORD *)(a1 + 126) = -*(_WORD *)(a1 + 130);
    result = 3 * *(_WORD *)(*(_DWORD *)(a1 + 156) + 26);
    *(_WORD *)(a1 + 26) = result;
  }
  if ( *(_BYTE *)(a1 + 70) != 14 )
  {
    result = *(_WORD *)(a1 + 128);
    *(_WORD *)(a1 + 126) = result;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (0001B4C0) --------------------------------------------------------
char sub_1B4C0(int a1)
{
  char result; // al

  result = sub_1A390(a1, 0xCu);
  if ( *(_BYTE *)(a1 + 70) == 14 )
    *(_WORD *)(a1 + 26) = 1;
  return result;
}

//----- (0001B4E0) --------------------------------------------------------
int sub_1B4E0(int a1)
{
  return sub_1A6C0(a1, 12);
}

//----- (0001B4F0) --------------------------------------------------------
void sub_1B4F0(int a1)
{
  sub_1A800(a1);
}

//----- (0001B500) --------------------------------------------------------
void sub_1B500(int a1)
{
  sub_19B10(a1, 18);
}

//----- (0001B510) --------------------------------------------------------
void sub_1B510(int a1)
{
  sub_19D70(a1, 18);
}

//----- (0001B520) --------------------------------------------------------
void sub_1B520(int a1)
{
  if ( (unsigned __int16)sub_1A120(a1, 18, (unsigned __int16 (*)(int, int))sub_1A8E0) )
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 8);
}
// AE400: using guessed type int dword_AE400;

//----- (0001B570) --------------------------------------------------------
char sub_1B570(int a1)
{
  return sub_1A390(a1, 0x12u);
}

//----- (0001B580) --------------------------------------------------------
int sub_1B580(int a1)
{
  return sub_1A6C0(a1, 18);
}

//----- (0001B590) --------------------------------------------------------
void sub_1B590(int a1)
{
  sub_1A800(a1);
}

//----- (0001B5A0) --------------------------------------------------------
void sub_1B5A0(int a1)
{
  sub_19B10(a1, 24);
  if ( *(_BYTE *)(a1 + 70) == 26 )
    sub_1BC50(a1);
}

//----- (0001B5D0) --------------------------------------------------------
char sub_1B5D0(int a1)
{
  unsigned int v1; // edx
  __int16 v2; // ax
  int v3; // eax
  int i; // esi
  int v5; // edi
  int v6; // esi
  int v7; // eax
  int v8; // edx
  unsigned int v9; // eax
  __int16 v10; // dx
  int v11; // eax
  int v12; // esi
  int v13; // ecx
  int v14; // eax
  unsigned int v15; // ebp
  unsigned int v16; // esi
  int v17; // edi
  unsigned int v18; // edi
  __int16 v19; // ax
  int v20; // ebp
  int v21; // eax
  unsigned int v22; // edi
  unsigned int v23; // edx
  unsigned int v24; // esi
  int v25; // ebp
  int v26; // ebp
  __int16 v27; // cx
  unsigned int v28; // eax
  int v29; // eax
  unsigned int v30; // esi
  unsigned int v31; // ebp
  int v32; // edi
  int v33; // eax
  unsigned int v34; // edi
  __int16 v35; // ax
  int v36; // esi
  int v38; // [esp+0h] [ebp-38h]
  int v39; // [esp+4h] [ebp-34h]
  int v40; // [esp+4h] [ebp-34h]
  unsigned int v41; // [esp+8h] [ebp-30h]
  unsigned int v42; // [esp+Ch] [ebp-2Ch]
  unsigned int v43; // [esp+14h] [ebp-24h]
  unsigned int v44; // [esp+1Ch] [ebp-1Ch]

  *(_WORD *)(a1 + 26) = 0;
  v1 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v2 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v1 = 1;
      *(_WORD *)(a1 + 40) = v2;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    if ( *(_WORD *)(a1 + 54) )
    {
      v3 = 164 * *(unsigned __int16 *)(a1 + 54);
      for ( i = dword_AE400 + 29795; ; i = 164 * *(unsigned __int16 *)(v6 + 54) )
      {
        v6 = v3 + i;
        v3 = dword_AE400 + 29795;
        if ( v6 == dword_AE400 + 29795 )
          break;
        v5 = *(_DWORD *)(v6 + 12);
        if ( v5 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v5;
          v1 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(v6 + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v1 )
  {
    if ( v1 <= 1 )
    {
      LOWORD(v7) = 41 * *(_WORD *)(a1 + 40);
      if ( *(_BYTE *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 40) + 29859) == 3 )
      {
        *(_WORD *)(a1 + 146) = *(_WORD *)(a1 + 40);
        LOBYTE(v7) = sub_424F0(a1, 0x1Au);
      }
    }
    else
    {
      LOBYTE(v7) = sub_424F0(a1, 0x1Cu);
    }
  }
  else
  {
    sub_196E0(a1);
    LOWORD(v7) = *(unsigned __int8 *)(a1 + 63) / *(__int16 *)(*(_DWORD *)(a1 + 156) + 26);
    v8 = *(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26);
    if ( !v8 )
    {
      if ( *(_WORD *)(a1 + 146) )
      {
        LOWORD(v8) = *(_WORD *)(a1 + 146);
        LOBYTE(v7) = dword_AE400 + 99;
        v36 = dword_AE400 + 29795 + 164 * v8;
        if ( *(_BYTE *)(v36 + 64) == 10 && *(_BYTE *)(v36 + 65) == 45 )
        {
          if ( sub_42340((_WORD *)(a1 + 72), (_WORD *)(v36 + 72)) > 0x1000 )
          {
            LOWORD(v7) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v36 + 72));
            *(_WORD *)(a1 + 34) = v7;
          }
          else
          {
            LOBYTE(v7) = sub_424F0(a1, 0x1Cu);
            *(_WORD *)(a1 + 26) = 1;
            ++*(_WORD *)(v36 + 26);
          }
        }
        else
        {
          *(_WORD *)(a1 + 146) = 0;
        }
      }
      else
      {
        v9 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
        *(_DWORD *)(a1 + 4) = v9;
        v10 = 2 * (v9 % 0x9D / 79i64);
        v11 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
        *(_DWORD *)(a1 + 4) = v11;
        *(_WORD *)(a1 + 34) += ((unsigned __int8)v11 + 85) * (v10 - 1);
        v12 = *(_DWORD *)(a1 + 156);
        *(_BYTE *)(a1 + 35) &= 7u;
        v13 = 4 * *(__int16 *)(v12 + 26);
        v7 = *(unsigned __int8 *)(a1 + 63) / v13;
        if ( !(*(unsigned __int8 *)(a1 + 63) % v13) )
        {
          v14 = *(__int16 *)(v12 + 28) * *(__int16 *)(v12 + 28);
          v15 = -1;
          v38 = *(unsigned __int8 *)(a1 + 63) % v13;
          v16 = *(_DWORD *)(dword_AE408 + 36462);
          v43 = v14;
          while ( 1 )
          {
            LOBYTE(v7) = dword_AE400 + 99;
            if ( v16 <= dword_AE400 + 29795 )
              break;
            v17 = (__int16)(*(_WORD *)(v16 + 72) - *(_WORD *)(a1 + 72));
            v18 = (__int16)(*(_WORD *)(v16 + 74) - *(_WORD *)(a1 + 74))
                * (__int16)(*(_WORD *)(v16 + 74) - *(_WORD *)(a1 + 74))
                + v17 * v17;
            if ( v18 <= v43 && (*(_BYTE *)(v16 + 16) & 0x20) == 0 )
            {
              v39 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 30);
              v19 = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v16 + 72));
              if ( (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), v19) < v39 && v18 < v15 )
              {
                v38 = v16;
                v15 = v18;
              }
            }
            v16 = *(_DWORD *)v16;
          }
          v20 = v38;
          if ( v38 )
          {
            if ( *(_BYTE *)(v38 + 65) > 1u || (v7 = *(_DWORD *)(v38 + 160), !*(_WORD *)(v7 + 528)) )
              v20 = 0;
          }
          if ( !v20 )
          {
            v21 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 28);
            v22 = -1;
            v23 = 0;
            v24 = *(_DWORD *)(dword_AE408 + 36418);
            v44 = v21 * v21;
            while ( 1 )
            {
              LOBYTE(v7) = dword_AE400 + 99;
              if ( v24 <= dword_AE400 + 29795 )
                break;
              v25 = (__int16)(*(_WORD *)(v24 + 72) - *(_WORD *)(a1 + 72));
              v26 = v25 * v25;
              v27 = *(_WORD *)(a1 + 74);
              v28 = v26 + (__int16)(*(_WORD *)(v24 + 74) - v27) * (__int16)(*(_WORD *)(v24 + 74) - v27);
              if ( v28 <= v44 && v28 < v22 )
              {
                v23 = v24;
                v22 = v26 + (__int16)(*(_WORD *)(v24 + 74) - v27) * (__int16)(*(_WORD *)(v24 + 74) - v27);
              }
              v24 = *(_DWORD *)v24;
            }
            v20 = v23;
          }
          if ( v20 )
          {
            if ( *(_BYTE *)(v20 + 64) != 10 || *(_BYTE *)(v20 + 65) != 45 )
            {
              *(_WORD *)(a1 + 146) = (v20 - (dword_AE400 + 29795)) / 164;
              LOBYTE(v7) = sub_424F0(a1, 0x1Au);
            }
          }
          else
          {
            v29 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 28);
            v42 = v29 * v29;
            v30 = *(_DWORD *)(dword_AE408 + 4 * *(char *)(a1 + 65) + 36382);
            v41 = 0;
            v31 = -1;
            while ( 1 )
            {
              v7 = dword_AE400 + 29795;
              if ( v30 <= dword_AE400 + 29795 )
                break;
              if ( !*(_WORD *)(v30 + 52) && v30 != a1 )
              {
                v32 = (__int16)(*(_WORD *)(v30 + 72) - *(_WORD *)(a1 + 72));
                v33 = (__int16)(*(_WORD *)(v30 + 74) - *(_WORD *)(a1 + 74));
                v34 = v33 * v33 + v32 * v32;
                if ( v34 <= v42 )
                {
                  v40 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 30);
                  v35 = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v30 + 72));
                  if ( (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), v35) < v40 && v34 < v31 )
                  {
                    v41 = v30;
                    v31 = v34;
                  }
                }
              }
              v30 = *(_DWORD *)v30;
            }
            if ( v41 )
            {
              *(_WORD *)(a1 + 52) = (int)(v41 - v7) / 164;
              LOBYTE(v7) = sub_424F0(a1, 0x1Bu);
            }
          }
        }
      }
    }
  }
  if ( *(_BYTE *)(a1 + 70) == 26 )
    LOBYTE(v7) = sub_1BC50(a1);
  return v7;
}
// 1B6B7: conditional instruction was optimized away because edx.4==2
// 1B8A8: conditional instruction was optimized away because %var_38.4!=0
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (0001BB20) --------------------------------------------------------
int sub_1BB20(int a1)
{
  int result; // eax

  sub_1A120(a1, 24, (unsigned __int16 (*)(int, int))sub_1A990);
  if ( *(_BYTE *)(a1 + 70) != 26 )
    return sub_1BCE0(a1);
  result = *(unsigned __int8 *)(a1 + 63) / *(__int16 *)(*(_DWORD *)(a1 + 156) + 26);
  if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26)) )
  {
    result = 164 * *(unsigned __int16 *)(a1 + 146);
    if ( result + dword_AE400 + 29795 )
    {
      result += dword_AE400;
      if ( *(_BYTE *)(result + 29860) <= 1u )
      {
        result = *(_DWORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 146) + 29955);
        *(_WORD *)(result + 528) = 200;
      }
    }
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (0001BBE0) --------------------------------------------------------
char sub_1BBE0(int a1)
{
  char result; // al

  result = sub_1A390(a1, 0x18u);
  if ( *(_BYTE *)(a1 + 70) == 26 )
    return sub_1BC50(a1);
  return result;
}

//----- (0001BC10) --------------------------------------------------------
int sub_1BC10(int a1)
{
  if ( *(_WORD *)(a1 + 26) )
    return sub_41E80(a1);
  else
    return sub_1A6C0(a1, 24);
}

//----- (0001BC40) --------------------------------------------------------
void sub_1BC40(int a1)
{
  sub_1A800(a1);
}

//----- (0001BC50) --------------------------------------------------------
char sub_1BC50(int a1)
{
  unsigned int v1; // eax
  int v2; // ecx
  unsigned __int16 v3; // dx
  char result; // al

  v1 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
  *(_DWORD *)(a1 + 4) = v1;
  *(_WORD *)(a1 + 126) = 0;
  if ( (int)(v1 % 0x14) <= 10 )
    sub_36FA0(a1, 206);
  else
    sub_36FA0(a1, 1);
  v2 = dword_AE400;
  v3 = *(_WORD *)(a1 + 146);
  *(_BYTE *)(a1 + 66) = *(_BYTE *)(dword_AE400 + 164 * v3 + 29859);
  result = *(_BYTE *)(v2 + 164 * v3 + 29860);
  *(_BYTE *)(a1 + 67) = result;
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (0001BCE0) --------------------------------------------------------
int sub_1BCE0(int a1)
{
  int result; // eax

  *(_WORD *)(a1 + 126) = *(_WORD *)(a1 + 128);
  result = sub_36FA0(a1, 0);
  *(_BYTE *)(a1 + 66) = 3;
  *(_BYTE *)(a1 + 67) = -1;
  return result;
}

//----- (0001BD10) --------------------------------------------------------
int sub_1BD10(int a1)
{
  return sub_424F0(a1, 0x1Fu);
}

//----- (0001BD20) --------------------------------------------------------
int sub_1BD20(int a1)
{
  unsigned int v1; // edi
  __int16 v2; // ax
  unsigned __int16 v3; // cx
  int i; // eax
  int v5; // edx
  int v6; // esi
  unsigned int v7; // ebp
  unsigned int v8; // esi
  int v9; // edi
  int v10; // eax
  unsigned int v11; // edi
  __int16 v12; // ax
  int v13; // eax
  unsigned int v14; // ebp
  int v15; // eax
  _WORD *v16; // esi
  unsigned int v17; // edi
  unsigned int v18; // edx
  unsigned int j; // eax
  int v20; // edi
  int v21; // edi
  __int16 v22; // cx
  int v23; // esi
  unsigned int v24; // eax
  int result; // eax
  int v26; // edx
  int v27; // [esp+0h] [ebp-20h]
  _WORD *v28; // [esp+4h] [ebp-1Ch]
  unsigned int v29; // [esp+8h] [ebp-18h]
  unsigned int v30; // [esp+Ch] [ebp-14h]

  v1 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v2 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v1 = 1;
      *(_WORD *)(a1 + 40) = v2;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v3 = *(_WORD *)(a1 + 54);
    if ( v3 )
    {
      for ( i = dword_AE400 + 29795 + 164 * v3;
            i != dword_AE400 + 29795;
            i = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(i + 54) )
      {
        v5 = *(_DWORD *)(i + 12);
        if ( v5 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v5;
          v1 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(i + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v1 )
  {
    if ( v1 <= 1 )
    {
      if ( *(_BYTE *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 40) + 29859) == 3 )
      {
        *(_WORD *)(a1 + 146) = *(_WORD *)(a1 + 40);
        sub_424F0(a1, 0x20u);
      }
    }
    else
    {
      sub_424F0(a1, 0x22u);
    }
  }
  else
  {
    sub_196E0(a1);
    v6 = *(_DWORD *)(a1 + 156);
    if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(v6 + 26)) )
    {
      v7 = -1;
      v29 = 0;
      v30 = *(__int16 *)(v6 + 28) * *(__int16 *)(v6 + 28);
      v8 = *(_DWORD *)(dword_AE408 + 36462);
      v28 = (_WORD *)(a1 + 72);
      while ( 1 )
      {
        v13 = dword_AE400 + 29795;
        if ( v8 <= dword_AE400 + 29795 )
          break;
        v9 = (__int16)(*(_WORD *)(v8 + 72) - *(_WORD *)(a1 + 72));
        v10 = (__int16)(*(_WORD *)(v8 + 74) - *(_WORD *)(a1 + 74));
        v11 = v10 * v10 + v9 * v9;
        if ( v11 <= v30 && (*(_BYTE *)(v8 + 16) & 0x20) == 0 )
        {
          v27 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 30);
          v12 = sub_42150(v28, (_WORD *)(v8 + 72));
          if ( (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), v12) < v27 && v11 < v7 )
          {
            v29 = v8;
            v7 = v11;
          }
        }
        v8 = *(_DWORD *)v8;
      }
      v14 = v29;
      if ( v29 )
      {
        *(_WORD *)(a1 + 146) = (int)(v29 - v13) / 164;
        sub_424F0(a1, 0x20u);
      }
      else if ( *(_WORD *)(a1 + 146) )
      {
        v15 = 164 * *(unsigned __int16 *)(a1 + 146) + v13;
        if ( *(_BYTE *)(v15 + 64) == 10 && *(_BYTE *)(v15 + 65) == 39 )
        {
          v16 = (_WORD *)(v15 + 72);
          v17 = *(__int16 *)(a1 + 128) << 7;
          if ( sub_423D0(v28, (_WORD *)(v15 + 72)) > v17 )
          {
            *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), v16);
          }
          else
          {
            *(_WORD *)(a1 + 26) = 15;
            sub_424F0(a1, 0x21u);
          }
        }
        else
        {
          *(_WORD *)(a1 + 146) = 0;
        }
      }
      else if ( !(2 * (*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26))) )
      {
        v18 = -1;
        for ( j = *(_DWORD *)(dword_AE408 + 36466); j > dword_AE400 + 29795; j = *(_DWORD *)j )
        {
          if ( *(_BYTE *)(j + 65) == 39 )
          {
            v20 = (__int16)(*(_WORD *)(j + 72) - *(_WORD *)(a1 + 72));
            v21 = v20 * v20;
            v22 = *(_WORD *)(a1 + 74);
            if ( v21 + (__int16)(*(_WORD *)(j + 74) - v22) * (__int16)(*(_WORD *)(j + 74) - v22) < v18 )
            {
              v14 = j;
              v18 = v21 + (__int16)(*(_WORD *)(j + 74) - v22) * (__int16)(*(_WORD *)(j + 74) - v22);
            }
          }
        }
        if ( v14 )
          *(_WORD *)(a1 + 146) = (int)(v14 - (dword_AE400 + 29795)) / 164;
        if ( *(_DWORD *)(a1 + 136) + 500 < *(_DWORD *)(a1 + 140) )
        {
          v23 = sub_373F0(a1 + 72, 10, 52);
          if ( v23 )
          {
            v24 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
            *(_DWORD *)(a1 + 4) = v24;
            *(_WORD *)(v23 + 26) = 10 * (v24 % 0xA) + 100;
            *(_DWORD *)(a1 + 140) -= 500;
          }
        }
      }
    }
  }
  result = *(_DWORD *)(a1 + 12);
  v26 = *(_DWORD *)(a1 + 8);
  if ( result < v26 )
  {
    result = v26 >> 7;
    *(_DWORD *)(a1 + 12) += v26 >> 7;
  }
  return result;
}
// 1BDEF: conditional instruction was optimized away because edi.4==2
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (0001C110) --------------------------------------------------------
int sub_1C110(int a1)
{
  int result; // eax
  int v2; // edx

  if ( (unsigned __int16)sub_1A120(a1, 30, (unsigned __int16 (*)(int, int))sub_1AB70) )
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 32);
  result = *(_DWORD *)(a1 + 12);
  v2 = *(_DWORD *)(a1 + 8);
  if ( result < v2 )
  {
    result = v2 >> 7;
    *(_DWORD *)(a1 + 12) += v2 >> 7;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (0001C170) --------------------------------------------------------
__int16 sub_1C170(int a1)
{
  int v1; // esi
  unsigned int v2; // edi
  __int16 v3; // ax
  unsigned __int16 v4; // cx
  int v5; // eax
  int i; // edx
  int v7; // ecx
  __int16 result; // ax
  int v9; // edi
  unsigned int v10; // eax
  int v11; // ebp

  v1 = dword_AE400;
  v2 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v3 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v2 = 1;
      *(_WORD *)(a1 + 40) = v3;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v4 = *(_WORD *)(a1 + 54);
    if ( v4 )
    {
      v5 = 164 * v4 + v1 + 29795;
      for ( i = v1 + 29795; v5 != i; v5 = i + 164 * *(unsigned __int16 *)(v5 + 54) )
      {
        v7 = *(_DWORD *)(v5 + 12);
        if ( v7 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v7;
          v2 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(v5 + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  dword_AE400 = v1;
  if ( v2 )
  {
    if ( v2 <= 1 )
    {
      result = 41 * *(_WORD *)(a1 + 40);
      if ( *(_BYTE *)(v1 + 164 * *(unsigned __int16 *)(a1 + 40) + 29859) == 3 )
      {
        *(_WORD *)(a1 + 146) = *(_WORD *)(a1 + 40);
        return sub_424F0(a1, 0x20u);
      }
    }
    else
    {
      return sub_424F0(a1, 0x22u);
    }
  }
  else
  {
    sub_196E0(a1);
    result = *(unsigned __int8 *)(a1 + 63) / *(__int16 *)(a1 + 26);
    if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(a1 + 26)) )
    {
      v9 = 164 * *(unsigned __int16 *)(a1 + 146) + dword_AE400 + 29795;
      if ( *(_BYTE *)(v9 + 64) == 10 && *(_BYTE *)(v9 + 65) == 39 )
      {
        v10 = sub_423D0((_WORD *)(a1 + 72), (_WORD *)(v9 + 72));
        v11 = *(__int16 *)(a1 + 128);
        if ( v10 > 5 * v11 )
        {
          if ( v10 <= 20 * v11 )
            *(_WORD *)(a1 + 26) = 3;
          result = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v9 + 72));
          *(_WORD *)(a1 + 34) = result;
        }
        else
        {
          *(_WORD *)(a1 + 146) = 0;
          *(_DWORD *)(a1 + 140) += *(_DWORD *)(v9 + 140);
          *(_WORD *)(v9 + 144) = 0;
          sub_41E80(v9);
          sub_424F0(a1, 0x1Fu);
          return sub_38820(a1);
        }
      }
      else
      {
        *(_WORD *)(a1 + 146) = 0;
        return sub_424F0(a1, 0x1Fu);
      }
    }
  }
  return result;
}
// 1C23C: conditional instruction was optimized away because edi.4==2
// AE400: using guessed type int dword_AE400;

//----- (0001C3C0) --------------------------------------------------------
int sub_1C3C0(int a1)
{
  return sub_1A6C0(a1, 30);
}

//----- (0001C3D0) --------------------------------------------------------
void sub_1C3D0(int a1)
{
  sub_1A800(a1);
}

//----- (0001C490) --------------------------------------------------------
void sub_1C490(int a1)
{
  sub_19B10(a1, 36);
}

//----- (0001C4A0) --------------------------------------------------------
void sub_1C4A0(int a1)
{
  sub_19D70(a1, 36);
  if ( *(_BYTE *)(a1 + 70) == 38 )
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 37);
  *(_WORD *)(a1 + 126) = 30;
}
// AE400: using guessed type int dword_AE400;

//----- (0001C4F0) --------------------------------------------------------
void sub_1C4F0(int a1)
{
  int v1; // ebp
  unsigned int v2; // esi
  __int16 v3; // ax
  unsigned __int16 v4; // cx
  int v5; // eax
  int i; // edx
  int v7; // ecx
  char v8; // cl
  __int16 v9; // ax
  int v10; // edi
  __int16 v11; // ax
  int v12; // ebp
  __int16 v13; // ax
  int v14; // edx
  int v15; // ecx
  int v16; // edx
  unsigned int v17; // esi
  char v18; // ah
  int v19; // eax
  int v20; // esi
  __int16 v21; // ax
  _WORD *v22; // [esp+4h] [ebp-14h]

  v1 = dword_AE400;
  *(_WORD *)(a1 + 126) = 30;
  v2 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v3 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v2 = 1;
      *(_WORD *)(a1 + 40) = v3;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v4 = *(_WORD *)(a1 + 54);
    if ( v4 )
    {
      v5 = 164 * v4 + v1 + 29795;
      for ( i = v1 + 29795; v5 != i; v5 = i + 164 * *(unsigned __int16 *)(v5 + 54) )
      {
        v7 = *(_DWORD *)(v5 + 12);
        if ( v7 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v7;
          v2 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(v5 + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v2 )
  {
    if ( v2 <= 1 )
    {
      v8 = *(_BYTE *)(v1 + 164 * *(unsigned __int16 *)(a1 + 40) + 29859);
      dword_AE400 = v1;
      if ( v8 == 3 )
      {
        v9 = *(_WORD *)(a1 + 40);
        *(_WORD *)(a1 + 26) = -10;
        *(_WORD *)(a1 + 146) = v9;
      }
    }
    else
    {
      dword_AE400 = v1;
      sub_424F0(a1, 0x28u);
    }
    return;
  }
  dword_AE400 = v1;
  sub_196E0(a1);
  v10 = 164 * *(unsigned __int16 *)(a1 + 146) + dword_AE400 + 29795;
  if ( (*(_BYTE *)(a1 + 63) & 3) == 0 )
    *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v10 + 72));
  if ( *(int *)(v10 + 12) < 0 || (*(_BYTE *)(v10 + 17) & 4) != 0 )
  {
LABEL_30:
    sub_424F0(a1, 0x25u);
    return;
  }
  v11 = *(_WORD *)(a1 + 26);
  v12 = dword_AE400;
  *(_WORD *)(a1 + 26) = v11 + 1;
  if ( v11 > 40 )
    *(_WORD *)(a1 + 26) = -90;
  if ( *(__int16 *)(a1 + 26) > 0 )
  {
    dword_AE400 = v12;
    v13 = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v10 + 72));
    HIBYTE(v13) = (HIBYTE(v13) + 4) & 7;
    *(_WORD *)(*(_DWORD *)(v10 + 160) + 24) = v13;
    *(_WORD *)(*(_DWORD *)(v10 + 160) + 26) = 256;
    v14 = dword_AE400 + 29795;
    *(_WORD *)(*(_DWORD *)(v10 + 160) + 22) = 80;
    sub_55370((a1 - v14) / 164, -1, 42);
    v12 = dword_AE400;
  }
  v15 = *(_DWORD *)(a1 + 156);
  v16 = *(unsigned __int8 *)(a1 + 63) % *(__int16 *)(v15 + 26);
  dword_AE400 = v12;
  if ( !v16 )
  {
    v17 = *(__int16 *)(v15 + 28);
    if ( sub_42340((_WORD *)(a1 + 72), (_WORD *)(v10 + 72)) >= v17 )
      goto LABEL_30;
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 37);
    *(_BYTE *)(a1 + 71) = 5;
  }
  v18 = *(_BYTE *)(a1 + 71);
  if ( v18 )
  {
    v22 = (_WORD *)(a1 + 72);
    *(_BYTE *)(a1 + 71) = v18 - 1;
    v19 = sub_373F0(a1 + 72, 9, 9);
    v20 = v19;
    if ( v19 )
    {
      *(_BYTE *)(v19 + 68) = 10;
      *(_BYTE *)(v19 + 69) = 23;
      *(_WORD *)(v19 + 24) = *(_WORD *)(a1 + 24);
      *(_WORD *)(v19 + 30) = sub_42150(v22, (_WORD *)(v10 + 72));
      *(_WORD *)(v20 + 32) = sub_42180(v22, (_WORD *)(v10 + 72));
      *(_WORD *)(v20 + 76) += *(_WORD *)(a1 + 84);
      v21 = *(_WORD *)(a1 + 146);
      *(_DWORD *)(v20 + 156) = (uint32)&unk_98FF8;
      *(_WORD *)(v20 + 146) = v21;
      *(_BYTE *)(v20 + 67) = *(_BYTE *)(v10 + 67);
      LOBYTE(v21) = *(_BYTE *)(v10 + 66);
      *(_WORD *)(v20 + 44) = 800;
      *(_BYTE *)(v20 + 66) = v21;
    }
  }
}
// 1C5C5: conditional instruction was optimized away because esi.4==2
// AE400: using guessed type int dword_AE400;

//----- (0001C880) --------------------------------------------------------
void sub_1C880(int a1)
{
  char v1; // ah

  sub_1A390(a1, 0x24u);
  v1 = *(_BYTE *)(a1 + 70);
  *(_WORD *)(a1 + 126) = 30;
  if ( v1 == 38 )
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 37);
}
// AE400: using guessed type int dword_AE400;

//----- (0001C8D0) --------------------------------------------------------
int sub_1C8D0(int a1)
{
  return sub_1A6C0(a1, 36);
}

//----- (0001C8E0) --------------------------------------------------------
void sub_1C8E0(int a1)
{
  sub_1A800(a1);
}

//----- (0001C8F0) --------------------------------------------------------
void sub_1C8F0(int a1)
{
  sub_19B10(a1, 42);
}

//----- (0001C900) --------------------------------------------------------
void sub_1C900(int a1)
{
  bool v1; // eax
  int v2; // esi

  if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26)) )
  {
    v1 = *(int *)(a1 + 8) >> 6 > *(_DWORD *)(a1 + 8);
    v2 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 12) = v1 + v2;
    if ( v1 + v2 )
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  }
  sub_19D70(a1, 42);
  if ( *(_BYTE *)(a1 + 70) == 44 )
    *(_WORD *)(a1 + 26) = 1;
}

//----- (0001C960) --------------------------------------------------------
__int16 sub_1C960(int a1)
{
  __int16 v1; // dx
  __int16 result; // ax

  v1 = *(_WORD *)(a1 + 26);
  if ( v1 )
  {
    *(_WORD *)(a1 + 26) = v1 - 1;
    if ( v1 == 1 && *(_WORD *)(a1 + 86) == 198 )
    {
      sub_36FA0(a1, 85);
      *(_WORD *)(a1 + 126) = *(_WORD *)(a1 + 128);
    }
  }
  result = sub_1A120(a1, 42, (unsigned __int16 (*)(int, int))sub_1AE30);
  if ( (_BYTE)result )
  {
    result = *(_WORD *)(a1 + 86);
    if ( result == 85 )
    {
      sub_36FA0(a1, 198);
      *(_WORD *)(a1 + 26) = 30;
      result = *(_WORD *)(a1 + 130);
      *(_WORD *)(a1 + 126) = result;
    }
  }
  if ( *(_BYTE *)(a1 + 70) != 44 )
  {
    result = *(_WORD *)(a1 + 86);
    if ( result == 198 )
    {
      sub_36FA0(a1, 85);
      result = *(_WORD *)(a1 + 128);
      *(_WORD *)(a1 + 126) = result;
    }
  }
  return result;
}

//----- (0001CA00) --------------------------------------------------------
char sub_1CA00(int a1)
{
  char result; // al

  result = sub_1A390(a1, 0x2Au);
  if ( *(_BYTE *)(a1 + 70) == 44 )
    *(_WORD *)(a1 + 26) = 1;
  return result;
}

//----- (0001CA20) --------------------------------------------------------
int sub_1CA20(int a1)
{
  return sub_1A6C0(a1, 42);
}

//----- (0001CA30) --------------------------------------------------------
void sub_1CA30(int a1)
{
  sub_1A800(a1);
}

//----- (0001CA40) --------------------------------------------------------
void sub_1CA40(int a1)
{
  sub_19B10(a1, 48);
}

//----- (0001CA50) --------------------------------------------------------
void sub_1CA50(int a1)
{
  unsigned int v1; // ebp
  __int16 v2; // ax
  unsigned __int16 v3; // cx
  int i; // esi
  int v5; // eax
  unsigned int v6; // eax
  int v7; // ebp
  int v8; // eax
  unsigned int v9; // ebp
  unsigned int j; // esi
  int v11; // eax
  unsigned int v12; // edi
  __int16 v13; // ax
  int v14; // eax
  unsigned int v15; // ebp
  unsigned int v16; // esi
  int v17; // eax
  unsigned int v18; // edi
  __int16 v19; // ax
  int v20; // [esp+0h] [ebp-2Ch]
  int v21; // [esp+0h] [ebp-2Ch]
  unsigned int v22; // [esp+8h] [ebp-24h]
  unsigned int v23; // [esp+Ch] [ebp-20h]
  unsigned int v24; // [esp+14h] [ebp-18h]
  unsigned int v25; // [esp+18h] [ebp-14h]

  v1 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v2 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v1 = 1;
      *(_WORD *)(a1 + 40) = v2;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v3 = *(_WORD *)(a1 + 54);
    if ( v3 )
    {
      for ( i = 164 * v3 + dword_AE400 + 29795;
            i != dword_AE400 + 29795;
            i = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(i + 54) )
      {
        v5 = *(_DWORD *)(i + 12);
        if ( v5 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v5;
          v1 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(i + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v1 )
  {
    if ( v1 <= 1 )
    {
      if ( *(_BYTE *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 40) + 29859) == 3 )
      {
        *(_WORD *)(a1 + 146) = *(_WORD *)(a1 + 40);
        sub_424F0(a1, 0x32u);
      }
    }
    else
    {
      sub_424F0(a1, 0x34u);
    }
  }
  else
  {
    sub_196E0(a1);
    if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26)) )
    {
      v6 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
      *(_DWORD *)(a1 + 4) = v6;
      v7 = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a1 + 4) = 9377 * v7 + 9439;
      *(_WORD *)(a1 + 34) += ((unsigned __int8)(-95 * v7 - 33) + 85) * (2 * ((int)(v6 % 0x9D) / 79) - 1);
      LOBYTE(v6) = *(_BYTE *)(a1 + 58);
      *(_BYTE *)(a1 + 35) &= 7u;
      if ( (_BYTE)v6 )
      {
        v8 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 28);
        v9 = -1;
        v23 = v8 * v8;
        v25 = 0;
        for ( j = *(_DWORD *)(dword_AE408 + 36462); j > dword_AE400 + 29795; j = *(_DWORD *)j )
        {
          v11 = (__int16)(*(_WORD *)(j + 72) - *(_WORD *)(a1 + 72));
          v12 = v11 * v11
              + (__int16)(*(_WORD *)(j + 74) - *(_WORD *)(a1 + 74))
              * (__int16)(*(_WORD *)(j + 74) - *(_WORD *)(a1 + 74));
          if ( v12 <= v23 )
          {
            v20 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 30);
            v13 = sub_42150((_WORD *)(a1 + 72), (_WORD *)(j + 72));
            if ( (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), v13) < v20 && v12 < v9 )
            {
              v25 = j;
              v9 = v12;
            }
          }
        }
        if ( v25 && *(_BYTE *)(v25 + 65) <= 1u && *(_WORD *)(*(_DWORD *)(v25 + 160) + 528) )
        {
          *(_WORD *)(a1 + 146) = (int)(v25 - (dword_AE400 + 29795)) / 164;
          *(_WORD *)(*(_DWORD *)(v25 + 160) + 528) = 200;
          sub_424F0(a1, 0x32u);
        }
        else
        {
          v14 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 28);
          v15 = -1;
          v22 = v14 * v14;
          v16 = *(_DWORD *)(dword_AE408 + 4 * *(char *)(a1 + 65) + 36382);
          v24 = 0;
          while ( v16 > dword_AE400 + 29795 )
          {
            if ( !*(_WORD *)(v16 + 52) && v16 != a1 )
            {
              v17 = (__int16)(*(_WORD *)(v16 + 72) - *(_WORD *)(a1 + 72));
              v18 = v17 * v17
                  + (__int16)(*(_WORD *)(v16 + 74) - *(_WORD *)(a1 + 74))
                  * (__int16)(*(_WORD *)(v16 + 74) - *(_WORD *)(a1 + 74));
              if ( v18 <= v22 )
              {
                v21 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 30);
                v19 = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v16 + 72));
                if ( (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), v19) < v21 && v18 < v15 )
                {
                  v24 = v16;
                  v15 = v18;
                }
              }
            }
            v16 = *(_DWORD *)v16;
          }
          if ( v24 )
          {
            *(_WORD *)(a1 + 52) = (int)(v24 - (dword_AE400 + 29795)) / 164;
            sub_424F0(a1, 0x33u);
          }
        }
      }
    }
  }
}
// 1CB20: conditional instruction was optimized away because ebp.4==2
// 1CCC5: conditional instruction was optimized away because %var_14.4!=0
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (0001CE30) --------------------------------------------------------
void sub_1CE30(int a1)
{
  int v1; // eax

  if ( *(_WORD *)(a1 + 26) )
    *(_WORD *)(a1 + 126) = *(_WORD *)(a1 + 128);
  *(_BYTE *)(a1 + 17) |= 0x80u;
  if ( (unsigned __int16)sub_1A120(a1, 48, (unsigned __int16 (*)(int, int))sub_1AEE0) )
  {
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 38);
    v1 = 164 * *(unsigned __int16 *)(a1 + 146);
    if ( v1 + dword_AE400 + 29795 )
    {
      if ( *(_BYTE *)(dword_AE400 + v1 + 29860) <= 1u )
        *(_WORD *)(*(_DWORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 146) + 29955) + 528) = 200;
    }
  }
  if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26)) )
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 38);
}
// AE400: using guessed type int dword_AE400;

//----- (0001CF50) --------------------------------------------------------
char sub_1CF50(int a1)
{
  return sub_1A390(a1, 0x30u);
}

//----- (0001CF60) --------------------------------------------------------
int sub_1CF60(int a1)
{
  int v1; // eax

  v1 = 164 * *(unsigned __int16 *)(a1 + 38);
  if ( v1 + dword_AE400 + 29795 && *(_BYTE *)(dword_AE400 + v1 + 29860) <= 1u )
    *(_WORD *)(*(_DWORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 38) + 29955) + 528) = 200;
  return sub_1A6C0(a1, 48);
}
// AE400: using guessed type int dword_AE400;

//----- (0001CFE0) --------------------------------------------------------
void sub_1CFE0(int a1)
{
  sub_1A800(a1);
}

//----- (0001CFF0) --------------------------------------------------------
int sub_1CFF0(int a1)
{
  __int16 v1; // dx
  __int16 v2; // cx
  int result; // eax

  v1 = *(_WORD *)(a1 + 26);
  v2 = v1 - 1;
  *(_WORD *)(a1 + 26) = v1 - 1;
  if ( v1 )
  {
    if ( v1 == 17 )
    {
      return sub_36FA0(a1, 237);
    }
    else if ( v2 < 16 )
    {
      result = v2 / 2;
      if ( !(v2 % 2) )
        return sub_42510(a1);
    }
  }
  else
  {
    sub_1DD50(a1);
    result = sub_424F0(a1, 0x37u);
    *(_WORD *)(a1 + 26) = 400;
    *(_BYTE *)(a1 + 71) = 0;
  }
  return result;
}

//----- (0001D060) --------------------------------------------------------
void sub_1D060(int a1)
{
  __int16 v1; // cx
  char v2; // al
  int v3; // ebp
  unsigned int v4; // edi
  __int16 v5; // ax
  int v6; // esi
  int i; // eax
  int v8; // edx
  unsigned int v9; // edx
  int v10; // ebp
  unsigned int j; // eax
  int v12; // edi
  unsigned int v13; // eax
  int v14; // ecx
  int v15; // eax
  unsigned int k; // esi
  __int16 v17; // ax
  __int16 v18; // di
  int v19; // edi
  unsigned int v20; // edi
  __int16 v21; // ax
  int v22; // esi
  unsigned int v23; // edx
  unsigned int v24; // edi
  unsigned int ii; // eax
  int v26; // edx
  int v27; // esi
  unsigned int v28; // esi
  int v29; // eax
  unsigned int v30; // edi
  unsigned int m; // eax
  int v32; // edx
  unsigned int v33; // esi
  unsigned int v34; // edi
  unsigned int n; // eax
  int v36; // edx
  int v37; // esi
  unsigned int v38; // esi
  int v39; // esi
  unsigned int v40; // [esp+0h] [ebp-48h]
  int v41; // [esp+4h] [ebp-44h]
  unsigned int v42; // [esp+8h] [ebp-40h]
  int v43; // [esp+8h] [ebp-40h]
  unsigned int v44; // [esp+Ch] [ebp-3Ch]
  unsigned int v45; // [esp+10h] [ebp-38h]
  int v46; // [esp+14h] [ebp-34h]
  unsigned int v47; // [esp+18h] [ebp-30h]
  unsigned int v48; // [esp+1Ch] [ebp-2Ch]
  unsigned int v49; // [esp+20h] [ebp-28h]
  unsigned int v50; // [esp+28h] [ebp-20h]
  unsigned int v51; // [esp+2Ch] [ebp-1Ch]
  int v52; // [esp+30h] [ebp-18h]

  v1 = *(_WORD *)(a1 + 26);
  if ( v1 > 0 )
  {
    *(_WORD *)(a1 + 26) = v1 - 1;
    if ( v1 == 1 )
      sub_1DD90(a1);
  }
  v2 = *(_BYTE *)(a1 + 71);
  v3 = dword_AE400;
  if ( v2 )
  {
    if ( v2 == 1 )
      sub_1D6D0(a1);
    goto LABEL_84;
  }
  if ( *(_BYTE *)(a1 + 58) )
    *(_WORD *)(a1 + 26) = 400;
  v4 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    v5 = *(_WORD *)(a1 + 94);
    if ( v5 )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v5 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v4 = 1;
    }
    *(_WORD *)(a1 + 40) = v5;
    if ( *(_WORD *)(a1 + 54) )
    {
      v6 = v3 + 29795;
      for ( i = 164 * *(unsigned __int16 *)(a1 + 54) + v3 + 29795; i != v6; i = v6 + 164 * *(unsigned __int16 *)(i + 54) )
      {
        v8 = *(_DWORD *)(i + 12);
        if ( v8 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v8;
          v4 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(i + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v4 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v4 )
  {
    dword_AE400 = v3;
    if ( v4 <= 1 )
    {
      *(_WORD *)(a1 + 146) = *(_WORD *)(a1 + 40);
      sub_424F0(a1, 0x38u);
    }
    else
    {
      sub_424F0(a1, 0x3Au);
    }
    goto LABEL_84;
  }
  dword_AE400 = v3;
  sub_196E0(a1);
  if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26)) )
  {
    v9 = -1;
    v10 = dword_AE400;
    v52 = 0;
    for ( j = *(_DWORD *)(dword_AE408 + 36462); j > dword_AE400 + 29795; j = *(_DWORD *)j )
    {
      if ( *(_BYTE *)(j + 65) == 2 && *(_WORD *)(j + 24) != *(_WORD *)(a1 + 24) )
      {
        v12 = (__int16)(*(_WORD *)(j + 72) - *(_WORD *)(a1 + 72));
        if ( v12 * v12
           + (__int16)(*(_WORD *)(j + 74) - *(_WORD *)(a1 + 74)) * (__int16)(*(_WORD *)(j + 74) - *(_WORD *)(a1 + 74)) < v9 )
        {
          v52 = j;
          v9 = v12 * v12
             + (__int16)(*(_WORD *)(j + 74) - *(_WORD *)(a1 + 74)) * (__int16)(*(_WORD *)(j + 74) - *(_WORD *)(a1 + 74));
        }
      }
    }
    v46 = v52;
    if ( v52 )
    {
      *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v52 + 72));
      v42 = *(__int16 *)(v52 + 80) + *(__int16 *)(*(_DWORD *)(a1 + 156) + 28);
      if ( sub_42340((_WORD *)(a1 + 72), (_WORD *)(v52 + 72)) > v42 )
      {
        v10 = dword_AE400;
        v46 = 0;
      }
      else
      {
        *(_WORD *)(a1 + 146) = (v52 - (dword_AE400 + 29795)) / 164;
        sub_424F0(a1, 0x38u);
        v10 = dword_AE400;
      }
    }
    else
    {
      v13 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
      *(_DWORD *)(a1 + 4) = v13;
      v14 = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a1 + 4) = 9377 * v14 + 9439;
      *(_WORD *)(a1 + 34) += ((unsigned __int8)(-95 * v14 - 33) + 85) * (2 * (v13 % 0x9D / 79i64) - 1);
      *(_BYTE *)(a1 + 35) &= 7u;
    }
    dword_AE400 = v10;
    if ( !v46 )
    {
      if ( *(_BYTE *)(a1 + 58) )
      {
        v15 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 28);
        v44 = -1;
        v41 = 0;
        v48 = v15 * v15;
        for ( k = *(_DWORD *)(dword_AE408 + 36462); k > v10 + 29795; k = *(_DWORD *)k )
        {
          v17 = *(_WORD *)(k + 24);
          v18 = *(_WORD *)(a1 + 24);
          dword_AE400 = v10;
          if ( v17 != v18 )
          {
            v19 = (__int16)(*(_WORD *)(k + 72) - *(_WORD *)(a1 + 72));
            v20 = (__int16)(*(_WORD *)(k + 74) - *(_WORD *)(a1 + 74))
                * (__int16)(*(_WORD *)(k + 74) - *(_WORD *)(a1 + 74))
                + v19 * v19;
            if ( v20 <= v48 && (*(_BYTE *)(k + 16) & 0x20) == 0 )
            {
              v43 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 30);
              v21 = sub_42150((_WORD *)(a1 + 72), (_WORD *)(k + 72));
              if ( (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), v21) < v43 && v20 < v44 )
              {
                v41 = k;
                v44 = v20;
              }
            }
          }
          v10 = dword_AE400;
        }
        dword_AE400 = v10;
        v46 = v41;
        if ( v41 )
        {
          *(_WORD *)(a1 + 146) = (v41 - (v10 + 29795)) / 164;
          sub_424F0(a1, 0x38u);
        }
      }
      if ( !v46 )
      {
        v22 = *(_DWORD *)(a1 + 156);
        v23 = *(unsigned __int8 *)(a1 + 63) / *(__int16 *)(v22 + 26) % 3;
        if ( v23 )
        {
          if ( v23 <= 1 )
          {
            v47 = *(__int16 *)(v22 + 28) * *(__int16 *)(v22 + 28);
            v30 = -1;
            v50 = 0;
            for ( m = *(_DWORD *)(dword_AE408 + 36430); m > dword_AE400 + 29795; m = *(_DWORD *)m )
            {
              v32 = (__int16)(*(_WORD *)(m + 72) - *(_WORD *)(a1 + 72));
              v33 = v32 * v32
                  + (__int16)(*(_WORD *)(m + 74) - *(_WORD *)(a1 + 74))
                  * (__int16)(*(_WORD *)(m + 74) - *(_WORD *)(a1 + 74));
              if ( v33 <= v47 && v33 < v30 )
              {
                v50 = m;
                v30 = v32 * v32
                    + (__int16)(*(_WORD *)(m + 74) - *(_WORD *)(a1 + 74))
                    * (__int16)(*(_WORD *)(m + 74) - *(_WORD *)(a1 + 74));
              }
            }
            v29 = v50;
          }
          else
          {
            if ( v23 != 2 )
              goto LABEL_78;
            v40 = *(__int16 *)(v22 + 28) * *(__int16 *)(v22 + 28);
            v34 = -1;
            v51 = 0;
            for ( n = *(_DWORD *)(dword_AE408 + 36434); n > dword_AE400 + 29795; n = *(_DWORD *)n )
            {
              v36 = (__int16)(*(_WORD *)(n + 72) - *(_WORD *)(a1 + 72));
              v37 = (__int16)(*(_WORD *)(n + 74) - *(_WORD *)(a1 + 74));
              v38 = v36 * v36 + v37 * v37;
              if ( v38 <= v40 && v38 < v34 )
              {
                v51 = n;
                v34 = v38;
              }
            }
            v29 = v51;
          }
        }
        else
        {
          v49 = *(__int16 *)(v22 + 28) * *(__int16 *)(v22 + 28);
          v24 = -1;
          v45 = 0;
          for ( ii = *(_DWORD *)(dword_AE408 + 36398); ii > dword_AE400 + 29795; ii = *(_DWORD *)ii )
          {
            v26 = (__int16)(*(_WORD *)(ii + 72) - *(_WORD *)(a1 + 72));
            v27 = (__int16)(*(_WORD *)(ii + 74) - *(_WORD *)(a1 + 74));
            v28 = v26 * v26 + v27 * v27;
            if ( v28 <= v49 && v28 < v24 )
            {
              v45 = ii;
              v24 = v28;
            }
          }
          v29 = v45;
        }
        v46 = v29;
LABEL_78:
        if ( v46 )
        {
          if ( sub_42340((_WORD *)(a1 + 72), (_WORD *)(v46 + 72)) <= 0x600 )
          {
            *(_DWORD *)&word_AE454 = *(_DWORD *)(v46 + 72);
            *(&word_AE454 + 2) = *(_WORD *)(v46 + 76);
            sub_41E80(v46);
            v39 = sub_373F0((int)&word_AE454, 5, 9);
            if ( v39 )
            {
              if ( *(_BYTE *)(164 * *(__int16 *)(a1 + 24) + dword_AE400 + 29859) == 3 )
                *(_WORD *)(v39 + 24) = *(_WORD *)(a1 + 24);
            }
          }
        }
      }
    }
  }
LABEL_84:
  if ( *(_BYTE *)(a1 + 70) == 56 )
    sub_1DCD0(a1);
}
// 1D174: conditional instruction was optimized away because edi.4==2
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE454: using guessed type __int16 word_AE454;

//----- (0001D6D0) --------------------------------------------------------
void sub_1D6D0(int a1)
{
  int v1; // ebp
  unsigned int v2; // esi
  __int16 v3; // ax
  unsigned __int16 v4; // cx
  int v5; // eax
  int i; // edx
  int v7; // ecx
  __int16 v8; // si
  int v9; // esi
  unsigned int v10; // edx
  unsigned int v11; // ecx
  unsigned int m; // eax
  int v13; // esi
  unsigned int v14; // edx
  _WORD *v15; // eax
  unsigned int v16; // ecx
  unsigned int j; // eax
  int v18; // esi
  int v19; // edx
  unsigned int v20; // edx
  unsigned int v21; // ecx
  unsigned int k; // eax
  int v23; // esi
  unsigned int v24; // edx
  int v25; // edx
  int v26; // eax
  unsigned int v27; // [esp+0h] [ebp-2Ch]
  _WORD *v28; // [esp+4h] [ebp-28h]
  unsigned int v29; // [esp+8h] [ebp-24h]
  unsigned int v30; // [esp+Ch] [ebp-20h]
  unsigned int v31; // [esp+10h] [ebp-1Ch]
  unsigned int v32; // [esp+14h] [ebp-18h]
  unsigned int v33; // [esp+18h] [ebp-14h]

  v1 = dword_AE400;
  v2 = 0;
  v28 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v3 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v2 = 1;
      *(_WORD *)(a1 + 40) = v3;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v4 = *(_WORD *)(a1 + 54);
    if ( v4 )
    {
      v5 = 164 * v4 + v1 + 29795;
      for ( i = v1 + 29795; v5 != i; v5 = i + 164 * *(unsigned __int16 *)(v5 + 54) )
      {
        v7 = *(_DWORD *)(v5 + 12);
        if ( v7 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v7;
          v2 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(v5 + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v2 )
  {
    dword_AE400 = v1;
    if ( v2 <= 1 )
    {
      *(_WORD *)(a1 + 146) = *(_WORD *)(a1 + 40);
      sub_424F0(a1, 0x38u);
    }
    else
    {
      sub_424F0(a1, 0x3Au);
    }
    return;
  }
  dword_AE400 = v1;
  v8 = *(_WORD *)(a1 + 26);
  if ( v8 < 0 )
  {
    *(_WORD *)(a1 + 26) = v8 + 1;
    if ( v8 == -1 )
      sub_1DDB0(a1);
    return;
  }
  if ( *(_BYTE *)(a1 + 58) )
  {
    *(_WORD *)(a1 + 26) = -50;
    return;
  }
  v9 = *(_DWORD *)(a1 + 156);
  if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(v9 + 26)) )
  {
    v10 = *(unsigned __int8 *)(a1 + 63) / *(__int16 *)(v9 + 26) % 3;
    if ( v10 )
    {
      if ( v10 <= 1 )
      {
        v29 = *(__int16 *)(v9 + 28) * *(__int16 *)(v9 + 28);
        v16 = -1;
        v32 = 0;
        for ( j = *(_DWORD *)(dword_AE408 + 36430); j > v1 + 29795; j = *(_DWORD *)j )
        {
          v18 = (__int16)(*(_WORD *)(j + 72) - *(_WORD *)(a1 + 72));
          v19 = (__int16)(*(_WORD *)(j + 74) - *(_WORD *)(a1 + 74));
          v20 = v18 * v18 + v19 * v19;
          if ( v20 <= v29 && v20 < v16 )
          {
            v32 = j;
            v16 = v20;
          }
        }
        v15 = (_WORD *)v32;
      }
      else
      {
        if ( v10 != 2 )
          goto LABEL_50;
        v31 = *(__int16 *)(v9 + 28) * *(__int16 *)(v9 + 28);
        v21 = -1;
        v33 = 0;
        for ( k = *(_DWORD *)(dword_AE408 + 36434); k > v1 + 29795; k = *(_DWORD *)k )
        {
          v23 = (__int16)(*(_WORD *)(k + 72) - *(_WORD *)(a1 + 72));
          v24 = v23 * v23
              + (__int16)(*(_WORD *)(k + 74) - *(_WORD *)(a1 + 74))
              * (__int16)(*(_WORD *)(k + 74) - *(_WORD *)(a1 + 74));
          if ( v24 <= v31 && v24 < v21 )
          {
            v33 = k;
            v21 = v23 * v23
                + (__int16)(*(_WORD *)(k + 74) - *(_WORD *)(a1 + 74))
                * (__int16)(*(_WORD *)(k + 74) - *(_WORD *)(a1 + 74));
          }
        }
        v15 = (_WORD *)v33;
      }
    }
    else
    {
      v30 = *(__int16 *)(v9 + 28) * *(__int16 *)(v9 + 28);
      v11 = -1;
      v27 = 0;
      for ( m = *(_DWORD *)(dword_AE408 + 36398); m > v1 + 29795; m = *(_DWORD *)m )
      {
        v13 = (__int16)(*(_WORD *)(m + 72) - *(_WORD *)(a1 + 72));
        v14 = v13 * v13
            + (__int16)(*(_WORD *)(m + 74) - *(_WORD *)(a1 + 74)) * (__int16)(*(_WORD *)(m + 74) - *(_WORD *)(a1 + 74));
        if ( v14 <= v30 && v14 < v11 )
        {
          v27 = m;
          v11 = v13 * v13
              + (__int16)(*(_WORD *)(m + 74) - *(_WORD *)(a1 + 74))
              * (__int16)(*(_WORD *)(m + 74) - *(_WORD *)(a1 + 74));
        }
      }
      v15 = (_WORD *)v27;
    }
    v28 = v15;
LABEL_50:
    dword_AE400 = v1;
    if ( v28 )
    {
      v25 = (__int16)(v28[36] - *(_WORD *)(a1 + 72));
      if ( sub_410CE(
             (__int16)(v28[37] - *(_WORD *)(a1 + 74)) * (__int16)(v28[37] - *(_WORD *)(a1 + 74))
           + v25 * v25
           + (__int16)(v28[38] - *(_WORD *)(a1 + 76)) * (__int16)(v28[38] - *(_WORD *)(a1 + 76))) <= 0x600 )
      {
        *(_DWORD *)&word_AE454 = *((_DWORD *)v28 + 18);
        *(&word_AE454 + 2) = v28[38];
        sub_41E80((int)v28);
        v26 = sub_373F0((int)&word_AE454, 5, 9);
        if ( v26 )
          *(_WORD *)(v26 + 24) = *(_WORD *)(a1 + 24);
      }
    }
  }
}
// 1D7A5: conditional instruction was optimized away because esi.4==2
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE454: using guessed type __int16 word_AE454;

//----- (0001DA60) --------------------------------------------------------
void sub_1DA60(int a1)
{
  int v1; // esi
  unsigned int v2; // edi
  __int16 v3; // ax
  unsigned __int16 v4; // cx
  int v5; // eax
  int i; // edx
  int v7; // ecx
  char v8; // cl
  int v9; // edi
  int v10; // ebp
  unsigned int v11; // ebp

  v1 = dword_AE400;
  v2 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v3 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v2 = 1;
      *(_WORD *)(a1 + 40) = v3;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v4 = *(_WORD *)(a1 + 54);
    if ( v4 )
    {
      v5 = 164 * v4 + v1 + 29795;
      for ( i = v1 + 29795; v5 != i; v5 = i + 164 * *(unsigned __int16 *)(v5 + 54) )
      {
        v7 = *(_DWORD *)(v5 + 12);
        if ( v7 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v7;
          v2 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(v5 + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v2 )
  {
    if ( v2 <= 1 )
    {
      v8 = *(_BYTE *)(v1 + 164 * *(unsigned __int16 *)(a1 + 40) + 29859);
      dword_AE400 = v1;
      if ( v8 == 3 )
        *(_WORD *)(a1 + 146) = *(_WORD *)(a1 + 40);
    }
    else
    {
      dword_AE400 = v1;
      sub_424F0(a1, 0x3Au);
    }
    goto LABEL_31;
  }
  dword_AE400 = v1;
  sub_196E0(a1);
  v9 = 164 * *(unsigned __int16 *)(a1 + 146) + dword_AE400 + 29795;
  if ( *(int *)(v9 + 12) < 0 || (*(_BYTE *)(v9 + 17) & 4) != 0 )
  {
LABEL_29:
    sub_424F0(a1, 0x37u);
    goto LABEL_31;
  }
  if ( !(*(unsigned __int8 *)(a1 + 63) % 10) )
    *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v9 + 72));
  v10 = *(_DWORD *)(a1 + 156);
  if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(v10 + 26)) )
  {
    v11 = *(__int16 *)(v10 + 28);
    if ( *(_BYTE *)(v9 + 64) == 3 && *(_BYTE *)(v9 + 65) == 2 )
      v11 += *(__int16 *)(v9 + 80);
    if ( sub_42340((_WORD *)(a1 + 72), (_WORD *)(v9 + 72)) < v11 )
    {
      sub_1AA40(a1, v9);
      goto LABEL_31;
    }
    goto LABEL_29;
  }
LABEL_31:
  if ( *(_BYTE *)(a1 + 70) != 56 )
    sub_1DD50(a1);
}
// 1DB2C: conditional instruction was optimized away because edi.4==2
// AE400: using guessed type int dword_AE400;

//----- (0001DC80) --------------------------------------------------------
char sub_1DC80(int a1)
{
  char result; // al

  result = sub_1A390(a1, 0x36u);
  if ( *(_BYTE *)(a1 + 70) == 56 )
    return sub_1DCD0(a1);
  return result;
}

//----- (0001DCB0) --------------------------------------------------------
int sub_1DCB0(int a1)
{
  return sub_1A6C0(a1, 54);
}

//----- (0001DCC0) --------------------------------------------------------
void sub_1DCC0(int a1)
{
  sub_1A800(a1);
}

//----- (0001DCD0) --------------------------------------------------------
char sub_1DCD0(int a1)
{
  int v1; // esi
  char result; // al

  v1 = 164 * *(unsigned __int16 *)(a1 + 146) + dword_AE400 + 29795;
  if ( *(_WORD *)(a1 + 24) == *(_WORD *)(v1 + 24) )
    return sub_424F0(a1, 0x37u);
  *(_WORD *)(a1 + 126) = 0;
  sub_36FA0(a1, 202);
  *(_BYTE *)(a1 + 66) = *(_BYTE *)(v1 + 64);
  result = *(_BYTE *)(v1 + 65);
  *(_BYTE *)(a1 + 67) = result;
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (0001DD50) --------------------------------------------------------
int sub_1DD50(int a1)
{
  int result; // eax

  *(_WORD *)(a1 + 126) = *(_WORD *)(a1 + 128);
  result = sub_36FA0(a1, 201);
  *(_BYTE *)(a1 + 66) = 3;
  *(_BYTE *)(a1 + 67) = -1;
  *(_WORD *)(a1 + 26) = 50;
  *(_BYTE *)(a1 + 71) = 0;
  return result;
}

//----- (0001DD90) --------------------------------------------------------
int sub_1DD90(int a1)
{
  int result; // eax

  sub_36FA0(a1, 245);
  result = a1;
  *(_BYTE *)(a1 + 71) = 1;
  return result;
}

//----- (0001DDB0) --------------------------------------------------------
int sub_1DDB0(int a1)
{
  *(_BYTE *)(a1 + 71) = 0;
  *(_WORD *)(a1 + 26) = 400;
  return sub_36FA0(a1, 201);
}

//----- (0001DDD0) --------------------------------------------------------
void sub_1DDD0(int a1)
{
  sub_19B10(a1, 60);
}

//----- (0001DDE0) --------------------------------------------------------
void sub_1DDE0(int a1)
{
  sub_19D70(a1, 60);
}

//----- (0001DDF0) --------------------------------------------------------
int sub_1DDF0(int a1)
{
  return sub_1A120(a1, 60, (unsigned __int16 (*)(int, int))sub_1A990);
}

//----- (0001DE10) --------------------------------------------------------
char sub_1DE10(int a1)
{
  return sub_1A390(a1, 0x3Cu);
}

//----- (0001DE20) --------------------------------------------------------
int sub_1DE20(int a1)
{
  return sub_1A6C0(a1, 60);
}

//----- (0001DE30) --------------------------------------------------------
void sub_1DE30(int a1)
{
  sub_1A800(a1);
}

//----- (0001DE40) --------------------------------------------------------
__int16 sub_1DE40(int a1)
{
  __int16 v1; // dx
  __int16 result; // ax
  int v3; // ebx
  int v4; // eax
  char v5; // dl
  unsigned int v6; // eax
  int v7; // ebx
  unsigned int v8; // eax

  v1 = *(_WORD *)(a1 + 26);
  if ( v1 )
  {
    result = *(_WORD *)(a1 + 26);
    *(_WORD *)(a1 + 26) = v1 - 1;
    if ( v1 == 1 )
    {
      sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 21);
      if ( (*(_BYTE *)(a1 + 16) & 1) != 0 )
      {
        *(_WORD *)(a1 + 146) = 0;
        *(_WORD *)(a1 + 94) = 0;
        *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
        *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
        v6 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
        *(_DWORD *)(a1 + 4) = v6;
        v7 = *(_DWORD *)(a1 + 4);
        word_AE454 += ((v6 % 0x3C) << 8) + 12800;
        v8 = 9377 * v7 + 9439;
        *(_DWORD *)(a1 + 4) = v8;
        word_AE456 += ((v8 % 0x3C) << 8) + 12800;
        sub_41C70(word_AE456, a1, (int)&word_AE454);
        return sub_424F0(a1, 0x43u);
      }
      else
      {
        return sub_424F0(a1, 0x44u);
      }
    }
  }
  else
  {
    *(_WORD *)(a1 + 26) = 12;
    while ( 1 )
    {
      result = *(_WORD *)(a1 + 26);
      *(_WORD *)(a1 + 26) = result - 1;
      if ( !result )
        break;
      *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
      *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
      v3 = *(__int16 *)(a1 + 26);
      word_AE454 += 40 * (*(__int16 *)(a1 + 26) % 3);
      word_AE456 += 40 * (v3 / 3);
      v4 = sub_373F0((int)&word_AE454, 10, 1);
      if ( v4 )
      {
        *(_WORD *)(v4 + 24) = *(_WORD *)(a1 + 24);
        *(_BYTE *)(v4 + 18) |= 1u;
      }
    }
    v5 = *(_BYTE *)(a1 + 16);
    *(_WORD *)(a1 + 26) = 1;
    *(_BYTE *)(a1 + 16) = v5 ^ 1;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;

//----- (0001DFE0) --------------------------------------------------------
void sub_1DFE0(int a1)
{
  unsigned int v1; // edi
  __int16 v2; // ax
  unsigned __int16 v3; // bx
  int i; // eax
  int v5; // edx
  int v6; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  unsigned int v10; // ebp
  unsigned int j; // ebx
  int v12; // edi
  unsigned int v13; // edi
  __int16 v14; // ax
  unsigned int v15; // eax
  int v16; // edx
  unsigned int v17; // edi
  int v18; // edx
  unsigned int k; // eax
  int v20; // ebx
  unsigned int v21; // [esp+0h] [ebp-20h]
  int v22; // [esp+4h] [ebp-1Ch]
  unsigned int v23; // [esp+Ch] [ebp-14h]

  v1 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v2 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v1 = 1;
      *(_WORD *)(a1 + 40) = v2;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v3 = *(_WORD *)(a1 + 54);
    if ( v3 )
    {
      for ( i = 164 * v3 + dword_AE400 + 29795;
            i != dword_AE400 + 29795;
            i = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(i + 54) )
      {
        v5 = *(_DWORD *)(i + 12);
        if ( v5 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v5;
          v1 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(i + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v1 )
  {
    if ( v1 > 1 )
    {
      sub_424F0(a1, 0x46u);
      return;
    }
    if ( *(_BYTE *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 40) + 29859) == 3 )
    {
      LOWORD(v6) = *(_WORD *)(a1 + 40);
LABEL_53:
      *(_WORD *)(a1 + 146) = v6;
      sub_1E770((_WORD *)a1);
    }
  }
  else
  {
    sub_196E0(a1);
    if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26)) )
    {
      v7 = (*(int *)(a1 + 8) >> 6) + *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 12) = v7;
      if ( v7 < -1 )
        *(_DWORD *)(a1 + 12) = -1;
      v8 = *(_DWORD *)(a1 + 8);
      if ( *(_DWORD *)(a1 + 12) > v8 )
        *(_DWORD *)(a1 + 12) = v8;
      if ( *(_BYTE *)(a1 + 58) && *(int *)(a1 + 8) >> 2 < *(_DWORD *)(a1 + 12) )
      {
        v9 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 28);
        v10 = -1;
        v23 = v9 * v9;
        v21 = 0;
        for ( j = *(_DWORD *)(dword_AE408 + 36462); j > dword_AE400 + 29795; j = *(_DWORD *)j )
        {
          if ( *(_BYTE *)(j + 65) <= 1u )
          {
            v12 = (__int16)(*(_WORD *)(j + 72) - *(_WORD *)(a1 + 72));
            v13 = (__int16)(*(_WORD *)(j + 74) - *(_WORD *)(a1 + 74))
                * (__int16)(*(_WORD *)(j + 74) - *(_WORD *)(a1 + 74))
                + v12 * v12;
            if ( v13 <= v23 && (*(_BYTE *)(j + 16) & 0x20) == 0 )
            {
              v22 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 30);
              v14 = sub_42150((_WORD *)(a1 + 72), (_WORD *)(j + 72));
              if ( (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), v14) < v22 && v13 < v10 )
              {
                v21 = j;
                v10 = v13;
              }
            }
          }
        }
        if ( v21 )
        {
          *(_WORD *)(a1 + 146) = (int)(v21 - (dword_AE400 + 29795)) / 164;
          sub_1E770((_WORD *)a1);
        }
        else
        {
          sub_1E810(a1);
        }
      }
      if ( !(4 * (*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26))) )
      {
        v15 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
        *(_DWORD *)(a1 + 4) = v15;
        v16 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
        *(_DWORD *)(a1 + 4) = v16;
        *(_WORD *)(a1 + 34) += (2 * ((int)(v15 % 0x9D) / 79) - 1) * ((unsigned __int8)v16 + 85);
        *(_BYTE *)(a1 + 35) &= 7u;
        if ( *(_DWORD *)(a1 + 8) - (*(int *)(a1 + 8) >> 2) < *(_DWORD *)(a1 + 12) )
        {
          v17 = 0;
          v18 = 0;
          for ( k = *(_DWORD *)(dword_AE408 + 36462); k > dword_AE400 + 29795; k = *(_DWORD *)k )
          {
            if ( *(_BYTE *)(k + 65) <= 1u )
            {
              v20 = *(_DWORD *)(k + 140) && (*(_BYTE *)(k + 16) & 0x20) == 0;
              if ( v20 )
              {
                if ( v20 > v18 )
                {
                  v17 = k;
                  v18 = v20;
                }
              }
            }
          }
          if ( v17 )
          {
            v6 = (int)(v17 - (dword_AE400 + 29795)) / 164;
            goto LABEL_53;
          }
        }
      }
    }
  }
}
// 1E0B2: conditional instruction was optimized away because edi.4==2
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (0001E380) --------------------------------------------------------
void sub_1E380(int a1)
{
  int v1; // ebp
  unsigned int v2; // esi
  __int16 v3; // ax
  unsigned __int16 v4; // di
  int v5; // eax
  int i; // edx
  int v7; // ecx
  char v8; // cl
  int v9; // edi
  int v10; // ecx
  unsigned int v11; // esi
  int v12; // ebp
  char v13; // dl
  int v14; // eax
  int v15; // esi
  __int16 v16; // ax
  __int16 v17; // dx
  _WORD *v18; // edi
  __int16 v19; // ax
  int v20; // ebx

  v1 = dword_AE400;
  v2 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v3 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v2 = 1;
      *(_WORD *)(a1 + 40) = v3;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v4 = *(_WORD *)(a1 + 54);
    if ( v4 )
    {
      v5 = 164 * v4 + v1 + 29795;
      for ( i = v1 + 29795; v5 != i; v5 = i + 164 * *(unsigned __int16 *)(v5 + 54) )
      {
        v7 = *(_DWORD *)(v5 + 12);
        if ( v7 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v7;
          v2 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(v5 + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v2 )
  {
    if ( v2 <= 1 )
    {
      v8 = *(_BYTE *)(v1 + 164 * *(unsigned __int16 *)(a1 + 40) + 29859);
      dword_AE400 = v1;
      if ( v8 == 3 )
        *(_WORD *)(a1 + 146) = *(_WORD *)(a1 + 40);
    }
    else
    {
      dword_AE400 = v1;
      sub_424F0(a1, 0x46u);
    }
    return;
  }
  dword_AE400 = v1;
  sub_196E0(a1);
  v9 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 146);
  if ( *(int *)(a1 + 8) >> 1 <= *(_DWORD *)(a1 + 12) )
  {
    if ( *(int *)(v9 + 12) >= 0 && (*(_BYTE *)(v9 + 17) & 4) == 0 && *(_BYTE *)(v9 + 64) )
    {
      if ( (*(_BYTE *)(a1 + 63) & 7) == 0 )
        *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v9 + 72));
    }
    else
    {
      sub_1E810(a1);
      sub_1E720(a1);
    }
  }
  else
  {
    sub_1E720(a1);
  }
  v10 = *(_DWORD *)(a1 + 156);
  if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(v10 + 26)) )
  {
    v11 = *(__int16 *)(v10 + 28);
    if ( sub_42340((_WORD *)(a1 + 72), (_WORD *)(v9 + 72)) >= v11 )
    {
      sub_1E720(a1);
      return;
    }
    v12 = dword_AE400;
    if ( !(*(unsigned __int8 *)(a1 + 63) % (8 * *(__int16 *)(*(_DWORD *)(a1 + 156) + 26))) )
    {
      sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 11);
      v12 = dword_AE400;
    }
    ++*(_WORD *)(a1 + 26);
    v13 = *(_BYTE *)(v9 + 65);
    dword_AE400 = v12;
    if ( v13 || (*(_BYTE *)(a1 + 26) & 1) == 0 )
    {
      v14 = sub_373F0(a1 + 72, 9, 8);
      v15 = v14;
      if ( !v14 )
        goto LABEL_38;
    }
    else
    {
      v14 = sub_373F0(a1 + 72, 9, 8);
      v15 = v14;
      if ( !v14 )
        goto LABEL_38;
    }
    *(_BYTE *)(v14 + 69) = 25;
LABEL_38:
    if ( v15 )
    {
      *(_BYTE *)(v15 + 68) = 10;
      *(_WORD *)(v15 + 24) = *(_WORD *)(a1 + 24);
      v16 = *(_WORD *)(a1 + 84);
      *(_WORD *)(v15 + 44) = 3000;
      v17 = *(_WORD *)(v15 + 76);
      *(_WORD *)(v15 + 26) = 20;
      *(_WORD *)(v15 + 76) = v16 + v17;
      v18 = (_WORD *)(v9 + 72);
      *(_WORD *)(v15 + 146) = *(_WORD *)(a1 + 146);
      *(_WORD *)(v15 + 30) = sub_42150((_WORD *)(a1 + 72), v18);
      v19 = sub_42180((_WORD *)(a1 + 72), v18);
      v20 = a1 - (dword_AE400 + 29795);
      *(_WORD *)(v15 + 32) = v19;
      sub_55370(v20 / 164, -1, 9);
    }
  }
}
// 1E459: conditional instruction was optimized away because esi.4==2
// AE400: using guessed type int dword_AE400;

//----- (0001E6F0) --------------------------------------------------------
char sub_1E6F0(int a1)
{
  return sub_1A390(a1, 0x42u);
}

//----- (0001E700) --------------------------------------------------------
int sub_1E700(int a1)
{
  return sub_1A6C0(a1, 66);
}

//----- (0001E710) --------------------------------------------------------
void sub_1E710(int a1)
{
  sub_1A800(a1);
}

//----- (0001E720) --------------------------------------------------------
void sub_1E720(int a1)
{
  *(_WORD *)(a1 + 146) = 0;
  *(_WORD *)(a1 + 26) = 0;
  sub_424F0(a1, 0x42u);
  sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 11);
}
// AE400: using guessed type int dword_AE400;

//----- (0001E770) --------------------------------------------------------
void sub_1E770(_WORD *a1)
{
  int v1; // eax
  __int16 v2; // ax

  if ( a1[73] )
  {
    a1[13] = 0;
    sub_424F0((int)a1, 0x42u);
    v1 = 164 * (unsigned __int16)a1[73] + dword_AE400 + 29795;
    *(_DWORD *)&word_AE454 = *(_DWORD *)(v1 + 72);
    *(&word_AE454 + 2) = *(_WORD *)(v1 + 76);
    v2 = (unsigned __int16)sub_41EC0((uint16*)&word_AE454, *(_WORD *)(v1 + 30), 0, a1[63] << 6);
    sub_41C70(v2, (int)a1, (int)&word_AE454);
  }
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;

//----- (0001E810) --------------------------------------------------------
void sub_1E810(int a1)
{
  int v1; // eax
  unsigned int v2; // esi
  int v3; // ebp
  unsigned int i; // eax
  int v5; // ecx
  int v6; // edx
  unsigned int v7; // edx
  int v8; // eax
  unsigned int v9; // [esp+0h] [ebp-14h]

  if ( *(_DWORD *)(a1 + 140) < *(_DWORD *)(a1 + 136) )
  {
    v1 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 28);
    v9 = v1 * v1;
    v2 = -1;
    v3 = 0;
    for ( i = *(_DWORD *)(dword_AE408 + 36466); i > dword_AE400 + 29795; i = *(_DWORD *)i )
    {
      if ( *(_BYTE *)(i + 65) == 39 )
      {
        v5 = (__int16)(*(_WORD *)(i + 72) - *(_WORD *)(a1 + 72));
        v6 = (__int16)(*(_WORD *)(i + 74) - *(_WORD *)(a1 + 74));
        v7 = v5 * v5 + v6 * v6;
        if ( v7 <= v9 && v7 < v2 )
        {
          v3 = i;
          v2 = v7;
        }
      }
    }
    if ( v3 )
    {
      *(_DWORD *)(a1 + 140) += *(_DWORD *)(v3 + 140);
      *(_WORD *)(v3 + 144) = 0;
      *(_DWORD *)&word_AE454 = *(_DWORD *)(v3 + 72);
      *(&word_AE454 + 2) = *(_WORD *)(v3 + 76);
      sub_41E80(v3);
      v8 = sub_373F0((int)&word_AE454, 10, 0);
      if ( v8 )
      {
        *(_WORD *)(v8 + 24) = *(_WORD *)(a1 + 24);
        *(_BYTE *)(v8 + 18) |= 1u;
      }
      sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 11);
    }
  }
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE454: using guessed type __int16 word_AE454;

//----- (0001E920) --------------------------------------------------------
_BOOL1 sub_1E920(_WORD *a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4)
{
  unsigned __int8 v4; // bl
  unsigned __int8 v5; // bh

  v4 = HIBYTE(*a1) - ((int)a2 >> 1);
  v5 = HIBYTE(a1[1]) - ((int)a3 >> 1);
  if ( (v4 + v5) % 2 )
    ++v4;
  return (__int16)sub_35EA0(v4, v5, a3, a2) < (int)a4;
}

//----- (0001E9B0) --------------------------------------------------------
_WORD *sub_1E9B0(unsigned __int16 a1, _WORD *a2, _WORD *a3)
{
  unsigned __int16 v3; // cx
  unsigned __int16 v4; // bx
  _WORD *result; // eax

  v3 = *(unsigned __int8 *)(dword_AE440 + 6 * a1 + 5);
  v4 = *(unsigned __int8 *)(dword_AE440 + 6 * a1 + 4);
  if ( word_12F02E == 1 )
  {
    v3 >>= 1;
    v4 >>= 1;
  }
  *a3 = (v3 << 8) / 2 + 768;
  result = a2;
  *a2 = (v4 << 8) / 2 + 768;
  return result;
}
// AE440: using guessed type int dword_AE440;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0001EA40) --------------------------------------------------------
char sub_1EA40(int a1)
{
  int v1; // ebx
  __int16 v2; // ax
  int v3; // eax
  unsigned int v4; // eax
  int v5; // edx
  unsigned int v6; // eax
  __int16 v7; // ax
  unsigned int v8; // eax
  int v9; // esi
  unsigned int v10; // eax
  int v11; // edx
  unsigned int v12; // eax
  unsigned int v13; // eax
  int v14; // esi
  __int16 v15; // di
  __int16 v16; // si
  int v17; // eax
  char v18; // cl
  unsigned int v19; // ebx
  unsigned int v20; // ebx
  int v21; // ebx
  char v22; // al
  unsigned __int16 v24; // [esp+4h] [ebp-20h] BYREF
  unsigned __int16 v25; // [esp+8h] [ebp-1Ch] BYREF
  __int16 v26; // [esp+Ch] [ebp-18h]
  unsigned __int8 v27; // [esp+10h] [ebp-14h]

  v26 = 72;
  v1 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 146);
  if ( !*(_BYTE *)(v1 + 64) || *(_BYTE *)(v1 + 65) != 45 )
  {
    *(_WORD *)(a1 + 26) = 5;
LABEL_33:
    v22 = v26;
    *(_WORD *)(a1 + 146) = 0;
    LOBYTE(v17) = sub_424F0(a1, v22 + 1);
    return v17;
  }
  *(_DWORD *)&word_AE454 = *(_DWORD *)(v1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(v1 + 76);
  v2 = *(_WORD *)(a1 + 26);
  *(_WORD *)(a1 + 26) = v2 + 1;
  if ( v2 >= 4 )
  {
    *(_WORD *)(a1 + 26) = 1;
    goto LABEL_33;
  }
  v3 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
  *(_DWORD *)(a1 + 4) = v3;
  v27 = (v3 & 7) + 25;
  sub_1E9B0(v27, &v24, &v25);
  switch ( *(_WORD *)(a1 + 26) )
  {
    case 1:
      v4 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
      *(_DWORD *)(a1 + 4) = v4;
      v5 = *(_DWORD *)(a1 + 4);
      word_AE454 += *(_WORD *)(v1 + 80) + v24 + ((v4 % 3) << 8) + 256;
      v6 = 9377 * v5 + 9439;
      *(_DWORD *)(a1 + 4) = v6;
      v7 = ((v6 % 3) << 8) - 1280 + word_AE456;
      goto LABEL_10;
    case 2:
      v8 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
      *(_DWORD *)(a1 + 4) = v8;
      v9 = *(_DWORD *)(a1 + 4);
      word_AE454 -= *(_WORD *)(v1 + 80) + v24 + ((v8 % 3) << 8) + 256;
      *(_DWORD *)(a1 + 4) = 9377 * v9 + 9439;
      v7 = (((9377 * v9 + 9439) % 3u) << 8) - 1280 + word_AE456;
      goto LABEL_10;
    case 3:
      v10 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
      *(_DWORD *)(a1 + 4) = v10;
      v11 = *(_DWORD *)(a1 + 4);
      word_AE454 += ((v10 % 3) << 8) - 1280;
      v12 = 9377 * v11 + 9439;
      *(_DWORD *)(a1 + 4) = v12;
      v7 = *(_WORD *)(v1 + 82) + v25 + ((v12 % 3) << 8) + 256 + word_AE456;
      goto LABEL_10;
    case 4:
      v13 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
      *(_DWORD *)(a1 + 4) = v13;
      v14 = *(_DWORD *)(a1 + 4);
      word_AE454 += ((v13 % 3) << 8) - 1280;
      *(_DWORD *)(a1 + 4) = 9377 * v14 + 9439;
      v7 = word_AE456 - (v25 + *(_WORD *)(v1 + 82) + (((9377 * v14 + 9439) % 3u) << 8) + 256);
LABEL_10:
      word_AE456 = v7;
      break;
    default:
      break;
  }
  v15 = word_AE454;
  v16 = word_AE456;
  if ( sub_11810(&word_AE454) == 1 )
  {
    *(_WORD *)(a1 + 26) = 2;
    goto LABEL_33;
  }
  LOBYTE(v17) = sub_1E920((uint16*)&word_AE454, (int)v24 >> 8, (int)v25 >> 8, (((int)v25 >> 7) + ((int)v24 >> 7) > 4) + 15);
  if ( (_BYTE)v17 )
  {
    v18 = 0;
    v19 = *(_DWORD *)(dword_AE408 + 36470);
    do
    {
      LOBYTE(v17) = dword_AE400 + 99;
      if ( v19 <= dword_AE400 + 29795 )
        break;
      v17 = abs16(*(_WORD *)(v19 + 72) - v15);
      if ( v17 <= *(__int16 *)(v19 + 80) + v24 )
      {
        v17 = abs16(*(_WORD *)(v19 + 74) - v16);
        if ( v17 <= v25 + *(__int16 *)(v19 + 82) )
          v18 = 1;
      }
      v19 = *(_DWORD *)v19;
    }
    while ( !v18 );
    if ( !v18 )
    {
      v20 = *(_DWORD *)(dword_AE408 + 36462);
      do
      {
        LOBYTE(v17) = dword_AE400 + 99;
        if ( v20 <= dword_AE400 + 29795 )
          break;
        if ( *(_BYTE *)(v20 + 65) == 2 )
        {
          v17 = abs16(*(_WORD *)(v20 + 72) - v15);
          if ( v17 <= *(__int16 *)(v20 + 80) + v24 )
          {
            v17 = abs16(*(_WORD *)(v20 + 74) - v16);
            if ( v17 <= *(__int16 *)(v20 + 82) + v25 )
              v18 = 1;
          }
        }
        v20 = *(_DWORD *)v20;
      }
      while ( !v18 );
    }
    if ( !v18 )
    {
      v21 = sub_373F0((int)&word_AE454, 10, 45);
      if ( v21 )
      {
        sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 10);
        sub_36DF0(v21, v27);
        *(_BYTE *)(v21 + 70) = 51;
      }
      *(_WORD *)(a1 + 146) = 0;
      LOBYTE(v17) = sub_424F0(a1, 0x4Fu);
    }
  }
  return v17;
}
// 1EDB9: conditional instruction was optimized away because cl.1==0
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;

//----- (0001EED0) --------------------------------------------------------
void sub_1EED0(int a1)
{
  int v1; // esi
  unsigned int v2; // edi
  __int16 v3; // ax
  unsigned __int16 v4; // ax
  int v5; // eax
  int i; // edx
  int v7; // ecx
  unsigned __int8 v8; // al
  int v9; // edx
  unsigned int v10; // eax
  __int16 v11; // dx
  int v12; // eax

  v1 = dword_AE400;
  v2 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v3 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v2 = 1;
      *(_WORD *)(a1 + 40) = v3;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v4 = *(_WORD *)(a1 + 54);
    if ( v4 )
    {
      v5 = 164 * v4 + v1 + 29795;
      for ( i = v1 + 29795; v5 != i; v5 = i + 164 * *(unsigned __int16 *)(v5 + 54) )
      {
        v7 = *(_DWORD *)(v5 + 12);
        if ( v7 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v7;
          v2 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(v5 + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v2 )
  {
    if ( v2 > 1 )
    {
      dword_AE400 = v1;
      v8 = 76;
LABEL_23:
      sub_424F0(a1, v8);
      return;
    }
    v9 = 164 * *(unsigned __int16 *)(a1 + 40);
    dword_AE400 = v1;
    if ( v9 + v1 + 29795 )
    {
      if ( *(_BYTE *)(v1 + v9 + 29860) <= 1u )
        *(_WORD *)(*(_DWORD *)(164 * *(unsigned __int16 *)(a1 + 40) + dword_AE400 + 29955) + 528) = 200;
    }
  }
  else
  {
    dword_AE400 = v1;
    sub_196E0(a1);
    if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26)) )
    {
      v10 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
      *(_DWORD *)(a1 + 4) = v10;
      v11 = 2 * (v10 % 0x9D / 79i64);
      v12 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
      *(_DWORD *)(a1 + 4) = v12;
      *(_WORD *)(a1 + 34) += ((unsigned __int8)v12 + 85) * (v11 - 1);
      LOWORD(v12) = *(_WORD *)(a1 + 26);
      *(_BYTE *)(a1 + 35) &= 7u;
      *(_WORD *)(a1 + 26) = v12 - 1;
      if ( !(_WORD)v12 )
      {
        *(_WORD *)(a1 + 26) = 1;
        v8 = 75;
        goto LABEL_23;
      }
    }
  }
}
// 1EFA7: conditional instruction was optimized away because edi.4==2
// AE400: using guessed type int dword_AE400;

//----- (0001F120) --------------------------------------------------------
void sub_1F120(int a1)
{
  int v1; // esi
  unsigned int v2; // edi
  __int16 v3; // ax
  unsigned __int16 v4; // ax
  int v5; // eax
  int i; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // edi
  __int16 v10; // ax
  _WORD *v11; // edi

  v1 = dword_AE400;
  v2 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v3 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v2 = 1;
      *(_WORD *)(a1 + 40) = v3;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v4 = *(_WORD *)(a1 + 54);
    if ( v4 )
    {
      v5 = 164 * v4 + v1 + 29795;
      for ( i = v1 + 29795; v5 != i; v5 = i + 164 * *(unsigned __int16 *)(v5 + 54) )
      {
        v7 = *(_DWORD *)(v5 + 12);
        if ( v7 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v7;
          v2 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(v5 + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v2 )
  {
    if ( v2 <= 1 )
    {
      v8 = 164 * *(unsigned __int16 *)(a1 + 40);
      dword_AE400 = v1;
      if ( v8 + v1 + 29795 )
      {
        if ( *(_BYTE *)(v1 + v8 + 29860) <= 1u )
          *(_WORD *)(*(_DWORD *)(164 * *(unsigned __int16 *)(a1 + 40) + dword_AE400 + 29955) + 528) = 200;
      }
    }
    else
    {
      dword_AE400 = v1;
      sub_424F0(a1, 0x4Cu);
    }
  }
  else
  {
    dword_AE400 = v1;
    sub_196E0(a1);
    if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26) / 2) )
    {
      v9 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 146);
      v10 = *(_WORD *)(a1 + 26);
      *(_WORD *)(a1 + 26) = v10 - 1;
      if ( !v10 || !*(_BYTE *)(v9 + 64) )
      {
        *(_WORD *)(a1 + 26) = 5;
        sub_424F0(a1, 0x49u);
      }
      v11 = (_WORD *)(v9 + 72);
      *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), v11);
      if ( sub_42340((_WORD *)(a1 + 72), v11) < 0xA00 )
      {
        *(_WORD *)(a1 + 26) = 0;
        sub_424F0(a1, 0x48u);
      }
    }
  }
}
// 1F1F8: conditional instruction was optimized away because edi.4==2
// AE400: using guessed type int dword_AE400;

//----- (0001F390) --------------------------------------------------------
void sub_1F390(int a1)
{
  unsigned int v1; // edi
  unsigned int v2; // ebp
  __int16 v3; // ax
  unsigned __int16 v4; // cx
  int i; // eax
  int v6; // edx
  unsigned __int8 v7; // al
  int v8; // edx
  unsigned int j; // ebx
  unsigned int v10; // eax

  v1 = -1;
  v2 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v3 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v2 = 1;
      *(_WORD *)(a1 + 40) = v3;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v4 = *(_WORD *)(a1 + 54);
    if ( v4 )
    {
      for ( i = dword_AE400 + 29795 + 164 * v4;
            i != dword_AE400 + 29795;
            i = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(i + 54) )
      {
        v6 = *(_DWORD *)(i + 12);
        if ( v6 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v6;
          v2 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(i + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( !v2 )
  {
    for ( j = *(_DWORD *)(dword_AE408 + 36470); j > dword_AE400 + 29795; j = *(_DWORD *)j )
    {
      v10 = sub_42340((_WORD *)(a1 + 72), (_WORD *)(j + 72));
      if ( v10 && v10 < v1 )
      {
        v2 = j;
        v1 = v10;
      }
    }
    if ( v2 )
    {
      *(_WORD *)(a1 + 146) = (int)(v2 - (dword_AE400 + 29795)) / 164;
      *(_WORD *)(a1 + 26) = 10;
      v7 = 74;
    }
    else
    {
      *(_WORD *)(a1 + 26) = 5;
      v7 = 73;
    }
    goto LABEL_28;
  }
  if ( v2 > 1 )
  {
    v7 = 76;
LABEL_28:
    sub_424F0(a1, v7);
    return;
  }
  v8 = 164 * *(unsigned __int16 *)(a1 + 40);
  if ( v8 + dword_AE400 + 29795 )
  {
    if ( *(_BYTE *)(v8 + dword_AE400 + 29860) <= 1u )
      *(_WORD *)(*(_DWORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 40) + 29955) + 528) = 200;
  }
}
// 1F46E: conditional instruction was optimized away because ebp.4==2
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (0001F5A0) --------------------------------------------------------
int sub_1F5A0(int a1)
{
  return sub_1A6C0(a1, 72);
}

//----- (0001F5B0) --------------------------------------------------------
void sub_1F5B0(int a1)
{
  int v1; // eax

  v1 = 164 * *(unsigned __int16 *)(a1 + 38);
  if ( v1 + dword_AE400 + 29795 && *(_BYTE *)(dword_AE400 + v1 + 29860) <= 1u )
    *(_WORD *)(*(_DWORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 38) + 29955) + 528) = 200;
  sub_1A800(a1);
}
// AE400: using guessed type int dword_AE400;

//----- (0001F640) --------------------------------------------------------
char sub_1F640(int a1)
{
  int v1; // edi
  unsigned int v2; // esi
  __int16 v3; // ax
  unsigned __int16 v4; // ax
  int v5; // eax
  int i; // edx
  int v7; // ecx
  unsigned int j; // eax
  int v9; // edx
  int v10; // edi
  int v11; // edx
  unsigned int v12; // ecx
  int v13; // esi
  int v14; // edx
  unsigned int v15; // edx
  int v16; // esi
  unsigned int v18; // [esp+4h] [ebp-1Ch]

  v1 = dword_AE400;
  v2 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v3 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v2 = 1;
      *(_WORD *)(a1 + 40) = v3;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v4 = *(_WORD *)(a1 + 54);
    if ( v4 )
    {
      v5 = 164 * v4 + v1 + 29795;
      for ( i = v1 + 29795; v5 != i; v5 = i + 164 * *(unsigned __int16 *)(v5 + 54) )
      {
        v7 = *(_DWORD *)(v5 + 12);
        if ( v7 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v7;
          v2 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(v5 + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v2 )
  {
    if ( v2 <= 1 )
    {
      LOBYTE(j) = v1;
      v9 = 164 * *(unsigned __int16 *)(a1 + 40);
      dword_AE400 = v1;
      if ( v9 + v1 + 29795 )
      {
        LOBYTE(j) = v1 + v9;
        if ( *(_BYTE *)(v1 + v9 + 29860) <= 1u )
        {
          j = *(_DWORD *)(164 * *(unsigned __int16 *)(a1 + 40) + dword_AE400 + 29955);
          *(_WORD *)(j + 528) = 200;
        }
      }
    }
    else
    {
      dword_AE400 = v1;
      LOBYTE(j) = sub_424F0(a1, 0x52u);
    }
  }
  else
  {
    dword_AE400 = v1;
    sub_196E0(a1);
    LOWORD(j) = *(unsigned __int8 *)(a1 + 63) / *(__int16 *)(*(_DWORD *)(a1 + 156) + 26);
    if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26)) )
    {
      v10 = dword_AE400;
      if ( *(_WORD *)(a1 + 146) )
      {
        v16 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 146);
        if ( *(_BYTE *)(v16 + 64) != 10 || *(_BYTE *)(v16 + 65) != 45 )
          goto LABEL_36;
        if ( sub_42340((_WORD *)(a1 + 72), (_WORD *)(v16 + 72)) > 0x800 )
        {
          LOWORD(j) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v16 + 72));
          *(_WORD *)(a1 + 34) = j;
          return j;
        }
        if ( *(_WORD *)(v16 + 128) <= *(_WORD *)(v16 + 26) )
        {
LABEL_36:
          *(_WORD *)(a1 + 146) = 0;
          LOWORD(j) = *(_WORD *)(a1 + 130);
          *(_WORD *)(a1 + 126) = j;
          return j;
        }
        sub_424F0(a1, 0x52u);
        *(_WORD *)(a1 + 26) = 1;
        LOWORD(j) = *(_WORD *)(v16 + 26) + 1;
        *(_WORD *)(v16 + 26) = j;
      }
      else
      {
        j = 9377 * *(_DWORD *)(a1 + 4) + 9439;
        *(_DWORD *)(a1 + 4) = j;
        v11 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
        *(_DWORD *)(a1 + 4) = v11;
        *(_WORD *)(a1 + 34) += (2 * (j % 0x9D / 79i64) - 1) * ((unsigned __int8)v11 + 85);
        *(_BYTE *)(a1 + 35) &= 7u;
        LOWORD(j) = *(unsigned __int8 *)(a1 + 63) / *(__int16 *)(*(_DWORD *)(a1 + 156) + 26);
        if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26)) )
        {
          v12 = -1;
          v18 = 0;
          for ( j = *(_DWORD *)(dword_AE408 + 36470); j > v10 + 29795; j = *(_DWORD *)j )
          {
            v13 = (__int16)(*(_WORD *)(j + 72) - *(_WORD *)(a1 + 72));
            v14 = (__int16)(*(_WORD *)(j + 74) - *(_WORD *)(a1 + 74));
            v15 = v13 * v13 + v14 * v14;
            if ( v15 < v12 )
            {
              v18 = j;
              v12 = v15;
            }
          }
          dword_AE400 = v10;
          if ( v18 )
          {
            *(_WORD *)(a1 + 146) = (int)(v18 - (v10 + 29795)) / 164;
            LOWORD(j) = *(_WORD *)(a1 + 128);
            *(_WORD *)(a1 + 126) = j;
          }
        }
      }
    }
  }
  return j;
}
// 1F723: conditional instruction was optimized away because esi.4==2
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (0001FA00) --------------------------------------------------------
int sub_1FA00(int a1)
{
  int v2; // eax

  if ( *(_WORD *)(a1 + 26) )
    return sub_41E80(a1);
  v2 = 164 * *(unsigned __int16 *)(a1 + 38);
  if ( v2 + dword_AE400 + 29795 )
  {
    if ( *(_BYTE *)(dword_AE400 + v2 + 29860) <= 1u )
      *(_WORD *)(*(_DWORD *)(164 * *(unsigned __int16 *)(a1 + 38) + dword_AE400 + 29955) + 528) = 200;
  }
  return sub_1A6C0(a1, 78);
}
// AE400: using guessed type int dword_AE400;

//----- (0001FAA0) --------------------------------------------------------
void sub_1FAA0(int a1)
{
  sub_1A800(a1);
}

//----- (0001FAC0) --------------------------------------------------------
char sub_1FAC0(int a1)
{
  int v1; // edi
  unsigned int v2; // esi
  __int16 v3; // ax
  unsigned __int16 v4; // ax
  int v5; // eax
  int i; // edx
  int v7; // ecx
  unsigned int j; // eax
  int v9; // edx
  int v10; // edi
  int v11; // ebp
  unsigned int v12; // ecx
  int v13; // esi
  int v14; // edx
  unsigned int v15; // edx
  int v16; // esi
  unsigned int v18; // [esp+4h] [ebp-1Ch]

  v1 = dword_AE400;
  v2 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v3 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v2 = 1;
      *(_WORD *)(a1 + 40) = v3;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v4 = *(_WORD *)(a1 + 54);
    if ( v4 )
    {
      v5 = 164 * v4 + v1 + 29795;
      for ( i = v1 + 29795; v5 != i; v5 = i + 164 * *(unsigned __int16 *)(v5 + 54) )
      {
        v7 = *(_DWORD *)(v5 + 12);
        if ( v7 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v7;
          v2 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(v5 + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v2 )
  {
    if ( v2 <= 1 )
    {
      LOBYTE(j) = v1;
      v9 = 164 * *(unsigned __int16 *)(a1 + 40);
      dword_AE400 = v1;
      if ( v9 + v1 + 29795 )
      {
        LOBYTE(j) = v1 + v9;
        if ( *(_BYTE *)(v1 + v9 + 29860) <= 1u )
        {
          j = *(_DWORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 40) + 29955);
          *(_WORD *)(j + 528) = 200;
        }
      }
    }
    else
    {
      dword_AE400 = v1;
      LOBYTE(j) = sub_424F0(a1, 0x58u);
    }
  }
  else
  {
    dword_AE400 = v1;
    sub_196E0(a1);
    LOWORD(j) = *(unsigned __int8 *)(a1 + 63) / *(__int16 *)(*(_DWORD *)(a1 + 156) + 26);
    if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26)) )
    {
      v10 = dword_AE400;
      if ( *(_WORD *)(a1 + 146) )
      {
        v16 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 146);
        if ( *(_BYTE *)(v16 + 64) != 10 || *(_BYTE *)(v16 + 65) != 45 )
          goto LABEL_37;
        if ( sub_42340((_WORD *)(a1 + 72), (_WORD *)(v16 + 72)) > 0x800 )
        {
          LOWORD(j) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v16 + 72));
          *(_WORD *)(a1 + 34) = j;
          return j;
        }
        if ( *(_WORD *)(v16 + 128) <= *(_WORD *)(v16 + 26) )
        {
LABEL_37:
          *(_WORD *)(a1 + 146) = 0;
          LOWORD(j) = *(_WORD *)(a1 + 130);
          *(_WORD *)(a1 + 126) = j;
          return j;
        }
        sub_424F0(a1, 0x58u);
        *(_WORD *)(a1 + 26) = 1;
        LOWORD(j) = *(_WORD *)(v16 + 26) + 1;
        *(_WORD *)(v16 + 26) = j;
      }
      else
      {
        j = 9377 * *(_DWORD *)(a1 + 4) + 9439;
        *(_DWORD *)(a1 + 4) = j;
        v11 = *(_DWORD *)(a1 + 4);
        *(_DWORD *)(a1 + 4) = 9377 * v11 + 9439;
        *(_WORD *)(a1 + 34) += ((unsigned __int8)(-95 * v11 - 33) + 85) * (2 * (j % 0x9D / 79i64) - 1);
        *(_BYTE *)(a1 + 35) &= 7u;
        LOWORD(j) = *(unsigned __int8 *)(a1 + 63) / *(__int16 *)(*(_DWORD *)(a1 + 156) + 26);
        if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26)) )
        {
          v12 = -1;
          v18 = 0;
          for ( j = *(_DWORD *)(dword_AE408 + 36470); j > v10 + 29795; j = *(_DWORD *)j )
          {
            v13 = (__int16)(*(_WORD *)(j + 72) - *(_WORD *)(a1 + 72));
            v14 = (__int16)(*(_WORD *)(j + 74) - *(_WORD *)(a1 + 74));
            v15 = v13 * v13 + v14 * v14;
            if ( v15 < v12 && v15 > 0xE100000 )
            {
              v18 = j;
              v12 = v15;
            }
          }
          dword_AE400 = v10;
          if ( v18 )
          {
            *(_WORD *)(a1 + 146) = (int)(v18 - (v10 + 29795)) / 164;
            LOWORD(j) = *(_WORD *)(a1 + 128);
            *(_WORD *)(a1 + 126) = j;
          }
        }
      }
    }
  }
  return j;
}
// 1FBA3: conditional instruction was optimized away because esi.4==2
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (0001FE90) --------------------------------------------------------
int sub_1FE90(int a1)
{
  if ( *(_WORD *)(a1 + 26) )
    return sub_41E80(a1);
  else
    return sub_1A6C0(a1, 84);
}

//----- (0001FEC0) --------------------------------------------------------
void sub_1FEC0(int a1)
{
  int v1; // eax

  v1 = 164 * *(unsigned __int16 *)(a1 + 38);
  if ( v1 + dword_AE400 + 29795 && *(_BYTE *)(dword_AE400 + v1 + 29860) <= 1u )
    *(_WORD *)(*(_DWORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 38) + 29955) + 528) = 200;
  sub_1A800(a1);
}
// AE400: using guessed type int dword_AE400;

//----- (0001FF40) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_1FF40(char a1, int a2, char a3, int a4, int a5)
{
  int v5; // ebx
  int v6; // [esp-8h] [ebp-8h]
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  //fix
  v6 = 0;
  //fix

  v5 = a4 - (a1 + *(_DWORD *)(v6 + 27));
  *(_BYTE *)(v5 - 1957008686) += a3 - *(_BYTE *)(a5 + 128);
  sub_19B10(a2, (char)&retaddr);
}
// 1FF47: positive sp value 8 has been found
// 1FF41: variable 'v6' is possibly undefined

//----- (0001FF60) --------------------------------------------------------
void sub_1FF60(int a1)
{
  unsigned int v1; // ebp
  __int16 v2; // ax
  unsigned __int16 v3; // bx
  int i; // ebx
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // ebx
  unsigned int v9; // ebp
  unsigned int j; // ebx
  int v11; // eax
  unsigned int v12; // edi
  __int16 v13; // ax
  unsigned int v14; // [esp+4h] [ebp-1Ch]
  int v15; // [esp+8h] [ebp-18h]
  unsigned int v16; // [esp+Ch] [ebp-14h]

  v1 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v2 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v1 = 1;
      *(_WORD *)(a1 + 40) = v2;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v3 = *(_WORD *)(a1 + 54);
    if ( v3 )
    {
      for ( i = dword_AE400 + 29795 + 164 * v3;
            i != dword_AE400 + 29795;
            i = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(i + 54) )
      {
        v5 = *(_DWORD *)(i + 12);
        if ( v5 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v5;
          v1 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(i + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v1 )
  {
    if ( v1 > 1 )
    {
      sub_424F0(a1, 0x5Eu);
      goto LABEL_34;
    }
    v6 = dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 40);
    if ( *(_BYTE *)(v6 + 29859) != 3 || *(_WORD *)(v6 + 29819) == *(_WORD *)(a1 + 24) )
      goto LABEL_34;
    LOWORD(v7) = *(_WORD *)(a1 + 40);
    goto LABEL_33;
  }
  sub_20480(a1);
  v8 = *(_DWORD *)(a1 + 156);
  if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(v8 + 26)) && *(_BYTE *)(a1 + 58) )
  {
    v9 = -1;
    v14 = *(__int16 *)(v8 + 28) * *(__int16 *)(v8 + 28);
    v16 = 0;
    for ( j = *(_DWORD *)(dword_AE408 + 36462); j > dword_AE400 + 29795; j = *(_DWORD *)j )
    {
      if ( *(_WORD *)(j + 24) != *(_WORD *)(a1 + 24) )
      {
        v11 = (__int16)(*(_WORD *)(j + 72) - *(_WORD *)(a1 + 72));
        v12 = v11 * v11
            + (__int16)(*(_WORD *)(j + 74) - *(_WORD *)(a1 + 74)) * (__int16)(*(_WORD *)(j + 74) - *(_WORD *)(a1 + 74));
        if ( v12 <= v14 && (*(_BYTE *)(j + 16) & 0x20) == 0 )
        {
          v15 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 30);
          v13 = sub_42150((_WORD *)(a1 + 72), (_WORD *)(j + 72));
          if ( (unsigned __int16)sub_42210(*(_WORD *)(a1 + 30), v13) < v15 && v12 < v9 )
          {
            v16 = j;
            v9 = v12;
          }
        }
      }
    }
    if ( v16 )
    {
      v7 = (int)(v16 - (dword_AE400 + 29795)) / 164;
LABEL_33:
      *(_WORD *)(a1 + 146) = v7;
      sub_424F0(a1, 0x5Cu);
    }
  }
LABEL_34:
  if ( *(_BYTE *)(a1 + 70) == 92 )
    sub_20410(a1);
}
// 2002B: conditional instruction was optimized away because ebp.4==2
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (000201D0) --------------------------------------------------------
void sub_201D0(int a1)
{
  int v1; // esi
  unsigned int v2; // edi
  __int16 v3; // ax
  unsigned __int16 v4; // cx
  int v5; // eax
  int i; // edx
  int v7; // ecx
  int v8; // edi
  int v9; // ecx
  int v10; // eax
  int v11; // edi
  unsigned int v12; // [esp+0h] [ebp-18h]
  _WORD *v13; // [esp+4h] [ebp-14h]

  v1 = dword_AE400;
  v2 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v3 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v2 = 1;
      *(_WORD *)(a1 + 40) = v3;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v4 = *(_WORD *)(a1 + 54);
    if ( v4 )
    {
      v5 = 164 * v4 + v1 + 29795;
      for ( i = v1 + 29795; v5 != i; v5 = i + 164 * *(unsigned __int16 *)(v5 + 54) )
      {
        v7 = *(_DWORD *)(v5 + 12);
        if ( v7 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v7;
          v2 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(v5 + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  dword_AE400 = v1;
  if ( v2 > 1 )
  {
    *(_BYTE *)(a1 + 70) = 94;
    goto LABEL_25;
  }
  v8 = v1 + 29795 + 164 * *(unsigned __int16 *)(a1 + 146);
  if ( (*(_BYTE *)(a1 + 63) & 3) == 0 )
    *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v8 + 72));
  if ( *(int *)(v8 + 12) < 0 || (*(_BYTE *)(v8 + 17) & 4) != 0 )
    goto LABEL_22;
  v9 = *(_DWORD *)(a1 + 156);
  if ( *(unsigned __int8 *)(a1 + 63) % *(__int16 *)(v9 + 26) )
    goto LABEL_25;
  v12 = *(__int16 *)(v9 + 28);
  v13 = (_WORD *)(v8 + 72);
  if ( sub_42340((_WORD *)(a1 + 72), (_WORD *)(v8 + 72)) >= v12 )
  {
LABEL_22:
    sub_424F0(a1, 0x5Bu);
  }
  else
  {
    v10 = sub_373F0(a1 + 72, 9, 13);
    v11 = v10;
    if ( v10 )
    {
      *(_WORD *)(v10 + 24) = *(_WORD *)(a1 + 24);
      *(_WORD *)(v10 + 30) = sub_42150((_WORD *)(a1 + 72), v13);
      *(_WORD *)(v11 + 32) = sub_42180((_WORD *)(a1 + 72), v13);
      *(_WORD *)(v11 + 76) += *(_WORD *)(a1 + 84);
      *(_WORD *)(v11 + 146) = *(_WORD *)(a1 + 146);
      *(_BYTE *)(v11 + 67) = *(_BYTE *)(a1 + 67);
      *(_BYTE *)(v11 + 66) = *(_BYTE *)(a1 + 66);
    }
  }
LABEL_25:
  if ( *(_BYTE *)(a1 + 70) != 92 )
    sub_20450(a1);
}
// 2029D: conditional instruction was optimized away because edi.4==2
// AE400: using guessed type int dword_AE400;

//----- (000203E0) --------------------------------------------------------
char sub_203E0(int a1)
{
  return sub_1A390(a1, 0x5Au);
}

//----- (000203F0) --------------------------------------------------------
int sub_203F0(int a1)
{
  return sub_1A6C0(a1, 90);
}

//----- (00020400) --------------------------------------------------------
void sub_20400(int a1)
{
  sub_1A800(a1);
}

//----- (00020410) --------------------------------------------------------
int sub_20410(int a1)
{
  signed int v1; // edx

  *(_DWORD *)(a1 + 4) = 9377 * *(_DWORD *)(a1 + 4) + 9439;
  v1 = *(_DWORD *)(a1 + 4) % 0x14u;
  *(_WORD *)(a1 + 126) = 0;
  if ( v1 <= 10 )
    return sub_36FA0(a1, 206);
  else
    return sub_36FA0(a1, 1);
}

//----- (00020450) --------------------------------------------------------
int sub_20450(int a1)
{
  *(_WORD *)(a1 + 126) = *(_WORD *)(a1 + 128);
  return sub_36FA0(a1, 0);
}

//----- (00020480) --------------------------------------------------------
int sub_20480(int a1)
{
  int v1; // esi
  int result; // eax
  unsigned int v3; // edx
  int v4; // ecx
  int v5; // eax
  unsigned int i; // ecx
  __int64 v7; // rax
  __int64 v8; // rax
  unsigned int v9; // eax
  signed int v10; // et2
  __int16 *v11; // eax
  __int16 v12; // ax
  __int16 v13; // ax
  unsigned __int16 v14; // [esp-Ch] [ebp-2Ch]
  int v15; // [esp-Ch] [ebp-2Ch]
  int v16; // [esp-8h] [ebp-28h]
  int v17; // [esp-4h] [ebp-24h]
  _DWORD v18[2]; // [esp+0h] [ebp-20h]
  int v19; // [esp+8h] [ebp-18h]
  int v20; // [esp+Ch] [ebp-14h]
  int v21; // [esp+10h] [ebp-10h]

  v20 = 0;
  v18[0] = *(_DWORD *)sub_1FF40;
  v18[1] = *((_DWORD *)sub_1FF40 + 1);
  v19 = 1;
  if ( !(*(unsigned __int8 *)(a1 + 63) % 8) )
  {
    v1 = ~*(_DWORD *)(*(_DWORD *)(a1 + 156) + 20);
    result = sub_11810((__int16 *)(a1 + 72));
    if ( (result & v1) != 0 )
    {
      *(_BYTE *)(a1 + 70) = 94;
      return result;
    }
    LOWORD(result) = *(_WORD *)(a1 + 30);
    v21 = result;
    do
    {
      v14 = v21;
      *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
      *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
      sub_41EC0((uint16*)&word_AE454, v14, 0, 256);
      *(_DWORD *)(a1 + 4) = 9377 * *(_DWORD *)(a1 + 4) + 9439;
      v3 = *(_DWORD *)(a1 + 4) % (unsigned int)*((unsigned __int16 *)v18 + (unsigned __int16)v20);
      v4 = (v3 + 2) * (sub_11640(a1, &word_AE454, 1) == 0);
      if ( (unsigned __int16)v4 > (unsigned __int16)v19 )
      {
        v19 = v4;
        *(_WORD *)(a1 + 30) = v21;
      }
      v5 = v21;
      BYTE1(v5) = (BYTE1(v21) + 2) & 7;
      ++v20;
      v21 = v5;
    }
    while ( (unsigned __int16)v20 < 4u );
  }
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  if ( !(*(unsigned __int8 *)(a1 + 63) % 16) )
  {
    switch ( ((*(unsigned __int16 *)(a1 + 30) - 256) >> 9) & 3 )
    {
      case 0:
      case 2:
        word_AE456 = (word_AE456 >> 8 << 8) + 128;
        break;
      case 1:
      case 3:
        word_AE454 = (word_AE454 >> 8 << 8) + 128;
        break;
      default:
        break;
    }
  }
  for ( i = *(_DWORD *)(4 * *(char *)(a1 + 65) + dword_AE408 + 36382); i > dword_AE400 + 29795; i = *(_DWORD *)i )
  {
    if ( *(_WORD *)(i + 24) != *(_WORD *)(a1 + 24) )
    {
      v7 = *(__int16 *)(a1 + 72) - *(__int16 *)(i + 72);
      if ( (int)((HIDWORD(v7) ^ v7) - HIDWORD(v7)) < 256 )
      {
        v8 = *(__int16 *)(a1 + 74) - *(__int16 *)(i + 74);
        if ( (int)((HIDWORD(v8) ^ v8) - HIDWORD(v8)) < 256 )
        {
          *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(i + 72), (_WORD *)(a1 + 72));
          break;
        }
      }
    }
  }
  if ( *(_WORD *)(a1 + 34) == *(_WORD *)(a1 + 30)
    || (v9 = 9377 * *(_DWORD *)(a1 + 4) + 9439, *(_DWORD *)(a1 + 4) = v9, v10 = v9 % 0x14, result = v9 / 0x14, v10 <= 10) )
  {
    sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), 0, *(_WORD *)(a1 + 126));
    v11 = *(__int16 **)(a1 + 156);
    v17 = v11[7];
    v16 = v11[5];
    v15 = v11[6];
    v12 = sub_11F50(&word_AE454);
    v13 = sub_42000((int)&word_AE454, v12, v15, v16, v17);
    return sub_41C70(v13, a1, (int)&word_AE454);
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;

//----- (00020700) --------------------------------------------------------
void sub_20700(int a1)
{
  sub_19B10(a1, 96);
}

//----- (00020710) --------------------------------------------------------
void sub_20710(int a1)
{
  int v1; // esi
  unsigned int v2; // ecx
  unsigned int v3; // edi
  unsigned int i; // eax
  int v5; // esi
  int v6; // edx
  unsigned int v7; // edx
  unsigned int v8; // [esp+0h] [ebp-10h]

  sub_19D70(a1, 96);
  if ( *(_BYTE *)(a1 + 70) == 97 )
  {
    v1 = *(_DWORD *)(a1 + 156);
    if ( !(*(unsigned __int8 *)(a1 + 63) % (*(__int16 *)(v1 + 26) + 1)) )
    {
      v8 = *(__int16 *)(v1 + 28) * *(__int16 *)(v1 + 28);
      v2 = -1;
      v3 = 0;
      for ( i = *(_DWORD *)(dword_AE408 + 36470); i > dword_AE400 + 29795; i = *(_DWORD *)i )
      {
        v5 = (__int16)(*(_WORD *)(i + 72) - *(_WORD *)(a1 + 72));
        v6 = (__int16)(*(_WORD *)(i + 74) - *(_WORD *)(a1 + 74));
        v7 = v5 * v5 + v6 * v6;
        if ( v7 <= v8 && v7 < v2 )
        {
          v3 = i;
          v2 = v7;
        }
      }
      if ( v3 )
      {
        *(_WORD *)(a1 + 146) = (int)(v3 - (dword_AE400 + 29795)) / 164;
        sub_424F0(a1, 0x62u);
      }
    }
  }
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (000207E0) --------------------------------------------------------
unsigned __int16 sub_207E0(int a1)
{
  int v1; // edi
  int v2; // eax
  unsigned int v3; // esi
  __int16 v4; // ax
  unsigned __int16 v5; // cx
  int v6; // eax
  int i; // edx
  int v8; // ecx
  unsigned __int16 result; // ax
  char v10; // cl
  int v11; // ebp
  __int16 v12; // si
  int v13; // eax
  int v14; // esi
  __int16 v15; // ax
  int v16; // eax
  __int16 v17; // ax
  unsigned int v18; // [esp+4h] [ebp-18h]
  _WORD *v19; // [esp+8h] [ebp-14h]

  v1 = dword_AE400;
  v2 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 28);
  v18 = v2 * v2;
  v3 = 0;
  if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
      v4 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      v3 = 1;
      *(_WORD *)(a1 + 40) = v4;
    }
    else
    {
      *(_WORD *)(a1 + 40) = 0;
    }
    v5 = *(_WORD *)(a1 + 54);
    if ( v5 )
    {
      v6 = 164 * v5 + v1 + 29795;
      for ( i = v1 + 29795; v6 != i; v6 = i + 164 * *(unsigned __int16 *)(v6 + 54) )
      {
        v8 = *(_DWORD *)(v6 + 12);
        if ( v8 < *(_DWORD *)(a1 + 12) )
        {
          *(_DWORD *)(a1 + 12) = v8;
          v3 = 1;
          *(_WORD *)(a1 + 40) = *(_WORD *)(v6 + 40);
          break;
        }
      }
    }
  }
  if ( *(int *)(a1 + 12) < 0 )
  {
    v3 = 2;
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 40);
  }
  if ( v3 )
  {
    if ( v3 <= 1 )
    {
      result = 41 * *(_WORD *)(a1 + 40);
      v10 = *(_BYTE *)(v1 + 164 * *(unsigned __int16 *)(a1 + 40) + 29859);
      dword_AE400 = v1;
      if ( v10 == 3 )
      {
        result = *(_WORD *)(a1 + 40);
        *(_WORD *)(a1 + 146) = result;
      }
    }
    else
    {
      dword_AE400 = v1;
      return sub_424F0(a1, 0x64u);
    }
    return result;
  }
  dword_AE400 = v1;
  sub_196E0(a1);
  v11 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 146);
  if ( (*(_BYTE *)(a1 + 63) & 7) == 0
    && (*(_BYTE *)(v11 + 64) == 3 || sub_42340((_WORD *)(a1 + 72), (_WORD *)(v11 + 72)) >= 0x200) )
  {
    *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v11 + 72));
  }
  if ( *(int *)(v11 + 12) < 0 || (*(_BYTE *)(v11 + 17) & 4) != 0 )
    return sub_424F0(a1, 0x61u);
  v12 = *(_WORD *)(a1 + 26);
  if ( v12 )
  {
    *(_WORD *)(a1 + 26) = v12 - 1;
    v19 = (_WORD *)(a1 + 72);
    v13 = sub_373F0(a1 + 72, 9, 0);
    v14 = v13;
    if ( v13 )
    {
      *(_BYTE *)(v13 + 68) = 10;
      *(_BYTE *)(v13 + 69) = 0;
      *(_DWORD *)(v13 + 156) = (uint32)&unk_98F78;
      *(_BYTE *)(v13 + 67) = *(_BYTE *)(a1 + 67);
      *(_BYTE *)(v13 + 66) = *(_BYTE *)(a1 + 66);
      *(_WORD *)(v13 + 24) = *(_WORD *)(a1 + 24);
      *(_WORD *)(v13 + 30) = sub_42150(v19, (_WORD *)(v11 + 72));
      *(_WORD *)(v14 + 32) = sub_42180(v19, (_WORD *)(v11 + 72));
      *(_WORD *)(v14 + 76) += 4 * *(_WORD *)(a1 + 84);
      v15 = *(_WORD *)(a1 + 146);
      *(_WORD *)(v14 + 44) = 3000;
      *(_DWORD *)(v14 + 140) = 60000;
      *(_WORD *)(v14 + 146) = v15;
    }
  }
  result = *(unsigned __int8 *)(a1 + 63) / *(__int16 *)(*(_DWORD *)(a1 + 156) + 26);
  if ( !(*(unsigned __int8 *)(a1 + 63) % *(__int16 *)(*(_DWORD *)(a1 + 156) + 26)) )
  {
    v16 = (__int16)(*(_WORD *)(v11 + 72) - *(_WORD *)(a1 + 72));
    if ( v16 * v16
       + (__int16)(*(_WORD *)(v11 + 74) - *(_WORD *)(a1 + 74)) * (__int16)(*(_WORD *)(v11 + 74) - *(_WORD *)(a1 + 74)) >= v18 )
      return sub_424F0(a1, 0x61u);
    if ( !(*(unsigned __int8 *)(a1 + 63) % (2 * *(__int16 *)(*(_DWORD *)(a1 + 156) + 26))) )
      sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 39);
    v17 = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v11 + 72));
    result = sub_42210(*(_WORD *)(a1 + 30), v17);
    if ( result < 0xE3u )
      *(_WORD *)(a1 + 26) = 15;
  }
  return result;
}
// 208C0: conditional instruction was optimized away because esi.4==2
// AE400: using guessed type int dword_AE400;

//----- (00020B60) --------------------------------------------------------
char sub_20B60(int a1)
{
  return sub_1A390(a1, 0x60u);
}

//----- (00020B70) --------------------------------------------------------
int sub_20B70(int a1)
{
  return sub_1A6C0(a1, 96);
}

//----- (00020B80) --------------------------------------------------------
void sub_20B80(int a1)
{
  sub_1A800(a1);
}

//----- (00020BD0) --------------------------------------------------------
int sub_20BD0()
{
  int v1; // eax
  void *retaddr[2]; // [esp+10h] [ebp+0h]

  if ( word_939D2 || !byte_9008E )
  {
    byte_9008C += byte_9008F;
    byte_ACFF0 = -77;
    byte_ACFF2 = byte_9008C;
    byte_ACFF1 = 7;
    //fix sub_5EDA0(dword_CBFDC, (int)&byte_ACFF0, __DS__, 3);
    byte_ACFF0 = -76;
    byte_ACFF1 = 7;
    byte_ACFF2 = byte_9008C;
    //fix sub_5EDA0(dword_CBFDC, (int)&byte_ACFF0, __DS__, 3);
    byte_ACFF0 = -75;
    byte_ACFF1 = 7;
    byte_ACFF2 = byte_9008C;
    //fix v1 = sub_5EDA0(dword_CBFDC, (int)&byte_ACFF0, __DS__, 3);
    BYTE1(v1) = byte_9008C;
    if ( byte_9008C == 126 && byte_9008D == 2 )
    {
      v1 = sub_5DC91(dword_80000);
      byte_9008E = 0;
    }
    if ( !byte_9008C && byte_9008D == 1 )
    {
      v1 = sub_5DC91(dword_80000);
      byte_9008C = 0;
      byte_9008E = 0;
    }
    return 0;//fix return MK_FP(retaddr[0], retaddr[0])(v1);
  }
  else
  {
    sub_5DC91(dword_80000);
    byte_9008E = 0;
    return 0;//fix return MK_FP(retaddr[0], retaddr[0])();
  }
}
// 80000: using guessed type int dword_80000;
// 9008C: using guessed type char byte_9008C;
// 9008D: using guessed type char byte_9008D;
// 9008E: using guessed type char byte_9008E;
// 9008F: using guessed type char byte_9008F;
// 939D2: using guessed type __int16 word_939D2;
// ACFF0: using guessed type char byte_ACFF0;
// ACFF1: using guessed type char byte_ACFF1;
// ACFF2: using guessed type char byte_ACFF2;
// CBFDC: using guessed type int dword_CBFDC;

//----- (00020D00) --------------------------------------------------------
void sub_20D00(char a1)
{
  if ( byte_939CC )
  {
    if ( word_939D2 || !byte_9008E )
    {
      if ( byte_939CD && word_939D2 )
      {
        if ( sub_5D7F0(dword_CBFD8) )
        {
          if ( byte_9008E )
            sub_5DC91(dword_80000);
          byte_9008C = 0;
          byte_9008F = -2;
          byte_9008D = 1;
          byte_9008E = 0;
          sub_5F529(dword_CBFD8, (unsigned int)&dword_12F030);
          sub_5F398(dword_CBFD8);
          word_939D0 = 100;
        }
        else if ( a1 != byte_9008D )
        {
          if ( byte_9008E )
            sub_5DC91(dword_80000);
          byte_9008D = a1;
          byte_9008E = 1;
          byte_9008F = -byte_9008F;
          if ( a1 == 1 )
          {
              //fix sub_5D97B(0x14u, (int)sub_20BD0, __CS__, (unsigned int)&dword_80000);
          }
          else if ( a1 == 2 )
          {
              //fix sub_5D97B(0x3Cu, (int)sub_20BD0, __CS__, (unsigned int)&dword_80000);
          }
        }
      }
    }
    else
    {
      sub_5DC91(dword_80000);
      byte_9008E = 0;
    }
  }
}
// 80000: using guessed type int dword_80000;
// 9008C: using guessed type char byte_9008C;
// 9008D: using guessed type char byte_9008D;
// 9008E: using guessed type char byte_9008E;
// 9008F: using guessed type char byte_9008F;
// 939CC: using guessed type char byte_939CC;
// 939CD: using guessed type char byte_939CD;
// 939D0: using guessed type __int16 word_939D0;
// 939D2: using guessed type __int16 word_939D2;
// CBFD8: using guessed type int dword_CBFD8;
// 12F030: using guessed type int dword_12F030;

//----- (00020E60) --------------------------------------------------------
void sub_20E60()
{
  if ( byte_939CC && byte_939CD && word_939D2 )
  {
    if ( !sub_5D7F0(dword_CBFD8) )
      sub_5F420(dword_CBFD8);
    sub_5F355(dword_CBFD8);
    sub_6091D(dword_CBFDC);
    if ( byte_9AF9C )
      sub_6091D(dword_12F074);
    word_939D2 = 0;
  }
}
// 939CC: using guessed type char byte_939CC;
// 939CD: using guessed type char byte_939CD;
// 939D2: using guessed type __int16 word_939D2;
// 9AF9C: using guessed type char byte_9AF9C;
// CBFD8: using guessed type int dword_CBFD8;
// CBFDC: using guessed type int dword_CBFDC;
// 12F074: using guessed type int dword_12F074;

//----- (00020FB0) --------------------------------------------------------
int sub_20FB0()
{
  int v0; // eax
  int v1; // ebx
  unsigned __int16 v2; // dx
  int v3; // ecx
  int v4; // ecx
  int v5; // ebx
  int v6; // ebx
  int v7; // ebx
  int v8; // ebx
  __int64 v9; // rax
  __int64 v10; // rax
  unsigned __int8 v11; // al
  unsigned __int16 v12; // di
  const char *v13; // ebp
  int v14; // ecx
  int v15; // edx
  const char *v16; // eax
  int v17; // eax
  int v18; // edx
  unsigned __int8 v19; // al
  char v20; // al
  int v21; // ebx
  unsigned __int16 v22; // dx
  __int16 v23; // si
  int v24; // ebx
  int v25; // ebx
  int v26; // ebx
  int v27; // ebx
  int v28; // ebx
  int v29; // ebx
  int v30; // ebx
  int v31; // ebx
  int v32; // ebx
  int v33; // ebx
  int v34; // ebx
  int v35; // ebx
  int v36; // ebx
  int v37; // ebx
  int v38; // ebx
  int v39; // ebx
  int v40; // ebx
  int v41; // ebx
  int v42; // ebx
  int v43; // ebx
  int v44; // ebx
  int v45; // ebx
  int v46; // ebx
  int v47; // ebx
  int v48; // ebx
  int v49; // ebx
  __int16 v50; // bx
  __int16 v51; // ax
  int v52; // esi
  int v53; // ebx
  int v54; // edx
  unsigned int v55; // eax
  int v56; // edi
  unsigned __int16 v57; // cx
  int v58; // eax
  int v59; // edx
  int v60; // eax
  unsigned int v61; // edx
  int v62; // ebx
  unsigned __int16 v63; // dx
  int v64; // ebx
  int v65; // ebx
  int v66; // ebx
  int result; // eax
  int v68; // esi
  int v69; // eax
  int v70; // ebx
  int i; // ebp
  __int16 v72; // di
  __int16 j; // bx
  unsigned __int16 v74; // si
  unsigned __int8 v75; // [esp-4h] [ebp-138h]
  unsigned __int8 v76; // [esp-4h] [ebp-138h]
  unsigned __int8 v77; // [esp-4h] [ebp-138h]
  unsigned __int8 v78; // [esp-4h] [ebp-138h]
  unsigned __int8 v79; // [esp-4h] [ebp-138h]
  unsigned __int8 v80; // [esp-4h] [ebp-138h]
  unsigned __int8 v81; // [esp-4h] [ebp-138h]
  unsigned __int8 v82; // [esp-4h] [ebp-138h]
  unsigned __int8 v83; // [esp-4h] [ebp-138h]
  unsigned __int8 v84; // [esp-4h] [ebp-138h]
  unsigned __int8 v85; // [esp-4h] [ebp-138h]
  unsigned __int8 v86; // [esp-4h] [ebp-138h]
  unsigned __int8 v87; // [esp-4h] [ebp-138h]
  unsigned __int8 v88; // [esp-4h] [ebp-138h]
  unsigned __int8 v89; // [esp-4h] [ebp-138h]
  unsigned __int8 v90; // [esp-4h] [ebp-138h]
  unsigned __int8 v91; // [esp-4h] [ebp-138h]
  unsigned __int8 v92; // [esp-4h] [ebp-138h]
  unsigned __int8 v93; // [esp-4h] [ebp-138h]
  unsigned __int8 v94; // [esp-4h] [ebp-138h]
  unsigned __int8 v95; // [esp-4h] [ebp-138h]
  unsigned __int8 v96; // [esp-4h] [ebp-138h]
  char v97[256]; // [esp+0h] [ebp-134h] BYREF
  int v98; // [esp+104h] [ebp-30h]
  int v99; // [esp+108h] [ebp-2Ch]
  int v100; // [esp+10Ch] [ebp-28h]
  int v101; // [esp+110h] [ebp-24h]
  int v102; // [esp+114h] [ebp-20h]
  int v103; // [esp+118h] [ebp-1Ch]
  int v104; // [esp+11Ch] [ebp-18h]
  int v105; // [esp+120h] [ebp-14h]

  dword_90098 = 0;
  v0 = *(unsigned __int8 *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 14421);
  switch ( *(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 14421) )
  {
    case 0:
    case 3:
      if ( byte_90094 || *(char *)(dword_AE400 + 8600) != (unsigned __int8)byte_90096 )
      {
        byte_90094 = 0;
        byte_90096 = *(_BYTE *)(dword_AE400 + 8600);
        if ( byte_90096 < 40 )
        {
          if ( (word_12F02E & 1) != 0 )
            sub_411D7(dword_AE400, (void *)dword_12EFF4, 0xC8u, 0);
          else
            sub_411FD(dword_12EFF4, (void *)dword_12EFF4, 0x1E0u, 0);
        }
      }
      if ( *(char *)(dword_AE400 + 8600) < 40 )
      {
        if ( (word_12F02E & 1) != 0 )
          sub_411D7(dword_AE400, (void *)dword_12EFF4, 0xC8u, 0);
        else
          sub_411FD(dword_AE400, (void *)dword_12EFF4, 0x1E0u, 0);
      }
      sub_30A70(*(char *)(dword_AE400 + 8600));
      v1 = 2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400;
      v2 = *(_WORD *)(v1 + 13337);
      sub_30D90(
        dword_12EFF4,
        *(__int16 *)(v1 + 14 * v2 + 13909),
        *(__int16 *)(v1 + 14 * v2 + 13911),
        *(_WORD *)(v1 + 14 * v2 + 13915),
        *(__int16 *)(v1 + 14 * v2 + 13913) + 128,
        *(__int16 *)(v1 + 14 * v2 + 13917),
        *(__int16 *)(v1 + 14 * v2 + 13919),
        *(__int16 *)(v1 + 14 * v2 + 13921));
      v3 = dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8);
      if ( *(int *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(v3 + 13333) + 12) >= 0
        && (*(_BYTE *)dword_AE408 & 4) == 0 )
      {
        if ( *(_BYTE *)(dword_AE400 + 8601) )
        {
          v4 = 14 * *(unsigned __int16 *)(v3 + 13337) + v3;
          sub_49300(
            0,
            0,
            *(__int16 *)(v4 + 13909),
            *(__int16 *)(v4 + 13911),
            128,
            128,
            *(_WORD *)(v4 + 13915),
            256,
            dword_12F000 - 2 * (dword_12F000 / 5u),
            0);
          v5 = 2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400;
          sub_48710(
            0,
            0,
            *(_WORD *)(v5 + 14 * *(unsigned __int16 *)(v5 + 13337) + 13909),
            *(_WORD *)(v5 + 14 * *(unsigned __int16 *)(v5 + 13337) + 13911),
            128,
            128,
            *(_WORD *)(v5 + 14 * *(unsigned __int16 *)(v5 + 13337) + 13915),
            256);
        }
        sub_5A3C0(1);
        v6 = dword_AE400
           + 29795
           + 164 * *(unsigned __int16 *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13333);
        if ( *(_BYTE *)(dword_AE400 + 8602) )
        {
          sub_23D40(
            510,
            2,
            dword_AE400
          + 29795
          + 164 * *(_DWORD *)(*(_DWORD *)(v6 + 160) + 4 * *(__int16 *)(*(_DWORD *)(v6 + 160) + 940) + 532),
            0);
          sub_23D40(
            574,
            2,
            164 * *(_DWORD *)(*(_DWORD *)(v6 + 160) + 4 * *(__int16 *)(*(_DWORD *)(v6 + 160) + 944) + 532)
          + dword_AE400
          + 29795,
            0);
          sub_22E50(v6);
        }
        sub_5A3C0(1);
        if ( (*(_BYTE *)(dword_AE408 + 1) & 2) == 0 )
        {
          sub_5A3C0(1);
          v7 = 50;
          if ( (*(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13325) & 2) != 0 )
          {
            if ( *(_BYTE *)(dword_AE400 + 8600) == 40 )
            {
              sub_5A180((_BYTE *)dword_AE328, 132, 50, byte_AD168[0]);
              v8 = sub_5A3B0() + 50;
              sub_5A180((_BYTE *)dword_AE32C, 132, v8, byte_AD168[0]);
            }
            else
            {
              v9 = 4080 * *(unsigned __int8 *)(dword_AE408 + 95);
              sub_5A180(
                (_BYTE *)dword_AE328,
                132,
                50,
                byte_AD168[273 * ((int)(v9 - (__CFSHL__(HIDWORD(v9), 8) + (HIDWORD(v9) << 8))) >> 8)]);
              v8 = sub_5A3B0() + 50;
              v10 = 4080 * *(unsigned __int8 *)(dword_AE408 + 95);
              sub_5A180(
                (_BYTE *)dword_AE32C,
                132,
                v8,
                byte_AD168[273 * ((int)(v10 - (__CFSHL__(HIDWORD(v10), 8) + (HIDWORD(v10) << 8))) >> 8)]);
            }
            v7 = sub_5A3B0() + v8;
          }
          if ( (*(_BYTE *)(dword_AE408 + 2) & 1) != 0 )
          {
            if ( *(_BYTE *)(dword_AE400 + 8600) == 40 )
              v11 = byte_AD168[0];
            else
              v11 = byte_AD168[273
                             * ((int)(4080 * *(unsigned __int8 *)(dword_AE408 + 95)
                                    - (__CFSHL__(*(unsigned __int8 *)(dword_AE408 + 95) / 0x80809u, 8)
                                     + ((*(unsigned __int8 *)(dword_AE408 + 95) / 0x80809u) << 8))) >> 8)];
            sub_5A180((uint8*)aPaused, 132, v7, v11);
            v7 += sub_5A3B0();
          }
          v12 = 0;
          v100 = dword_AE400 + 13323;
          v13 = (const char *)(dword_AE400 + 14357);
          while ( v12 < *(_WORD *)(dword_AE400 + 10) )
          {
            v14 = 68 * v12;
            v99 = 2049 * *(__int16 *)(dword_AE400 + 8);
            v15 = v14 + dword_AE400 + v99;
            v101 = v14;
            LOWORD(v14) = *(_WORD *)(v15 + 13417);
            v104 = v14;
            v16 = (const char *)(v101 + v99 + dword_AE400 + 13323 + 28);
            switch ( (__int16)v14 )
            {
              case 0:
                if ( *(__int16 *)(v15 + 13415) > 0 )
                {
                  sprintf(v97, "%s %s", v13, v16);
                  sub_5A180((uint8*)v97, 132, v7, byte_AE068);
                  goto LABEL_41;
                }
                break;
              case 1:
                sprintf(v97, ">%s?", v16);
                sub_5A180((uint8*)v97, 132, v7, byte_AE068);
                v7 += sub_5A3B0();
                break;
              case 2:
                if ( *(__int16 *)(v15 + 13415) > 0 )
                {
                  sprintf(v97, "%s", v16);
                  sub_5A180((uint8*)v97, 132, v7, byte_AE068);
                  v7 += sub_5A3B0();
                  v17 = 2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400;
                  v18 = 68 * v12;
                  goto LABEL_42;
                }
                break;
              case 3:
                if ( *(__int16 *)(v15 + 13415) > 0 )
                {
                  sprintf(v97, "[%s] %s", v13, v16);
                  if ( *(__int16 *)(v101 + 2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 13415) <= 100 )
                    v19 = byte_AE068;
                  else
                    v19 = byte_AD168[256
                                   * ((int)(4080 * *(unsigned __int8 *)(dword_AE408 + 95)
                                          - (__CFSHL__(*(unsigned __int8 *)(dword_AE408 + 95) / 0x80809u, 8)
                                           + ((*(unsigned __int8 *)(dword_AE408 + 95) / 0x80809u) << 8))) >> 8)];
                  sub_5A180((uint8*)v97, 132, v7, v19);
LABEL_41:
                  v7 += sub_5A3B0();
                  v18 = dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8);
                  v17 = 68 * v12;
LABEL_42:
                  --*(_WORD *)(v18 + v17 + 13415);
                }
                break;
              default:
                break;
            }
            v13 += 2049;
            ++v12;
            v100 += 2049;
          }
        }
        if ( (*(_BYTE *)(dword_AE408 + 1) & 2) != 0 )
          sub_5A3C0(1);
      }
      goto LABEL_139;
    case 1:
      if ( byte_90094 || *(char *)(dword_AE400 + 8600) != (unsigned __int8)byte_90096 )
      {
        memset((void*)dword_12EFF4, 0, dword_12EFF8 * dword_12EFF0);
        v20 = *(_BYTE *)(dword_AE400 + 8600);
        byte_90094 = 0;
        byte_90096 = v20;
      }
      sub_30A70(*(char *)(dword_AE400 + 8600));
      v21 = 2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400;
      v22 = *(_WORD *)(v21 + 13337);
      sub_30D90(
        dword_12EFF4,
        *(__int16 *)(v21 + 14 * v22 + 13909),
        *(__int16 *)(v21 + 14 * v22 + 13911),
        *(_WORD *)(v21 + 14 * v22 + 13915),
        *(__int16 *)(v21 + 14 * v22 + 13913) + 128,
        *(__int16 *)(v21 + 14 * v22 + 13917),
        *(__int16 *)(v21 + 14 * v22 + 13919),
        *(__int16 *)(v21 + 14 * v22 + 13921));
      sub_5A3C0(1);
      v23 = sub_5A3A0();
      v24 = -sub_5A3B0() / 2;
      v75 = byte_AE167;
      if ( (word_12F02E & 1) != 0 )
      {
        v25 = sub_5A3B0() + v24;
        sub_5A180((uint8*)aCursorUpMoveFo, v23, v25, v75);
      }
      else
      {
        v25 = sub_5A3B0() + v24;
        sub_5A180((uint8*)aCursorUpMoveFo_0, v23, v25, v75);
      }
      v76 = byte_AE167;
      if ( (word_12F02E & 1) != 0 )
      {
        v26 = sub_5A3B0() + v25;
        sub_5A180((uint8*)aCursorDownMove, v23, v26, v76);
      }
      else
      {
        v26 = sub_5A3B0() + v25;
        sub_5A180((uint8*)aCursorDownMove_0, v23, v26, v76);
      }
      v77 = byte_AE167;
      v27 = sub_5A3B0() + v26;
      sub_5A180((uint8*)aCursorLeftMove, v23, v27, v77);
      v78 = byte_AE167;
      v28 = sub_5A3B0() + v27;
      sub_5A180((uint8*)aCursorRightMov, v23, v28, v78);
      v79 = byte_AE167;
      if ( (word_12F02E & 1) != 0 )
      {
        v29 = sub_5A3B0() + v28;
        sub_5A180((uint8*)aLeftButtonUseS, v23, v29, v79);
      }
      else
      {
        v29 = sub_5A3B0() + v28;
        sub_5A180((uint8*)aLeftButtonUseS_0, v23, v29, v79);
      }
      v80 = byte_AE167;
      if ( (word_12F02E & 1) != 0 )
      {
        v30 = sub_5A3B0() + v29;
        sub_5A180((uint8*)aRightButtonUse, v23, v30, v80);
      }
      else
      {
        v30 = sub_5A3B0() + v29;
        sub_5A180((uint8*)aRightButtonUse_0, v23, v30, v80);
      }
      v81 = byte_AE167;
      if ( (word_12F02E & 1) != 0 )
      {
        v31 = sub_5A3B0() + v30;
        sub_5A180((uint8*)a10SelectAssign, v23, v31, v81);
      }
      else
      {
        v31 = sub_5A3B0() + v30;
        sub_5A180((uint8*)a10SelectAssign_0, v23, v31, v81);
      }
      v82 = byte_AE167;
      v32 = sub_5A3B0() + v31;
      sub_5A180((uint8*)aSpaceRebirth, v23, v32, v82);
      v83 = byte_AE167;
      v33 = sub_5A3B0() + v32;
      sub_5A180((uint8*)aShiftQExitToDo, v23, v33, v83);
      v84 = byte_AE167;
      if ( (word_12F02E & 1) != 0 )
      {
        v34 = sub_5A3B0() + v33;
        sub_5A180((uint8*)aF5ReflectionsT, v23, v34, v84);
      }
      else
      {
        v34 = sub_5A3B0() + v33;
        sub_5A180((uint8*)aF5ReflectionsT_0, v23, v34, v84);
      }
      v85 = byte_AE167;
      v35 = sub_5A3B0() + v34;
      sub_5A180((uint8*)aF6SkyToggle, v23, v35, v85);
      v86 = byte_AE167;
      if ( (word_12F02E & 1) != 0 )
      {
        v36 = sub_5A3B0() + v35;
        sub_5A180((uint8*)aF7ShadowsToggl, v23, v36, v86);
      }
      else
      {
        v36 = sub_5A3B0() + v35;
        sub_5A180((uint8*)aF7ShadowsToggl_0, v23, v36, v86);
      }
      v87 = byte_AE167;
      if ( (word_12F02E & 1) != 0 )
      {
        v37 = sub_5A3B0() + v36;
        sub_5A180((uint8*)aF8IconsToggle, v23, v37, v87);
      }
      else
      {
        v37 = sub_5A3B0() + v36;
        sub_5A180((uint8*)aF8IconsToggle_0, v23, v37, v87);
      }
      v88 = byte_AE167;
      if ( (word_12F02E & 1) != 0 )
      {
        v38 = sub_5A3B0() + v37;
        sub_5A180((uint8*)aF9SpeedBlurTog, v23, v38, v88);
      }
      else
      {
        v38 = sub_5A3B0() + v37;
        sub_5A180((uint8*)aF9SpeedBlurTog_0, v23, v38, v88);
      }
      v89 = byte_AE167;
      if ( (word_12F02E & 1) != 0 )
      {
        v39 = sub_5A3B0() + v38;
        sub_5A180((uint8*)aF10StereoModes, v23, v39, v89);
      }
      else
      {
        v39 = sub_5A3B0() + v38;
        sub_5A180((uint8*)aF10StereoModes_0, v23, v39, v89);
      }
      v90 = byte_AE167;
      v40 = sub_5A3B0() + v39;
      sub_5A180((uint8*)aReturn, v23, v40, v90);
      v91 = byte_AE167;
      if ( (word_12F02E & 1) != 0 )
      {
        v41 = sub_5A3B0() + v40;
        sub_5A180((uint8*)aLeftAndRightSp, v23, v41, v91);
      }
      else
      {
        v41 = sub_5A3B0() + v40;
        sub_5A180((uint8*)aLeftAndRightSp_0, v23, v41, v91);
      }
      v42 = sub_5A3B0() + v41;
      v43 = sub_5A3B0() + v42;
      v92 = byte_AE167;
      if ( (word_12F02E & 1) != 0 )
      {
        v44 = sub_5A3B0() + v43;
        sub_5A180((uint8*)aIfYouAreExperi, v23, v44, v92);
      }
      else
      {
        v44 = sub_5A3B0() + v43;
        sub_5A180((uint8*)aIfYouAreExperi_0, v23, v44, v92);
      }
      v45 = sub_5A3B0() + v44;
      v46 = sub_5A3B0() + v45;
      v93 = byte_AE167;
      if ( (word_12F02E & 1) != 0 )
      {
        v47 = sub_5A3B0() + v46;
        sub_5A180((uint8*)aMagicCarpetCom, v23, v47, v93);
      }
      else
      {
        v47 = sub_5A3B0() + v46;
        sub_5A180((uint8*)aMagicCarpetCom_0, v23, v47, v93);
      }
      v94 = byte_AE167;
      if ( (word_12F02E & 1) != 0 )
      {
        v48 = sub_5A3B0() + v47;
        sub_5A180((uint8*)aAndWillBeRelea, v23, v48, v94);
      }
      else
      {
        v48 = sub_5A3B0() + v47;
        sub_5A180((uint8*)aAndWillBeRelea_0, v23, v48, v94);
      }
      v95 = byte_AE167;
      if ( (word_12F02E & 1) != 0 )
      {
        v49 = sub_5A3B0() + v48;
        sub_5A180((uint8*)aCopyright1994B, v23, v49, v95);
      }
      else
      {
        v49 = sub_5A3B0() + v48;
        sub_5A180((uint8*)aCopyright1994B_0, v23, v49, v95);
      }
      v50 = sub_5A3B0() + v49;
      v96 = byte_AE167;
      v51 = sub_5A3B0();
      sub_5A180((uint8*)aGoodLuck, v23, v51 + v50, v96);
      goto LABEL_139;
    case 2:
      if ( (word_12F02E & 1) != 0 )
        sub_411D7(v0, (void *)dword_12EFF4, 0xC8u, 0);
      else
        sub_411FD(v0, (void *)dword_12EFF4, 0x1E0u, 0);
      v98 = 164 * *(unsigned __int16 *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13333)
          + dword_AE400
          + 29795;
      v52 = 384;
      if ( word_12F02E == 1 )
        v53 = 162;
      else
        v53 = 194;
      LOWORD(v103) = 0;
      *(_BYTE *)(dword_AE408 + 22) = -1;
      break;
    case 4:
LABEL_132:
      if ( byte_90094 != 2 )
      {
        memset((void*)dword_12EFF4, 0, dword_12EFF8 * dword_12EFF0);
        byte_90094 = 2;
      }
      sub_309D0(16);
      v62 = dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8);
      v63 = *(_WORD *)(v62 + 13337);
      sub_30D90(
        dword_12EFF4,
        *(__int16 *)(v62 + 14 * v63 + 13909),
        *(__int16 *)(v62 + 14 * v63 + 13911),
        *(_WORD *)(v62 + 14 * v63 + 13915),
        *(__int16 *)(v62 + 14 * v63 + 13913) + 128,
        *(__int16 *)(v62 + 14 * v63 + 13917),
        *(__int16 *)(v62 + 14 * v63 + 13919),
        *(__int16 *)(v62 + 14 * v63 + 13921));
      v64 = 2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400;
      if ( word_12F02E == 1 )
      {
        sub_49300(
          0,
          0,
          *(__int16 *)(v64 + 14 * *(unsigned __int16 *)(v64 + 13337) + 13909),
          *(__int16 *)(v64 + 14 * *(unsigned __int16 *)(v64 + 13337) + 13911),
          382,
          378,
          *(_WORD *)(v64 + 14 * *(unsigned __int16 *)(v64 + 13337) + 13915),
          170,
          dword_12F000 - 192,
          1);
        v65 = 2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400;
        sub_48710(
          0,
          0,
          *(_WORD *)(v65 + 14 * *(unsigned __int16 *)(v65 + 13337) + 13909),
          *(_WORD *)(v65 + 14 * *(unsigned __int16 *)(v65 + 13337) + 13911),
          382,
          382,
          *(_WORD *)(v65 + 14 * *(unsigned __int16 *)(v65 + 13337) + 13915),
          170);
      }
      else
      {
        sub_49300(
          0,
          0,
          *(__int16 *)(v64 + 14 * *(unsigned __int16 *)(v64 + 13337) + 13909),
          *(__int16 *)(v64 + 14 * *(unsigned __int16 *)(v64 + 13337) + 13911),
          382,
          414,
          *(_WORD *)(v64 + 14 * *(unsigned __int16 *)(v64 + 13337) + 13915),
          170,
          dword_12F000 - 192,
          1);
        v66 = 2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400;
        sub_48710(
          0,
          0,
          *(_WORD *)(v66 + 14 * *(unsigned __int16 *)(v66 + 13337) + 13909),
          *(_WORD *)(v66 + 14 * *(unsigned __int16 *)(v66 + 13337) + 13911),
          382,
          414,
          *(_WORD *)(v66 + 14 * *(unsigned __int16 *)(v66 + 13337) + 13915),
          170);
      }
      if ( SHIWORD(dword_9AD90) >= 382 )
        sub_22880();
      goto LABEL_139;
    default:
LABEL_139:
      sub_5A3C0(1);
      if ( (*(_BYTE *)dword_AE408 & 0x20) == 0
        && (*(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13341) & 2) != 0
        && (*(_BYTE *)dword_AE408 & 2) != 0 )
      {
        sprintf(v97, "MOVIE: %d", *(__int16 *)(dword_AE408 + 13));
        sub_5A180((uint8*)v97, 0, 0, byte_AE068);
      }
      result = dword_AE408;
      if ( (*(_BYTE *)dword_AE408 & 4) != 0 )
      {
        if ( *(_BYTE *)(dword_AE408 + 161) == 3 )
        {
          v68 = *(_DWORD *)(dword_AE408 + 162);
          if ( v68 <= 0 )
            *(_BYTE *)(dword_AE408 + 161) = 2;
          else
            *(_DWORD *)(dword_AE408 + 162) = v68 - 1;
        }
        v69 = dword_AE408;
        if ( *(_BYTE *)(dword_AE408 + 161) == 2 )
        {
          *(_BYTE *)(dword_AE408 + 161) = 1;
          *(_WORD *)(v69 + 166) = 0;
          *(_DWORD *)(v69 + 162) = 50;
        }
        result = dword_AE408;
        if ( *(_BYTE *)(dword_AE408 + 161) == 1 )
        {
          if ( *(int *)(dword_AE408 + 162) <= 0 )
          {
            while ( 1 )
            {
              result = dword_AE408;
              if ( *off_9AB44[*(unsigned __int16 *)(dword_AE408 + 166)] == 33 )
                break;
              ++*(_WORD *)(dword_AE408 + 166);
            }
            v74 = *(_WORD *)(dword_AE408 + 166) + 1;
            *(_WORD *)(dword_AE408 + 166) = v74;
            if ( *off_9AB44[v74] == 35 )
            {
              *(_BYTE *)(result + 161) = 3;
              *(_DWORD *)(result + 162) = 200;
            }
            else
            {
              *(_DWORD *)(result + 162) = 50;
            }
          }
          else
          {
            v70 = 380;
            for ( i = 0; *(&off_9AB44[i])[*(unsigned __int16 *)(dword_AE408 + 166)] != 33; ++i )
              v70 -= sub_5A3B0();
            v72 = 0;
            for ( j = 8; i > 0; j += sub_5A3B0() )
            {
              if ( v72 )
                sub_5A180((uint8*)((&off_9AB44[v72])[*(unsigned __int16 *)(dword_AE408 + 166)]), 8, j, byte_AD168[0]);
              else
                sub_5A180((uint8*)(off_9AB44[*(unsigned __int16 *)(dword_AE408 + 166)]), 8, j, byte_AE167);
              --i;
              ++v72;
            }
            result = dword_AE408;
            --*(_DWORD *)(dword_AE408 + 162);
          }
        }
      }
      return result;
  }
  while ( 1 )
  {
    v54 = *(_DWORD *)(v98 + 160);
    v55 = dword_AE400 + 29795 + 164 * *(__int16 *)(v54 + 2 * (unsigned __int8)byte_99B88[(__int16)v103] + 676);
    if ( v55 <= dword_AE400 + 29795 )
      break;
    v56 = *(_DWORD *)(v55 + 132);
    if ( v56 && ((v57 = *(_WORD *)(v54 + 50)) == 0 || v56 > *(_DWORD *)(164 * v57 + dword_AE400 + 29935))
      || (__int16)dword_9AD90 < v52
      || (__int16)dword_9AD90 >= v52 + 64
      || SHIWORD(dword_9AD90) < v53
      || SHIWORD(dword_9AD90) >= v53 + *(unsigned __int8 *)(dword_AE42C + 23) )
    {
      sub_24230(v52, v53, v55, 0);
      if ( !byte_B7700 )
        goto LABEL_126;
      if ( (__int16)dword_9AD90 < v52 )
        goto LABEL_126;
      if ( (__int16)dword_9AD90 >= v52 + 64 )
        goto LABEL_126;
      if ( SHIWORD(dword_9AD90) < v53 )
        goto LABEL_126;
      v58 = dword_AE42C;
      v59 = *(unsigned __int8 *)(dword_AE42C + 23);
      if ( SHIWORD(dword_9AD90) >= v53 + v59 )
        goto LABEL_126;
      if ( (word_12F02E & 1) == 0 )
      {
LABEL_125:
        sub_24DA0(v52, v53, *(unsigned __int8 *)(v58 + 22), v59, (unsigned __int8)byte_AE167);
        goto LABEL_126;
      }
      goto LABEL_118;
    }
    v105 = v52;
    v102 = v53;
    *(_BYTE *)(dword_AE408 + 22) = v103;
LABEL_126:
    v52 += 64;
    if ( v52 >= 640 )
    {
      v52 = 384;
      v53 += *(unsigned __int8 *)(dword_AE42C + 23);
    }
    LOWORD(v103) = v103 + 1;
    if ( (__int16)v103 >= 24 )
    {
      v60 = *(char *)(dword_AE408 + 22);
      if ( v60 != -1 )
      {
        v61 = dword_AE400
            + 29795
            + 164 * *(__int16 *)(*(_DWORD *)(v98 + 160) + 2 * (unsigned __int8)byte_99B88[v60] + 676);
        if ( v61 > dword_AE400 + 29795 )
          sub_23D40((__int16)v105, (__int16)v102, v61, 1);
      }
      goto LABEL_132;
    }
  }
  sub_23CF0(v52, v53, (unsigned __int8)byte_99B88[(__int16)v103]);
  if ( !byte_B7700 )
    goto LABEL_126;
  if ( (__int16)dword_9AD90 < v52 )
    goto LABEL_126;
  if ( (__int16)dword_9AD90 >= v52 + 64 )
    goto LABEL_126;
  if ( SHIWORD(dword_9AD90) < v53 )
    goto LABEL_126;
  v58 = dword_AE42C;
  v59 = *(unsigned __int8 *)(dword_AE42C + 23);
  if ( SHIWORD(dword_9AD90) >= v53 + v59 )
    goto LABEL_126;
  if ( (word_12F02E & 1) == 0 )
    goto LABEL_125;
LABEL_118:
  sub_24D20(v52, v53, *(unsigned __int8 *)(dword_AE42C + 22), v59, (unsigned __int8)byte_AE167);
  goto LABEL_126;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 90094: using guessed type char byte_90094;
// 90096: using guessed type char byte_90096;
// 90098: using guessed type int dword_90098;
// 9AB44: using guessed type char *off_9AB44[2];
// 9AD90: using guessed type int dword_9AD90;
// AE068: using guessed type char byte_AE068;
// AE167: using guessed type char byte_AE167;
// AE328: using guessed type int dword_AE328;
// AE32C: using guessed type int dword_AE32C;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE42C: using guessed type int dword_AE42C;
// B7700: using guessed type char byte_B7700;
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12EFF8: using guessed type int dword_12EFF8;
// 12F000: using guessed type int dword_12F000;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00022810) --------------------------------------------------------
void sub_22810(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6)
{
  int v6; // eax

  v6 = a5;
  if ( a5 >= a3 )
    v6 = a3;
  if ( v6 >= 2 && a4 >= 2 )
  {
    if ( (word_12F02E & 1) != 0 )
      sub_24C20(a1, a2, v6, a4, a6);
    else
      sub_24CA0(a1, a2, v6, a4, a6);
  }
}
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00022880) --------------------------------------------------------
int sub_22880()
{
  int v0; // esi
  int v1; // edx
  int v2; // eax
  __int64 v3; // rax
  int v4; // edx
  int v5; // esi
  char v6; // bh
  __int16 v7; // bx
  int v8; // edi
  __int16 v9; // bx
  int v10; // ebp
  int v11; // eax
  int result; // eax
  char v13[256]; // [esp+0h] [ebp-140h] BYREF
  int v14; // [esp+100h] [ebp-40h]
  int v15; // [esp+104h] [ebp-3Ch]
  int v16; // [esp+108h] [ebp-38h]
  int v17; // [esp+10Ch] [ebp-34h]
  _BYTE *v18; // [esp+110h] [ebp-30h]
  int v19; // [esp+114h] [ebp-2Ch]
  int v20; // [esp+118h] [ebp-28h]
  int v21; // [esp+11Ch] [ebp-24h]
  unsigned __int8 v22; // [esp+120h] [ebp-20h]
  unsigned __int8 v23; // [esp+124h] [ebp-1Ch]
  unsigned __int8 v24; // [esp+128h] [ebp-18h]
  unsigned __int8 v25; // [esp+12Ch] [ebp-14h]

  sub_5A3C0(1);
  v0 = 0;
  v1 = 0;
  v2 = dword_AE400 + 13323;
  while ( v1 < *(unsigned __int16 *)(dword_AE400 + 10) )
  {
    if ( *(_BYTE *)(v2 + 6) )
      ++v0;
    ++v1;
    v2 += 2049;
  }
  v3 = 640 - (v0 * *(unsigned __int8 *)(dword_AE42C + 520) + *(unsigned __int8 *)(dword_AE42C + 514));
  v21 = ((int)v3 - HIDWORD(v3)) >> 1;
  if ( word_12F02E == 1 )
    v4 = 400;
  else
    v4 = 480;
  v5 = (v4 - v0 * *(unsigned __int8 *)(dword_AE42C + 515)) / 2;
  v19 = 0;
  v14 = dword_AE400 + 13323;
  v16 = 0;
  v18 = (_BYTE *)(dword_AE400 + 14357);
  while ( 1 )
  {
    result = dword_AE400;
    if ( *(unsigned __int16 *)(dword_AE400 + 10) <= v19 )
      break;
    v6 = *(_BYTE *)(v14 + 6);
    v17 = 164 * *(unsigned __int16 *)(v14 + 10) + dword_AE400 + 29795;
    if ( v6 == 1 )
    {
      v23 = byte_99B59[v16];
      v7 = v21;
      v22 = byte_99B58[v16];
      if ( (word_12F02E & 1) != 0 )
        sub_60CE0(v21, v5, dword_AE42C + 510);
      else
        sub_60D18(v21, v5, dword_AE42C + 510);
      if ( (word_12F02E & 1) != 0 )
        sub_24C20(
          v7 + 4,
          (__int16)v5 + 4,
          *(unsigned __int8 *)(dword_AE42C + 514) - 8,
          *(unsigned __int8 *)(dword_AE42C + 515) - 8,
          v22);
      else
        sub_24CA0(
          v7 + 4,
          (__int16)v5 + 4,
          *(unsigned __int8 *)(dword_AE42C + 514) - 8,
          *(unsigned __int8 *)(dword_AE42C + 515) - 8,
          v22);
      sub_5A180(v18, (__int16)(v7 + 8), v5 + 6, v23);
      sprintf(v13, "%d", *(_DWORD *)(v17 + 136));
      sub_5A180((uint8*)v13, (__int16)(v7 + 8), v5 + 20, v23);
      v8 = 0;
      v9 = *(unsigned __int8 *)(dword_AE42C + 514) + v7;
      v10 = 0;
      v15 = 0;
      v20 = v5 + 10;
      do
      {
        if ( v8 == v19 || *(_BYTE *)(v15 + dword_AE400 + 13329) != 1 )
        {
          if ( v8 == v19 )
          {
            if ( (word_12F02E & 1) != 0 )
              sub_60CE0(v9, v5, dword_AE42C + 516);
            else
              sub_60D18(v9, v5, dword_AE42C + 516);
            if ( (word_12F02E & 1) != 0 )
              sub_24C20(
                v9 + 4,
                (__int16)v5 + 4,
                *(unsigned __int8 *)(dword_AE42C + 520) - 8,
                *(unsigned __int8 *)(dword_AE42C + 521) - 8,
                (unsigned __int8)byte_AD168);
            else
              sub_24CA0(
                v9 + 4,
                (__int16)v5 + 4,
                *(unsigned __int8 *)(dword_AE42C + 520) - 8,
                *(unsigned __int8 *)(dword_AE42C + 521) - 8,
                (unsigned __int8)byte_AD168);
          }
        }
        else
        {
          v25 = byte_99B59[v10];
          v24 = byte_99B58[v10];
          if ( (word_12F02E & 1) != 0 )
            sub_60CE0(v9, v5, dword_AE42C + 516);
          else
            sub_60D18(v9, v5, dword_AE42C + 516);
          if ( (word_12F02E & 1) != 0 )
            sub_24C20(
              v9 + 4,
              (__int16)v5 + 4,
              *(unsigned __int8 *)(dword_AE42C + 520) - 8,
              *(unsigned __int8 *)(dword_AE42C + 521) - 8,
              v24);
          else
            sub_24CA0(
              v9 + 4,
              (__int16)v5 + 4,
              *(unsigned __int8 *)(dword_AE42C + 520) - 8,
              *(unsigned __int8 *)(dword_AE42C + 521) - 8,
              v24);
          sprintf(v13, "%03d", *(__int16 *)(*(_DWORD *)(v17 + 160) + v10 + 30));
          sub_5A180((uint8*)v13, (__int16)(v9 + 8), v20, v25);
        }
        HIWORD(v11) = HIWORD(dword_AE42C);
        v9 += *(unsigned __int8 *)(dword_AE42C + 520);
        v10 += 2;
        ++v8;
        v15 += 2049;
      }
      while ( v8 < 8 );
      LOWORD(v11) = *(unsigned __int8 *)(dword_AE42C + 515);
      v5 += v11;
    }
    v16 += 2;
    ++v19;
    v18 += 2049;
    v14 += 2049;
  }
  return result;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// AD168: using guessed type char byte_AD168;
// AE400: using guessed type int dword_AE400;
// AE42C: using guessed type int dword_AE42C;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00022E50) --------------------------------------------------------
void sub_22E50(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // edi
  unsigned int v4; // ebx
  __int16 v5; // cx
  __int16 v6; // ax
  int v7; // edi
  int v8; // edx
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  int v12; // eax
  __int64 v13; // rtt
  __int16 v14; // dx
  __int16 v15; // ax
  __int16 v16; // si
  _DWORD *v17; // ebx
  __int16 v18; // ax
  __int16 v19; // ax
  int v20; // ebx
  unsigned __int8 v21; // [esp-4h] [ebp-48h]
  int v22; // [esp+4h] [ebp-40h]
  int v23; // [esp+4h] [ebp-40h]
  int v24; // [esp+4h] [ebp-40h]
  int v25; // [esp+18h] [ebp-2Ch]
  __int16 v26; // [esp+1Ch] [ebp-28h]
  unsigned __int8 v27; // [esp+28h] [ebp-1Ch]
  unsigned __int8 v28; // [esp+2Ch] [ebp-18h]
  unsigned __int8 v29; // [esp+30h] [ebp-14h]

  v1 = (a1 - (dword_AE400 + 29795)) / 164;
  if ( !v1 || v1 >= 1000 )
    return;
  v2 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 48);
  v29 = byte_99B58[2 * v2];
  v27 = byte_99B59[2 * v2];
  v28 = byte_99B58[2 * v2 + *(unsigned __int8 *)(dword_AE408 + 95)];
  sub_23940(2, 2, dword_AE42C + 240);
  v3 = *(_DWORD *)(a1 + 160);
  v22 = *(unsigned __int8 *)(dword_AE42C + 244) + 2;
  v4 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(v3 + 50);
  if ( v4 > dword_AE400 + 29795 && *(__int16 *)(v4 + 26) > 0 )
  {
    if ( *(char *)(v3 + 391) > 0 && *(_BYTE *)(dword_AE408 + 94) )
    {
      sub_23940(v22, 2, dword_AE42C + 330);
      --*(_BYTE *)(*(_DWORD *)(a1 + 160) + 391);
    }
    else
    {
      sub_23940(v22, 2, dword_AE42C + 246);
    }
    v5 = v22 + 2;
    if ( (word_12F02E & 1) != 0 )
      sub_60CE0(v5, 2, dword_AE42C + 6 * (*(__int16 *)(v4 + 26) + 43));
    else
      sub_60D18(v5, 2, dword_AE42C + 6 * (*(__int16 *)(v4 + 26) + 43));
    v6 = v22 + 38;
    if ( (word_12F02E & 1) != 0 )
      sub_60CE0(v6, 2, dword_AE42C + 252);
    else
      sub_60D18(v6, 2, dword_AE42C + 252);
    v7 = v22 + 58;
    sub_22810(v22 + 58, 10, 64, 10, (*(_DWORD *)(v4 + 12) << 6) / *(_DWORD *)(v4 + 8), 0x7Bu);
    v8 = *(_DWORD *)(v4 + 136);
    v9 = *(_DWORD *)(*(_DWORD *)(a1 + 160) + 308) + *(_DWORD *)(v4 + 140);
    if ( v9 == v8 )
    {
      v10 = dword_AE408;
      if ( *(_BYTE *)(dword_AE408 + 95) != 1 )
      {
        v12 = v9 << 6;
        v21 = v29;
        v11 = v12;
        goto LABEL_21;
      }
      v11 = *(_DWORD *)(v4 + 136) << 6;
      v21 = v27;
    }
    else
    {
      sub_22810(v7, 28, 64, 10, (v8 << 6) / *(_DWORD *)(dword_AE408 + 188), v27);
      v21 = v29;
      v11 = (*(_DWORD *)(v4 + 140) + *(_DWORD *)(*(_DWORD *)(a1 + 160) + 308)) << 6;
      v10 = dword_AE408;
    }
    v12 = v11;
LABEL_21:
    LODWORD(v13) = v12;
    HIDWORD(v13) = v11 >> 31;
    sub_22810(v7, 28, 64, 10, v13 / *(int *)(v10 + 188), v21);
    if ( (*(_BYTE *)dword_AE408 & 0x10) == 0 )
    {
      if ( (word_12F02E & 1) != 0 )
        sub_24C20(v7 + (*(unsigned __int16 *)&byte_38C93[dword_AE400] << 6) / 100, 26, 2, 2, v28);
      else
        sub_24CA0(v7 + (*(unsigned __int16 *)&byte_38C93[dword_AE400] << 6) / 100, 26, 2, 2, v28);
      if ( (word_12F02E & 1) != 0 )
        sub_24C20(v7 + (*(unsigned __int16 *)&byte_38C93[dword_AE400] << 6) / 100, 38, 2, 2, v28);
      else
        sub_24CA0(v7 + (*(unsigned __int16 *)&byte_38C93[dword_AE400] << 6) / 100, 38, 2, 2, v28);
    }
    goto LABEL_29;
  }
  sub_23940(v22, 2, dword_AE42C + 324);
LABEL_29:
  v23 = *(unsigned __int8 *)(dword_AE42C + 250) + v22;
  if ( v4 <= dword_AE400 + 29795 )
  {
    sub_23940(v23, 2, dword_AE42C + 324);
  }
  else
  {
    if ( *(char *)(*(_DWORD *)(a1 + 160) + 393) > 0 && *(_BYTE *)(dword_AE408 + 94) )
    {
      sub_23940(v23, 2, dword_AE42C + 330);
      --*(_BYTE *)(*(_DWORD *)(a1 + 160) + 393);
    }
    else
    {
      sub_23940(v23, 2, dword_AE42C + 246);
    }
    switch ( *(_WORD *)(v4 + 26) )
    {
      case 1:
      case 2:
      case 3:
        v26 = 1;
        break;
      case 4:
      case 5:
        v26 = 2;
        break;
      case 6:
      case 7:
        v26 = 3;
        break;
      default:
        v26 = 0;
        break;
    }
    if ( v26 )
    {
      v14 = v23 + 2;
      if ( (word_12F02E & 1) != 0 )
        sub_60CE0(v14, 2, dword_AE42C + 6 * (v26 + 50));
      else
        sub_60D18(v14, 2, dword_AE42C + 6 * (v26 + 50));
      v15 = v23 + 38;
      if ( (word_12F02E & 1) != 0 )
        sub_60CE0(v15, 2, dword_AE42C + 252);
      else
        sub_60D18(v15, 2, dword_AE42C + 252);
    }
    v16 = 0;
    if ( v26 > 0 )
    {
      v25 = v23 + 58;
      do
      {
        v17 = (_DWORD *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(2 * v16 + *(_DWORD *)(a1 + 160) + 52));
        if ( (unsigned int)v17 > dword_AE400 + 29795 )
        {
          if ( (int)v17[3] >= 0 )
            sub_22810(v25, 2 * v16 + 12, 64, 2, (v17[3] << 6) / v17[2], 0x7Bu);
          sub_22810(v25, 2 * v16 + 30, 64, 2, (v17[35] << 6) / v17[34], v29);
        }
        ++v16;
      }
      while ( v16 < v26 );
    }
  }
  v24 = *(unsigned __int8 *)(dword_AE42C + 250) + v23;
  if ( *(char *)(*(_DWORD *)(a1 + 160) + 392) > 0 && *(_BYTE *)(dword_AE408 + 94) )
  {
    sub_23940(v24, 2, dword_AE42C + 330);
    --*(_BYTE *)(*(_DWORD *)(a1 + 160) + 392);
  }
  else
  {
    sub_23940(v24, 2, dword_AE42C + 246);
  }
  if ( ((*(_BYTE *)(a1 + 16) & 0x30) != 0 || *(_WORD *)(*(_DWORD *)(a1 + 160) + 331)) && *(_BYTE *)(dword_AE408 + 94) )
  {
    sub_23940(v24 + 2, 2, dword_AE42C + 258);
    sub_23940(v24 + 38, 2, dword_AE42C + 252);
  }
  else
  {
    v18 = v24 + 2;
    if ( (word_12F02E & 1) != 0 )
      sub_60CE0(v18, 2, dword_AE42C + 258);
    else
      sub_60D18(v18, 2, dword_AE42C + 258);
    v19 = v24 + 38;
    if ( (word_12F02E & 1) != 0 )
      sub_60CE0(v19, 2, dword_AE42C + 252);
    else
      sub_60D18(v19, 2, dword_AE42C + 252);
  }
  v20 = v24 + 58;
  sub_22810(v24 + 58, 10, 64, 10, (*(_DWORD *)(a1 + 12) << 6) / *(_DWORD *)(a1 + 8), 0x7Bu);
  sub_22810(v24 + 58, 28, 64, 10, (*(_DWORD *)(a1 + 136) << 6) / *(_DWORD *)(dword_AE408 + 188), v27);
  sub_22810(v24 + 58, 28, 64, 10, (*(_DWORD *)(a1 + 140) << 6) / *(_DWORD *)(dword_AE408 + 188), v29);
  if ( (*(_BYTE *)dword_AE408 & 0x10) == 0 )
  {
    if ( (word_12F02E & 1) != 0 )
      sub_24C20(v20 + (*(unsigned __int16 *)&byte_38C93[dword_AE400] << 6) / 100, 26, 2, 2, v28);
    else
      sub_24CA0(v20 + (*(unsigned __int16 *)&byte_38C93[dword_AE400] << 6) / 100, 26, 2, 2, v28);
    if ( (word_12F02E & 1) != 0 )
      sub_24C20(v20 + (*(unsigned __int16 *)&byte_38C93[dword_AE400] << 6) / 100, 38, 2, 2, v28);
    else
      sub_24CA0(v20 + (*(unsigned __int16 *)&byte_38C93[dword_AE400] << 6) / 100, 38, 2, 2, v28);
  }
}
// 23273: conditional instruction was optimized away because %var_24.1==0
// 23562: conditional instruction was optimized away because %var_24.1==0
// 23611: conditional instruction was optimized away because %var_24.1==0
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE42C: using guessed type int dword_AE42C;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00023940) --------------------------------------------------------
char sub_23940(__int16 a1, __int16 a2, int a3)
{
  int v3; // eax
  int v4; // edx
  char *v5; // edx
  _BYTE *v6; // edi
  _BYTE *v7; // ebp
  _BOOL1 v8; // zf
  int v9; // ebx
  char *v10; // esi
  int v11; // ecx
  int v12; // ebp
  char *v13; // edx
  char v14; // bl
  char *v15; // esi
  _BYTE *v16; // edi
  int v17; // ecx
  __int16 v19; // [esp+0h] [ebp-18h]
  int v20; // [esp+4h] [ebp-14h]

  LOBYTE(v3) = a2;
  if ( word_12F02E == 1 )
  {
    if ( a1 >= 0 && a2 >= 0 && a1 + *(unsigned __int8 *)(a3 + 4) <= 640 )
    {
      v4 = *(unsigned __int8 *)(a3 + 5);
      v3 = v4 + a2;
      if ( v3 <= 400 )
      {
        v20 = v4 / 2;
        v5 = *(char **)a3;
        v6 = (_BYTE *)(a2 / 2 * dword_12EFF0 + a1 / 2 + dword_12EFF4);
        LOBYTE(v3) = v20;
        v7 = v6;
        v8 = (_WORD)v20 == 0;
        while ( 1 )
        {
          if ( v8 )
            return v3;
          LOBYTE(v3) = *v5++;
          if ( !(_BYTE)v3 )
            break;
          if ( (v3 & 0x80u) == 0 )
          {
            v9 = (char)v3;
            v10 = v5;
            v11 = (char)v3;
            HIWORD(v3) = 0;
            do
            {
              LOBYTE(v3) = *v10++;
              BYTE1(v3) = *v6;
              LOBYTE(v3) = byte_BB934[v3];
              *v6++ = v3;
              --v11;
            }
            while ( v11 );
            v5 += v9;
LABEL_15:
            v8 = (_WORD)v20 == 0;
          }
          else
          {
            v6 -= (char)v3;
            v8 = (_WORD)v20 == 0;
          }
        }
        v7 += dword_12EFF0;
        LOBYTE(v3) = v20 - 1;
        v6 = v7;
        LOWORD(v20) = v20 - 1;
        goto LABEL_15;
      }
    }
  }
  else if ( a1 >= 0 && a2 >= 0 && a1 + *(unsigned __int8 *)(a3 + 4) <= 640 )
  {
    LOBYTE(v3) = a2;
    if ( a2 + *(unsigned __int8 *)(a3 + 5) <= 480 )
    {
      v3 = dword_12EFF4 + a1 + dword_12EFF0 * a2;
      v19 = *(unsigned __int8 *)(a3 + 5);
      v12 = v3;
      v13 = *(char **)a3;
      if ( *(_BYTE *)(a3 + 5) )
      {
        do
        {
          v14 = *v13++;
          if ( v14 )
          {
            if ( v14 >= 0 )
            {
              v15 = v13;
              v16 = (_BYTE *)v3;
              v17 = v14;
              HIWORD(v3) = 0;
              do
              {
                LOBYTE(v3) = *v15++;
                BYTE1(v3) = *v16;
                *v16++ = byte_BB934[v3];
                --v17;
              }
              while ( v17 );
              v13 += v14;
              v3 = (int)v16;
            }
            else
            {
              v3 -= v14;
            }
          }
          else
          {
            v12 += dword_12EFF0;
            v3 = v12;
            --v19;
          }
        }
        while ( v19 );
      }
    }
  }
  return v3;
}
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00023AE0) --------------------------------------------------------
char sub_23AE0(__int16 a1, __int16 a2, int a3, unsigned __int8 a4)
{
  int v4; // eax
  _BYTE *v5; // edi
  char *v6; // edx
  _BOOL1 v7; // zf
  int v8; // ebp
  int v9; // ebx
  int v10; // ecx
  char *v11; // edx
  char v12; // bl
  _BYTE *v13; // edi
  int v14; // ecx
  int v15; // ebx
  int v17; // [esp+0h] [ebp-20h]
  _BYTE *v18; // [esp+4h] [ebp-1Ch]
  int v19; // [esp+8h] [ebp-18h]
  __int16 v20; // [esp+Ch] [ebp-14h]

  if ( word_12F02E == 1 )
  {
    v19 = (int)*(unsigned __int8 *)(a3 + 5) >> 1;
    LOBYTE(v4) = dword_12EFF4;
    v5 = (_BYTE *)(dword_12EFF4 + a1 / 2 + a2 / 2 * dword_12EFF0);
    v6 = *(char **)a3;
    v18 = v5;
    v7 = (_WORD)v19 == 0;
    while ( 1 )
    {
      if ( v7 )
        return v4;
      LOBYTE(v4) = *v6++;
      if ( !(_BYTE)v4 )
        break;
      if ( (v4 & 0x80u) == 0 )
      {
        v8 = (char)v4;
        v9 = a4;
        v10 = (char)v4;
        do
        {
          BYTE1(v9) = *v5;
          LOBYTE(v4) = byte_BB934[v9];
          *v5++ = v4;
          --v10;
        }
        while ( v10 );
        v6 += v8;
LABEL_11:
        v7 = (_WORD)v19 == 0;
      }
      else
      {
        v5 -= (char)v4;
        v7 = (_WORD)v19 == 0;
      }
    }
    LOBYTE(v4) = dword_12EFF0;
    v18 += dword_12EFF0;
    v5 = v18;
    LOWORD(v19) = v19 - 1;
    goto LABEL_11;
  }
  v20 = *(unsigned __int8 *)(a3 + 5);
  v4 = dword_12EFF0 * a2 + a1 + dword_12EFF4;
  v11 = *(char **)a3;
  v17 = v4;
  if ( *(_BYTE *)(a3 + 5) )
  {
    do
    {
      v12 = *v11++;
      if ( v12 )
      {
        if ( v12 >= 0 )
        {
          v13 = (_BYTE *)v4;
          v14 = v12;
          v15 = a4;
          v11 += v14;
          do
          {
            BYTE1(v15) = *v13;
            *v13++ = byte_BB934[v15];
            --v14;
          }
          while ( v14 );
          v4 = (int)v13;
        }
        else
        {
          v4 -= v12;
        }
      }
      else
      {
        v17 += dword_12EFF0;
        v4 = v17;
        --v20;
      }
    }
    while ( v20 );
  }
  return v4;
}
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00023CF0) --------------------------------------------------------
char sub_23CF0(__int16 a1, __int16 a2, int a3)
{
  sub_23940(a1, a2, dword_AE42C + 18);
  return sub_23AE0(a1, a2, dword_AE42C + 6 * (a3 + 6), 0xA6u);
}
// AE42C: using guessed type int dword_AE42C;

//----- (00023D40) --------------------------------------------------------
char sub_23D40(int a1, int a2, unsigned int a3, char a4)
{
  int v4; // eax
  unsigned int v5; // ebx
  int v6; // eax
  __int16 v7; // dx
  int v8; // eax
  int v9; // edx
  int v10; // edi
  char v11; // dl
  unsigned __int16 v12; // bx
  int v13; // esi
  int v14; // ebx
  int v15; // edx
  int v16; // esi
  int v17; // edi
  int v18; // esi
  unsigned __int16 v19; // cx
  unsigned int v21; // [esp+8h] [ebp-28h]
  int v22; // [esp+Ch] [ebp-24h]
  __int16 v23; // [esp+10h] [ebp-20h]
  unsigned __int16 v24; // [esp+14h] [ebp-1Ch]
  unsigned __int8 v25; // [esp+18h] [ebp-18h]
  unsigned __int8 v26; // [esp+1Ch] [ebp-14h]

  LOBYTE(v4) = dword_AE400 + 99;
  if ( a3 > dword_AE400 + 29795 )
  {
    sub_5A3C0(1);
    LOBYTE(v4) = dword_AE400 + 99;
    v5 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a3 + 42);
    v21 = v5;
    if ( dword_AE400 + 29795 < v5 )
    {
      v6 = *(__int16 *)(*(_DWORD *)(v5 + 160) + 48);
      v25 = byte_99B58[2 * v6];
      v26 = byte_99B59[2 * v6];
      v7 = *(_WORD *)(a3 + 48);
      if ( v7 >= 64 || !v7 || *(__int16 *)(a3 + 50) <= 64 || (LOBYTE(v4) = dword_AE408, !*(_BYTE *)(dword_AE408 + 94)) )
      {
        if ( a4 )
        {
          if ( *(_WORD *)(a3 + 48) )
          {
            if ( (word_12F02E & 1) != 0 )
              sub_60CE0(a1, a2, dword_AE42C + 12);
            else
              sub_60D18(a1, a2, dword_AE42C + 12);
          }
          else if ( (word_12F02E & 1) != 0 )
          {
            sub_60CE0(a1, a2, dword_AE42C + 6);
          }
          else
          {
            sub_60D18(a1, a2, dword_AE42C + 6);
          }
        }
        else
        {
          if ( *(_WORD *)(a3 + 48) )
            v8 = dword_AE42C + 12;
          else
            v8 = dword_AE42C + 6;
          sub_23940(a1, a2, v8);
        }
        if ( (word_12F02E & 1) != 0 )
          sub_60CE0(a1, a2, dword_AE42C + 6 * (*(char *)(a3 + 65) + 6));
        else
          sub_60D18(a1, a2, dword_AE42C + 6 * (*(char *)(a3 + 65) + 6));
        v9 = 56 * (*(_DWORD *)(v5 + 140) % *(_DWORD *)(a3 + 136));
        if ( (word_12F02E & 1) != 0 )
          sub_24C20(a1 + 4, a2 + 36, v9 / *(_DWORD *)(a3 + 136), 4, v26);
        else
          sub_24CA0(a1 + 4, a2 + 36, v9 / *(_DWORD *)(a3 + 136), 4, v26);
        v22 = 0;
        v10 = *(_DWORD *)(v5 + 140) / *(_DWORD *)(a3 + 136);
        v23 = 4;
        do
        {
          if ( !v10 )
            break;
          v13 = 0;
          v12 = a2 + 36;
          v24 = v23 + a1;
          do
          {
            if ( !v10 )
              break;
            if ( (word_12F02E & 1) != 0 )
              sub_61594(v24, v12, v25);
            else
              sub_615D4(v24, v12, v25);
            v12 += 2;
            ++v13;
            --v10;
          }
          while ( v13 < 2 );
          v23 += 2;
          ++v22;
        }
        while ( v22 < 27 );
        if ( *(_BYTE *)(a3 + 62) )
        {
          v11 = *(_BYTE *)(a3 + 61);
          if ( v11 > 0 )
          {
            if ( (word_12F02E & 1) != 0 )
              sub_24C20(a1 + 4, a2 + 36, 55 * v11 / *(char *)(a3 + 62), 4, (unsigned __int8)byte_AD258);
            else
              sub_24CA0(a1 + 4, a2 + 36, 55 * v11 / *(char *)(a3 + 62), 4, (unsigned __int8)byte_AD258);
          }
        }
        v14 = *(_DWORD *)(v21 + 160);
        if ( *(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(v14 + 48) + 14421)
          || (v4 = *(char *)(a3 + 65), *(char *)(v14 + v4 + 844) > 0) )
        {
          v15 = *(char *)(a3 + 65) + *(_DWORD *)(v21 + 160);
          --*(_BYTE *)(v15 + 844);
          v4 = 0;
          v16 = *(_DWORD *)(v21 + 160);
          while ( 1 )
          {
            v17 = *(char *)(v16 + 772);
            if ( v17 != -1 && 164 * *(_DWORD *)(*(_DWORD *)(v21 + 160) + 4 * v17 + 532) + dword_AE400 + 29795 == a3 )
              break;
            ++v4;
            ++v16;
            if ( v4 >= 10 )
              goto LABEL_48;
          }
          LOBYTE(v4) = sub_23AE0(a1, a2, 6 * (v4 + 30) + dword_AE42C, (unsigned char)byte_AD168);
        }
LABEL_48:
        v18 = *(_DWORD *)(a3 + 132);
        if ( v18 )
        {
          v19 = *(_WORD *)(*(_DWORD *)(v21 + 160) + 50);
          if ( !v19 || (LOBYTE(v4) = dword_AE400, v18 > *(_DWORD *)(164 * v19 + dword_AE400 + 29935)) )
            LOBYTE(v4) = sub_247C0(
                           (__int16)a1,
                           (__int16)a1,
                           a2,
                           *(unsigned __int8 *)(dword_AE42C + 10),
                           *(unsigned __int8 *)(dword_AE42C + 11),
                           0x30u);
        }
      }
    }
  }
  return v4;
}
// AD168: using guessed type char byte_AD168;
// AD258: using guessed type char byte_AD258;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE42C: using guessed type int dword_AE42C;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00024230) --------------------------------------------------------
char sub_24230(__int16 a1, __int16 a2, unsigned int a3, char a4)
{
  int v4; // eax
  unsigned int v5; // ebp
  __int16 v6; // dx
  int v7; // eax
  int v8; // edx
  int v9; // edx
  int v10; // edx
  int v11; // ebx
  int v12; // eax

  LOBYTE(v4) = dword_AE400 + 99;
  if ( a3 > dword_AE400 + 29795 )
  {
    sub_5A3C0(1);
    LOBYTE(v4) = dword_AE400 + 99;
    v5 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a3 + 42);
    if ( v5 > dword_AE400 + 29795 )
    {
      v6 = *(_WORD *)(a3 + 48);
      if ( v6 >= 64 || !v6 || *(__int16 *)(a3 + 50) <= 64 || (LOBYTE(v4) = dword_AE408, !*(_BYTE *)(dword_AE408 + 94)) )
      {
        if ( a4 )
        {
          if ( *(_WORD *)(a3 + 48) )
          {
            if ( (word_12F02E & 1) != 0 )
              sub_60CE0(a1, a2, dword_AE42C + 24);
            else
              sub_60D18(a1, a2, dword_AE42C + 24);
          }
          else if ( (word_12F02E & 1) != 0 )
          {
            sub_60CE0(a1, a2, dword_AE42C + 18);
          }
          else
          {
            sub_60D18(a1, a2, dword_AE42C + 18);
          }
        }
        else
        {
          if ( *(_WORD *)(a3 + 48) )
            v7 = dword_AE42C + 24;
          else
            v7 = dword_AE42C + 18;
          sub_23940(a1, a2, v7);
        }
        if ( (word_12F02E & 1) != 0 )
          sub_60CE0(a1, a2, dword_AE42C + 6 * (*(char *)(a3 + 65) + 6));
        else
          sub_60D18(a1, a2, dword_AE42C + 6 * (*(char *)(a3 + 65) + 6));
        v8 = *(_DWORD *)(v5 + 160);
        if ( *(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(v8 + 48) + 14421)
          || (v4 = *(char *)(a3 + 65), *(char *)(v8 + v4 + 844) > 0) )
        {
          v9 = *(_DWORD *)(v5 + 160) + *(char *)(a3 + 65);
          --*(_BYTE *)(v9 + 844);
          v4 = 0;
          v10 = *(_DWORD *)(v5 + 160);
          while ( 1 )
          {
            v11 = *(char *)(v10 + 772);
            if ( v11 != -1 && 164 * *(_DWORD *)(*(_DWORD *)(v5 + 160) + 4 * v11 + 532) + dword_AE400 + 29795 == a3 )
              break;
            ++v4;
            ++v10;
            if ( v4 >= 10 )
              goto LABEL_29;
          }
          LOBYTE(v4) = sub_23AE0(a1, a2, dword_AE42C + 6 * (v4 + 30), (unsigned char)byte_AD168);
        }
LABEL_29:
        if ( *(_DWORD *)(a3 + 132) )
        {
          v12 = *(_DWORD *)(v5 + 160);
          if ( !*(_WORD *)(v12 + 50)
            || (v4 = 41 * *(unsigned __int16 *)(v12 + 50),
                *(_DWORD *)(a3 + 132) > *(_DWORD *)(dword_AE400 + 4 * v4 + 29935)) )
          {
            LOBYTE(v4) = sub_247C0(
                           a1,
                           a1,
                           a2,
                           *(unsigned __int8 *)(dword_AE42C + 22),
                           *(unsigned __int8 *)(dword_AE42C + 23),
                           0x30u);
          }
        }
      }
    }
  }
  return v4;
}
// AD168: using guessed type char byte_AD168;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE42C: using guessed type int dword_AE42C;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (000247C0) --------------------------------------------------------
int sub_247C0(int result, int a2, __int16 a3, __int16 a4, int a5, unsigned __int8 a6)
{
  int v6; // edi
  int v7; // eax
  __int16 i; // si
  _BYTE *v9; // edx

  v6 = a2;
  if ( word_12F02E == 1 )
  {
    HIWORD(v7) = HIWORD(a2);
    LOWORD(v7) = (__int16)a2 / 2;
    v6 = v7;
    a3 /= 2;
    a4 /= 2;
    HIWORD(result) = HIWORD(a5);
    LOWORD(result) = (__int16)a5 / 2;
    LOWORD(a5) = (__int16)a5 / 2;
  }
  for ( i = a3; i < (__int16)a5 + a3; ++i )
  {
    for ( result = v6; (__int16)result < a4 + (__int16)v6; ++result )
    {
      v9 = (_BYTE *)(dword_12EFF4 + dword_12EFF0 * i + (__int16)result);
      *v9 = byte_B7934[256 * a6 + (unsigned __int8)*v9];
    }
  }
  return result;
}
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00024AB0) --------------------------------------------------------
void sub_24AB0()
{
  if ( !byte_9009E )
  {
    byte_9009E = 1;
    byte_90091 = 1;
    sub_40440((int)"data\\screens\\sfont1.dat");
    sub_51360(10, 180, 300, 50);
    sub_51480((int)byte_AE460, &dword_B3288, (unsigned __int8 *)dword_AE428);
    byte_AE466 = sub_5CC70((unsigned __int8 *)dword_AE428, 0x3Fu, 0x3Fu, 0x3Fu);
    word_B329C = 19200;
    dword_B3294 = dword_12EFF4 + 57600;
    sub_24B80();
  }
}
// 90091: using guessed type char byte_90091;
// 9009E: using guessed type char byte_9009E;
// AE428: using guessed type int dword_AE428;
// AE460: using guessed type _BYTE byte_AE460[6];
// AE466: using guessed type char byte_AE466;
// B3288: using guessed type _DWORD dword_B3288;
// B3294: using guessed type int dword_B3294;
// B329C: using guessed type __int16 word_B329C;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (00024B50) --------------------------------------------------------
unsigned __int8 *sub_24B50(unsigned __int8 *a1)
{
  unsigned __int8 *result; // eax

  //fix
  result = 0;
  //fix

  if ( byte_9009E )
  {
    sub_24B80();
    sub_51560(byte_AE460, 0, 0, a1);
    result = a1;
    dword_900A0 = (int)a1;
  }
  return result;
}
// 9009E: using guessed type char byte_9009E;
// 900A0: using guessed type int dword_900A0;
// AE460: using guessed type _BYTE byte_AE460[6];

//----- (00024B80) --------------------------------------------------------
int sub_24B80()
{
  int result; // eax

  //fix
  result = 0;
  //fix

  if ( byte_9009E )
    return (uint32)memset((void*)dword_B3294, 0, (unsigned __int16)word_B329C);
  return result;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 9009E: using guessed type char byte_9009E;
// B3294: using guessed type int dword_B3294;
// B329C: using guessed type __int16 word_B329C;

//----- (00024BB0) --------------------------------------------------------
int sub_24BB0()
{
  int result; // eax

  if ( byte_9009E )
  {
    sub_24B80();
    result = sub_61610((int)"data\\screens\\sfont1.dat");
    byte_90091 = 0;
    byte_9009E = 0;
    dword_900A0 = 0;
  }
  return result;
}
// 90091: using guessed type char byte_90091;
// 9009E: using guessed type char byte_9009E;
// 900A0: using guessed type int dword_900A0;

//----- (00024BF0) --------------------------------------------------------
unsigned __int8 sub_24BF0(unsigned __int8 a1)
{
  unsigned __int8 result; // al

  if ( byte_9009E )
  {
    result = a1;
    byte_AE466 = a1;
    if ( dword_900A0 )
      return (unsigned __int8)sub_24B50((unsigned __int8 *)dword_900A0);
  }
  return result;
}
// 9009E: using guessed type char byte_9009E;
// 900A0: using guessed type int dword_900A0;
// AE466: using guessed type char byte_AE466;

//----- (00024C20) --------------------------------------------------------
void sub_24C20(int a1, int a2, int a3, int a4, unsigned __int16 a5)
{
  if ( a3 >= 2
    && a4 >= 2
    && a1 >= 0
    && a1 + a3 < 640
    && (a1 + a3 >= 0 || a1 < 640)
    && a2 >= 0
    && a2 + a4 < 400
    && (a2 + a4 >= 0 || a2 < 400) )
  {
    sub_61640(a1, a2, a3, a4, a5);
  }
}

//----- (00024CA0) --------------------------------------------------------
void sub_24CA0(int a1, int a2, int a3, int a4, unsigned __int16 a5)
{
  if ( a3 >= 2
    && a4 >= 2
    && a1 >= 0
    && a1 + a3 < 640
    && (a1 + a3 >= 0 || a1 < 640)
    && a2 >= 0
    && a2 + a4 < 480
    && (a2 + a4 >= 0 || a2 < 480) )
  {
    sub_616C0(a1, a2, a3, a4, a5);
  }
}

//----- (00024D20) --------------------------------------------------------
void sub_24D20(int a1, int a2, int a3, int a4, unsigned __int16 a5)
{
  if ( a3 >= 2
    && a4 >= 2
    && a1 >= 0
    && a1 + a3 < 640
    && (a1 + a3 >= 0 || a1 < 640)
    && a2 >= 0
    && a2 + a4 < 400
    && (a2 + a4 >= 0 || a2 < 400) )
  {
    sub_61740(a1, a2, a3, a4, a5);
  }
}

//----- (00024DA0) --------------------------------------------------------
void sub_24DA0(int a1, int a2, int a3, int a4, unsigned __int16 a5)
{
  if ( a3 >= 2
    && a4 >= 2
    && a1 >= 0
    && a1 + a3 < 640
    && (a1 + a3 >= 0 || a1 < 640)
    && a2 >= 0
    && a2 + a4 < 480
    && (a2 + a4 >= 0 || a2 < 480) )
  {
    sub_61810(a1, a2, a3, a4, a5);
  }
}

//----- (00024F60) --------------------------------------------------------
void sub_24F60(int a1)
{
  int v1; // eax
  char v2; // dl
  int v3; // esi
  char v4; // cl
  char v5; // ch
  unsigned int v6; // eax
  unsigned int v7; // eax
  __int16 v8; // dx
  int v9; // eax
  unsigned __int16 v10; // [esp+0h] [ebp-Ch]

  if ( (*(_BYTE *)(a1 + 26) & 3) != 0 )
  {
    --*(_WORD *)(a1 + 26);
  }
  else
  {
    v1 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 12) = v1 - 1;
    if ( v1 >= 0 )
    {
      v2 = *(_BYTE *)(a1 + 16) & 0xFE;
      *(_BYTE *)(a1 + 16) = v2;
      v3 = (__int16)sub_11F50((__int16 *)(a1 + 72));
      if ( (*(_BYTE *)(a1 + 16) & 2) == 0 )
      {
        LOBYTE(v10) = (unsigned __int16)(*(_WORD *)(a1 + 72) + 128) >> 8;
        v4 = *(_BYTE *)(a1 + 18);
        HIBYTE(v10) = (unsigned __int16)(*(_WORD *)(a1 + 74) + 128) >> 8;
        if ( (v4 & 1) == 0 )
          sub_120B0(a1, 0, *(_WORD *)(a1 + 44));
        v5 = byte_CC1E0[v10];
        if ( v5 )
        {
          switch ( v5 )
          {
            case 26:
              sub_33800(v2, v4, v10, 0x14u);
              break;
            case 10:
              sub_33800(v2, v4, v10, 0x15u);
              break;
            case 11:
              sub_33800(v2, v4, v10, 0x16u);
              break;
            default:
              if ( ((unsigned __int8)v5 < 6u || (unsigned __int8)v5 > 0x22u)
                && (byte_FC1E0[v10] & 7) != 1
                && *(__int16 *)(a1 + 76) - v3 <= 128
                && (sub_11760(a1 + 72) & 1) == 0 )
              {
                v6 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
                *(_DWORD *)(a1 + 4) = v6;
                //fix sub_40D30((__int16 *)a1, 0, 0, -(v6 % 7), 1);
              }
              break;
          }
        }
        v7 = 9377 * *(_DWORD *)(a1 + 4);
        *(_BYTE *)(a1 + 16) |= 2u;
        v7 += 9439;
        *(_DWORD *)(a1 + 4) = v7;
        v8 = v7 % 0x41;
        v9 = dword_AE400 + 29795;
        *(_WORD *)(a1 + 46) = v8 - 32;
        sub_55370((a1 - v9) / 164, -1, 3);
      }
      sub_42000(a1 + 72, v3, 0, 0, *(__int16 *)(a1 + 46));
      sub_42510(a1);
    }
    else
    {
      sub_41E80(a1);
    }
  }
}
// AE400: using guessed type int dword_AE400;

//----- (00025130) --------------------------------------------------------
int sub_25130(int a1)
{
  int v1; // eax
  int result; // eax
  char v3; // ah
  int v4; // esi
  unsigned int v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // eax
  int v8; // eax
  unsigned int v9; // edx
  __int16 v10[4]; // [esp+0h] [ebp-1Ch] BYREF
  int v11; // [esp+8h] [ebp-14h] BYREF
  int v12[4]; // [esp+Ch] [ebp-10h] BYREF

  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 < 0 )
    return sub_41E80(a1);
  v3 = *(_BYTE *)(a1 + 16);
  if ( (v3 & 2) == 0 )
  {
    *(_BYTE *)(a1 + 16) = v3 | 2;
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 3);
  }
  result = sub_11410(*(__int16 *)(a1 + 26), *(__int16 *)(a1 + 26));
  v4 = result;
  if ( result )
  {
    while ( sub_114B0(v4, (uint32*)v12, (uint32*)&v11) == 1 )
    {
      v5 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
      *(_DWORD *)(a1 + 4) = v5;
      if ( (int)(2 * (v5 % 0x9D / 79i64) - 1) > 0 )
      {
        v6 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
        *(_DWORD *)(a1 + 4) = v6;
        v10[0] = *(_WORD *)(a1 + 72) - 96 + 192 * LOWORD(v12[0]) + v6 % 0x81 - 64;
        v7 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
        *(_DWORD *)(a1 + 4) = v7;
        v10[1] = *(_WORD *)(a1 + 74) - 96 + 192 * v11 + v7 % 0x81 - 64;
        v10[2] = *(_WORD *)(a1 + 76);
        v8 = sub_373F0((int)v10, 10, 0);
        if ( v8 )
        {
          *(_WORD *)(v8 + 24) = *(_WORD *)(a1 + 24);
          *(_WORD *)(v8 + 30) = *(_WORD *)(a1 + 30);
          v9 = (unsigned int)sub_10000 & *(_DWORD *)(a1 + 16);
          LOBYTE(v9) = v9 | 0x80;
          *(_DWORD *)(v8 + 16) |= v9;
        }
      }
    }
    return sub_11490(v4);
  }
  return result;
}
// 10000: using guessed type void sub_10000();
// AE400: using guessed type int dword_AE400;
// 25130: using guessed type int var_10[4];

//----- (000252B0) --------------------------------------------------------
int sub_252B0(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = result - 1;
  if ( result < 0 )
    return sub_41E80(a1);
  return result;
}

//----- (000252D0) --------------------------------------------------------
int sub_252D0(int a1)
{
  int v1; // eax
  __int16 v2; // cx
  __int16 v3; // si
  char v4; // ah
  unsigned int v5; // eax
  int v6; // eax
  __int16 v7; // dx
  __int16 v8; // di
  int result; // eax

  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 < 0 )
    goto LABEL_11;
  sub_44C10(a1);
  if ( *(int *)(a1 + 12) < 12 )
  {
    if ( *(__int16 *)(a1 + 26) > 0 )
    {
      v3 = *(_WORD *)(a1 + 26);
      --*(_WORD *)(a1 + 86);
      v4 = *(_BYTE *)(a1 + 16);
      *(_WORD *)(a1 + 26) = v3 - 1;
      if ( v4 >= 0 )
      {
        v5 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
        *(_DWORD *)(a1 + 4) = v5;
        if ( !(v5 % 7) )
        {
          v6 = sub_373F0(a1 + 72, 10, 13);
          if ( v6 )
          {
            v7 = *(_WORD *)(a1 + 24);
            *(_WORD *)(v6 + 26) = 100;
            v8 = *(_WORD *)(v6 + 86);
            *(_DWORD *)(v6 + 12) = 15;
            *(_WORD *)(v6 + 24) = v7;
            *(_WORD *)(v6 + 86) = v8 + 2;
          }
        }
      }
    }
  }
  else if ( *(__int16 *)(a1 + 26) <= 6 )
  {
    v2 = *(_WORD *)(a1 + 26) + 1;
    ++*(_WORD *)(a1 + 86);
    *(_WORD *)(a1 + 26) = v2;
  }
  *(_WORD *)(a1 + 76) = *(_WORD *)(a1 + 46) + sub_11F50((__int16 *)(a1 + 72));
  result = sub_11810((__int16 *)(a1 + 72));
  if ( result == 1 )
LABEL_11:
    result = sub_41E80(a1);
  if ( (*(_BYTE *)(a1 + 18) & 1) == 0 )
    return sub_124F0(a1, 0, *(_WORD *)(a1 + 44));
  return result;
}

//----- (000253E0) --------------------------------------------------------
int sub_253E0(int a1)
{
  return sub_41E80(a1);
}

//----- (000253F0) --------------------------------------------------------
int sub_253F0(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = result - 1;
  if ( result < 0 )
    return sub_41E80(a1);
  return result;
}

//----- (00025410) --------------------------------------------------------
void sub_25410(int a1)
{
  int v1; // edx
  int v2; // eax

  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 >= 0 )
  {
    sub_42510(a1);
    if ( (*(_BYTE *)(a1 + 16) & 2) == 0 )
    {
      v2 = dword_AE400 + 29795;
      *(_BYTE *)(a1 + 16) |= 2u;
      sub_55370((a1 - v2) / 164, -1, 27);
    }
  }
  else
  {
    sub_41E80(a1);
  }
}
// AE400: using guessed type int dword_AE400;

//----- (00025470) --------------------------------------------------------
void sub_25470(int a1)
{
  int v1; // eax
  unsigned int v2; // eax
  int v3; // eax

  v1 = *(_DWORD *)(a1 + 12);
  ++*(_WORD *)(a1 + 26);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 < 0
    || (v2 = 9377 * *(_DWORD *)(a1 + 4) + 9439,
        *(_DWORD *)(a1 + 4) = v2,
        (unsigned __int8)sub_40D30((__int16 *)a1, 0, *(__int16 *)(a1 + 26) / 6, v2 % 9, 0)) )
  {
    sub_40D30((__int16 *)a1, 0, 0, -40, 0);
    *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
    *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
    word_AE458 = sub_11F50(&word_AE454);
    v3 = sub_373F0((int)&word_AE454, 10, 18);
    if ( v3 )
      *(_WORD *)(v3 + 24) = *(_WORD *)(a1 + 24);
    sub_41E80(a1);
  }
  else
  {
    sub_127E0(a1, 0, *(_WORD *)(a1 + 44));
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 10);
  }
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE458: using guessed type __int16 word_AE458;

//----- (00025570) --------------------------------------------------------
int sub_25570(int a1)
{
  unsigned int v1; // eax

  if ( (sub_11760(a1 + 72) & 1) == 0 )
  {
    v1 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
    *(_DWORD *)(a1 + 4) = v1;
    //fix
    /*sub_40D30(
      (__int16 *)a1,
      0,
      (int)(*(__int16 *)(a1 + 80)
          - (__CFSHL__((unsigned __int64)*(__int16 *)(a1 + 80) >> 32, 8)
           + ((unsigned __int64)*(__int16 *)(a1 + 80) >> 32 << 8))) >> 8,
      -(v1 % 7),
      1);*/
  }
  return sub_41E80(a1);
}

//----- (000255D0) --------------------------------------------------------
int sub_255D0(__int16 *a1, __int16 a2, __int16 a3)
{
  int v3; // ebx
  int v4; // edi
  int v5; // esi
  int result; // eax
  int v7; // ebx
  int v8; // [esp+0h] [ebp-14h] BYREF
  int v9[4]; // [esp+4h] [ebp-10h] BYREF

  LOWORD(v3) = a3;
  v4 = (a1[36] + 128) >> 8;
  v5 = (a1[37] + 128) >> 8;
  if ( a3 > (int)(a1[40] - (__CFSHL__((unsigned __int64)a1[40] >> 32, 8) + ((unsigned __int64)a1[40] >> 32 << 8))) >> 8 )
    v3 = (int)(a1[40] - (__CFSHL__((unsigned __int64)a1[40] >> 32, 8) + ((unsigned __int64)a1[40] >> 32 << 8))) >> 8;
  result = sub_11410(a2, (__int16)v3);
  v7 = result;
  if ( result )
  {
    while ( sub_114B0(v7, (uint32*)v9, (uint32*)&v8) == 1 )
      sub_40A10(v4 + LOWORD(v9[0]), v5 + v8, -3, 0);
    return sub_11490(v7);
  }
  return result;
}
// 255D0: using guessed type int var_10[4];

//----- (00025670) --------------------------------------------------------
void sub_25670(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // esi
  __int16 v4; // [esp-8h] [ebp-10h]

  if ( !(*(unsigned __int8 *)(a1 + 63) % 3) )
    ++*(_WORD *)(a1 + 26);
  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 < 0 || (sub_11760(a1 + 72) & 1) != 0 )
  {
    sub_41E80(a1);
  }
  else
  {
    if ( (*(_BYTE *)(a1 + 16) & 2) != 0 )
      v2 = *(unsigned __int16 *)(a1 + 44) / 25;
    else
      LOWORD(v2) = *(_WORD *)(a1 + 44);
    sub_127E0(a1, 0, v2);
    LOWORD(v3) = *(_WORD *)(a1 + 26);
    if ( (__int16)v3 > ((int)(*(__int16 *)(a1 + 80)
                            - (__CFSHL__((unsigned __int64)*(__int16 *)(a1 + 80) >> 32, 8)
                             + ((unsigned __int64)*(__int16 *)(a1 + 80) >> 32 << 8))) >> 8)
                     - 1 )
    {
      v3 = ((int)(*(__int16 *)(a1 + 80)
                - (__CFSHL__((unsigned __int64)*(__int16 *)(a1 + 80) >> 32, 8)
                 + ((unsigned __int64)*(__int16 *)(a1 + 80) >> 32 << 8))) >> 8)
         - 1;
      if ( (*(_BYTE *)(a1 + 16) & 2) == 0 )
      {
        v4 = (int)(*(__int16 *)(a1 + 80)
                 - (__CFSHL__((unsigned __int64)*(__int16 *)(a1 + 80) >> 32, 8)
                  + ((unsigned __int64)*(__int16 *)(a1 + 80) >> 32 << 8))) >> 8;
        sub_255D0((__int16 *)a1, v4, v4);
      }
    }
    *(_BYTE *)(a1 + 16) |= 2u;
    sub_255D0((__int16 *)a1, 0, v3);
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 10);
  }
}
// AE400: using guessed type int dword_AE400;

//----- (00025760) --------------------------------------------------------
int sub_25760(int a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 12);
  ++*(_WORD *)(a1 + 26);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 < 0 )
    return sub_41E80(a1);
  sub_42510(a1);
  return sub_120B0(a1, 1u, *(_WORD *)(a1 + 44));
}

//----- (000257B0) --------------------------------------------------------
int sub_257B0(int a1)
{
  int v1; // eax
  __int16 v3; // dx
  __int16 v4; // ax
  __int16 v5; // ax
  __int16 v6; // si
  __int16 v7; // ax

  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 < 0 )
    return sub_41E80(a1);
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  v3 = *(_WORD *)(a1 + 126) - 4;
  *(_WORD *)(a1 + 126) = v3;
  if ( v3 < 64 )
    *(_WORD *)(a1 + 126) = 64;
  if ( *(__int16 *)(a1 + 126) > 128 )
    *(_WORD *)(a1 + 126) = 128;
  word_AE458 += *(_WORD *)(a1 + 126);
  v4 = sub_11F50((__int16 *)(a1 + 72));
  if ( word_AE458 < v4 )
    word_AE458 = v4;
  v5 = *(_WORD *)(a1 + 26) + 1;
  *(_WORD *)(a1 + 26) = v5;
  if ( v5 < 16 )
  {
    sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), 0, 30);
    if ( (*(_BYTE *)(a1 + 26) & 1) == 0 )
      ++*(_WORD *)(a1 + 86);
  }
  if ( *(int *)(a1 + 12) < 6 )
  {
    v6 = *(_WORD *)(a1 + 86);
    if ( v6 > 67 )
      *(_WORD *)(a1 + 86) = v6 - 1;
  }
  v7 = nullsub_11((uint32)&word_AE454);
  return sub_41C70(v7, a1, (int)&word_AE454);
}
// 5B5D0: using guessed type int nullsub_11(_DWORD);
// AE454: using guessed type __int16 word_AE454;
// AE458: using guessed type __int16 word_AE458;

//----- (000258A0) --------------------------------------------------------
int sub_258A0(int a1)
{
  int v1; // eax
  __int16 v3; // dx
  __int16 v4; // ax
  __int16 v5; // ax
  __int16 v6; // ax
  int v7; // eax

  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 < 0 )
    return sub_41E80(a1);
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  v3 = *(_WORD *)(a1 + 126) - 4;
  *(_WORD *)(a1 + 126) = v3;
  if ( v3 < 64 )
    *(_WORD *)(a1 + 126) = 64;
  if ( *(__int16 *)(a1 + 126) > 128 )
    *(_WORD *)(a1 + 126) = 128;
  word_AE458 += *(_WORD *)(a1 + 126);
  v4 = sub_11F50((__int16 *)(a1 + 72));
  if ( word_AE458 < v4 )
    word_AE458 = v4;
  v5 = *(_WORD *)(a1 + 26) + 1;
  *(_WORD *)(a1 + 26) = v5;
  if ( v5 < 16 )
  {
    sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), 0, 30);
    if ( (*(_BYTE *)(a1 + 26) & 1) == 0 )
      ++*(_WORD *)(a1 + 86);
  }
  if ( *(int *)(a1 + 12) < 6 )
    --*(_WORD *)(a1 + 86);
  v6 = nullsub_11((uint32)&word_AE454);
  v7 = sub_41C70(v6, a1, (int)&word_AE454);
  return nullsub_19(v7);
}
// 25980: using guessed type int nullsub_19(_DWORD);
// 5B5D0: using guessed type int nullsub_11(_DWORD);
// AE454: using guessed type __int16 word_AE454;
// AE458: using guessed type __int16 word_AE458;

//----- (00025990) --------------------------------------------------------
int sub_25990(int a1)
{
  __int16 v1; // dx
  int v2; // eax
  int result; // eax
  unsigned int v4; // eax

  if ( (sub_11760(a1 + 72) & 1) != 0 )
  {
    ++*(_WORD *)(a1 + 26);
  }
  else
  {
    v1 = *(_WORD *)(a1 + 26);
    if ( v1 > 0 )
      *(_WORD *)(a1 + 26) = v1 - 1;
  }
  v2 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v2 - 1;
  if ( v2 < 0 || *(__int16 *)(a1 + 26) > 8 )
    return sub_41E80(a1);
  v4 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
  *(_DWORD *)(a1 + 4) = v4;
  *(_WORD *)(a1 + 30) = (v4 % 0x5B + *(_WORD *)(a1 + 30) - 45) & 0x7FF;
  sub_41EC0((_WORD *)(a1 + 72), *(_WORD *)(a1 + 30), 0, 256);
  result = sub_373F0(a1 + 72, 10, 11);
  if ( result )
  {
    *(_DWORD *)(result + 80) = *(_DWORD *)(a1 + 80);
    *(_WORD *)(result + 84) = *(_WORD *)(a1 + 84);
    *(_DWORD *)(result + 12) = 10;
    *(_WORD *)(result + 24) = *(_WORD *)(a1 + 24);
  }
  return result;
}

//----- (00025A60) --------------------------------------------------------
int sub_25A60(int a1)
{
  int v1; // eax
  int result; // eax
  char v3; // ah
  __int16 v4; // di
  __int16 v5; // ax
  __int16 v6; // ax
  __int16 v7; // si
  int v8; // edx
  int v9; // eax
  int v10; // eax
  __int16 v11; // cx
  __int16 v12; // ax
  int v13; // eax
  int v14; // edx

  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 < 0 )
    return sub_41E80(a1);
  v3 = *(_BYTE *)(a1 + 16);
  if ( (v3 & 2) == 0 )
    *(_BYTE *)(a1 + 16) = v3 | 2;
  if ( *(__int16 *)(a1 + 150) < -80 )
    *(_WORD *)(a1 + 150) = -80;
  if ( *(__int16 *)(a1 + 150) > 80 )
    *(_WORD *)(a1 + 150) = 80;
  if ( *(__int16 *)(a1 + 152) < -80 )
    *(_WORD *)(a1 + 152) = -80;
  if ( *(__int16 *)(a1 + 152) > 80 )
    *(_WORD *)(a1 + 152) = 80;
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  v4 = *(_WORD *)(a1 + 152);
  word_AE454 = *(_WORD *)(a1 + 150) + *(_WORD *)(a1 + 72);
  word_AE456 = v4 + *(_WORD *)(a1 + 74);
  v5 = *(_WORD *)(a1 + 46);
  word_AE458 += v5;
  *(_WORD *)(a1 + 46) = v5 - 28;
  if ( (__int16)(v5 - 28) < -384 )
    *(_WORD *)(a1 + 46) = -384;
  if ( *(__int16 *)(a1 + 46) > 256 )
    *(_WORD *)(a1 + 46) = 256;
  v6 = sub_11F50(&word_AE454);
  v7 = v6;
  if ( v6 > word_AE458 )
  {
    v8 = *(__int16 *)(a1 + 46);
    word_AE458 = v6;
    *(_WORD *)(a1 + 46) = -(__int16)((v8 - (__CFSHL__(v8 >> 31, 2) + 4 * (v8 >> 31))) >> 2);
    if ( sub_11810((__int16 *)(a1 + 72)) == 1 )
    {
      v9 = sub_373F0((int)&word_AE454, 10, 5);
      if ( v9 )
      {
        *(_WORD *)(v9 + 24) = *(_WORD *)(a1 + 24);
        sub_41E80(a1);
      }
    }
    else
    {
      if ( !sub_11E50(&word_AE454, 10, 6) )
      {
        v10 = sub_373F0((int)&word_AE454, 10, 6);
        if ( v10 )
        {
          v11 = *(_WORD *)(v10 + 44);
          *(_WORD *)(v10 + 24) = *(_WORD *)(a1 + 24);
          *(_DWORD *)(v10 + 12) = 30;
          *(_WORD *)(v10 + 44) = 3 * v11;
          *(_WORD *)(a1 + 26) = 0;
        }
      }
      if ( *(__int16 *)(a1 + 46) <= 28 )
        *(_WORD *)(a1 + 46) = 0;
    }
  }
  v12 = *(_WORD *)(a1 + 26) + 1;
  *(_WORD *)(a1 + 26) = v12;
  result = sub_41C70(v12, a1, (int)&word_AE454);
  if ( v7 == word_AE458 )
  {
    sub_41F50(a1 + 72, (uint16*)&word_AE454);
    *(_WORD *)(a1 + 150) += word_AE454;
    v13 = 250 * *(__int16 *)(a1 + 150);
    *(_WORD *)(a1 + 152) += word_AE456;
    v14 = *(__int16 *)(a1 + 152);
    *(_WORD *)(a1 + 150) = (v13 - (__CFSHL__(v13 >> 31, 8) + (v13 >> 31 << 8))) >> 8;
    result = (250 * v14 - (__CFSHL__((250 * v14) >> 31, 8) + ((250 * v14) >> 31 << 8))) >> 8;
    *(_WORD *)(a1 + 152) = result;
  }
  return result;
}
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;
// AE458: using guessed type __int16 word_AE458;

//----- (00025CE0) --------------------------------------------------------
__int16 sub_25CE0(int a1)
{
  int v1; // eax
  __int16 result; // ax
  __int64 v3; // rax
  int v4; // edi
  unsigned int v5; // eax
  unsigned int v6; // eax
  int v7; // eax
  int v8; // esi
  __int16 v9[4]; // [esp+0h] [ebp-1Ch] BYREF
  int v10; // [esp+8h] [ebp-14h] BYREF
  int v11[4]; // [esp+Ch] [ebp-10h] BYREF

  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 < 0 )
    return sub_41E80(a1);
  if ( (*(_BYTE *)(a1 + 16) & 2) == 0 )
  {
    *(_DWORD *)(a1 + 16) |= 0x10002u;
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 30);
  }
  v3 = 768 * *(__int16 *)(a1 + 26);
  sub_37130((_WORD *)a1, (int)(v3 - (__CFSHL__(HIDWORD(v3), 2) + 4 * HIDWORD(v3))) >> 2, 512);
  sub_120B0(a1, 0, *(unsigned __int16 *)(a1 + 44) / *(int *)(a1 + 8));
  v4 = sub_11410(*(__int16 *)(a1 + 26), *(__int16 *)(a1 + 26));
  if ( v4 )
  {
    *(_DWORD *)(a1 + 4) = 9377 * *(_DWORD *)(a1 + 4) + 9439;
    while ( sub_114B0(v4, (uint32*)v11, (uint32*)&v10) == 1 )
    {
      v5 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
      *(_DWORD *)(a1 + 4) = v5;
      v9[0] = *(_WORD *)(a1 + 72) - 96 + 160 * LOWORD(v11[0]) + v5 % 0x81 - 64;
      v6 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
      *(_DWORD *)(a1 + 4) = v6;
      v9[1] = v6 % 0x81 + 160 * v10 + *(_WORD *)(a1 + 74) - 96 - 64;
      v9[2] = *(_WORD *)(a1 + 76);
      v7 = sub_373F0((int)v9, 10, 0);
      v8 = v7;
      if ( v7 )
      {
        *(_WORD *)(v7 + 24) = *(_WORD *)(a1 + 24);
        *(_WORD *)(v7 + 30) = *(_WORD *)(a1 + 30);
        *(_DWORD *)(v7 + 16) |= (unsigned int)&loc_10080;
        sub_37130((_WORD *)v7, 512, 512);
        *(_WORD *)(v8 + 26) = 0;
      }
    }
    sub_11490(v4);
  }
  result = (__int16)(*(_WORD *)(a1 + 26) + 2) / 11;
  *(_WORD *)(a1 + 26) = (__int16)(*(_WORD *)(a1 + 26) + 2) % 11;
  return result;
}
// AE400: using guessed type int dword_AE400;
// 25CE0: using guessed type int var_10[4];

//----- (00025EC0) --------------------------------------------------------
void sub_25EC0(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // si
  __int16 v3; // ax
  unsigned int v4; // eax
  __int16 v5; // si
  __int16 v6; // ax
  unsigned int v7; // edx
  int v8; // eax
  int v9; // edi
  int v10; // ebp
  int v11; // eax
  int v12; // edx
  __int16 v13; // di
  int v14; // eax
  int v15; // ebp
  __int16 v16; // ax

  if ( *(__int16 *)(a1 + 26) > 2500 )
  {
    v1 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
    *(_DWORD *)(a1 + 4) = v1;
    if ( !(v1 % 0x64) && !*(_WORD *)(dword_AE400 + 36) )
    {
      v2 = *(_WORD *)(a1 + 76);
      v3 = sub_11F50((__int16 *)(a1 + 72));
      *(_WORD *)(a1 + 76) = v3;
      if ( v2 != v3 )
      {
LABEL_5:
        sub_41E80(a1);
        return;
      }
      *(_WORD *)(a1 + 26) = 0;
    }
  }
  if ( *(__int16 *)(a1 + 26) < 128
    && (*(_BYTE *)(a1 + 26) & 0xF) != 0
    && (v4 = 9377 * *(_DWORD *)(a1 + 4) + 9439, *(_DWORD *)(a1 + 4) = v4, !(v4 % 5))
    || !*(_WORD *)(a1 + 26) )
  {
    v5 = *(_WORD *)(a1 + 76);
    v6 = sub_11F50((__int16 *)(a1 + 72));
    *(_WORD *)(a1 + 76) = v6;
    if ( v5 != v6 )
      goto LABEL_5;
    if ( !*(_WORD *)(a1 + 26) )
    {
      v7 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(dword_AE400 + 36);
      if ( v7 > dword_AE400 + 29795 )
        *(_WORD *)(v7 + 26) = 250;
      *(_WORD *)(dword_AE400 + 36) = (a1 - (dword_AE400 + 29795)) / 164;
      v8 = sub_373F0(a1 + 72, 10, 19);
      v9 = v8;
      if ( v8 )
      {
        *(_WORD *)(v8 + 24) = *(_WORD *)(a1 + 24);
        v10 = 164 * *(unsigned __int16 *)(dword_AE400 + 38);
        if ( dword_AE400 + 29795 + v10 > (unsigned int)(dword_AE400 + 29795) )
          sub_41E80(dword_AE400 + 29795 + v10);
        *(_WORD *)(dword_AE400 + 38) = (v9 - (dword_AE400 + 29795)) / 164;
      }
    }
    v11 = sub_373F0(a1 + 72, 10, 16);
    if ( v11 )
    {
      *(_WORD *)(v11 + 24) = *(_WORD *)(a1 + 24);
      v12 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
      *(_DWORD *)(a1 + 4) = v12;
      *(_DWORD *)(v11 + 4) = v12;
    }
    v13 = *(_WORD *)(a1 + 26);
    *(_BYTE *)(a1 + 31) += 5;
    if ( !v13 )
    {
      v14 = sub_373F0(a1 + 72, 9, 0);
      v15 = v14;
      if ( v14 )
      {
        *(_WORD *)(v14 + 24) = *(_WORD *)(a1 + 24);
        v16 = *(_WORD *)(a1 + 30);
        *(_WORD *)(v15 + 32) = -386;
        *(_BYTE *)(v15 + 68) = 10;
        *(_BYTE *)(v15 + 69) = 17;
        HIBYTE(v16) &= 7u;
        *(_DWORD *)(v15 + 12) = 1;
        *(_WORD *)(v15 + 30) = v16;
        *(_DWORD *)(v15 + 150) = *(_DWORD *)(a1 + 72);
        *(_WORD *)(v15 + 154) = *(_WORD *)(a1 + 76);
        sub_41EC0((_WORD *)(v15 + 150), *(_WORD *)(v15 + 30), 0, 1536);
        *(_WORD *)(v15 + 154) = sub_11F50((__int16 *)(v15 + 150));
      }
    }
    if ( *(__int16 *)(a1 + 26) >= 127 )
    {
      sub_41E80(a1);
      *(_WORD *)(dword_AE400 + 36) = 0;
    }
  }
  ++*(_WORD *)(a1 + 26);
}
// AE400: using guessed type int dword_AE400;

//----- (00026140) --------------------------------------------------------
int sub_26140(int a1)
{
  int v1; // eax
  int v2; // edi
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // eax
  int v6; // esi
  _BOOL1 i; // cf
  int v8; // eax
  __int16 v10[4]; // [esp+0h] [ebp-20h] BYREF
  int v11; // [esp+8h] [ebp-18h] BYREF
  int v12[5]; // [esp+Ch] [ebp-14h] BYREF

  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 >= 0 )
  {
    *(_WORD *)(a1 + 26) = 0;
    v2 = sub_11410(0, *(__int16 *)(a1 + 26));
    if ( v2 )
    {
      while ( sub_114B0(v2, (uint32*)v12, (uint32*)&v11) == 1 )
      {
        v3 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
        *(_DWORD *)(a1 + 4) = v3;
        if ( (int)(2 * (v3 % 0x9D / 79i64) - 1) > 0 )
        {
          v4 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
          *(_DWORD *)(a1 + 4) = v4;
          v10[0] = v4 % 0x81 + *(_WORD *)(a1 + 72) - 96 + 192 * LOWORD(v12[0]) - 64;
          v5 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
          *(_DWORD *)(a1 + 4) = v5;
          v10[1] = v5 % 0x81 + 192 * v11 + *(_WORD *)(a1 + 74) - 96 - 64;
          v10[2] = *(_WORD *)(a1 + 76);
          if ( (*(_BYTE *)(a1 + 12) & 1) != 0 )
          {
            v6 = ((*(_DWORD *)(a1 + 12) / 2) & 1) << 8;
            for ( i = (unsigned __int16)v6 < 0x800u; i; i = (unsigned __int16)v6 < 0x800u )
            {
              v8 = sub_373F0((int)v10, 10, 13);
              if ( v8 )
              {
                *(_WORD *)(v8 + 24) = *(_WORD *)(a1 + 24);
                *(_WORD *)(v8 + 30) = v6;
              }
              LOWORD(v6) = v6 + 512;
            }
          }
        }
      }
      sub_11490(v2);
    }
    *(_WORD *)(a1 + 76) = sub_11F50((__int16 *)(a1 + 72));
  }
  else
  {
    sub_41E80(a1);
  }
  return sub_120B0(a1, 0, *(_WORD *)(a1 + 44));
}
// 26140: using guessed type int var_14[5];

//----- (000262D0) --------------------------------------------------------
void sub_262D0(int a1)
{
  int v1; // eax
  char v2; // dl

  v1 = *(_DWORD *)(a1 + 12);
  ++*(_WORD *)(a1 + 26);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 >= 0 )
  {
    if ( (*(_BYTE *)(a1 + 16) & 2) == 0 )
    {
      sub_120B0(a1, 0, *(_WORD *)(a1 + 44));
      sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 24);
      v2 = *(_BYTE *)(a1 + 16);
      *(_DWORD *)(a1 + 12) = 1;
      *(_BYTE *)(a1 + 16) = v2 | 2;
    }
  }
  else
  {
    sub_41E80(a1);
  }
}
// AE400: using guessed type int dword_AE400;

//----- (00026360) --------------------------------------------------------
int sub_26360(int a1)
{
  int v1; // eax
  int result; // eax
  unsigned __int16 v3; // [esp-4h] [ebp-8h]

  v1 = *(_DWORD *)(a1 + 12);
  ++*(_WORD *)(a1 + 26);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 < 0 )
    return sub_41E80(a1);
  result = sub_42510(a1);
  BYTE1(result) = *(_BYTE *)(a1 + 16);
  if ( (result & 0x200) == 0 )
  {
    v3 = *(_WORD *)(a1 + 44);
    *(_BYTE *)(a1 + 16) |= 2u;
    return sub_120B0(a1, 3u, v3);
  }
  return result;
}

//----- (000263C0) --------------------------------------------------------
int sub_263C0(int a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 12);
  ++*(_WORD *)(a1 + 26);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 < 0 )
    return sub_41E80(a1);
  sub_42510(a1);
  return sub_120B0(a1, 4u, *(_WORD *)(a1 + 44));
}

//----- (000264D0) --------------------------------------------------------
_BOOL1 sub_264D0(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  int v2; // edx
  unsigned __int16 v3; // ax
  _BOOL1 result; // al

  HIBYTE(v1) = HIBYTE(a1);
  LOBYTE(v1) = a1 - 1;
  result = 1;
  if ( byte_CC1E0[v1] == 8 )
  {
    v2 = (unsigned __int16)((unsigned __int8)byte_DC1E0[a1] + 30);
    if ( (unsigned __int8)byte_DC1E0[v1] <= (int)(unsigned __int16)v2 )
    {
      LOBYTE(v1) = v1 + 2;
      if ( (unsigned __int8)byte_DC1E0[v1] <= v2 )
      {
        LOBYTE(v3) = v1 - 1;
        HIBYTE(v3) = HIBYTE(a1) + 1;
        if ( (unsigned __int8)byte_DC1E0[v3] <= v2 )
        {
          HIBYTE(v3) = HIBYTE(a1) - 1;
          if ( (unsigned __int8)byte_DC1E0[v3] <= v2 )
            return 0;
        }
      }
    }
  }
  return result;
}

//----- (00026560) --------------------------------------------------------
int sub_26560(int a1, int a2)
{
  __int16 i; // di
  unsigned __int16 v4; // [esp+0h] [ebp-18h]
  unsigned __int16 v5; // [esp+4h] [ebp-14h]

  LOBYTE(v4) = (unsigned __int16)(*(_WORD *)(a2 + 72) + 128) >> 8;
  HIBYTE(v4) = (unsigned __int16)(*(_WORD *)(a2 + 74) + 128) >> 8;
  if ( v4 % 2 )
    LOBYTE(v4) = v4 + 1;
  LOBYTE(v4) = v4 - *(_BYTE *)(a2 + 12) + 1;
  for ( i = *(_WORD *)(a2 + 12) + *(_WORD *)(a2 + 26); i; --i )
  {
    HIBYTE(v5) = HIBYTE(v4);
    LOBYTE(v5) = v4 - 1;
    byte_FC1E0[v5] |= 0x80u;
    LOWORD(a1) = *(_WORD *)(a2 + 12);
    for ( LOBYTE(v5) = v4; (_WORD)a1; ++v5 )
    {
      if ( byte_CC1E0[v5] != 8 || sub_264D0(v5) )
        byte_DC1E0[v5] += 48;
      sub_33AE0(v5, 8);
      --a1;
    }
    byte_FC1E0[v5] |= 0x80u;
    ++HIBYTE(v4);
  }
  return sub_41E80(a2);
}

//----- (00026670) --------------------------------------------------------
int sub_26670(int a1, _WORD *a2)
{
  __int16 i; // di
  unsigned __int16 v4; // [esp+0h] [ebp-18h]
  char v5; // [esp+4h] [ebp-14h]
  char v6; // [esp+5h] [ebp-13h]

  v5 = (unsigned __int16)(a2[36] + 128) >> 8;
  v6 = ((unsigned __int16)(a2[37] + 128) >> 8) + 2;
  for ( i = a2[6] + a2[13]; i; --i )
  {
    HIBYTE(v4) = v6;
    LOBYTE(v4) = v5 - 1;
    byte_FC1E0[v4] |= 0x80u;
    LOWORD(a1) = a2[6];
    for ( LOBYTE(v4) = v5; (_WORD)a1; ++v4 )
    {
      if ( byte_CC1E0[v4] != 8 || sub_264D0(v4) )
        byte_DC1E0[v4] += 48;
      sub_33AE0(v4, 8);
      --a1;
    }
    byte_FC1E0[v4] |= 0x80u;
    --v6;
  }
  return sub_41E80((int)a2);
}

//----- (00026760) --------------------------------------------------------
int sub_26760(int a1, _WORD *a2)
{
  int v2; // eax
  __int16 j; // di
  unsigned __int16 v5; // [esp+0h] [ebp-18h]
  __int16 v6; // [esp+2h] [ebp-16h]
  unsigned __int16 i; // [esp+4h] [ebp-14h]
  unsigned __int16 k; // [esp+4h] [ebp-14h]
  unsigned __int16 m; // [esp+4h] [ebp-14h]

  //fix
  v6 = 0;
  //fix

  LOBYTE(v5) = (unsigned __int16)(a2[36] + 128) >> 8;
  HIBYTE(v5) = (unsigned __int16)(a2[37] + 128) >> 8;
  if ( ((unsigned __int8)v5 + HIBYTE(v5)) % 2 )
    LOBYTE(v5) = v5 + 1;
  HIWORD(v2) = v6;
  LOWORD(v2) = a2[13];
  for ( i = v5 - 256; (_WORD)v2; ++i )
  {
    byte_FC1E0[i] |= 0x80u;
    --v2;
  }
  for ( j = a2[6]; j; --j )
  {
    LOWORD(a1) = a2[13];
    for ( k = v5; (_WORD)a1; ++k )
    {
      if ( byte_CC1E0[k] != 8 || sub_264D0(k) )
        byte_DC1E0[k] += 48;
      sub_33AE0(k, 8);
      --a1;
    }
    ++HIBYTE(v5);
  }
  LOWORD(a1) = a2[13];
  for ( m = v5; (_WORD)a1; ++m )
  {
    byte_FC1E0[m] |= 0x80u;
    --a1;
  }
  return sub_41E80((int)a2);
}
// 267A8: variable 'v6' is possibly undefined

//----- (00026890) --------------------------------------------------------
int sub_26890(_WORD *a1)
{
  int v1; // ebx
  __int16 v2; // si
  __int16 v4; // [esp+0h] [ebp-14h]
  __int16 i; // [esp+4h] [ebp-10h]

  v1 = ((__int16)a1[36] + 128) >> 8;
  BYTE1(v1) = (unsigned __int16)(a1[37] + 128) >> 8;
  v4 = a1[15];
  v2 = a1[13];
  for ( i = a1[16]; v2; --v2 )
  {
    byte_FC1E0[(unsigned __int16)v1] = byte_FC1E0[(unsigned __int16)v1] & 0xF0 | 1;
    sub_33B90(v1, v1);
    LOBYTE(v1) = v4 + v1;
    BYTE1(v1) += i;
  }
  return sub_41E80((int)a1);
}

//----- (00026920) --------------------------------------------------------
_WORD *sub_26920(int a1)
{
  int v1; // eax
  int v3; // eax
  __int16 v4; // si

  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 < 0 || (sub_11760(a1 + 72) & 1) != 0 )
    return (_WORD *)sub_41E80(a1);
  v3 = sub_373F0(a1 + 72, 10, 11);
  if ( v3 )
  {
    v4 = *(_WORD *)(a1 + 84);
    *(_DWORD *)(v3 + 12) = 2;
    *(_WORD *)(v3 + 84) = v4;
    *(_WORD *)(v3 + 24) = *(_WORD *)(a1 + 24);
  }
  return sub_41EC0((_WORD *)(a1 + 72), *(_WORD *)(a1 + 30), 0, *(_WORD *)(a1 + 126));
}

//----- (000269A0) --------------------------------------------------------
_WORD *sub_269A0(int a1)
{
  int v1; // eax
  unsigned int v3; // eax

  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 < 0 || (sub_11760(a1 + 72) & 1) != 0 )
    return (_WORD *)sub_41E80(a1);
  v3 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
  *(_DWORD *)(a1 + 4) = v3;
  if ( !(unsigned __int8)sub_40D30((__int16 *)a1, 0, 1024, v3 % 0xF + 10, 0) )
  {
    sub_120B0(a1, 0, *(_WORD *)(a1 + 44));
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 10);
  }
  return sub_41EC0((_WORD *)(a1 + 72), *(_WORD *)(a1 + 30), 0, *(_WORD *)(a1 + 126));
}
// AE400: using guessed type int dword_AE400;

//----- (00026A60) --------------------------------------------------------
void sub_26A60(int a1)
{
  int v1; // eax
  int v2; // edx
  int v3; // edi
  int v4; // ebx
  __int16 v5; // ax
  __int16 v6; // ax
  int v7; // [esp+0h] [ebp-1Ch]
  __int16 *v8; // [esp+4h] [ebp-18h]
  unsigned __int16 v9; // [esp+8h] [ebp-14h]

  //fix
  v6 = 0;
  //fix

  if ( (*(_BYTE *)(a1 + 16) & 2) == 0 )
  {
    v1 = dword_AE400 + 29795;
    *(_BYTE *)(a1 + 16) |= 2u;
    sub_55370((a1 - v1) / 164, -1, 21);
  }
  v2 = *(_DWORD *)(a1 + 12);
  if ( v2 > 0 && (*(_DWORD *)(a1 + 12) = v2 - 1, v2 == 1) )
  {
    sub_41E80(a1);
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 20);
  }
  else
  {
    v3 = dword_AE400 + 13323;
    v9 = 0;
    v8 = (__int16 *)(a1 + 72);
    while ( v9 < *(_WORD *)(dword_AE400 + 10) )
    {
      v4 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(v3 + 10);
      if ( sub_11950(a1, v4) )
      {
        v5 = sub_42150((_WORD *)(v4 + 72), (uint16*)v8);
        if ( (unsigned __int16)sub_42210(*(_WORD *)(v4 + 30), v5) < 0xAAu )
        {
          v7 = *(_DWORD *)(a1 + 156);
          *(_WORD *)(a1 + 154) = *(_WORD *)(v7 + 12) + sub_11F50((__int16 *)(a1 + 150));
          sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 22);
          sub_41C70(v6, v4, a1 + 150);
          sub_44BE0(v4, 6);
        }
      }
      v3 += 2049;
      ++v9;
    }
    *(_WORD *)(a1 + 76) = sub_11F50(v8);
  }
}
// 26BAF: variable 'v6' is possibly undefined
// AE400: using guessed type int dword_AE400;

//----- (00026C00) --------------------------------------------------------
int sub_26C00(int a1)
{
  int result; // eax
  unsigned int v2; // esi
  unsigned int v3; // esi
  __int16 v4; // ax
  __int16 v5; // ax

  result = dword_AE400 + 29795;
  v2 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42);
  if ( v2 > dword_AE400 + 29795 )
  {
    if ( *(_DWORD *)(v2 + 12) == 1 )
    {
      return sub_41E80(a1);
    }
    else
    {
      v3 = v2 + 72;
      *(_DWORD *)&word_AE454 = *(_DWORD *)v3;
      *(&word_AE454 + 2) = *(_WORD *)(v3 + 4);
      sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 126));
      v4 = *(_WORD *)(a1 + 30) + 45;
      HIBYTE(v4) &= 7u;
      *(_WORD *)(a1 + 30) = v4;
      v5 = sub_11F50(&word_AE454);
      ++HIBYTE(v5);
      word_AE458 = v5;
      return sub_41C70(v5, a1, (int)&word_AE454);
    }
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE458: using guessed type __int16 word_AE458;

//----- (00026CE0) --------------------------------------------------------
int sub_26CE0(int a1)
{
  int result; // eax
  int v2; // edx
  char v3; // dl

  result = a1;
  ++*(_WORD *)(a1 + 26);
  v2 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v2 - 1;
  if ( v2 < 0 )
    return sub_41E80(a1);
  v3 = *(_BYTE *)(a1 + 16);
  if ( (v3 & 2) == 0 )
    *(_BYTE *)(a1 + 16) = v3 | 2;
  return result;
}

//----- (00026D20) --------------------------------------------------------
void sub_26D20(int a1)
{
  __int16 v1; // bx
  __int16 v2; // dx
  int v3; // edx
  int v4; // eax
  __int16 v5; // ax
  int v6; // eax
  int v7; // ebx
  int v8; // esi
  __int16 v9; // ax
  int v10; // [esp-8h] [ebp-20h]
  int v11; // [esp-4h] [ebp-1Ch]
  int i; // [esp+4h] [ebp-14h]

  v1 = 0;
  v2 = sub_11F50((__int16 *)(a1 + 72));
  if ( *(__int16 *)(a1 + 76) < v2 + 1024 )
  {
    v1 = 1;
    *(_WORD *)(a1 + 76) += 64;
  }
  if ( *(__int16 *)(a1 + 76) > v2 + 1024 )
  {
    HIBYTE(v2) += 4;
    v1 = 1;
    *(_WORD *)(a1 + 76) = v2;
  }
  if ( !v1 )
  {
    v3 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 12) = v3 - 1;
    if ( v3 >= 0 )
    {
      v4 = 9377 * *(_DWORD *)(a1 + 4);
      *(_WORD *)(a1 + 32) = 56;
      v4 += 9439;
      *(_DWORD *)(a1 + 4) = v4;
      *(_WORD *)(a1 + 30) = v4 & 0x7FF;
      for ( i = 0; i < 2; ++i )
      {
        v5 = *(_WORD *)(a1 + 30);
        HIBYTE(v5) = (HIBYTE(v5) + 4) & 7;
        *(_WORD *)(a1 + 30) = v5;
        *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
        *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
        v11 = *(char *)(a1 + 69);
        v10 = *(char *)(a1 + 68);
        word_AE458 += *(_WORD *)(a1 + 78);
        v6 = sub_373F0(a1 + 72, v10, v11);
        v7 = v6;
        v8 = v6;
        if ( v6 )
        {
          *(_WORD *)(v6 + 24) = *(_WORD *)(a1 + 24);
          *(int *)(v6 + 12) /= 3;
          *(_WORD *)(v6 + 30) = *(_WORD *)(a1 + 30);
          *(_WORD *)(v6 + 32) = *(_WORD *)(a1 + 32);
          v9 = *(_WORD *)(a1 + 44);
          *(_BYTE *)(v7 + 68) = 10;
          *(_BYTE *)(v7 + 69) = 23;
          *(_WORD *)(v7 + 44) = v9;
        }
      }
      sub_55370((v8 - (dword_AE400 + 29795)) / 164, -1, 23);
    }
    else
    {
      sub_41E80(a1);
    }
  }
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE458: using guessed type __int16 word_AE458;

//----- (00026E90) --------------------------------------------------------
int sub_26E90(int a1)
{
  int v1; // eax
  unsigned int i; // edx
  int v3; // eax
  int v4; // ebx
  __int16 v5; // ax
  __int16 v7; // [esp+0h] [ebp-24h]
  int v8; // [esp+4h] [ebp-20h]
  int v9; // [esp+8h] [ebp-1Ch]
  unsigned __int16 v10; // [esp+Ch] [ebp-18h]
  int v11; // [esp+10h] [ebp-14h]

  *(_WORD *)(a1 + 44) = 10000;
  if ( *(_WORD *)(a1 + 44) )
  {
    v9 = sub_37710();
    if ( (v9 & 0x8000u) != 0 )
      v9 = 0;
    if ( (__int16)v9 > 8 )
      v9 = 8;
    v1 = 0;
    for ( i = *(_DWORD *)(dword_AE408 + 36418); i > dword_AE400 + 29795; i = *(_DWORD *)i )
    {
      if ( *(unsigned __int16 *)(i + 144) == *(__int16 *)(a1 + 24) )
        ++v1;
    }
    if ( (__int16)v9 > 64 - (unsigned __int16)v1 )
      v9 = 64 - v1;
    if ( (__int16)v9 > 0 )
    {
      LOWORD(v1) = *(_WORD *)(a1 + 44);
      v8 = v1;
      v11 = (__int16)v1 / (__int16)v9;
      v10 = 0;
      v7 = 2048 / (__int16)v9;
      do
      {
        *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
        *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
        sub_41EC0((uint16*)&word_AE454, v10, 0, 512);
        v3 = sub_373F0((int)&word_AE454, 5, 9);
        v4 = v3;
        if ( v3 )
        {
          *(_DWORD *)(v3 + 140) = (__int16)v8 % (__int16)v11;
          *(_WORD *)(v3 + 144) = *(_WORD *)(a1 + 24);
          LOBYTE(v5) = v10;
          HIBYTE(v5) = (HIBYTE(v10) + 4) & 7;
          *(_WORD *)(v4 + 34) = v5;
          *(_WORD *)(v4 + 30) = v5;
          v8 -= v11;
        }
        --v9;
        v10 += v7;
      }
      while ( (__int16)v9 > 0 );
    }
  }
  return sub_41E80(a1);
}
// 26F74: conditional instruction was optimized away because %var_1C.2>=1
// 26F0A: conditional instruction was optimized away because %var_1C.2<9u
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE454: using guessed type __int16 word_AE454;

//----- (00027030) --------------------------------------------------------
void sub_27030(int a1)
{
  __int16 v1; // dx
  unsigned __int16 v2; // si
  __int16 v3; // si
  int v4; // eax
  __int16 v5; // ax
  unsigned __int16 v6; // dx
  signed int v7; // eax
  int v8; // eax
  __int16 v9; // si
  __int16 v10; // ax
  __int16 v11; // cx
  __int16 v12; // ax
  int v13; // eax
  __int16 v14; // si
  int v15; // eax
  int v16; // eax
  int v17; // edx
  unsigned __int16 v18; // [esp-Ch] [ebp-18h]
  _WORD *v19; // [esp-4h] [ebp-10h]

  v1 = *(_WORD *)(a1 + 100);
  if ( v1 )
  {
    if ( v1 != *(_WORD *)(a1 + 144) )
    {
      *(_WORD *)(a1 + 144) = v1;
      sub_55370(v1, -1, 4);
      *(_BYTE *)(a1 + 16) &= ~0x40u;
    }
    *(_WORD *)(a1 + 100) = 0;
    *(_DWORD *)(a1 + 96) = 0;
  }
  v2 = *(_WORD *)(a1 + 118);
  if ( v2 )
  {
    *(_WORD *)(a1 + 30) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(164 * v2 + dword_AE400 + 29795 + 72));
    v18 = *(_WORD *)(a1 + 30);
    word_AE454 = 0;
    word_AE456 = 0;
    word_AE458 = 0;
    sub_41EC0((uint16*)&word_AE454, v18, 0, 4);
    *(_WORD *)(a1 + 150) += word_AE454;
    v3 = word_AE456 + *(_WORD *)(a1 + 152);
    *(_WORD *)(a1 + 118) = 0;
    *(_WORD *)(a1 + 152) = v3;
  }
  if ( (*(_BYTE *)(a1 + 16) & 0x40) != 0 )
  {
    v4 = dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 146);
    if ( *(_BYTE *)(v4 + 29859) == 3 && *(_BYTE *)(v4 + 29860) == 3 )
    {
      v19 = (_WORD *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 146) + 72);
      *(_WORD *)(a1 + 46) = 128;
      v5 = sub_42150((_WORD *)(a1 + 72), v19);
      v6 = *(_WORD *)(a1 + 146);
      *(_WORD *)(a1 + 30) = v5;
      v7 = sub_423D0((_WORD *)(a1 + 72), (_WORD *)(164 * v6 + dword_AE400 + 29795 + 72));
      if ( v7 <= 1024 )
      {
        if ( v7 >= 16 )
        {
          *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
          *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
          sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), 0, 16);
        }
        else
        {
          *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
          *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
          v8 = dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 146);
          word_AE454 = *(_WORD *)(v8 + 29867);
          v9 = *(_WORD *)(v8 + 29871);
          word_AE456 = *(_WORD *)(v8 + 29869);
          if ( word_AE458 >= v9 )
          {
            if ( word_AE458 > v9 + 512 )
              word_AE458 -= 32;
          }
          else
          {
            word_AE458 += 32;
          }
        }
        v10 = sub_11F50(&word_AE454);
        if ( v10 > word_AE458 )
          word_AE458 = v10;
        sub_41C70(v10, a1, (int)&word_AE454);
      }
      else
      {
        *(_BYTE *)(a1 + 16) &= ~0x40u;
      }
    }
    else
    {
      *(_BYTE *)(a1 + 16) &= ~0x40u;
    }
  }
  else if ( *(_BYTE *)(a1 + 58) )
  {
    if ( *(__int16 *)(a1 + 150) < -64 )
      *(_WORD *)(a1 + 150) = -64;
    if ( *(__int16 *)(a1 + 150) > 64 )
      *(_WORD *)(a1 + 150) = 64;
    if ( *(__int16 *)(a1 + 152) < -64 )
      *(_WORD *)(a1 + 152) = -64;
    if ( *(__int16 *)(a1 + 152) > 64 )
      *(_WORD *)(a1 + 152) = 64;
    *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
    *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
    v11 = *(_WORD *)(a1 + 152);
    word_AE454 = *(_WORD *)(a1 + 150) + *(_WORD *)(a1 + 72);
    word_AE456 = v11 + *(_WORD *)(a1 + 74);
    v12 = *(_WORD *)(a1 + 46);
    word_AE458 += v12;
    *(_WORD *)(a1 + 46) = v12 - 16;
    if ( (__int16)(v12 - 16) < -128 )
      *(_WORD *)(a1 + 46) = -128;
    LOWORD(v13) = sub_11F50(&word_AE454);
    v14 = v13;
    if ( (__int16)v13 > word_AE458 )
    {
      v13 = -((int)(*(__int16 *)(a1 + 46)
                  - (__CFSHL__((unsigned __int64)*(__int16 *)(a1 + 46) >> 32, 2)
                   + 4 * ((unsigned __int64)*(__int16 *)(a1 + 46) >> 32))) >> 2);
      *(_WORD *)(a1 + 46) = v13;
      if ( (__int16)v13 <= 16 )
        *(_WORD *)(a1 + 46) = 0;
      word_AE458 = v14;
    }
    sub_41C70(v13, a1, (int)&word_AE454);
    if ( v14 == word_AE458 )
    {
      v15 = sub_11D10(a1);
      if ( v15 )
        sub_277D0(a1, v15);
      sub_41F50(a1 + 72, (uint16*)&word_AE454);
      *(_WORD *)(a1 + 150) += word_AE454;
      v16 = 250 * *(__int16 *)(a1 + 150);
      *(_WORD *)(a1 + 152) += word_AE456;
      v17 = *(__int16 *)(a1 + 152);
      *(_WORD *)(a1 + 150) = (v16 - (__CFSHL__(v16 >> 31, 8) + (v16 >> 31 << 8))) >> 8;
      *(_WORD *)(a1 + 152) = (250 * v17 - (__CFSHL__((250 * v17) >> 31, 8) + ((250 * v17) >> 31 << 8))) >> 8;
    }
    sub_274D0(a1);
  }
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;
// AE458: using guessed type __int16 word_AE458;

//----- (000274D0) --------------------------------------------------------
__int16 sub_274D0(int a1)
{
  __int16 v1; // cx
  __int16 i; // bx
  unsigned int v3; // eax
  int v4; // eax

  for ( i = 0; i < 7; ++i )
  {
    if ( *(_DWORD *)(a1 + 140) <= dword_900A4[i] )
      break;
  }
  v3 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 144);
  if ( v3 > dword_AE400 + 29795 && *(_BYTE *)(v3 + 64) == 3 )
  {
    switch ( *(_WORD *)(*(_DWORD *)(v3 + 160) + 48) )
    {
      case 0xFFFF:
        goto LABEL_15;
      case 0:
        v1 = 105;
        break;
      case 1:
        v1 = 113;
        break;
      case 2:
        v1 = 121;
        break;
      case 3:
        v1 = 129;
        break;
      case 4:
        v1 = 137;
        break;
      case 5:
        v1 = 145;
        break;
      case 6:
        v1 = 153;
        break;
      case 7:
        v1 = 161;
        break;
      default:
        break;
    }
  }
  else
  {
LABEL_15:
    v1 = 52;
  }
  v4 = *(__int16 *)(a1 + 86);
  if ( v4 != v1 + i )
  {
    LOWORD(v4) = sub_36FA0(a1, v1 + i);
    if ( i )
      LOWORD(v4) = sub_370E0((__int16 *)a1, v1 + i);
  }
  return v4;
}
// 27589: variable 'v1' is possibly undefined
// 900A4: using guessed type int dword_900A4[8];
// AE400: using guessed type int dword_AE400;

//----- (000275C0) --------------------------------------------------------
int sub_275C0(__int16 *a1)
{
  int result; // eax
  __int16 v2; // dx
  int v3; // edi
  unsigned int i; // ebx

  result = sub_11F50(a1 + 36);
  v2 = a1[50];
  a1[38] = result;
  if ( v2 )
  {
    v3 = 164 * (unsigned __int16)a1[50] + dword_AE400 + 29795;
    if ( *(_BYTE *)(v3 + 64) == 3 && !a1[72] )
    {
      for ( i = dword_AE400 + 29959; i < dword_AE400 + 193795; i += 164 )
      {
        if ( *(unsigned __int16 *)(i + 144) == ((int)a1 - dword_AE400 - 29795) / 164 )
          *(_WORD *)(i + 144) = (v3 - (dword_AE400 + 29795)) / 164;
      }
    }
    a1[50] = 0;
    return sub_41E80((int)a1);
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00027690) --------------------------------------------------------
_WORD* sub_27690fix(_WORD *result, int a2)
{
  _WORD *v2; // ebx
  int v3; // ecx
  unsigned int v4; // eax
  int v5; // ebp
  int v6; // ebp
  __int16 v7; // ax

  if ( *(int *)(a2 + 140) > 0 )
  {
    *(_DWORD *)(a2 + 4) = 9377 * *(_DWORD *)(a2 + 4) + 9439;
    result = (_WORD *)sub_373F0(a2 + 72, 10, 39);
    v2 = result;
    if ( result )
    {
      *((_DWORD *)result + 35) = *(_DWORD *)(a2 + 140);
      v3 = *((_DWORD *)result + 1);
      result[72] = *(_WORD *)(a2 + 144);
      v4 = 9377 * v3 + 9439;
      *((_DWORD *)v2 + 1) = v4;
      v5 = *((_DWORD *)v2 + 1);
      v2[15] = (v4 % 0x71 + *(_WORD *)(a2 + 30) - 56) & 0x7FF;
      *((_DWORD *)v2 + 1) = 9377 * v5 + 9439;
      v2[75] = 0;
      v2[76] = 0;
      v2[63] = (9377 * v5 + 9439) % 0x30u + 16;
      v6 = *(__int16 *)(a2 + 76);
      v7 = sub_11F50((__int16 *)(a2 + 72));
      v2[23] = (1024 - (v6 - v7) - (__CFSHL__((1024 - (v6 - v7)) >> 31, 3) + 8 * ((1024 - (v6 - v7)) >> 31))) >> 3;
      result = sub_41EC0(v2 + 75, v2[15], 0, v2[63]);
    }
    *(_WORD *)(a2 + 144) = 0;
  }
  return result;
}

//----- (000277D0) --------------------------------------------------------
int sub_277D0(int a1, int a2)
{
  int v2; // eax
  unsigned __int16 v3; // si
  int v4; // edx
  int v5; // eax
  int v6; // ebp
  int v7; // edx
  int v8; // eax
  int v9; // eax
  int v11; // eax
  __int64 v12; // rtt

  if ( *(_WORD *)(a1 + 144) || *(_WORD *)(a2 + 144) )
  {
    if ( !*(_WORD *)(a1 + 144) )
    {
      *(_DWORD *)(a1 + 140) += *(_DWORD *)(a2 + 140);
      LOWORD(v2) = *(_WORD *)(a2 + 144);
LABEL_20:
      *(_WORD *)(a1 + 144) = v2;
      return sub_41E90(v2, a2);
    }
    if ( *(_WORD *)(a2 + 144) )
    {
      v3 = *(_WORD *)(a2 + 144);
      v4 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 144);
      v5 = dword_AE400 + 29795 + 164 * v3;
      if ( *(_BYTE *)(v4 + 64) != 10 || *(_BYTE *)(v5 + 64) != 10 )
      {
        if ( *(_BYTE *)(v4 + 64) == 10 )
        {
          *(_DWORD *)(a1 + 140) += *(_DWORD *)(a2 + 140);
          v2 = 164 * v3 / 164;
          goto LABEL_20;
        }
        if ( *(_BYTE *)(v5 + 64) == 10 )
        {
          v6 = *(_DWORD *)(a2 + 140) + *(_DWORD *)(a1 + 140);
          v7 = 164 * *(unsigned __int16 *)(a1 + 144);
          v8 = v7;
          goto LABEL_19;
        }
        if ( v4 != v5 )
        {
          if ( *(_DWORD *)(v4 + 136) > *(_DWORD *)(v5 + 136) )
          {
            v11 = dword_AE400 + 29795;
            *(_DWORD *)(a1 + 140) += *(_DWORD *)(a2 + 140);
            v2 = (v4 - v11) / 164;
            goto LABEL_20;
          }
          v6 = *(_DWORD *)(a2 + 140) + *(_DWORD *)(a1 + 140);
          v8 = 164 * v3;
          v7 = v8;
LABEL_19:
          LODWORD(v12) = v8;
          HIDWORD(v12) = v7 >> 31;
          v2 = v12 / 164;
          *(_DWORD *)(a1 + 140) = v6;
          goto LABEL_20;
        }
      }
    }
    v9 = *(_DWORD *)(a2 + 140);
    *(_DWORD *)(a1 + 140) += v9;
    return sub_41E90(v9, a2);
  }
  v2 = *(_DWORD *)(a2 + 140);
  *(_DWORD *)(a1 + 140) += v2;
  return sub_41E90(v2, a2);
}
// AE400: using guessed type int dword_AE400;

//----- (000279D0) --------------------------------------------------------
char sub_279D0(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // edi
  unsigned int v4; // eax
  unsigned __int16 v5; // bx
  char v6; // al
  int v7; // ebp
  unsigned __int8 v8; // al
  int v9; // eax
  char v10; // ch
  char v11; // dl
  __int16 v12; // dx
  __int16 v13; // dx
  char v14; // cl
  unsigned __int16 v15; // bx
  char result; // al
  int v17; // esi
  int v18; // ebp
  char v19; // cl
  __int16 v20; // dx
  unsigned int v21; // eax
  unsigned __int8 v22; // al
  unsigned int v23; // [esp+0h] [ebp-38h]
  unsigned int v24; // [esp+8h] [ebp-30h]
  unsigned int v25; // [esp+Ch] [ebp-2Ch]
  unsigned __int16 v26; // [esp+10h] [ebp-28h]
  __int16 v27; // [esp+14h] [ebp-24h]
  unsigned __int16 v28; // [esp+18h] [ebp-20h]
  unsigned __int16 v29; // [esp+18h] [ebp-20h]
  unsigned __int8 v30; // [esp+20h] [ebp-18h]

  v27 = *(__int16 *)(a1 + 76) >> 5;
  v1 = dword_AE440 + 6 * *(unsigned __int8 *)(a1 + 71);
  v2 = 0;
  v3 = *(_DWORD *)v1;
  v25 = *(unsigned __int8 *)(v1 + 5);
  v4 = *(unsigned __int8 *)(v1 + 4);
  if ( word_12F02E == 1 )
  {
    v4 >>= 1;
    v25 >>= 1;
  }
  LOBYTE(v28) = ((unsigned __int16)(*(_WORD *)(a1 + 72) + 128) >> 8) - (v4 >> 1);
  HIBYTE(v28) = ((unsigned __int16)(*(_WORD *)(a1 + 74) + 128) >> 8) - (v25 >> 1);
  v26 = v28;
  v5 = v28;
  v24 = v25;
  if ( v25 )
  {
    while ( 1 )
    {
      v6 = *(_BYTE *)(v3 + v2++);
      if ( v6 )
        break;
      ++HIBYTE(v28);
      --v25;
      v5 = v28;
LABEL_26:
      if ( !v25 )
        goto LABEL_27;
    }
    if ( v6 < 0 )
    {
      LOBYTE(v5) = v5 - v6;
      goto LABEL_26;
    }
    v7 = v6;
    while ( 1 )
    {
      v8 = *(_BYTE *)(v3 + v2++);
      if ( v8 < 0xFu )
      {
        if ( v8 <= 6u )
          goto LABEL_25;
        v9 = v5;
        v10 = byte_FC1E0[v5];
        byte_DC1E0[v5] = v27;
        if ( (v10 & 7) != 0 )
          goto LABEL_25;
        v11 = v10;
        goto LABEL_24;
      }
      v12 = v8 % 16;
      if ( (int)v8 >> 4 != 3 )
        break;
      v13 = (unsigned __int8)v12 % 3;
      if ( (_BYTE)v13 )
      {
        if ( (unsigned __int8)v13 > 1u )
        {
          if ( (_BYTE)v13 != 2 )
            goto LABEL_25;
          v9 = v5;
          byte_DC1E0[v5] = v27 + 16;
          if ( (byte_FC1E0[v5] & 7) != 0 )
            goto LABEL_25;
          v11 = byte_FC1E0[v5];
          goto LABEL_24;
        }
        v9 = v5;
        v14 = byte_FC1E0[v5];
        byte_DC1E0[v5] = v27 + 12;
        if ( (v14 & 7) == 0 )
        {
          v11 = v14;
LABEL_24:
          byte_FC1E0[v9] = v11 & 0xF8 | 1;
          sub_33B90(v5, v5);
        }
      }
LABEL_25:
      LOBYTE(v5) = v5 + 1;
      if ( !--v7 )
        goto LABEL_26;
    }
    if ( !(_BYTE)v12 )
      goto LABEL_25;
    v9 = v5;
    byte_DC1E0[v5] = 4 * (v12 - 1) + v27;
    v11 = byte_FC1E0[v5];
    if ( (v11 & 7) != 0 )
      goto LABEL_25;
    goto LABEL_24;
  }
LABEL_27:
  v23 = v24;
  v29 = v26;
  v15 = v26;
  result = v24;
  v17 = 0;
  if ( v24 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        result = *(_BYTE *)(v3 + v17++);
        if ( result )
          break;
        ++HIBYTE(v29);
        result = v23 - 1;
        v15 = v29;
        --v23;
LABEL_44:
        if ( !v23 )
          return result;
      }
      if ( result >= 0 )
        break;
      LOBYTE(v15) = v15 - result;
      if ( !v23 )
        return result;
    }
    v18 = result;
    while ( 1 )
    {
      v30 = *(_BYTE *)(v3 + v17);
      v19 = v30;
      LOBYTE(v20) = 0;
      v21 = (int)v30 >> 4;
      ++v17;
      if ( v21 )
        break;
      v19 = 7;
      v20 = v30 % 7;
      result = v20;
      if ( (_BYTE)v20 )
      {
        v22 = v20 - 1;
LABEL_42:
        result = sub_33800(v20, v19, v15, v22);
      }
      LOBYTE(v15) = v15 + 1;
      if ( !--v18 )
        goto LABEL_44;
    }
    if ( v21 <= 2 )
    {
      v22 = v21 + 7;
    }
    else if ( v21 == 3 )
    {
      v20 = v30 % 16 % 3;
      v19 = v30 % 16 / 3 + 10;
      v22 = v19;
    }
    else
    {
      LOBYTE(v20) = 0;
      v22 = ((int)v30 >> 4) + 11;
    }
    goto LABEL_42;
  }
  return result;
}
// 27AD5: conditional instruction was optimized away because al.1>=1
// 27C5D: conditional instruction was optimized away because al.1>=1
// AE440: using guessed type int dword_AE440;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00027D30) --------------------------------------------------------
char sub_27D30(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // ebp
  unsigned int v4; // eax
  unsigned int v5; // ebx
  unsigned __int16 v6; // bx
  char v7; // al
  unsigned __int8 v8; // al
  int v9; // ecx
  char v10; // dl
  char v11; // al
  __int16 v12; // ax
  __int16 v13; // dx
  char v14; // dh
  unsigned __int16 v15; // bx
  int v16; // eax
  int v17; // esi
  int v18; // edi
  _BOOL1 i; // zf
  char v20; // cl
  __int16 v21; // dx
  unsigned int v22; // eax
  unsigned __int8 v23; // al
  unsigned __int16 v24; // dx
  __int16 v25; // ax
  int v26; // ebx
  unsigned int v28; // [esp+0h] [ebp-38h]
  unsigned int v29; // [esp+4h] [ebp-34h]
  unsigned int v30; // [esp+8h] [ebp-30h]
  int v31; // [esp+Ch] [ebp-2Ch]
  unsigned int v32; // [esp+10h] [ebp-28h]
  int v33; // [esp+14h] [ebp-24h]
  unsigned __int16 v34; // [esp+18h] [ebp-20h]
  char v35; // [esp+1Ch] [ebp-1Ch]
  unsigned __int16 v36; // [esp+1Ch] [ebp-1Ch]
  unsigned __int16 v37; // [esp+1Ch] [ebp-1Ch]
  unsigned __int8 v38; // [esp+1Dh] [ebp-1Bh]
  int v39; // [esp+20h] [ebp-18h]
  unsigned __int8 v40; // [esp+24h] [ebp-14h]

  v35 = (unsigned __int16)(*(_WORD *)(a1 + 72) + 128) >> 8;
  v38 = (unsigned __int16)(*(_WORD *)(a1 + 74) + 128) >> 8;
  v39 = *(__int16 *)(a1 + 76) >> 5;
  v1 = dword_AE440 + 6 * *(unsigned __int8 *)(a1 + 71);
  v2 = 0;
  v3 = *(_DWORD *)v1;
  v29 = *(unsigned __int8 *)(v1 + 5);
  v4 = *(unsigned __int8 *)(v1 + 4);
  if ( word_12F02E == 1 )
  {
    v4 >>= 1;
    v29 >>= 1;
  }
  v32 = v4 >> 1;
  --*(_DWORD *)(a1 + 12);
  v5 = v29 >> 1;
  if ( *(_DWORD *)(a1 + 12) )
  {
    LOBYTE(v36) = v35 - v32;
    HIBYTE(v36) = v38 - v5;
    v34 = v36;
    v6 = v36;
    v28 = v29;
    if ( v29 )
    {
      while ( 1 )
      {
        v7 = *(_BYTE *)(v2 + v3);
        ++v2;
        if ( v7 )
          break;
        ++HIBYTE(v36);
        --v29;
        v6 = v36;
LABEL_28:
        if ( !v29 )
          goto LABEL_29;
      }
      if ( v7 < 0 )
      {
        LOBYTE(v6) = v6 - v7;
        goto LABEL_28;
      }
      v33 = v7;
      while ( 1 )
      {
        v8 = *(_BYTE *)(v2 + v3);
        ++v2;
        if ( v8 < 0xFu )
        {
          if ( v8 <= 6u )
            goto LABEL_27;
          v9 = v6;
          v10 = byte_FC1E0[v6];
          byte_DC1E0[v6] += ((__int16)v39 - (unsigned __int8)byte_DC1E0[v6]) / *(_DWORD *)(a1 + 12);
          if ( (v10 & 7) != 0 )
            goto LABEL_27;
          v11 = v10;
          goto LABEL_26;
        }
        v31 = (int)v8 >> 4;
        v12 = v8 % 16;
        if ( v31 != 3 )
          break;
        v13 = (unsigned __int8)v12 % 3;
        if ( (_BYTE)v13 )
        {
          if ( (unsigned __int8)v13 > 1u )
          {
            if ( (_BYTE)v13 != 2 )
              goto LABEL_27;
            v9 = v6;
            byte_DC1E0[v6] += ((__int16)v39 + 16 - (unsigned __int8)byte_DC1E0[v6]) / *(_DWORD *)(a1 + 12);
            v11 = byte_FC1E0[v6];
            if ( (v11 & 7) != 0 )
              goto LABEL_27;
            goto LABEL_26;
          }
          v9 = v6;
          byte_DC1E0[v6] += ((__int16)v39 + 12 - (unsigned __int8)byte_DC1E0[v6]) / *(_DWORD *)(a1 + 12);
          if ( (byte_FC1E0[v6] & 7) == 0 )
          {
            v11 = byte_FC1E0[v6];
LABEL_26:
            byte_FC1E0[v9] = v11 & 0xF0 | 1;
            sub_33B90(v6, v6);
          }
        }
LABEL_27:
        LOBYTE(v6) = v6 + 1;
        if ( !--v33 )
          goto LABEL_28;
      }
      if ( !(_BYTE)v12 )
        goto LABEL_27;
      v9 = v6;
      v14 = byte_FC1E0[v6];
      byte_DC1E0[v6] += (4 * (unsigned __int8)(v12 - 1) + (__int16)v39 - (unsigned __int8)byte_DC1E0[v6])
                      / *(_DWORD *)(a1 + 12);
      if ( (v14 & 7) != 0 )
        goto LABEL_27;
      v11 = v14;
      goto LABEL_26;
    }
LABEL_29:
    v30 = v28;
    v37 = v34;
    v15 = v34;
    v16 = *(_DWORD *)(a1 + 12) / 5;
    v17 = 0;
    if ( !(*(_DWORD *)(a1 + 12) % 5) || *(_DWORD *)(a1 + 12) == 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
LABEL_31:
          if ( !v30 )
            return v16;
          LOBYTE(v16) = *(_BYTE *)(v17 + v3);
          ++v17;
          if ( (_BYTE)v16 )
            break;
          ++HIBYTE(v37);
          --v30;
          v15 = v37;
        }
        if ( (v16 & 0x80u) == 0 )
          break;
        LOBYTE(v15) = v15 - v16;
      }
      v18 = (char)v16;
      for ( i = (char)v16 == 0; ; i = v18 == 0 )
      {
        if ( i )
          goto LABEL_31;
        v40 = *(_BYTE *)(v17 + v3);
        v20 = v40;
        LOBYTE(v21) = 0;
        v22 = (int)v40 >> 4;
        ++v17;
        if ( v22 )
        {
          if ( v22 <= 2 )
          {
            v23 = v22 + 7;
          }
          else if ( v22 == 3 )
          {
            v21 = v40 % 16 % 3;
            v20 = v40 % 16 / 3 + 10;
            v23 = v20;
          }
          else
          {
            LOBYTE(v21) = 0;
            v23 = ((int)v40 >> 4) + 11;
          }
        }
        else
        {
          v20 = 7;
          LOWORD(v16) = v40 / 7;
          v21 = v40 % 7;
          if ( !(_BYTE)v21 )
            goto LABEL_47;
          v23 = v21 - 1;
        }
        LOBYTE(v16) = sub_33800(v21, v20, v15, v23);
LABEL_47:
        LOBYTE(v15) = v15 + 1;
        --v18;
      }
    }
  }
  else
  {
    LOBYTE(v24) = v35 - v32;
    HIBYTE(v24) = v38 - v5;
    LOBYTE(v25) = v32 + v35;
    HIBYTE(v25) = v5 + v38;
    sub_33B90(v24, v25);
    LOBYTE(v16) = *(_BYTE *)(a1 + 70);
    if ( (unsigned __int8)v16 >= 0x30u )
    {
      if ( (unsigned __int8)v16 <= 0x30u )
      {
        *(_WORD *)(164 * *(unsigned __int16 *)(a1 + 42) + dword_AE400 + 29843) = 2;
        LOBYTE(v16) = sub_41E80(a1);
      }
      else if ( (_BYTE)v16 == 51 )
      {
        *(_DWORD *)(a1 + 12) = *(unsigned __int16 *)(a1 + 44);
        *(_BYTE *)(a1 + 16) |= 1u;
        *(_BYTE *)(a1 + 70) = 52;
        *(_WORD *)(a1 + 76) = sub_11F50((__int16 *)(a1 + 72));
        v26 = (unsigned __int16)(v29 >> 1);
        sub_35F30(v38, v35, v38, v26, (unsigned __int16)v32, 2u);
        LOBYTE(v16) = sub_35F30(v38, v35, v38, v26, (unsigned __int16)v32, 5u);
      }
    }
  }
  return v16;
}
// 27E39: conditional instruction was optimized away because al.1>=1
// AE400: using guessed type int dword_AE400;
// AE440: using guessed type int dword_AE440;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00028200) --------------------------------------------------------
unsigned __int16 sub_28200(int a1)
{
  char v1; // cl
  char v2; // ch
  unsigned int v3; // edx
  unsigned int v4; // ebx
  unsigned int v5; // esi
  char v6; // dh
  unsigned int v7; // edi
  __int16 v8; // ax
  unsigned __int16 result; // ax
  int v10; // eax
  unsigned __int16 v11; // si
  unsigned __int16 v12; // ax
  unsigned int v13; // ebp
  unsigned int i; // esi
  char v15; // cl
  unsigned __int16 v16; // dx
  char v17; // ch
  unsigned __int16 v18; // ax
  unsigned int v19; // ebp
  unsigned int j; // esi
  char v21; // cl
  __int16 v22; // cx
  unsigned __int16 v23; // ax
  unsigned int v24; // ebp
  unsigned int k; // edx
  unsigned __int16 v26; // si
  char v27; // ch
  int v28; // [esp+0h] [ebp-24h]
  __int16 v29; // [esp+4h] [ebp-20h]

  v1 = (unsigned __int16)(*(_WORD *)(a1 + 72) + 128) >> 8;
  v2 = (unsigned __int16)(*(_WORD *)(a1 + 74) + 128) >> 8;
  if ( word_12F02E == 1 )
    v3 = (int)*(unsigned __int8 *)(6 * *(char *)(a1 + 71) + dword_AE440 + 4) >> 1;
  else
    v3 = *(unsigned __int8 *)(dword_AE440 + 6 * *(char *)(a1 + 71) + 4);
  v4 = v3;
  if ( word_12F02E == 1 )
    v5 = (int)*(unsigned __int8 *)(dword_AE440 + 6 * *(char *)(a1 + 71) + 5) >> 1;
  else
    v5 = *(unsigned __int8 *)(dword_AE440 + 6 * *(char *)(a1 + 71) + 5);
  LOBYTE(v29) = v1 - (v3 >> 1);
  HIBYTE(v29) = v2 - (v5 >> 1);
  v6 = *(_BYTE *)(a1 + 16);
  v7 = v5;
  if ( (v6 & 2) != 0 )
  {
    if ( !*(_WORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 42) + 29845) && *(_WORD *)(a1 + 26) )
    {
      v28 = (*(unsigned __int16 *)(a1 + 44) - *(__int16 *)(a1 + 48)) / *(__int16 *)(a1 + 26);
      *(_WORD *)(a1 + 48) += v28;
      if ( *(_WORD *)(a1 + 26) == 1 )
      {
        v12 = v29;
        v13 = 0;
        if ( v5 )
        {
          do
          {
            for ( i = 0; i < v4; byte_DC1E0[v16] = v17 )
            {
              v15 = byte_FC1E0[v12];
              if ( v15 < 0 )
                byte_FC1E0[v12] = v15 & 0x77 | 8;
              v16 = v12;
              ++i;
              v17 = v28 + byte_DC1E0[v12];
              LOBYTE(v12) = v12 + 1;
            }
            ++v13;
            v12 = __PAIR16__(HIBYTE(v12), v29) + 256;
          }
          while ( v13 < v7 );
        }
        result = -10;
        *(_WORD *)(a1 + 26) = -10;
      }
      else if ( *(__int16 *)(a1 + 26) == -1 )
      {
        v18 = v29;
        v19 = 0;
        if ( v5 )
        {
          do
          {
            for ( j = 0; j < v4; LOBYTE(v18) = v18 + 1 )
            {
              v21 = byte_FC1E0[v18];
              if ( (v21 & 8) != 0 )
                byte_FC1E0[v18] = v21 & 0x77 | 0x80;
              ++j;
            }
            ++v19;
            v18 = __PAIR16__(HIBYTE(v18), v29) + 256;
          }
          while ( v19 < v7 );
        }
        result = a1;
        ++*(_WORD *)(a1 + 26);
      }
      else
      {
        result = a1;
        v22 = *(_WORD *)(a1 + 26);
        if ( v22 <= 0 )
        {
          *(_WORD *)(a1 + 26) = v22 + 1;
        }
        else
        {
          v23 = v29;
          v24 = 0;
          if ( v5 )
          {
            do
            {
              for ( k = 0; k < v4; byte_DC1E0[v26] = v27 )
              {
                v26 = v23;
                ++k;
                v27 = v28 + byte_DC1E0[v23];
                LOBYTE(v23) = v23 + 1;
              }
              ++v24;
              v23 = __PAIR16__(HIBYTE(v23), v29) + 256;
            }
            while ( v24 < v7 );
          }
          result = a1;
          --*(_WORD *)(a1 + 26);
        }
      }
    }
    else
    {
      v10 = dword_AE400;
      *(_WORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 42) + 29843) = 2;
      v11 = *(_WORD *)(a1 + 42);
      *(_WORD *)(164 * v11 + v10 + 29949) = 32 * *(_WORD *)(a1 + 48);
      sub_35F30(v11, v1, v2, (unsigned __int16)(v7 >> 1), (unsigned __int16)(v4 >> 1), 3u);
      return sub_41E80(a1);
    }
  }
  else
  {
    *(_BYTE *)(a1 + 16) = v6 | 2;
    *(_WORD *)(a1 + 26) = 10;
    *(_WORD *)(a1 + 48) = *(__int16 *)(a1 + 76) >> 5;
    v8 = sub_361C0(v29 - 1, HIBYTE(v29) - 1, v5 + 2, v4 + 2);
    *(_WORD *)(a1 + 44) = v8;
    if ( (unsigned __int16)v8 > 0xDCu )
      *(_WORD *)(a1 + 44) = 220;
    result = *(_WORD *)(a1 + 44);
    if ( *(__int16 *)(a1 + 48) == result )
      *(_WORD *)(a1 + 26) = 0;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE440: using guessed type int dword_AE440;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (000285C0) --------------------------------------------------------
char sub_285C0(int a1)
{
  __int16 v1; // ax
  __int16 v2; // dx
  int v3; // eax
  unsigned int v4; // eax
  int v5; // ecx
  unsigned int v6; // eax
  int v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // ebx
  unsigned int v10; // ebx
  unsigned __int16 v11; // dx
  unsigned int v12; // edi
  int v13; // esi
  char v14; // al
  unsigned __int8 v15; // cl
  __int16 v16; // dx
  __int16 v17; // dx
  unsigned int v18; // eax
  unsigned __int8 v19; // al
  unsigned int v20; // edi
  __int16 *v21; // esi
  char v22; // dh
  int v23; // eax
  unsigned int v24; // ebx
  unsigned int v25; // eax
  unsigned int v26; // esi
  unsigned int m; // edx
  char v28; // cl
  int v30; // [esp+4h] [ebp-60h]
  unsigned int v31; // [esp+8h] [ebp-5Ch]
  int v32; // [esp+Ch] [ebp-58h]
  unsigned int v33; // [esp+10h] [ebp-54h]
  unsigned int v34; // [esp+14h] [ebp-50h]
  unsigned int v35; // [esp+18h] [ebp-4Ch]
  int v36; // [esp+1Ch] [ebp-48h]
  unsigned int v37; // [esp+20h] [ebp-44h]
  int j; // [esp+24h] [ebp-40h]
  _WORD *v39; // [esp+28h] [ebp-3Ch]
  int v40; // [esp+2Ch] [ebp-38h]
  unsigned __int16 v41; // [esp+30h] [ebp-34h]
  __int16 v42; // [esp+30h] [ebp-34h]
  unsigned __int16 v43; // [esp+34h] [ebp-30h]
  int v44; // [esp+38h] [ebp-2Ch]
  unsigned __int16 v45; // [esp+3Ch] [ebp-28h]
  unsigned __int16 v46; // [esp+3Ch] [ebp-28h]
  unsigned __int16 k; // [esp+3Ch] [ebp-28h]
  char v48; // [esp+44h] [ebp-20h]
  unsigned __int8 v49; // [esp+48h] [ebp-1Ch]
  char v50; // [esp+4Ch] [ebp-18h]
  unsigned __int8 i; // [esp+50h] [ebp-14h]

  LOBYTE(v1) = dword_AE3FC;
  v30 = dword_AE3FC;
  HIBYTE(v1) = *(_BYTE *)(a1 + 16);
  if ( (v1 & 0x200) == 0 )
  {
    *(_WORD *)(a1 + 26) = 19;
    *(_BYTE *)(a1 + 16) = HIBYTE(v1) | 2;
  }
  v2 = *(_WORD *)(a1 + 26);
  if ( v2 > 0 )
  {
    LOBYTE(v1) = v2 - 1;
    *(_WORD *)(a1 + 26) = v2 - 1;
    if ( v2 == 1 )
    {
      if ( *(_BYTE *)(a1 + 60) )
        *(_WORD *)(a1 + 26) = -25;
      else
        *(_WORD *)(a1 + 26) = -1;
      return v1;
    }
    v1 = 41 * *(_WORD *)(a1 + 42);
    if ( *(_WORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 42) + 29845) )
      return v1;
    v48 = (unsigned __int16)(*(_WORD *)(a1 + 72) + 128) >> 8;
    v50 = (unsigned __int16)(*(_WORD *)(a1 + 74) + 128) >> 8;
    v44 = *(__int16 *)(a1 + 76) >> 5;
    if ( word_12F02E == 1 )
      v3 = (int)*(unsigned __int8 *)(dword_AE440 + 6 * *(char *)(a1 + 71) + 4) >> 1;
    else
      v3 = *(unsigned __int8 *)(dword_AE440 + 6 * *(char *)(a1 + 71) + 4);
    v35 = v3;
    if ( word_12F02E == 1 )
      v4 = (int)*(unsigned __int8 *)(dword_AE440 + 6 * *(char *)(a1 + 71) + 5) >> 1;
    else
      v4 = *(unsigned __int8 *)(dword_AE440 + 6 * *(char *)(a1 + 71) + 5);
    v5 = 2 * v4 * v35;
    v33 = v4;
    v6 = v4 >> 1;
    HIBYTE(v41) = v50 - v6;
    v49 = v6;
    memset((void*)v30, 0, v5);
    for ( i = 1; ; ++i )
    {
      if ( i > *(char *)(a1 + 71) )
      {
        LOBYTE(v1) = v48 - (v35 >> 1);
        LOBYTE(v41) = v1;
        v46 = v41;
        v37 = 0;
        for ( j = 0; v37 < v33; ++v37 )
        {
          v20 = 0;
          if ( v35 )
          {
            v21 = (__int16 *)(v30 + 2 * j);
            do
            {
              if ( *v21 )
              {
                if ( !byte_DC1E0[v46] )
                {
                  byte_FC1E0[v46] = byte_FC1E0[v46] & 0xF8 | 1;
                  sub_33E10(v46, v46);
                }
                byte_DC1E0[v46] += *v21 / *(__int16 *)(a1 + 26);
                if ( *(_WORD *)(a1 + 26) == 1 )
                {
                  v22 = byte_FC1E0[v46];
                  if ( v22 < 0 )
                    byte_FC1E0[v46] = v22 & 0x77 | 8;
                }
              }
              if ( *(_WORD *)(a1 + 26) == 2 )
                byte_FC1E0[v46] &= ~8u;
              ++v21;
              ++v20;
              LOBYTE(v46) = v46 + 1;
              ++j;
            }
            while ( v20 < v35 );
          }
          LOBYTE(v1) = v48 - (v35 >> 1);
          ++HIBYTE(v46);
          LOBYTE(v46) = v1;
        }
        return v1;
      }
      v7 = 6 * i;
      v8 = word_12F02E == 1
         ? (int)*(unsigned __int8 *)(dword_AE440 + v7 + 4) >> 1
         : *(unsigned __int8 *)(dword_AE440 + v7 + 4);
      v9 = word_12F02E == 1
         ? (int)*(unsigned __int8 *)(dword_AE440 + 6 * i + 5) >> 1
         : *(unsigned __int8 *)(6 * i + dword_AE440 + 5);
      v10 = v9 >> 1;
      v36 = *(_DWORD *)(6 * i + dword_AE440);
      LOBYTE(v11) = v48 - v10;
      HIBYTE(v11) = v50 - (v8 >> 1);
      v31 = v8;
      v43 = v11;
      v45 = v11;
      v34 = (unsigned __int8)(v35 >> 1) - v10;
      v12 = v34 + v35 * (v49 - (v8 >> 1));
      v32 = v35 * (v49 - (v8 >> 1));
      v13 = 0;
      if ( v8 )
        break;
LABEL_46:
      ;
    }
    while ( 1 )
    {
      v14 = *(_BYTE *)(v36 + v13++);
      if ( v14 )
        break;
      ++HIBYTE(v43);
      v45 = v43;
      v32 += v35;
      --v31;
      v12 = v32 + v34;
LABEL_45:
      if ( !v31 )
        goto LABEL_46;
    }
    if ( v14 < 0 )
    {
      LOBYTE(v45) = v45 - v14;
      v12 -= v14;
      goto LABEL_45;
    }
    v40 = v14;
    v39 = (_WORD *)(v30 + 2 * v12);
    while ( 1 )
    {
      if ( (*(_BYTE *)(a1 + 18) & 1) != 0 )
        sub_40E20(v45, *(_WORD *)(a1 + 24));
      v15 = *(_BYTE *)(v36 + v13++);
      if ( v15 >= 0xFu )
      {
        v16 = v15 % 16;
        if ( (_BYTE)v16 )
          *v39 = 4 * (unsigned __int8)(v16 - 1) + v44 - (unsigned __int8)byte_DC1E0[v45];
      }
      else if ( v15 > 6u )
      {
        *v39 = v44 - (unsigned __int8)byte_DC1E0[v45];
      }
      if ( *(__int16 *)(a1 + 26) % 7 && *(_WORD *)(a1 + 26) != 1 )
        goto LABEL_44;
      LOBYTE(v17) = 0;
      v18 = (int)v15 >> 4;
      if ( v18 )
        break;
      v17 = v15 % 7;
      if ( (_BYTE)v17 )
      {
        v19 = v17 - 1;
LABEL_43:
        sub_33800(v17, v15, v45, v19);
      }
LABEL_44:
      ++v12;
      LOBYTE(v45) = v45 + 1;
      ++v39;
      if ( !--v40 )
        goto LABEL_45;
    }
    if ( v18 <= 2 )
    {
      v19 = v18 + 7;
    }
    else if ( v18 == 3 )
    {
      v17 = v15 % 16 % 3;
      v19 = v15 % 16 / 3 + 10;
    }
    else
    {
      LOBYTE(v17) = 0;
      v19 = ((int)v15 >> 4) + 11;
    }
    goto LABEL_43;
  }
  *(_WORD *)(a1 + 26) = v2 + 1;
  if ( v2 == -1 )
  {
    if ( word_12F02E == 1 )
      v23 = (int)*(unsigned __int8 *)(dword_AE440 + 6 * *(char *)(a1 + 71) + 4) >> 1;
    else
      v23 = *(unsigned __int8 *)(dword_AE440 + 6 * *(char *)(a1 + 71) + 4);
    v24 = v23;
    if ( word_12F02E == 1 )
      v25 = (int)*(unsigned __int8 *)(dword_AE440 + 6 * *(char *)(a1 + 71) + 5) >> 1;
    else
      v25 = *(unsigned __int8 *)(dword_AE440 + 6 * *(char *)(a1 + 71) + 5);
    LOBYTE(v42) = ((unsigned __int16)(*(_WORD *)(a1 + 72) + 128) >> 8) - (v24 >> 1);
    HIBYTE(v42) = ((unsigned __int16)(*(_WORD *)(a1 + 74) + 128) >> 8) - (v25 >> 1);
    v26 = 0;
    for ( k = v42; v26 < v25; k = __PAIR16__(HIBYTE(k), v42) + 256 )
    {
      for ( m = 0; m < v24; LOBYTE(k) = k + 1 )
      {
        v28 = byte_FC1E0[k];
        if ( (v28 & 8) != 0 )
          byte_FC1E0[k] = v28 & 0x77 | 0x80;
        ++m;
      }
      ++v26;
    }
    *(_WORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 42) + 29843) = 5;
    LOBYTE(v1) = sub_41E80(a1);
  }
  return v1;
}
// 28880: conditional instruction was optimized away because al.1>=1
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// AE3FC: using guessed type int dword_AE3FC;
// AE400: using guessed type int dword_AE400;
// AE440: using guessed type int dword_AE440;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00028D10) --------------------------------------------------------
int sub_28D10(int a1, int a2)
{
  unsigned int v2; // eax
  int result; // eax
  int v4; // eax

  v2 = 9377 * *(_DWORD *)(a2 + 4) + 9439;
  *(_DWORD *)(a2 + 4) = v2;
  switch ( v2 % 0xC )
  {
    case 0u:
    case 1u:
      result = sub_373F0((int)&word_AE454, 5, 4);
      a1 = result;
      if ( !result )
        goto LABEL_10;
      *(_BYTE *)(result + 70) = 25;
      break;
    case 2u:
    case 3u:
      result = sub_373F0((int)&word_AE454, 5, 14);
      a1 = result;
      if ( !result )
        goto LABEL_10;
      *(_BYTE *)(result + 70) = 85;
      break;
    case 4u:
    case 5u:
    case 6u:
    case 7u:
    case 8u:
      result = sub_373F0((int)&word_AE454, 5, 13);
      a1 = result;
      if ( !result )
        goto LABEL_10;
      *(_BYTE *)(result + 70) = 79;
      break;
    case 9u:
    case 0xAu:
    case 0xBu:
      v4 = sub_373F0((int)&word_AE454, 5, 12);
      a1 = v4;
      if ( v4 )
        *(_BYTE *)(v4 + 70) = 73;
      goto LABEL_10;
    default:
LABEL_10:
      result = a1;
      break;
  }
  return result;
}
// AE454: using guessed type __int16 word_AE454;

//----- (00028DC0) --------------------------------------------------------
unsigned int sub_28DC0(int a1)
{
  unsigned int result; // eax
  __int16 v2; // dx
  int v3; // eax
  int v4; // edx
  __int16 v5; // di
  __int16 v6; // si
  unsigned int v7; // ecx
  unsigned int v8; // eax

  result = sub_29640(a1);
  if ( result )
  {
    if ( result > 1 )
    {
      if ( result == 2 )
        *(_BYTE *)(a1 + 70) = 53;
      return result;
    }
    v2 = *(_WORD *)(a1 + 26);
    if ( v2 > 2 )
    {
      *(_WORD *)(a1 + 26) = v2 - 1;
      *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
      *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
      word_AE454 += *(_WORD *)(a1 + 80);
      v3 = sub_373F0((int)&word_AE454, 5, 4);
      if ( v3 )
        *(_BYTE *)(v3 + 70) = 25;
      v4 = 164 * *(unsigned __int16 *)(a1 + 40);
      if ( v4 + dword_AE400 + 29795 && *(_BYTE *)(v4 + dword_AE400 + 29860) <= 1u )
        *(_WORD *)(*(_DWORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 40) + 29955) + 528) = 200;
    }
  }
  v5 = *(_WORD *)(a1 + 100);
  if ( v5 )
  {
    if ( v5 != *(_WORD *)(a1 + 144) )
    {
      *(_WORD *)(a1 + 144) = v5;
      sub_55370(v5, -1, 4);
      *(_BYTE *)(a1 + 16) &= ~1u;
      sub_36FA0(a1, 177);
      *(_WORD *)(a1 + 86) += *(_WORD *)(*(_DWORD *)(164 * *(unsigned __int16 *)(a1 + 100) + dword_AE400 + 29955) + 48);
    }
    *(_WORD *)(a1 + 100) = 0;
    *(_DWORD *)(a1 + 96) = 0;
  }
  if ( !(*(unsigned __int8 *)(a1 + 63) % 40) )
  {
    v6 = *(_WORD *)(a1 + 128);
    *(_DWORD *)(a1 + 140) = *(__int16 *)(a1 + 26) << 8;
    if ( v6 > 5 && v6 == *(_WORD *)(a1 + 26) )
    {
      v7 = *(__int16 *)(a1 + 128);
      v8 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
      *(_DWORD *)(a1 + 4) = v8;
      if ( (int)(v8 % v7) > *(__int16 *)(a1 + 128) - (*(__int16 *)(a1 + 128) >> 4) - 2 )
      {
        *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
        *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
        word_AE454 += *(_WORD *)(a1 + 80);
        sub_28D10(a1, a1);
      }
    }
  }
  return sub_44C90(a1);
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;

//----- (00028FE0) --------------------------------------------------------
int sub_28FE0(int a1)
{
  int v1; // eax
  int v2; // ebp
  unsigned int v3; // eax
  int v4; // eax
  int v5; // ebx
  char v6; // al
  unsigned __int8 v7; // al
  __int16 v8; // cx
  int v9; // eax
  int v10; // eax
  int v11; // eax
  __int16 v12; // dx
  char v13; // ch
  char v14; // dh
  char v15; // al
  __int16 v16; // dx
  int v17; // ecx
  unsigned int v18; // eax
  unsigned int v19; // eax
  int v21; // [esp+0h] [ebp-3Ch]
  int v22; // [esp+4h] [ebp-38h]
  unsigned int v23; // [esp+Ch] [ebp-30h]
  unsigned int v24; // [esp+10h] [ebp-2Ch]
  unsigned int v25; // [esp+18h] [ebp-24h]
  int v26; // [esp+1Ch] [ebp-20h]
  __int16 v27; // [esp+20h] [ebp-1Ch]
  __int16 v28; // [esp+24h] [ebp-18h]
  unsigned __int8 v29; // [esp+28h] [ebp-14h]

  v1 = dword_AE440 + 6 * *(unsigned __int8 *)(a1 + 71);
  v21 = *(_DWORD *)v1;
  v2 = 0;
  v23 = *(unsigned __int8 *)(v1 + 5);
  v3 = *(unsigned __int8 *)(v1 + 4);
  v24 = v3;
  if ( word_12F02E == 1 )
  {
    v23 >>= 1;
    v24 = v3 >> 1;
  }
  LOBYTE(v26) = ((unsigned __int16)(*(_WORD *)(a1 + 72) + 128) >> 8) - (v24 >> 1);
  BYTE1(v26) = ((unsigned __int16)(*(_WORD *)(a1 + 74) + 128) >> 8) - (v23 >> 1);
  if ( *(_BYTE *)(a1 + 65) )
    LOWORD(v4) = sub_361C0(v26, SBYTE1(v26), v23, v24);
  else
    v4 = *(__int16 *)(a1 + 76) >> 5;
  v5 = v26;
  v25 = v23;
  if ( v23 )
  {
    v27 = 32 * v4;
    v28 = 32 * (v4 - 10);
    while ( 1 )
    {
      v6 = *(_BYTE *)(v21 + v2++);
      if ( v6 )
        break;
      ++BYTE1(v26);
      v5 = v26;
      --v25;
LABEL_44:
      if ( !v25 )
        goto LABEL_45;
    }
    if ( v6 < 0 )
    {
      LOBYTE(v5) = v5 - v6;
      goto LABEL_44;
    }
    v22 = v6;
    while ( 1 )
    {
      v7 = *(_BYTE *)(v21 + v2++);
      v29 = v7;
      if ( v7 )
      {
        word_AE454 = (unsigned __int8)v5 << 8;
        word_AE456 = BYTE1(v5) << 8;
        word_AE458 = v27;
        if ( (v2 & 7) == 0 )
          word_AE458 = v28;
        v8 = *(_WORD *)(a1 + 26);
        if ( v8 > 0 )
        {
          *(_WORD *)(a1 + 26) = v8 - 1;
          if ( v8 == 1 )
          {
            v9 = sub_373F0((int)&word_AE454, 5, 12);
            if ( v9 )
              *(_BYTE *)(v9 + 70) = 73;
          }
          else if ( (__int16)(v8 - 1) >= 4 )
          {
            sub_28D10(v5, a1);
          }
          else
          {
            v10 = sub_373F0((int)&word_AE454, 5, 4);
            if ( v10 )
              *(_BYTE *)(v10 + 70) = 25;
          }
        }
        v11 = (int)v29 >> 4;
        if ( v11 )
        {
          if ( v11 != 3 )
          {
            v15 = byte_FC1E0[(unsigned __int16)v5] & 0x70;
            byte_FC1E0[(unsigned __int16)v5] &= ~0x80u;
            byte_FC1E0[(unsigned __int16)v5] = v15 | 1;
            sub_33E10(v5, v5);
            v16 = v29 % 16;
            if ( (_BYTE)v16 )
            {
              v17 = 4 * (unsigned __int8)(v16 - 1);
              if ( (unsigned __int8)byte_DC1E0[(unsigned __int16)v5] <= v17 )
              {
                byte_DC1E0[(unsigned __int16)v5] = 0;
              }
              else
              {
                v18 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
                *(_DWORD *)(a1 + 4) = v18;
                if ( (int)(v18 % 0x32) <= 20 )
                {
                  byte_DC1E0[(unsigned __int16)v5] -= 4 * (v16 - 1);
                }
                else
                {
                  v19 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
                  *(_DWORD *)(a1 + 4) = v19;
                  byte_DC1E0[(unsigned __int16)v5] -= v17 - v19 % 0x14;
                }
              }
            }
            goto LABEL_43;
          }
          byte_FC1E0[(unsigned __int16)v5] &= ~0x80u;
          v12 = v29 % 16 % 3;
          if ( !(_BYTE)v12 )
            goto LABEL_36;
          if ( (unsigned __int8)v12 <= 1u )
          {
            v13 = byte_DC1E0[(unsigned __int16)v5];
            if ( (unsigned __int8)v13 > 0xCu )
              byte_DC1E0[(unsigned __int16)v5] = v13 - 12;
          }
          else if ( (_BYTE)v12 != 2 )
          {
LABEL_36:
            sub_33E10(v5, v5);
            goto LABEL_43;
          }
          v14 = byte_DC1E0[(unsigned __int16)v5];
          if ( (unsigned __int8)v14 > 0x10u )
            byte_DC1E0[(unsigned __int16)v5] = v14 - 16;
          goto LABEL_36;
        }
        byte_FC1E0[(unsigned __int16)v5] &= ~0x80u;
      }
LABEL_43:
      LOBYTE(v5) = v5 + 1;
      if ( !--v22 )
        goto LABEL_44;
    }
  }
LABEL_45:
  sub_36080(v26, BYTE1(v26) - v23, (unsigned __int16)v23, (unsigned __int16)v24);
  return sub_41E80(a1);
}
// 29110: conditional instruction was optimized away because al.1>=1
// 290B7: variable 'v26' is possibly undefined
// AE440: using guessed type int dword_AE440;
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;
// AE458: using guessed type __int16 word_AE458;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (000293D0) --------------------------------------------------------
int sub_293D0(int a1)
{
  int v1; // eax
  int v2; // edx
  __int16 v3; // ax

  v1 = *(_DWORD *)(a1 + 12);
  ++*(_WORD *)(a1 + 26);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 >= 0 )
  {
    sub_42510(a1);
    if ( (*(_BYTE *)(a1 + 16) & 2) == 0 )
    {
      *(_BYTE *)(a1 + 16) |= 2u;
      sub_11F50((__int16 *)(a1 + 72));
      if ( sub_11950(
             a1,
             dword_AE400
           + 29795
           + 164 * *(unsigned __int16 *)(*(_DWORD *)(dword_AE400 + 164 * *(__int16 *)(a1 + 24) + 29955) + 50)) )
      {
        v2 = dword_AE400;
        v3 = *(_WORD *)(a1 + 24);
        *(_WORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(*(_DWORD *)(dword_AE400 + 164 * v3 + 29955) + 50) + 29919) = v3;
        *(_DWORD *)(v2 + 164 * *(unsigned __int16 *)(*(_DWORD *)(v2 + 164 * v3 + 29955) + 50) + 29915) = 10;
        return sub_41E80(a1);
      }
      sub_46D20(a1, 0);
    }
  }
  return sub_41E80(a1);
}
// AE400: using guessed type int dword_AE400;

//----- (00029540) --------------------------------------------------------
int sub_29540(int a1)
{
  int v1; // eax
  __int16 v2; // ax

  sub_41F50(a1 + 72, (uint16*)&word_AE454);
  *(_WORD *)(a1 + 150) += word_AE454;
  v1 = *(__int16 *)(a1 + 150);
  *(_WORD *)(a1 + 152) += word_AE456;
  if ( v1 < -128 )
    *(_WORD *)(a1 + 150) = -128;
  if ( *(__int16 *)(a1 + 150) > 128 )
    *(_WORD *)(a1 + 150) = 128;
  if ( *(__int16 *)(a1 + 152) < -128 )
    *(_WORD *)(a1 + 152) = -128;
  if ( *(__int16 *)(a1 + 152) > 128 )
    *(_WORD *)(a1 + 152) = 128;
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  v2 = *(_WORD *)(a1 + 152);
  word_AE454 += *(_WORD *)(a1 + 150);
  word_AE456 += v2;
  word_AE458 = sub_11F50(&word_AE454);
  sub_41C70(word_AE458, a1, (int)&word_AE454);
  return sub_120B0(a1, 0, *(_WORD *)(a1 + 44));
}
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;
// AE458: using guessed type __int16 word_AE458;

//----- (00029640) --------------------------------------------------------
int sub_29640(int a1)
{
  int v1; // ebx
  int v3; // ecx

  *(_WORD *)(a1 + 40) = 0;
  v1 = 0;
  if ( *(int *)(a1 + 12) < 0 )
    return 2;
  if ( *(_WORD *)(a1 + 94) )
  {
    v3 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 90);
    *(_DWORD *)(a1 + 12) = v3;
    if ( v3 < 0 )
    {
      *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 94);
      return 2;
    }
    *(_WORD *)(a1 + 40) = *(_WORD *)(a1 + 94);
    *(_DWORD *)(a1 + 90) = 0;
    v1 = 1;
    *(_WORD *)(a1 + 94) = 0;
  }
  return v1;
}

//----- (000296A0) --------------------------------------------------------
__int16 sub_296A0(int a1)
{
  int v1; // eax
  __int16 result; // ax

  *(_WORD *)(a1 + 76) = sub_11F50((__int16 *)(a1 + 72));
  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 < 0 )
    return sub_41E80(a1);
  result = *(_WORD *)(a1 + 26);
  *(_WORD *)(a1 + 26) = result - 1;
  if ( !result )
  {
    result = sub_424F0(a1, 0x39u);
    *(_DWORD *)(a1 + 8) = 5000;
  }
  return result;
}

//----- (00029700) --------------------------------------------------------
int sub_29700(int a1)
{
  int v1; // ebx
  int v2; // eax

  *(_WORD *)(a1 + 76) = sub_11F50((__int16 *)(a1 + 72));
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  v1 = sub_373F0((int)&word_AE454, 5, 5);
  if ( v1 )
  {
    ++*(int *)((char *)&dword_38C9F + dword_AE400);
    v2 = sub_373F0((int)&word_AE454, 10, 1);
    if ( v2 )
      *(_WORD *)(v2 + 24) = *(_WORD *)(v1 + 24);
  }
  return sub_41E80(a1);
}
// 38C9F: using guessed type int dword_38C9F;
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;

//----- (00029780) --------------------------------------------------------
int sub_29780(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // esi
  unsigned int v4; // eax
  unsigned int v5; // eax
  int v6; // eax
  int v7; // ecx
  __int16 v8; // di
  int v9; // eax
  int result; // eax
  __int16 v11[4]; // [esp+0h] [ebp-20h] BYREF
  int v12; // [esp+8h] [ebp-18h] BYREF
  int v13[5]; // [esp+Ch] [ebp-14h] BYREF

  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 < 0 )
    return sub_41E80(a1);
  sub_37130((_WORD *)a1, 512, 2048);
  sub_120B0(a1, 0, *(unsigned __int16 *)(a1 + 44) / *(int *)(a1 + 8));
  v2 = sub_11410(0, 1);
  v3 = v2;
  if ( v2 )
  {
    *(_DWORD *)(a1 + 4) = 9377 * *(_DWORD *)(a1 + 4) + 9439;
    while ( sub_114B0(v3, (uint32*)v13, (uint32*)&v12) == 1 )
    {
      v4 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
      *(_DWORD *)(a1 + 4) = v4;
      v11[0] = v4 % 0x81 + *(_WORD *)(a1 + 72) - 96 + 112 * LOWORD(v13[0]) - 64;
      v5 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
      *(_DWORD *)(a1 + 4) = v5;
      v11[1] = *(_WORD *)(a1 + 74) - 96 + 112 * v12 + v5 % 0x81 - 64;
      v11[2] = *(_WORD *)(a1 + 76);
      v6 = sub_373F0((int)v11, 10, 6);
      v7 = v6;
      if ( v6 )
      {
        *(_WORD *)(v6 + 24) = *(_WORD *)(a1 + 24);
        *(_WORD *)(v6 + 44) = *(_WORD *)(a1 + 44);
        if ( *(_WORD *)(a1 + 26) )
          *(_DWORD *)(v6 + 12) = 1;
        else
          *(_DWORD *)(v6 + 12) = 14;
        v8 = *(_WORD *)(v6 + 86) + 7;
        *(_DWORD *)(v6 + 16) |= (unsigned int)&loc_10080;
        *(_WORD *)(v6 + 86) = v8;
        v9 = *(__int16 *)(a1 + 26) << 8;
        *(_WORD *)(v7 + 26) = 7;
        *(_WORD *)(v7 + 46) = v9 / 2;
      }
    }
    v2 = sub_11490(v3);
  }
  LOWORD(v2) = *(_WORD *)(a1 + 26);
  result = v2 + 1;
  *(_WORD *)(a1 + 26) = result;
  if ( (__int16)result > 14 )
    return sub_41E80(a1);
  return result;
}
// 29780: using guessed type int var_14[5];

//----- (00029920) --------------------------------------------------------
int sub_29920(int a1)
{
  int v1; // eax
  int result; // eax
  unsigned int i; // ebx
  int v4; // eax

  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( v1 < 0 )
    return sub_41E80(a1);
  for ( i = *(_DWORD *)(dword_AE408 + 36466); ; i = *(_DWORD *)i )
  {
    result = dword_AE400 + 29795;
    if ( i <= dword_AE400 + 29795 )
      break;
    if ( *(_BYTE *)(i + 65) == 39 && sub_42410((_WORD *)(a1 + 72), (_WORD *)(i + 72)) < 12845056 )
    {
      v4 = (a1 - (dword_AE400 + 29795)) / 164;
      *(_DWORD *)(i + 114) = 100;
      *(_WORD *)(i + 118) = v4;
    }
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (000299D0) --------------------------------------------------------
void sub_299D0(int a1)
{
  int v1; // eax
  _WORD *v2; // esi
  unsigned int i; // ebx
  int v4; // edx

  if ( *(_WORD *)(a1 + 26) )
  {
    v4 = dword_AE400 + 29795;
    --*(_WORD *)(a1 + 26);
    sub_55370((a1 - v4) / 164, -1, 43);
  }
  else
  {
    v1 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 12) = v1 - 1;
    if ( v1 >= 0 )
    {
      v2 = (_WORD *)(dword_AE400 + 29867);
      for ( i = dword_AE400 + 29795; i < dword_AE400 + 193795; i += 164 )
      {
        if ( *(_BYTE *)(i + 64) && *(_WORD *)(i + 24) != *(_WORD *)(a1 + 24) )
        {
          switch ( *(_BYTE *)(i + 64) )
          {
            case 2:
            case 5:
              if ( sub_423D0((_WORD *)(a1 + 72), v2) < 0xA00 )
                *(_DWORD *)(i + 12) = -1;
              break;
            case 3:
              if ( sub_423D0((_WORD *)(a1 + 72), v2) < 0xA00 )
                sub_12B50(a1, i, 0, *(_WORD *)(a1 + 44));
              break;
            case 9:
            case 0xA:
              if ( sub_423D0((_WORD *)(a1 + 72), v2) < 0xA00 )
                *(_DWORD *)(a1 + 12) = 0;
              break;
            default:
              break;
          }
        }
        v2 += 82;
      }
      sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 44);
      sub_55370(*(_WORD *)(a1 + 24), -1, 44);
      sub_44BE0(164 * *(__int16 *)(a1 + 24) + dword_AE400 + 29795, 3);
      sub_41E80(a1);
    }
    else
    {
      sub_41E80(a1);
    }
  }
}
// AE400: using guessed type int dword_AE400;

//----- (00029BA0) --------------------------------------------------------
int *sub_29BA0(int a1)
{
  int *result; // eax
  char v2; // bl
  int v3; // edx

  result = (int *)&unk_902DC;
  v2 = 32;
  v3 = (a1 << 16) - 1;
  do
  {
    if ( *result )
      *result = v3;
    if ( result[1] )
      result[1] = v3;
    if ( result[2] )
      result[2] = v3;
    if ( result[3] )
      result[3] = v3;
    if ( result[4] )
      result[4] = v3;
    if ( result[5] )
      result[5] = v3;
    if ( result[6] )
      result[6] = v3;
    if ( result[7] )
      result[7] = v3;
    result += 8;
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (00029C30) --------------------------------------------------------
_DWORD *sub_29C30(__int16 a1)
{
  int v1; // edx
  int v2; // edi
  int v3; // eax
  int v4; // ebx
  _DWORD *v5; // edi
  int *v6; // esi
  int v7; // eax
  __int16 v8; // bx
  int v9; // ecx
  int v10; // edx
  _BOOL1 v11; // cf
  int v12; // ebx
  int v13; // edx
  int v14; // eax
  _DWORD *v15; // edi
  int *v16; // esi
  int v17; // eax
  int v18; // ecx
  int v19; // edx
  _DWORD *v20; // edi
  int *v21; // esi
  int v22; // eax
  __int16 v23; // bx
  int v24; // ecx
  int v25; // edx
  int v26; // edx
  int v27; // eax
  _DWORD *v28; // edi
  int *v29; // esi
  int v30; // eax
  __int16 v31; // bx
  int v32; // ecx
  int v33; // edx
  int v34; // edx
  void (*v35)(); // eax
  _DWORD *v36; // edi
  int *v37; // esi
  int v38; // eax
  int v39; // ecx
  int v40; // edx
  _DWORD *v41; // edi
  int *v42; // esi
  int v43; // eax
  __int16 v44; // bx
  int v45; // ecx
  int v46; // edx
  int v47; // eax
  _DWORD *v48; // edi
  int *v49; // esi
  int v50; // eax
  __int16 v51; // bx
  int v52; // ecx
  int v53; // edx
  int *v54; // esi
  _DWORD *v55; // edi
  int v56; // eax
  int v57; // ecx
  int v58; // edx
  _DWORD *v59; // edi
  int *v60; // esi
  int v61; // eax
  __int16 v62; // bx
  int v63; // ecx
  int v64; // edx
  _DWORD *v65; // edi
  int *v66; // esi
  int v67; // eax
  __int16 v68; // bx
  int v69; // ecx
  int v70; // edx
  _DWORD *v71; // edi
  int *v72; // esi
  int v73; // eax
  int v74; // ecx
  int v75; // edx
  _DWORD *v76; // edi
  int *v77; // esi
  int v78; // eax
  __int16 v79; // bx
  int v80; // ecx
  int v81; // edx
  _DWORD *result; // eax
  int v83; // edx
  int v84; // ebx
  int v85; // [esp+0h] [ebp-1Ch]
  int v86; // [esp+0h] [ebp-1Ch]
  int v87; // [esp+0h] [ebp-1Ch]
  int v88; // [esp+0h] [ebp-1Ch]
  int v89; // [esp+4h] [ebp-18h]
  int v90; // [esp+4h] [ebp-18h]
  int v91; // [esp+4h] [ebp-18h]
  int v92; // [esp+4h] [ebp-18h]
  int v93; // [esp+8h] [ebp-14h]
  int v94; // [esp+8h] [ebp-14h]
  int v95; // [esp+8h] [ebp-14h]
  int v96; // [esp+8h] [ebp-14h]
  int v97; // [esp+8h] [ebp-14h]
  int v98; // [esp+8h] [ebp-14h]
  int v99; // [esp+8h] [ebp-14h]
  int v100; // [esp+8h] [ebp-14h]
  int v101; // [esp+8h] [ebp-14h]
  int v102; // [esp+Ch] [ebp-10h]
  __int16 v103; // [esp+18h] [ebp-4h]
  __int16 v104; // [esp+18h] [ebp-4h]
  __int16 v105; // [esp+18h] [ebp-4h]
  __int16 v106; // [esp+18h] [ebp-4h]
  __int16 v107; // [esp+18h] [ebp-4h]
  __int16 v108; // [esp+18h] [ebp-4h]
  __int16 v109; // [esp+18h] [ebp-4h]
  __int16 v110; // [esp+18h] [ebp-4h]

  //fix
  v11 = 0;
  //fix

  v1 = a1 & 0x7FF;
  dword_B5D28 = v1 >> 8;
  v102 = v1 - 512;
  v2 = v1 - 1024;
  v3 = v1 - 512;
  v4 = v1 - 1536;
  switch ( v1 >> 8 )
  {
    case 0:
      dword_B5D18 = dword_90B4C[v1];
      dword_B5CE0 = (int)off_9134C[v1];
      v89 = dword_93AD4;
      v93 = (unsigned __int16)dword_93AD8;
      dword_B5CF4 = (dword_B5D18 << 8) / (dword_B5CE0 >> 8);
      v103 = (dword_B5D18 << 8) / (dword_B5CE0 >> 8);
      v5 = (uint32*)&unk_B3EA0;
      v6 = (int *)(dword_AE3FC + 59360);
      v7 = 0;
      v8 = 0;
      v9 = 1;
      v10 = 0;
      do
      {
        v5[1] = v7;
        v5[2] = v10;
        //fix v11 = __CFADD__(v103, v8);
        v8 += v103;
        if ( v11 )
        {
          v7 += v89;
          ++v10;
          *v6++ = v9;
        }
        v5 += 3;
        ++v7;
        ++v9;
        --v93;
      }
      while ( v93 );
      dword_B5D24 = v10;
      dword_B5D2C = -v10;
      v12 = (unsigned __int16)dword_93ADC - v10;
      dword_B5D30 = (unsigned __int16)dword_93ADC;
      dword_B5D34 = (unsigned __int16)dword_93AD8;
      v13 = (unsigned __int16)dword_93ADC + (unsigned __int16)dword_93AD8;
      v14 = -1 - dword_B5D2C;
      goto LABEL_62;
    case 1:
      dword_B5D18 = dword_90B4C[v1];
      dword_B5CE0 = (int)off_9134C[v1];
      v85 = dword_93AD4;
      v94 = (unsigned __int16)dword_93ADC;
      if ( v1 == 256 )
      {
        v15 = (uint32*)&unk_B3EA0;
        v16 = (int *)(dword_AE3FC + 59360);
        dword_B5CF4 = (int)sub_10000;
        v17 = 0;
        v18 = 1;
        v19 = 0;
        do
        {
          v15[1] = v17;
          v15[2] = v19++;
          *v16++ = v18;
          v15 += 3;
          v17 += v85 + 1;
          ++v18;
          --v94;
        }
        while ( v94 );
        dword_B5D24 = (unsigned __int16)dword_93ADC;
        dword_B5D2C = -(unsigned __int16)dword_93ADC;
      }
      else
      {
        dword_B5CF4 = (dword_B5CE0 << 8) / (dword_B5D18 >> 8);
        v104 = (dword_B5CE0 << 8) / (dword_B5D18 >> 8);
        v20 = (uint32*)&unk_B3EA0;
        v21 = (int *)(dword_AE3FC + 59360);
        v22 = 0;
        v23 = 0;
        v24 = 1;
        v25 = 0;
        do
        {
          v20[1] = v22;
          v20[2] = v25;
          //fix v11 = __CFADD__(v104, v23);
          v23 += v104;
          if ( v11 )
          {
            ++v22;
            ++v25;
            *v21++ = v24;
          }
          v20 += 3;
          v22 += v85;
          ++v24;
          --v94;
        }
        while ( v94 );
        dword_B5D24 = v25;
        dword_B5D2C = -v25;
      }
      dword_B5D1C = (unsigned __int16)dword_93AD8 + dword_B5D2C;
      dword_B5D30 = (unsigned __int16)dword_93AD8;
      dword_B5D20 = (unsigned __int16)dword_93ADC + (unsigned __int16)dword_93AD8;
      dword_B5D34 = (unsigned __int16)dword_93ADC;
      dword_B5D04 = -1;
      dword_B5CD8 = 4 * (-1 - dword_B5D2C) + dword_AE3FC + 59360;
      break;
    case 2:
      v26 = dword_90B4C[v3];
      v27 = (int)off_9134C[v3];
      dword_B5D18 = v26;
      dword_B5CE0 = v27;
      v86 = dword_93AD4;
      v95 = (unsigned __int16)dword_93ADC;
      dword_B5CF4 = (v26 << 8) / (v27 >> 8);
      v105 = (v26 << 8) / (v27 >> 8);
      v28 = (uint32*)&unk_B3EA0;
      v29 = (int *)(dword_AE3FC + 59360);
      v30 = 0;
      v31 = 0;
      v32 = 1;
      v33 = 0;
      do
      {
        v28[1] = v30;
        v28[2] = v33;
        //fix v11 = __CFADD__(v105, v31);
        v31 += v105;
        if ( v11 )
        {
          --v30;
          ++v33;
          *v29++ = v32;
        }
        v28 += 3;
        v30 += v86;
        ++v32;
        --v95;
      }
      while ( v95 );
      dword_B5D24 = v33;
      dword_B5D2C = -v33;
      dword_B5D30 = (unsigned __int16)dword_93AD8;
      dword_B5D34 = (unsigned __int16)dword_93ADC;
      dword_B5D20 = (unsigned __int16)dword_93ADC + (unsigned __int16)dword_93AD8;
      dword_B5D04 = -1;
      dword_B5D1C = (unsigned __int16)dword_93AD8 - v33;
      dword_B5CD8 = 4 * (v33 - 1) + dword_AE3FC + 59360;
      break;
    case 3:
      v34 = dword_90B4C[v3];
      v35 = off_9134C[v3];
      dword_B5D18 = v34;
      dword_B5CE0 = (int)v35;
      v90 = dword_93AD4;
      v96 = (unsigned __int16)dword_93AD8;
      if ( v102 == 256 )
      {
        v36 = (uint32*)&unk_B3EA0;
        v37 = (int *)(dword_AE3FC + 59360);
        dword_B5CF4 = (int)sub_10000;
        v38 = 0;
        v39 = 1;
        v40 = 0;
        do
        {
          v36[1] = v38;
          v36[2] = v40++;
          *v37++ = v39;
          v36 += 3;
          v38 = v90 + v38 - 1;
          ++v39;
          --v96;
        }
        while ( v96 );
        dword_B5D24 = (unsigned __int16)dword_93AD8;
        dword_B5D2C = -(unsigned __int16)dword_93AD8;
      }
      else
      {
        dword_B5CF4 = (dword_B5CE0 << 8) / (dword_B5D18 >> 8);
        v106 = (dword_B5CE0 << 8) / (dword_B5D18 >> 8);
        v41 = (uint32*)&unk_B3EA0;
        v42 = (int *)(dword_AE3FC + 59360);
        v43 = 0;
        v44 = 0;
        v45 = 1;
        v46 = 0;
        do
        {
          v41[1] = v43;
          v41[2] = v46;
          //fix v11 = __CFADD__(v106, v44);
          v44 += v106;
          if ( v11 )
          {
            v43 += v90;
            ++v46;
            *v42++ = v45;
          }
          v41 += 3;
          --v43;
          ++v45;
          --v96;
        }
        while ( v96 );
        dword_B5D24 = v46;
        dword_B5D2C = -v46;
      }
      dword_B5D1C = (unsigned __int16)dword_93ADC + dword_B5D2C;
      dword_B5D30 = (unsigned __int16)dword_93ADC;
      dword_B5D34 = (unsigned __int16)dword_93AD8;
      dword_B5D20 = (unsigned __int16)dword_93ADC + (unsigned __int16)dword_93AD8;
      dword_B5CD8 = 4 * (-1 - dword_B5D2C) + dword_AE3FC + 59360;
      v47 = -dword_93AD4;
      goto LABEL_63;
    case 4:
      dword_B5D18 = dword_90B4C[v2];
      dword_B5CE0 = (int)off_9134C[v2];
      v91 = -dword_93AD4;
      v97 = (unsigned __int16)dword_93AD8;
      dword_B5CF4 = (dword_B5D18 << 8) / (dword_B5CE0 >> 8);
      v107 = (dword_B5D18 << 8) / (dword_B5CE0 >> 8);
      v48 = (uint32*)&unk_B3EA0;
      v49 = (int *)(dword_AE3FC + 59360);
      v50 = 0;
      v51 = 0;
      v52 = 1;
      v53 = 0;
      do
      {
        v48[1] = v50;
        v48[2] = v53;
        //fix v11 = __CFADD__(v107, v51);
        v51 += v107;
        if ( v11 )
        {
          v50 += v91;
          ++v53;
          *v49++ = v52;
        }
        v48 += 3;
        --v50;
        ++v52;
        --v97;
      }
      while ( v97 );
      dword_B5D24 = v53;
      dword_B5D2C = -v53;
      dword_B5D30 = (unsigned __int16)dword_93ADC;
      dword_B5D34 = (unsigned __int16)dword_93AD8;
      dword_B5D20 = (unsigned __int16)dword_93ADC + (unsigned __int16)dword_93AD8;
      dword_B5D1C = (unsigned __int16)dword_93ADC - v53;
      v47 = -dword_93AD4;
      dword_B5CD8 = 4 * (v53 - 1) + dword_AE3FC + 59360;
      goto LABEL_63;
    case 5:
      dword_B5D18 = dword_90B4C[v2];
      dword_B5CE0 = (int)off_9134C[v2];
      v87 = -dword_93AD4;
      v98 = (unsigned __int16)dword_93ADC;
      if ( v1 == 1280 )
      {
        dword_B5CF4 = (int)sub_10000;
        v54 = (int *)(dword_AE3FC + 59360);
        v55 = (uint32*)&unk_B3EA0;
        v56 = 0;
        v57 = 1;
        v58 = 0;
        do
        {
          v55[1] = v56;
          v55[2] = v58++;
          *v54++ = v57;
          v55 += 3;
          v56 = v87 + v56 - 1;
          ++v57;
          --v98;
        }
        while ( v98 );
        dword_B5D24 = (unsigned __int16)dword_93ADC;
        dword_B5D2C = -(unsigned __int16)dword_93ADC;
      }
      else
      {
        dword_B5CF4 = (dword_B5CE0 << 8) / (dword_B5D18 >> 8);
        v108 = (dword_B5CE0 << 8) / (dword_B5D18 >> 8);
        v59 = (uint32*)&unk_B3EA0;
        v60 = (int *)(dword_AE3FC + 59360);
        v61 = 0;
        v62 = 0;
        v63 = 1;
        v64 = 0;
        do
        {
          v59[1] = v61;
          v59[2] = v64;
          //fix v11 = __CFADD__(v108, v62);
          v62 += v108;
          if ( v11 )
          {
            --v61;
            ++v64;
            *v60++ = v63;
          }
          v59 += 3;
          v61 += v87;
          ++v63;
          --v98;
        }
        while ( v98 );
        dword_B5D24 = v64;
        dword_B5D2C = -v64;
      }
      dword_B5D30 = (unsigned __int16)dword_93AD8;
      dword_B5D34 = (unsigned __int16)dword_93ADC;
      dword_B5D20 = (unsigned __int16)dword_93ADC + (unsigned __int16)dword_93AD8;
      dword_B5D1C = (unsigned __int16)dword_93AD8 + dword_B5D2C;
      dword_B5D04 = 1;
      dword_B5CD8 = 4 * (-1 - dword_B5D2C) + dword_AE3FC + 59360;
      break;
    case 6:
      dword_B5D18 = dword_90B4C[v4];
      dword_B5CE0 = (int)off_9134C[v4];
      v88 = -dword_93AD4;
      v99 = (unsigned __int16)dword_93ADC;
      dword_B5CF4 = (dword_B5D18 << 8) / (dword_B5CE0 >> 8);
      v109 = (dword_B5D18 << 8) / (dword_B5CE0 >> 8);
      v65 = (uint32*)&unk_B3EA0;
      v66 = (int *)(dword_AE3FC + 59360);
      v67 = 0;
      v68 = 0;
      v69 = 1;
      v70 = 0;
      do
      {
        v65[1] = v67;
        v65[2] = v70;
        //fix v11 = __CFADD__(v109, v68);
        v68 += v109;
        if ( v11 )
        {
          ++v67;
          ++v70;
          *v66++ = v69;
        }
        v65 += 3;
        v67 += v88;
        ++v69;
        --v99;
      }
      while ( v99 );
      dword_B5D24 = v70;
      dword_B5D2C = -v70;
      dword_B5D30 = (unsigned __int16)dword_93AD8;
      dword_B5D34 = (unsigned __int16)dword_93ADC;
      dword_B5D20 = (unsigned __int16)dword_93ADC + (unsigned __int16)dword_93AD8;
      dword_B5D1C = (unsigned __int16)dword_93AD8 - v70;
      dword_B5D04 = 1;
      dword_B5CD8 = 4 * (v70 - 1) + dword_AE3FC + 59360;
      break;
    case 7:
      dword_B5D18 = dword_90B4C[v4];
      dword_B5CE0 = (int)off_9134C[v4];
      v92 = -dword_93AD4;
      v100 = (unsigned __int16)dword_93AD8;
      if ( v1 == 1792 )
      {
        v71 = (uint32*)&unk_B3EA0;
        v72 = (int *)(dword_AE3FC + 59360);
        dword_B5CF4 = (int)sub_10000;
        v73 = 0;
        v74 = 1;
        v75 = 0;
        do
        {
          v71[1] = v73;
          v71[2] = v75++;
          *v72++ = v74;
          v71 += 3;
          v73 += v92 + 1;
          ++v74;
          --v100;
        }
        while ( v100 );
        dword_B5D24 = (unsigned __int16)dword_93AD8;
        dword_B5D2C = -(unsigned __int16)dword_93AD8;
      }
      else
      {
        dword_B5CF4 = (dword_B5CE0 << 8) / (dword_B5D18 >> 8);
        v110 = (dword_B5CE0 << 8) / (dword_B5D18 >> 8);
        v76 = (uint32*)&unk_B3EA0;
        v77 = (int *)(dword_AE3FC + 59360);
        v78 = 0;
        v79 = 0;
        v80 = 1;
        v81 = 0;
        do
        {
          v76[1] = v78;
          v76[2] = v81;
          //fix v11 = __CFADD__(v110, v79);
          v79 += v110;
          if ( v11 )
          {
            v78 += v92;
            ++v81;
            *v77++ = v80;
          }
          v76 += 3;
          ++v78;
          ++v80;
          --v100;
        }
        while ( v100 );
        dword_B5D24 = v81;
        dword_B5D2C = -v81;
      }
      v12 = (unsigned __int16)dword_93ADC + dword_B5D2C;
      dword_B5D30 = (unsigned __int16)dword_93ADC;
      dword_B5D34 = (unsigned __int16)dword_93AD8;
      v13 = (unsigned __int16)dword_93ADC + (unsigned __int16)dword_93AD8;
      v14 = -1 - dword_B5D2C;
LABEL_62:
      dword_B5D20 = v13;
      dword_B5CD8 = 4 * v14 + dword_AE3FC + 59360;
      v47 = dword_93AD4;
      dword_B5D1C = v12;
LABEL_63:
      dword_B5D04 = v47;
      break;
    default:
      break;
  }
  v101 = dword_B5D34 - 1;
  for ( result = (uint32*)&unk_B3EA0; v101 >= 0; --v101 )
  {
    v83 = result[1];
    v84 = *(result - 2);
    result += 3;
    *(result - 3) = v83 - v84;
  }
  return result;
}
// 10000: using guessed type void sub_10000();
// 90B4C: using guessed type int dword_90B4C[256];
// 9134C: using guessed type void (*off_9134C[2])();
// 93AD4: using guessed type int dword_93AD4;
// 93AD8: using guessed type int dword_93AD8;
// 93ADC: using guessed type int dword_93ADC;
// AE3FC: using guessed type int dword_AE3FC;
// B5CD8: using guessed type int dword_B5CD8;
// B5CE0: using guessed type int dword_B5CE0;
// B5CF4: using guessed type int dword_B5CF4;
// B5D04: using guessed type int dword_B5D04;
// B5D18: using guessed type int dword_B5D18;
// B5D1C: using guessed type int dword_B5D1C;
// B5D20: using guessed type int dword_B5D20;
// B5D24: using guessed type int dword_B5D24;
// B5D28: using guessed type int dword_B5D28;
// B5D2C: using guessed type int dword_B5D2C;
// B5D30: using guessed type int dword_B5D30;
// B5D34: using guessed type int dword_B5D34;

//----- (0002A700) --------------------------------------------------------
char sub_2A700(int a1, __int16 a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8)
{
  int v8; // eax
  int v9; // edx
  int v10; // ecx
  int v11; // eax
  int v12; // edx
  int v13; // edx
  int v14; // eax
  int v15; // ebp
  int v16; // eax
  int v17; // edi
  char v18; // dl
  int v19; // ecx
  int v20; // edi
  int v21; // esi
  _DWORD *v22; // eax
  char v23; // dl
  int v24; // ebp
  unsigned int v25; // edx
  char v26; // cl
  int v27; // eax
  int v28; // ebx
  int v29; // ebp
  int v30; // ebx
  __int16 v31; // si
  char *v32; // edi
  int v33; // eax
  __int16 v34; // cx
  int v35; // eax
  int v36; // ebx
  int v37; // esi
  int v38; // ebx
  unsigned __int16 v39; // dx
  __int16 v40; // ax
  int v41; // eax
  int v42; // eax
  int v43; // edx
  unsigned __int16 v44; // bx
  unsigned __int8 v45; // al
  char v46; // dl
  _BYTE *v47; // eax
  char v48; // dl
  char v49; // bh
  int v50; // ebx
  int v51; // eax
  int v52; // edi
  int v53; // ecx
  int v54; // esi
  int v55; // edx
  int v56; // edx
  int v57; // ecx
  int v58; // ecx
  int v59; // edi
  int v60; // esi
  int v61; // edi
  int v62; // ebx
  int v63; // eax
  char v64; // dl
  char v65; // ch
  char v66; // dl
  int v67; // eax
  int v68; // ebx
  int v69; // eax
  char v70; // ch
  int v71; // ebx
  char v72; // dl
  int *v73; // esi
  char v74; // dl
  unsigned int v75; // ebp
  unsigned int v76; // ebx
  char v77; // dl
  char v78; // dl
  int v79; // eax
  unsigned int v80; // ebx
  int v81; // eax
  char v82; // cl
  int v83; // eax
  int v84; // ebx
  char v85; // dl
  int *v86; // esi
  int v87; // eax
  char v88; // dh
  int v89; // edi
  int *v90; // esi
  int v91; // ebx
  int v92; // eax
  char v93; // dl
  char v94; // dh
  char v95; // ah
  char v96; // dl
  char v97; // dh
  int v98; // eax
  int v99; // ebx
  char v100; // ch
  int v101; // eax
  int v102; // ebx
  char v103; // dl
  char v104; // dh
  int *v105; // ebp
  int v106; // ebp
  char v107; // ch
  unsigned int v108; // ebp
  unsigned int v109; // ebx
  char v110; // dl
  char v111; // ch
  char v112; // dh
  char v113; // ah
  char v114; // dl
  char v115; // dh
  int v116; // eax
  unsigned int v117; // ebx
  int v118; // eax
  int v119; // eax
  char v120; // ch
  int v121; // ebx
  char v122; // dl
  char v123; // dh
  char v124; // ch
  int v125; // eax
  int v126; // ebx
  int v127; // esi
  int v128; // eax
  int v129; // ebx
  unsigned __int16 v130; // dx
  __int16 v131; // ax
  int v132; // eax
  int v133; // eax
  unsigned __int16 v134; // bx
  unsigned int v135; // eax
  _BYTE *v136; // eax
  char v137; // ch
  int v138; // eax
  int v139; // ebx
  int v140; // edx
  void (*v141)(); // eax
  int v142; // eax
  int v143; // ecx
  int v144; // edx
  int v145; // ecx
  int v146; // edx
  int *v147; // esi
  int v148; // ebp
  int v149; // ebx
  char v150; // dl
  char v151; // dh
  char v152; // al
  char v153; // cl
  unsigned __int8 v154; // dl
  char v155; // dh
  char v156; // dh
  int v157; // ebx
  unsigned int v158; // esi
  unsigned int v159; // ebx
  char v160; // dl
  char v161; // al
  char v162; // dh
  char v163; // cl
  unsigned __int8 v164; // dl
  unsigned int v165; // ebx
  char v166; // dh
  int v167; // ebx
  int v168; // edi
  int v169; // ebx
  char v170; // dl
  char v171; // dh
  char v172; // ah
  char v173; // dl
  char v174; // dh
  int v175; // eax
  int v176; // ebx
  char v177; // ch
  int v178; // eax
  int v179; // ebx
  char v180; // dl
  char v181; // dh
  char v182; // dl
  unsigned int v183; // ebp
  unsigned int v184; // ebx
  char v185; // dl
  char v186; // dh
  char v187; // al
  char v188; // dl
  char v189; // dh
  int v190; // eax
  unsigned int v191; // ebx
  int v192; // eax
  char v193; // cl
  int v194; // ebx
  char v195; // dl
  char v196; // dh
  int v198; // [esp+0h] [ebp-E0h] BYREF
  int v199; // [esp+4h] [ebp-DCh]
  int v200; // [esp+8h] [ebp-D8h]
  int v201; // [esp+Ch] [ebp-D4h]
  int *v202; // [esp+10h] [ebp-D0h]
  int v203; // [esp+18h] [ebp-C8h] BYREF
  int v204; // [esp+1Ch] [ebp-C4h]
  int v205; // [esp+20h] [ebp-C0h]
  int v206; // [esp+24h] [ebp-BCh]
  int *v207; // [esp+28h] [ebp-B8h]
  int v208; // [esp+30h] [ebp-B0h] BYREF
  int v209; // [esp+34h] [ebp-ACh]
  int v210; // [esp+38h] [ebp-A8h]
  int v211; // [esp+3Ch] [ebp-A4h]
  int v212; // [esp+40h] [ebp-A0h]
  int v213; // [esp+48h] [ebp-98h] BYREF
  int v214; // [esp+4Ch] [ebp-94h]
  int v215; // [esp+50h] [ebp-90h]
  int v216; // [esp+54h] [ebp-8Ch]
  int v217; // [esp+58h] [ebp-88h]
  int v218; // [esp+60h] [ebp-80h]
  int v219; // [esp+64h] [ebp-7Ch]
  int v220; // [esp+68h] [ebp-78h]
  _BYTE *v221; // [esp+6Ch] [ebp-74h]
  int v222; // [esp+70h] [ebp-70h]
  int v223; // [esp+74h] [ebp-6Ch]
  void (*v224)(); // [esp+78h] [ebp-68h]
  int v225; // [esp+7Ch] [ebp-64h]
  int v226; // [esp+80h] [ebp-60h]
  int v227; // [esp+84h] [ebp-5Ch]
  int v228; // [esp+88h] [ebp-58h]
  int v229; // [esp+8Ch] [ebp-54h]
  int v230; // [esp+90h] [ebp-50h]
  unsigned __int16 v231; // [esp+94h] [ebp-4Ch]
  char v232; // [esp+98h] [ebp-48h]
  char v233; // [esp+9Ch] [ebp-44h]
  char v234; // [esp+A0h] [ebp-40h]
  char v235; // [esp+A4h] [ebp-3Ch]
  char v236; // [esp+A8h] [ebp-38h]
  char v237; // [esp+ACh] [ebp-34h]
  char v238; // [esp+B0h] [ebp-30h]
  char v239; // [esp+B4h] [ebp-2Ch]
  char v240; // [esp+B8h] [ebp-28h]
  char v241; // [esp+BCh] [ebp-24h]
  char v242; // [esp+C0h] [ebp-20h]
  char v243; // [esp+C4h] [ebp-1Ch]
  char v244; // [esp+C8h] [ebp-18h]
  char v245; // [esp+CCh] [ebp-14h]

  byte_B5D3F = *(_BYTE *)(dword_AE400 + 8598);
  dword_B5CE4 = (int)(unsigned __int16)dword_93ADC >> 1;
  word_B5D3C = a2;
  word_B5D38 = a4 & 0x7FF;
  word_B5D3A = a3;
  v8 = (a4 & 0x7FF) + 256;
  dword_B5CF8 = a5;
  v9 = dword_90F4C[v8];
  dword_B5D08 = dword_902B0 + ((int)(unsigned __int16)dword_93AD8 >> 1);
  dword_B5CDC = v9;
  v10 = dword_9074C[v8];
  v223 = (v8 >> 9) & 3;
  v11 = ((((a4 & 0x7FF) + 256) & 0x1FF) - 256) & 0x7FF;
  v12 = dword_90B4C[v11];
  v224 = off_9134C[v11];
  dword_B5D10 = v10;
  v225 = v12;
  sub_29C30(-a7 & 0x7FF);
  dword_B5D14 = (a8
               * sub_410CE(
                   (unsigned __int16)dword_93AD8 * (unsigned __int16)dword_93AD8
                 + (unsigned __int16)dword_93ADC * (unsigned __int16)dword_93ADC)) >> 8;
  v221 = (uint8*)((char *)&unk_902B4 + 10 * v223);
  v13 = (unsigned __int8)a3;
  switch ( v223 )
  {
    case 0:
      a1 = -(unsigned __int8)a2 - 4864;
      v226 = (unsigned __int8)a3 - 256;
      break;
    case 1:
      v13 = -(unsigned __int8)a3;
      v14 = -(unsigned __int8)a2;
      goto LABEL_6;
    case 2:
      a1 = (unsigned __int8)a2 - 4864;
      v226 = -(unsigned __int8)a3;
      break;
    case 3:
      v14 = (unsigned __int8)a2 - 256;
LABEL_6:
      a1 = v13 - 4864;
      v226 = v14;
      break;
    default:
      break;
  }
  v15 = a1 * v225;
  v235 = 40;
  v218 = (_DWORD)v224 << 8;
  v228 = a1 * (_DWORD)v224;
  v229 = v225 << 8;
  v16 = dword_AE3FC;
  v17 = v225 << 8;
  do
  {
    v18 = 21;
    v19 = v228 >> 16;
    do
    {
      *(_DWORD *)v16 = v19;
      *(_DWORD *)(v16 + 12) = v15 >> 16;
      if ( a1 < 0 )
        *(_WORD *)(v16 + 38) = 0;
      else
        *(_WORD *)(v16 + 38) = 4;
      v16 += 1760;
      --v18;
    }
    while ( v18 );
    v16 -= 36916;
    a1 += 256;
    v15 += v17;
    v228 += v218;
    --v235;
  }
  while ( v235 );
  v20 = (_DWORD)v224 * v226;
  v230 = (_DWORD)v224 << 8;
  v219 = v225 << 8;
  v21 = v225 * v226;
  v22 = (_DWORD *)dword_AE3FC;
  v234 = 21;
  do
  {
    v23 = 40;
    do
    {
      *v22 -= v21 >> 16;
      v24 = v22[3];
      v22 += 11;
      *(v22 - 8) = (v20 >> 16) + v24;
      --v23;
    }
    while ( v23 );
    v20 += v230;
    v21 += v219;
    v226 += 256;
    --v234;
  }
  while ( v234 );
  dword_B5D0C = 23658496;
  dword_B5CF0 = 14745600;
  v25 = (unsigned __int16)dword_93AD8;
  dword_B5D00 = 26214400;
  dword_B5CEC = 8912896;
  v26 = *v221;
  dword_B5CFC = ((unsigned __int16)dword_93AD8 * a6) >> 8;
  LOBYTE(v231) = v26 + HIBYTE(a2);
  HIBYTE(v231) = v221[1] + HIBYTE(a3);
  v27 = a7 & 0x7FF;
  v28 = dword_90B4C[v27];
  dword_B5CE8 = (int)off_9134C[v27];
  dword_B5CD4 = v28;
  v29 = dword_AE3FC;
  if ( *(_BYTE *)(dword_AE400 + 8603) == 2 && !*(_BYTE *)(dword_AE400 + 8606) )
  {
    v30 = dword_93AD4 - (unsigned __int16)dword_93AD8;
    v33 = (int)(unsigned __int16)dword_93AD8 >> 2;
    v31 = dword_93ADC;
    v32 = (char *)dword_93ACC;
    v25 = v33;
    LOBYTE(v33) = 64;
    goto LABEL_24;
  }
  if ( !*(_BYTE *)(dword_AE400 + 8599) )
  {
    v30 = dword_93AD4 - (unsigned __int16)dword_93AD8;
    v33 = (int)(unsigned __int16)dword_93AD8 >> 2;
    v31 = dword_93ADC;
    v32 = (char *)dword_93ACC;
    v25 = v33;
    LOBYTE(v33) = -1;
LABEL_24:
    BYTE1(v33) = v33;
    v34 = v33;
    v35 = v33 << 16;
    LOWORD(v35) = v34;
    do
    {
      memset32((char*)v32, v35, v25);
      v32 += 4 * v25 + v30;
      --v31;
    }
    while ( v31 );
    goto LABEL_26;
  }
  sub_30730(a7);
LABEL_26:
  if ( *(_BYTE *)(dword_AE400 + 8597) && (*(_BYTE *)(dword_AE400 + 8603) != 2 || *(_BYTE *)(dword_AE400 + 8606)) )
  {
    v233 = 21;
    while ( 1 )
    {
      v242 = 40;
      do
      {
        v36 = *(_DWORD *)v29 * *(_DWORD *)v29;
        v37 = *(_DWORD *)(v29 + 12);
        v220 = ((unsigned __int8)byte_EC1E0[v231] << 8) + 128;
        *(_WORD *)(v29 + 36) = 0;
        v38 = v37 * v37 + v36;
        if ( v37 <= -256 || v38 >= dword_B5D00 )
        {
          *(_BYTE *)(v29 + 38) |= 2u;
          goto LABEL_49;
        }
        if ( v37 < 128 )
          v37 = 128;
        v39 = v231;
        *(_DWORD *)(v29 + 16) = dword_B5D14 * *(_DWORD *)v29 / v37;
        *(_DWORD *)(v29 + 4) = 32 * (unsigned __int8)byte_DC1E0[v39] - a5;
        v40 = (unsigned __int16)*(_DWORD *)(2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 13341) << 6;
        v227 = dword_90B4C[(v40 + (HIBYTE(v231) << 7)) & 0x7FF] >> 8;
        v41 = v227 * (dword_90B4C[(((unsigned __int8)v231 << 7) + v40) & 0x7FF] >> 8);
        v227 = (unsigned __int8)byte_DC1E0[v39];
        *(_DWORD *)(v29 + 8) = -((v227 * ((v41 >> 4) + 0x8000)) >> 10) - a5;
        if ( (byte_FC1E0[v39] & 8) != 0 )
          *(_DWORD *)(v29 + 4) -= v41 >> 10;
        else
          v41 = 0;
        v42 = (v220 << 8) + 8 * v41;
        if ( v38 <= dword_B5CF0 )
          goto LABEL_42;
        if ( v38 < dword_B5D0C )
        {
          v42 = v42 * (__int64)(dword_B5D0C - v38) / dword_B5CEC;
LABEL_42:
          *(_DWORD *)(v29 + 32) = v42;
          goto LABEL_43;
        }
        *(_DWORD *)(v29 + 32) = 0;
LABEL_43:
        v43 = dword_B5D14 * *(_DWORD *)(v29 + 8);
        *(_DWORD *)(v29 + 20) = dword_B5CFC + dword_B5D14 * *(_DWORD *)(v29 + 4) / v37;
        *(_DWORD *)(v29 + 28) = dword_B5CFC + v43 / v37;
        LOBYTE(v44) = v221[2] + v231;
        HIBYTE(v44) = v221[3] + HIBYTE(v231);
        v45 = byte_CC1E0[v44];
        *(_BYTE *)(v29 + 41) = v45;
        if ( byte_9020C[v45] )
          *(_BYTE *)(v29 + 38) |= 0x80u;
        if ( byte_90168[*(unsigned __int8 *)(v29 + 41)] )
          *(_BYTE *)(v29 + 39) |= 0x10u;
        *(_BYTE *)(v29 + 43) = byte_900C4[*(unsigned __int8 *)(v29 + 41)];
        *(_BYTE *)(v29 + 42) = v223 + (((int)(unsigned __int8)byte_FC1E0[v44] >> 2) & 0x1C);
        LOBYTE(v44) = v221[4] + v44;
        HIBYTE(v44) += v221[5];
        *(_WORD *)(v29 + 36) = word_10C1E0[v44];
LABEL_49:
        v46 = v231;
        v47 = v221;
        *(_WORD *)(v29 + 38) |= ((_BYTE)v231 + HIBYTE(v231)) & 1;
        LOBYTE(v231) = v47[8] + v46;
        v48 = v221[9] + HIBYTE(v231);
        HIBYTE(v231) = v48;
        v29 += 44;
        --v242;
      }
      while ( v242 );
      v49 = v221[6] + v231;
      HIBYTE(v231) = v221[7] + v48;
      LOBYTE(v231) = v49;
      if ( !--v233 )
      {
        v50 = 840;
        v51 = dword_AE3FC;
        do
        {
          v52 = ((dword_B5CE8 * *(_DWORD *)(v51 + 16) - dword_B5CD4 * *(_DWORD *)(v51 + 28)) >> 16) + dword_B5D08;
          v53 = *(_DWORD *)(v51 + 16) * dword_B5CD4;
          v54 = dword_B5CE4 - ((v53 + dword_B5CE8 * *(_DWORD *)(v51 + 20)) >> 16);
          v55 = dword_B5CE8 * *(_DWORD *)(v51 + 28);
          *(_DWORD *)(v51 + 16) = ((dword_B5CE8 * *(_DWORD *)(v51 + 16) - dword_B5CD4 * *(_DWORD *)(v51 + 20)) >> 16)
                                + dword_B5D08;
          v56 = v53 + v55;
          v57 = dword_B5CE4;
          *(_DWORD *)(v51 + 24) = v52;
          *(_DWORD *)(v51 + 28) = v57 - (v56 >> 16);
          v58 = *(_DWORD *)(v51 + 16);
          *(_DWORD *)(v51 + 20) = v54;
          if ( v58 >= 0 )
          {
            if ( (unsigned __int16)dword_93AD8 <= v58 )
              *(_BYTE *)(v51 + 38) |= 0x10u;
          }
          else
          {
            *(_BYTE *)(v51 + 38) |= 8u;
          }
          v59 = *(_DWORD *)(v51 + 20);
          if ( v59 >= 0 )
          {
            if ( (unsigned __int16)dword_93ADC <= v59 )
              *(_BYTE *)(v51 + 38) |= 0x40u;
          }
          else
          {
            *(_BYTE *)(v51 + 38) |= 0x20u;
          }
          if ( *(int *)(v51 + 24) >= 0 )
          {
            if ( (unsigned __int16)dword_93AD8 <= *(int *)(v51 + 24) )
              *(_BYTE *)(v51 + 39) |= 2u;
          }
          else
          {
            *(_BYTE *)(v51 + 39) |= 1u;
          }
          v60 = *(_DWORD *)(v51 + 28);
          if ( v60 >= 0 )
          {
            if ( (unsigned __int16)dword_93ADC <= v60 )
              *(_BYTE *)(v51 + 39) |= 8u;
          }
          else
          {
            *(_BYTE *)(v51 + 39) |= 4u;
          }
          v51 += 44;
          --v50;
        }
        while ( v50 );
        if ( a5 < 4096 )
        {
          v61 = dword_AE3FC + 35200;
          v240 = 20;
          while ( 1 )
          {
            v62 = v61;
            v241 = 39;
            do
            {
              v213 = *(_DWORD *)(v62 + 24);
              v214 = *(_DWORD *)(v62 + 28);
              v63 = *(_DWORD *)(v62 + 32);
              v62 += 44;
              v217 = v63;
              v64 = *(_BYTE *)(v62 - 6);
              if ( (*(_BYTE *)(v62 + 38) & 4) != 0 )
                break;
              v208 = *(_DWORD *)(v62 + 24);
              v209 = *(_DWORD *)(v62 + 28);
              v212 = *(_DWORD *)(v62 + 32);
              v65 = *(_BYTE *)(v62 + 38);
              v203 = *(_DWORD *)(v62 - 1736);
              v204 = *(_DWORD *)(v62 - 1732);
              v207 = *(int **)(v62 - 1728);
              v66 = *(_BYTE *)(v62 - 1722) | v65 | v64;
              v198 = *(_DWORD *)(v62 - 1780);
              v67 = *(_DWORD *)(v62 - 1776);
              v68 = v62 - 1760;
              v199 = v67;
              v69 = *(_DWORD *)(v68 - 12);
              v68 -= 44;
              v202 = (int *)v69;
              v70 = *(_BYTE *)(v68 + 38);
              v71 = v68 + 1760;
              v72 = v70 | v66;
              if ( *(_BYTE *)(v71 + 41) )
              {
                if ( (*(_BYTE *)(v71 + 39) & 0x10) != 0 )
                {
                  byte_967E1 = 7;
                  byte_967E0 = ((int)v202 + (int)v207 + v212 + v217) >> 18;
                }
                else
                {
                  byte_967E1 = 5;
                }
                if ( (v72 & 2) == 0 )
                {
                  v73 = (int *)((char *)&unk_902DC + 32 * *(unsigned __int8 *)(v71 + 42));
                  v215 = *v73;
                  v216 = v73[1];
                  v210 = v73[2];
                  v211 = v73[3];
                  v205 = v73[4];
                  v206 = v73[5];
                  v200 = v73[6];
                  v201 = v73[7];
                  dword_93AD0 = dword_9334C[*(unsigned __int8 *)(v71 + 41)];
                  v74 = *(_BYTE *)(v71 + 38);
                  byte_967E1 = 5;
                  if ( (v74 & 1) != 0 )
                  {
                    sub_729A3((uint32*)&v213, (uint32*)&v198, (uint32*)&v208);
                    sub_729A3((uint32*)&v198, (uint32*)&v203, (uint32*)&v208);
                  }
                  else
                  {
                    sub_729A3((uint32*)&v213, (uint32*)&v203, (uint32*)&v208);
                    sub_729A3((uint32*)&v213, (uint32*)&v198, (uint32*)&v203);
                  }
                }
                if ( !*(_WORD *)(v71 + 36) )
                  goto LABEL_85;
LABEL_84:
                sub_2FC50(v61, v71);
                goto LABEL_85;
              }
              if ( *(_WORD *)(v71 + 36) )
                goto LABEL_84;
LABEL_85:
              v62 = v71 + 44;
              --v241;
            }
            while ( v241 );
            if ( v241 )
              break;
LABEL_101:
            v61 -= 1760;
            if ( !--v240 )
              goto LABEL_102;
          }
          v75 = v62 - 44;
          v76 = v61 + 1672;
          while ( 2 )
          {
            v213 = *(_DWORD *)(v76 + 24);
            v214 = *(_DWORD *)(v76 + 28);
            v217 = *(_DWORD *)(v76 + 32);
            v77 = *(_BYTE *)(v76 + 38);
            v208 = *(_DWORD *)(v76 + 68);
            v209 = *(_DWORD *)(v76 + 72);
            v212 = *(_DWORD *)(v76 + 76);
            v78 = *(_BYTE *)(v76 + 82) | v77;
            v203 = *(_DWORD *)(v76 - 1692);
            v79 = *(_DWORD *)(v76 - 1688);
            v80 = v76 + 44;
            v204 = v79;
            v81 = *(_DWORD *)(v80 - 1728);
            v80 -= 1760;
            v207 = (int *)v81;
            v82 = *(_BYTE *)(v80 + 38);
            v198 = *(_DWORD *)(v80 - 20);
            v83 = *(_DWORD *)(v80 - 16);
            v80 -= 44;
            v199 = v83;
            v202 = *(int **)(v80 + 32);
            LOBYTE(v83) = *(_BYTE *)(v80 + 38);
            v84 = v80 + 1760;
            v85 = v83 | v82 | v78;
            if ( *(_BYTE *)(v84 + 41) )
            {
              if ( (*(_BYTE *)(v84 + 39) & 0x10) != 0 )
              {
                byte_967E1 = 7;
                byte_967E0 = ((int)v202 + (int)v207 + v212 + v217) >> 18;
              }
              else
              {
                byte_967E1 = 5;
              }
              if ( (v85 & 2) == 0 )
              {
                v86 = (int *)((char *)&unk_902DC + 32 * *(unsigned __int8 *)(v84 + 42));
                v215 = *v86;
                v216 = v86[1];
                v210 = v86[2];
                v211 = v86[3];
                v205 = v86[4];
                v206 = v86[5];
                v200 = v86[6];
                v201 = v86[7];
                v87 = *(unsigned __int8 *)(v84 + 41);
                byte_967E1 = 5;
                v88 = *(_BYTE *)(v84 + 38);
                dword_93AD0 = dword_9334C[v87];
                if ( (v88 & 1) != 0 )
                {
                  sub_729A3((uint32*)&v213, (uint32*)&v198, (uint32*)&v208);
                  sub_729A3((uint32*)&v198, (uint32*)&v203, (uint32*)&v208);
                }
                else
                {
                  sub_729A3((uint32*)&v213, (uint32*)&v203, (uint32*)&v208);
                  sub_729A3((uint32*)&v213, (uint32*)&v198, (uint32*)&v203);
                }
              }
              if ( *(_WORD *)(v84 + 36) )
LABEL_99:
                sub_2FC50(v61, v84);
            }
            else if ( *(_WORD *)(v84 + 36) )
            {
              goto LABEL_99;
            }
            v76 = v84 - 44;
            if ( v76 < v75 )
              goto LABEL_101;
            continue;
          }
        }
LABEL_102:
        v89 = dword_AE3FC + 35200;
        v239 = 20;
        while ( 2 )
        {
          v90 = (int *)&unk_902DC;
          v91 = v89;
          v237 = 39;
LABEL_104:
          v213 = *(_DWORD *)(v91 + 16);
          v214 = *(_DWORD *)(v91 + 20);
          v92 = *(_DWORD *)(v91 + 32);
          v91 += 44;
          v217 = v92;
          v93 = *(_BYTE *)(v91 - 6);
          v94 = v93;
          if ( (*(_BYTE *)(v91 + 38) & 4) != 0 )
          {
LABEL_124:
            if ( !v237 )
            {
LABEL_145:
              v89 -= 1760;
              LOBYTE(v125) = --v239;
              if ( !v239 )
                return v125;
              continue;
            }
            v108 = v91 - 44;
            v109 = v89 + 1672;
            while ( 2 )
            {
              v213 = *(_DWORD *)(v109 + 16);
              v214 = *(_DWORD *)(v109 + 20);
              v217 = *(_DWORD *)(v109 + 32);
              v110 = *(_BYTE *)(v109 + 38);
              v208 = *(_DWORD *)(v109 + 60);
              v209 = *(_DWORD *)(v109 + 64);
              v212 = *(_DWORD *)(v109 + 76);
              v111 = *(_BYTE *)(v109 + 82);
              v203 = *(_DWORD *)(v109 - 1700);
              v204 = *(_DWORD *)(v109 - 1696);
              v112 = v110;
              v207 = *(int **)(v109 - 1684);
              v113 = *(_BYTE *)(v109 - 1678);
              v114 = v113 | v111 | v110;
              v115 = v113 & v111 & v112;
              v116 = *(_DWORD *)(v109 - 1744);
              v117 = v109 + 44;
              v198 = v116;
              v118 = *(_DWORD *)(v117 - 1784);
              v117 -= 1760;
              v199 = v118;
              v119 = *(_DWORD *)(v117 - 12);
              v117 -= 44;
              v202 = (int *)v119;
              v120 = *(_BYTE *)(v117 + 38);
              v121 = v117 + 1760;
              v122 = v120 | v114;
              v123 = v120 & v115;
              if ( *(char *)(v121 + 38) >= 0 )
              {
                if ( (*(_BYTE *)(v121 + 39) & 0x10) != 0 )
                {
                  byte_967E1 = 7;
                  v90 = v207;
                  byte_967E0 = ((int)v202 + (int)v207 + v212 + v217) >> 18;
                }
                else
                {
                  byte_967E1 = 5;
                }
                if ( (v122 & 2) == 0 && (v123 & 0x78) == 0 )
                {
                  v90 = (int *)((char *)&unk_902DC + 32 * *(unsigned __int8 *)(v121 + 42));
                  v215 = *v90;
                  v216 = v90[1];
                  v210 = v90[2];
                  v211 = v90[3];
                  v205 = v90[4];
                  v206 = v90[5];
                  v200 = v90[6];
                  v201 = v90[7];
                  dword_93AD0 = dword_9334C[*(unsigned __int8 *)(v121 + 41)];
                  if ( (*(_BYTE *)(v121 + 38) & 1) != 0 )
                  {
                    sub_729A3((uint32*)&v213, (uint32*)&v208, (uint32*)&v198);
                    sub_729A3((uint32*)&v198, (uint32*)&v208, (uint32*)&v203);
                  }
                  else
                  {
                    sub_729A3((uint32*)&v213, (uint32*)&v208, (uint32*)&v203);
                    sub_729A3((uint32*)&v213, (uint32*)&v203, (uint32*)&v198);
                  }
                }
                if ( *(_WORD *)(v121 + 36) )
LABEL_143:
                  sub_2DCB0((int)v90, v121);
              }
              else
              {
                byte_967E1 = 26;
                if ( (v122 & 2) == 0 && (v123 & 0x78) == 0 )
                {
                  v90 = (int *)((char *)&unk_902DC + 32 * *(unsigned __int8 *)(v121 + 42));
                  v215 = *v90;
                  v216 = v90[1];
                  v210 = v90[2];
                  v211 = v90[3];
                  v205 = v90[4];
                  v206 = v90[5];
                  v200 = v90[6];
                  v201 = v90[7];
                  v124 = *(_BYTE *)(v121 + 38);
                  dword_93AD0 = dword_9334C[*(unsigned __int8 *)(v121 + 41)];
                  if ( (v124 & 1) != 0 )
                  {
                    sub_729A3((uint32*)&v213, (uint32*)&v208, (uint32*)&v198);
                    sub_729A3((uint32*)&v198, (uint32*)&v208, (uint32*)&v203);
                  }
                  else
                  {
                    sub_729A3((uint32*)&v213, (uint32*)&v208, (uint32*)&v203);
                    sub_729A3((uint32*)&v213, (uint32*)&v203, (uint32*)&v198);
                  }
                }
                if ( *(_WORD *)(v121 + 36) )
                  goto LABEL_143;
              }
              v109 = v121 - 44;
              if ( v109 < v108 )
                goto LABEL_145;
              continue;
            }
          }
          break;
        }
        v208 = *(_DWORD *)(v91 + 16);
        v209 = *(_DWORD *)(v91 + 20);
        v212 = *(_DWORD *)(v91 + 32);
        v95 = *(_BYTE *)(v91 + 38);
        v96 = v95 | v93;
        v97 = v95 & v94;
        v203 = *(_DWORD *)(v91 - 1744);
        v204 = *(_DWORD *)(v91 - 1740);
        v98 = *(_DWORD *)(v91 - 1728);
        v99 = v91 - 1760;
        v207 = (int *)v98;
        v100 = *(_BYTE *)(v99 + 38);
        v198 = *(_DWORD *)(v99 - 28);
        v101 = *(_DWORD *)(v99 - 24);
        v99 -= 44;
        v199 = v101;
        v202 = *(int **)(v99 + 32);
        BYTE1(v101) = *(_BYTE *)(v99 + 38);
        v102 = v99 + 1760;
        v103 = BYTE1(v101) | v100 | v96;
        v104 = BYTE1(v101) & v100 & v97;
        if ( *(char *)(v102 + 38) >= 0 )
        {
          if ( (*(_BYTE *)(v102 + 39) & 0x10) != 0 )
          {
            byte_967E1 = 7;
            byte_967E0 = ((int)v202 + (int)v207 + v212 + v217) >> 18;
          }
          else
          {
            byte_967E1 = 5;
          }
          if ( (v103 & 2) == 0 && (v104 & 0x78) == 0 )
          {
            v106 = 32 * *(unsigned __int8 *)(v102 + 42);
            v215 = *(_DWORD *)((char *)&unk_902DC + v106);
            v216 = *(_DWORD *)((char *)&unk_902DC + v106 + 4);
            v210 = *(_DWORD *)((char *)&unk_902DC + v106 + 8);
            v211 = *(_DWORD *)((char *)&unk_902DC + v106 + 12);
            v205 = *(_DWORD *)((char *)&unk_902DC + v106 + 16);
            v206 = *(_DWORD *)((char *)&unk_902DC + v106 + 20);
            v200 = *(_DWORD *)((char *)&unk_902DC + v106 + 24);
            v201 = *(_DWORD *)((char *)&unk_902DC + v106 + 28);
            v107 = *(_BYTE *)(v102 + 38);
            dword_93AD0 = dword_9334C[*(unsigned __int8 *)(v102 + 41)];
            if ( (v107 & 1) != 0 )
            {
              sub_729A3((uint32*)&v213, (uint32*)&v208, (uint32*)&v198);
              sub_729A3((uint32*)&v198, (uint32*)&v208, (uint32*)&v203);
            }
            else
            {
              sub_729A3((uint32*)&v213, (uint32*)&v208, (uint32*)&v203);
              sub_729A3((uint32*)&v213, (uint32*)&v203, (uint32*)&v198);
            }
          }
          if ( *(_WORD *)(v102 + 36) )
LABEL_122:
            sub_2DCB0((int)&unk_902DC, v102);
        }
        else
        {
          byte_967E1 = 26;
          if ( (v103 & 2) == 0 && (v104 & 0x78) == 0 )
          {
            v105 = (int *)((char *)&unk_902DC + 32 * *(unsigned __int8 *)(v102 + 42));
            v215 = *v105;
            v216 = v105[1];
            v210 = v105[2];
            v211 = v105[3];
            v205 = v105[4];
            v206 = v105[5];
            v200 = v105[6];
            v201 = v105[7];
            dword_93AD0 = dword_9334C[*(unsigned __int8 *)(v102 + 41)];
            if ( (*(_BYTE *)(v102 + 38) & 1) != 0 )
            {
              sub_729A3((uint32*)&v213, (uint32*)&v208, (uint32*)&v198);
              sub_729A3((uint32*)&v198, (uint32*)&v208, (uint32*)&v203);
            }
            else
            {
              sub_729A3((uint32*)&v213, (uint32*)&v208, (uint32*)&v203);
              sub_729A3((uint32*)&v213, (uint32*)&v203, (uint32*)&v198);
            }
          }
          if ( *(_WORD *)(v102 + 36) )
            goto LABEL_122;
        }
        v91 = v102 + 44;
        if ( !--v237 )
          goto LABEL_124;
        goto LABEL_104;
      }
    }
  }
  v238 = 21;
  do
  {
    v243 = 40;
    do
    {
      v126 = *(_DWORD *)v29 * *(_DWORD *)v29;
      v127 = *(_DWORD *)(v29 + 12);
      v222 = ((unsigned __int8)byte_EC1E0[v231] << 8) + 128;
      v128 = v127 * v127;
      *(_WORD *)(v29 + 36) = 0;
      v129 = v127 * v127 + v126;
      if ( v127 > -256 && v129 < dword_B5D00 )
      {
        if ( v127 < 128 )
          v127 = 128;
        v130 = v231;
        *(_DWORD *)(v29 + 16) = dword_B5D14 * *(_DWORD *)v29 / v127;
        *(_DWORD *)(v29 + 4) = 32 * (unsigned __int8)byte_DC1E0[v130] - a5;
        v131 = (unsigned __int16)*(_DWORD *)(2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 13341) << 6;
        v227 = dword_90B4C[(v131 + (HIBYTE(v231) << 7)) & 0x7FF] >> 8;
        v132 = v227 * (dword_90B4C[(((unsigned __int8)v231 << 7) + v131) & 0x7FF] >> 8);
        if ( (byte_FC1E0[v130] & 8) != 0 )
          *(_DWORD *)(v29 + 4) -= v132 >> 10;
        else
          v132 = 0;
        v133 = (v222 << 8) + 8 * v132;
        if ( v129 > dword_B5CF0 )
        {
          if ( v129 >= dword_B5D0C )
          {
            *(_DWORD *)(v29 + 32) = 0;
LABEL_161:
            *(_DWORD *)(v29 + 20) = dword_B5CFC + dword_B5D14 * *(_DWORD *)(v29 + 4) / v127;
            LOBYTE(v134) = v221[2] + v231;
            HIBYTE(v134) = v221[3] + HIBYTE(v231);
            *(_BYTE *)(v29 + 41) = byte_CC1E0[v134];
            *(_BYTE *)(v29 + 43) = byte_900C4[*(unsigned __int8 *)(v29 + 41)];
            HIWORD(v25) = HIWORD(v223);
            *(_BYTE *)(v29 + 42) = v223 + (((int)(unsigned __int8)byte_FC1E0[v134] >> 2) & 0x1C);
            LOBYTE(v134) = v221[4] + v134;
            HIWORD(v128) = 0;
            HIBYTE(v134) += v221[5];
            *(_WORD *)(v29 + 36) = word_10C1E0[v134];
            goto LABEL_163;
          }
          v133 = v133 * (__int64)(dword_B5D0C - v129) / dword_B5CEC;
        }
        *(_DWORD *)(v29 + 32) = v133;
        goto LABEL_161;
      }
      *(_BYTE *)(v29 + 38) |= 2u;
LABEL_163:
      LOWORD(v128) = HIBYTE(v231);
      LOWORD(v25) = (unsigned __int8)v231;
      v135 = v25 + v128;
      LOWORD(v25) = *(_WORD *)(v29 + 38);
      LOWORD(v135) = v135 & 1;
      v25 |= v135;
      v136 = v221;
      *(_WORD *)(v29 + 38) = v25;
      v137 = v136[8] + v231;
      LOBYTE(v136) = v221[9];
      v29 += 44;
      LOBYTE(v231) = v137;
      HIBYTE(v231) += (_BYTE)v136;
      --v243;
    }
    while ( v243 );
    LOBYTE(v231) = v221[6] + v137;
    HIBYTE(v231) += v221[7];
    --v238;
  }
  while ( v238 );
  v138 = a7 & 0x7FF;
  v139 = 840;
  v140 = dword_90B4C[v138];
  v141 = off_9134C[v138];
  dword_B5CD4 = v140;
  dword_B5CE8 = (int)v141;
  v142 = dword_AE3FC;
  do
  {
    v143 = dword_B5CE4;
    v144 = (dword_B5CD4 * *(_DWORD *)(v142 + 16) + dword_B5CE8 * *(_DWORD *)(v142 + 20)) >> 16;
    *(_DWORD *)(v142 + 16) = ((*(_DWORD *)(v142 + 16) * dword_B5CE8 - dword_B5CD4 * *(_DWORD *)(v142 + 20)) >> 16)
                           + dword_B5D08;
    v145 = v143 - v144;
    v146 = *(_DWORD *)(v142 + 16);
    *(_DWORD *)(v142 + 20) = v145;
    if ( v146 >= 0 )
    {
      if ( (unsigned __int16)dword_93AD8 <= *(int *)(v142 + 16) )
        *(_BYTE *)(v142 + 38) |= 0x10u;
    }
    else
    {
      *(_BYTE *)(v142 + 38) |= 8u;
    }
    v147 = *(int **)(v142 + 20);
    if ( (int)v147 >= 0 )
    {
      if ( (unsigned __int16)dword_93ADC <= (int)v147 )
        *(_BYTE *)(v142 + 38) |= 0x40u;
    }
    else
    {
      *(_BYTE *)(v142 + 38) |= 0x20u;
    }
    v142 += 44;
    --v139;
  }
  while ( v139 );
  if ( *(_BYTE *)(dword_AE400 + 8603) != 2 || *(_BYTE *)(dword_AE400 + 8606) )
  {
    v168 = dword_AE3FC + 35200;
    v244 = 20;
    do
    {
      v169 = v168;
      v232 = 39;
      do
      {
        v213 = *(_DWORD *)(v169 + 16);
        v214 = *(_DWORD *)(v169 + 20);
        v125 = *(_DWORD *)(v169 + 32);
        v169 += 44;
        v217 = v125;
        v170 = *(_BYTE *)(v169 - 6);
        LOBYTE(v125) = *(_BYTE *)(v169 + 38);
        v171 = v170;
        if ( (v125 & 4) != 0 )
          break;
        v208 = *(_DWORD *)(v169 + 16);
        v209 = *(_DWORD *)(v169 + 20);
        v212 = *(_DWORD *)(v169 + 32);
        v172 = *(_BYTE *)(v169 + 38);
        v173 = v172 | v170;
        v174 = v172 & v171;
        v203 = *(_DWORD *)(v169 - 1744);
        v204 = *(_DWORD *)(v169 - 1740);
        v175 = *(_DWORD *)(v169 - 1728);
        v176 = v169 - 1760;
        v207 = (int *)v175;
        v177 = *(_BYTE *)(v176 + 38);
        v198 = *(_DWORD *)(v176 - 28);
        v178 = *(_DWORD *)(v176 - 24);
        v176 -= 44;
        v199 = v178;
        v125 = *(_DWORD *)(v176 + 32);
        v202 = (int *)v125;
        BYTE1(v125) = *(_BYTE *)(v176 + 38);
        v179 = v176 + 1760;
        v180 = BYTE1(v125) | v177 | v173;
        v181 = BYTE1(v125) & v177 & v174;
        if ( (*(_BYTE *)(v179 + 39) & 0x10) != 0 )
        {
          byte_967E1 = 7;
          v147 = v207;
          v125 = ((int)v202 + (int)v207 + v212 + v217) >> 18;
          byte_967E0 = v125;
        }
        else
        {
          byte_967E1 = 5;
        }
        if ( (v180 & 2) == 0 && (v181 & 0x78) == 0 )
        {
          v147 = (int *)((char *)&unk_902DC + 32 * *(unsigned __int8 *)(v179 + 42));
          v215 = *v147;
          v216 = v147[1];
          v210 = v147[2];
          v211 = v147[3];
          v205 = v147[4];
          v206 = v147[5];
          v200 = v147[6];
          v201 = v147[7];
          v182 = *(_BYTE *)(v179 + 38);
          dword_93AD0 = dword_9334C[*(unsigned __int8 *)(v179 + 41)];
          if ( (v182 & 1) != 0 )
          {
            sub_729A3((uint32*)&v213, (uint32*)&v208, (uint32*)&v198);
            v125 = (int)&v198;
            sub_729A3((uint32*)&v198, (uint32*)&v208, (uint32*)&v203);
          }
          else
          {
            sub_729A3((uint32*)&v213, (uint32*)&v208, (uint32*)&v203);
            v125 = (int)&v213;
            sub_729A3((uint32*)&v213, (uint32*)&v203, (uint32*)&v198);
          }
        }
        if ( *(_WORD *)(v179 + 36) )
          LOBYTE(v125) = sub_2DCB0((int)v147, v179);
        v169 = v179 + 44;
        --v232;
      }
      while ( v232 );
      if ( v232 )
      {
        v183 = v169 - 44;
        v184 = v168 + 1672;
        do
        {
          v213 = *(_DWORD *)(v184 + 16);
          v214 = *(_DWORD *)(v184 + 20);
          v217 = *(_DWORD *)(v184 + 32);
          v185 = *(_BYTE *)(v184 + 38);
          v208 = *(_DWORD *)(v184 + 60);
          v209 = *(_DWORD *)(v184 + 64);
          v212 = *(_DWORD *)(v184 + 76);
          v186 = v185;
          v187 = *(_BYTE *)(v184 + 82);
          v188 = v187 | v185;
          v189 = v187 & v186;
          v203 = *(_DWORD *)(v184 - 1700);
          v190 = *(_DWORD *)(v184 - 1696);
          v191 = v184 + 44;
          v204 = v190;
          v192 = *(_DWORD *)(v191 - 1728);
          v191 -= 1760;
          v207 = (int *)v192;
          v193 = *(_BYTE *)(v191 + 38);
          v198 = *(_DWORD *)(v191 - 28);
          v125 = *(_DWORD *)(v191 - 24);
          v191 -= 44;
          v199 = v125;
          v202 = *(int **)(v191 + 32);
          LOBYTE(v125) = *(_BYTE *)(v191 + 38);
          v194 = v191 + 1760;
          v195 = v125 | v193 | v188;
          v196 = v125 & v193 & v189;
          if ( (*(_BYTE *)(v194 + 39) & 0x10) != 0 )
          {
            byte_967E1 = 7;
            v147 = v202;
            v125 = ((int)v202 + (int)v207 + v212 + v217) >> 18;
            byte_967E0 = v125;
          }
          else
          {
            byte_967E1 = 5;
          }
          if ( (v195 & 2) == 0 && (v196 & 0x78) == 0 )
          {
            v147 = (int *)((char *)&unk_902DC + 32 * *(unsigned __int8 *)(v194 + 42));
            v215 = *v147;
            v216 = v147[1];
            v210 = v147[2];
            v211 = v147[3];
            v205 = v147[4];
            v206 = v147[5];
            v200 = v147[6];
            v201 = v147[7];
            dword_93AD0 = dword_9334C[*(unsigned __int8 *)(v194 + 41)];
            if ( (*(_BYTE *)(v194 + 38) & 1) != 0 )
            {
              sub_729A3((uint32*)&v213, (uint32*)&v208, (uint32*)&v198);
              v125 = (int)&v198;
              sub_729A3((uint32*)&v198, (uint32*)&v208, (uint32*)&v203);
            }
            else
            {
              sub_729A3((uint32*)&v213, (uint32*)&v208, (uint32*)&v203);
              v125 = (int)&v213;
              sub_729A3((uint32*)&v213, (uint32*)&v203, (uint32*)&v198);
            }
          }
          if ( *(_WORD *)(v194 + 36) )
            LOBYTE(v125) = sub_2DCB0((int)v147, v194);
          v184 = v194 - 44;
        }
        while ( v184 >= v183 );
      }
      v168 -= 1760;
      --v244;
    }
    while ( v244 );
  }
  else
  {
    byte_967E1 = 1;
    v148 = dword_AE3FC + 35200;
    v245 = 20;
    do
    {
      v149 = v148;
      v236 = 39;
      do
      {
        v213 = *(_DWORD *)(v149 + 16);
        v214 = *(_DWORD *)(v149 + 20);
        v125 = 350 * (5120 - *(_DWORD *)(v149 + 12));
        v149 += 44;
        v217 = 0x400000 - v125;
        v150 = *(_BYTE *)(v149 - 6);
        v151 = v150;
        if ( (*(_BYTE *)(v149 + 38) & 4) != 0 )
          break;
        v208 = *(_DWORD *)(v149 + 16);
        v209 = *(_DWORD *)(v149 + 20);
        v212 = 0x400000 - 350 * (5120 - *(_DWORD *)(v149 + 12));
        v152 = *(_BYTE *)(v149 + 38);
        v203 = *(_DWORD *)(v149 - 1744);
        v204 = *(_DWORD *)(v149 - 1740);
        v207 = (int *)(0x400000 - 350 * (5120 - *(_DWORD *)(v149 - 1748)));
        v153 = *(_BYTE *)(v149 - 1722);
        v198 = *(_DWORD *)(v149 - 1788);
        v154 = v153 | v152 | v150;
        v155 = v153 & v152 & v151;
        v199 = *(_DWORD *)(v149 - 1784);
        v202 = (int *)(0x400000 - 350 * (5120 - *(_DWORD *)(v149 - 1792)));
        LOBYTE(v125) = *(_BYTE *)(v149 - 1766);
        v156 = v125 & v155;
        v157 = v149 - 1804 + 1760;
        if ( (((unsigned __int8)v125 | v154) & 2) == 0 && (v156 & 0x78) == 0 )
        {
          if ( (*(_BYTE *)(v157 + 38) & 1) != 0 )
          {
            sub_729A3((uint32*)&v213, (uint32*)&v208, (uint32*)&v198);
            v125 = (int)&v198;
            sub_729A3((uint32*)&v198, (uint32*)&v208, (uint32*)&v203);
          }
          else
          {
            sub_729A3((uint32*)&v213, (uint32*)&v208, (uint32*)&v203);
            v125 = (int)&v213;
            sub_729A3((uint32*)&v213, (uint32*)&v203, (uint32*)&v198);
          }
        }
        if ( *(_WORD *)(v157 + 36) )
          LOBYTE(v125) = sub_2F170(5120, v157);
        v149 = v157 + 44;
        --v236;
      }
      while ( v236 );
      if ( v236 )
      {
        v158 = v149 - 44;
        v159 = v148 + 1672;
        do
        {
          v213 = *(_DWORD *)(v159 + 16);
          v214 = *(_DWORD *)(v159 + 20);
          v217 = 0x400000 - 350 * (5120 - *(_DWORD *)(v159 + 12));
          v160 = *(_BYTE *)(v159 + 38);
          v208 = *(_DWORD *)(v159 + 60);
          v209 = *(_DWORD *)(v159 + 64);
          v212 = 0x400000 - 350 * (5120 - *(_DWORD *)(v159 + 56));
          v161 = *(_BYTE *)(v159 + 82);
          v162 = v161 & v160;
          v203 = *(_DWORD *)(v159 - 1700);
          v204 = *(_DWORD *)(v159 - 1696);
          v207 = (int *)(0x400000 - 350 * (5120 - *(_DWORD *)(v159 - 1704)));
          v163 = *(_BYTE *)(v159 - 1678);
          v198 = *(_DWORD *)(v159 - 1744);
          v164 = v163 | v161 | v160;
          v199 = *(_DWORD *)(v159 - 1740);
          v125 = 350 * (5120 - *(_DWORD *)(v159 - 1748));
          v165 = v159 + 44;
          v202 = (int *)(0x400000 - v125);
          LOBYTE(v125) = *(_BYTE *)(v165 - 1766);
          v166 = v125 & v163 & v162;
          v167 = v165 - 1804 + 1760;
          if ( (((unsigned __int8)v125 | v164) & 2) == 0 && (v166 & 0x78) == 0 )
          {
            if ( (*(_BYTE *)(v167 + 38) & 1) != 0 )
            {
              sub_729A3((uint32*)&v213, (uint32*)&v208, (uint32*)&v198);
              v125 = (int)&v198;
              sub_729A3((uint32*)&v198, (uint32*)&v208, (uint32*)&v203);
            }
            else
            {
              sub_729A3((uint32*)&v213, (uint32*)&v208, (uint32*)&v203);
              v125 = (int)&v213;
              sub_729A3((uint32*)&v213, (uint32*)&v203, (uint32*)&v198);
            }
          }
          if ( *(_WORD *)(v167 + 36) )
            LOBYTE(v125) = sub_2F170(5120, v167);
          v159 = v167 - 44;
        }
        while ( v159 >= v158 );
      }
      v148 -= 1760;
      --v245;
    }
    while ( v245 );
  }
  return v125;
}
// 902B0: using guessed type int dword_902B0;
// 9074C: using guessed type int dword_9074C[];
// 90B4C: using guessed type int dword_90B4C[256];
// 90F4C: using guessed type int dword_90F4C[256];
// 9134C: using guessed type void (*off_9134C[2])();
// 9334C: using guessed type int dword_9334C[148];
// 93ACC: using guessed type int dword_93ACC;
// 93AD0: using guessed type int dword_93AD0;
// 93AD4: using guessed type int dword_93AD4;
// 93AD8: using guessed type int dword_93AD8;
// 93ADC: using guessed type int dword_93ADC;
// 967E0: using guessed type char byte_967E0;
// 967E1: using guessed type char byte_967E1;
// AE3FC: using guessed type int dword_AE3FC;
// AE400: using guessed type int dword_AE400;
// B5CD4: using guessed type int dword_B5CD4;
// B5CDC: using guessed type int dword_B5CDC;
// B5CE4: using guessed type int dword_B5CE4;
// B5CE8: using guessed type int dword_B5CE8;
// B5CEC: using guessed type int dword_B5CEC;
// B5CF0: using guessed type int dword_B5CF0;
// B5CF8: using guessed type int dword_B5CF8;
// B5CFC: using guessed type int dword_B5CFC;
// B5D00: using guessed type int dword_B5D00;
// B5D08: using guessed type int dword_B5D08;
// B5D0C: using guessed type int dword_B5D0C;
// B5D10: using guessed type int dword_B5D10;
// B5D14: using guessed type int dword_B5D14;
// B5D38: using guessed type __int16 word_B5D38;
// B5D3A: using guessed type __int16 word_B5D3A;
// B5D3C: using guessed type __int16 word_B5D3C;
// B5D3F: using guessed type char byte_B5D3F;
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (0002C410) --------------------------------------------------------
int sub_2C410(unsigned int a1)
{
  int v1; // eax
  int v2; // edx
  int v3; // ecx
  int v4; // ebx
  int v5; // edi
  int v6; // esi
  int v7; // ecx
  int v8; // ebx
  int v9; // edi
  int v10; // ecx
  _DWORD *v11; // ebx
  char *v12; // ebx
  int v13; // eax
  _DWORD *v14; // esi
  _BYTE *v15; // edi
  int v16; // ecx
  char v17; // cf
  int v18; // ecx
  int v19; // ecx
  char v20; // al
  char v21; // al
  char v22; // al
  char v23; // al
  _BYTE *v24; // edi
  int v25; // eax
  int v26; // ecx
  _BYTE *v27; // edi
  int v28; // eax
  int v29; // ecx
  _BYTE *v30; // edi
  int v31; // eax
  int v32; // ecx
  _BYTE *v33; // edi
  int v34; // ecx
  _BYTE *v35; // edi
  int v36; // ecx
  _BYTE *v37; // edi
  int v38; // edx
  int v39; // eax
  int v40; // ecx
  _BYTE *v41; // edi
  int v42; // edx
  int v43; // eax
  int v44; // ecx
  _BYTE *v45; // edi
  int v46; // eax
  int v47; // ecx
  int v48; // ecx
  int v49; // ecx
  char v50; // al
  char v51; // al
  char v52; // al
  char v53; // al
  int result; // eax
  int v55; // esi
  int v56; // esi
  int v57; // edx
  int v58; // ecx
  int v59; // eax
  int v60; // edi
  int v61; // esi
  int v62; // edx
  int *v63; // eax
  int v64; // edx
  int v65; // ecx
  int v66; // ebx
  int v67; // ebx
  int v68; // ebx
  int v69; // ebx
  _DWORD *v70; // eax
  _DWORD *v71; // ebx
  int v72; // ecx
  _DWORD *v73; // eax
  _DWORD *v74; // ebx
  int v75; // ecx
  int v76; // ebx
  int i; // eax
  int v78; // ecx
  int v79; // edx
  int v80; // edi
  _BOOL1 j; // zf
  _DWORD *v82; // esi
  int v83; // eax
  _DWORD *v84; // edi
  char *v85; // ebx
  _BYTE *v86; // edx
  int v87; // ecx
  int v88; // ecx
  int v89; // ecx
  char v90; // al
  char v91; // al
  char v92; // al
  char v93; // al
  _BYTE *v94; // ebx
  _BYTE *v95; // edx
  int v96; // eax
  int v97; // ecx
  _BYTE *v98; // ebx
  _BYTE *v99; // edx
  int v100; // ecx
  _BYTE *v101; // ebx
  _BYTE *v102; // edx
  int v103; // ecx
  _BYTE *v104; // ebx
  _BYTE *v105; // edx
  int v106; // eax
  int v107; // ecx
  _BYTE *v108; // ebx
  _BYTE *v109; // edx
  int v110; // eax
  int v111; // ecx
  _BYTE *v112; // ebx
  int v113; // ecx
  _BYTE *v114; // edx
  _DWORD *v115; // esi
  _DWORD *v116; // edi
  _BYTE *v117; // ebx
  int v118; // ecx
  _BYTE *v119; // edx
  _DWORD *v120; // esi
  _DWORD *v121; // edi
  char *v122; // ebx
  int v123; // eax
  _BYTE *v124; // edx
  int v125; // ecx
  char v126; // al
  char v127; // al
  char *v128; // ebx
  int v129; // eax
  _BYTE *v130; // edx
  int v131; // ecx
  int v132; // ecx
  int v133; // ecx
  char v134; // al
  char v135; // al
  char v136; // al
  char v137; // al
  int v138; // ecx
  int *v139; // eax
  int v140; // edx
  int v141; // edx
  int v142; // edx
  int v143; // ebx
  int v144; // ebx
  int v145; // ebx
  _DWORD *v146; // eax
  _DWORD *v147; // ecx
  int v148; // ebx
  _DWORD *v149; // eax
  int v150; // ebx
  int v151; // edx
  int v152; // ebx
  int v153; // edx
  int v154; // ebx
  int v155; // ecx
  int v156; // edx
  int v157; // ecx
  int v158; // edx
  int v159; // edx
  int v160; // ecx
  int v161; // edx
  int v162; // edx
  int v163; // ebx
  int v164; // edx
  int v165; // ecx
  int v166; // edx
  int v167; // edx
  int v168; // edx
  int k; // [esp+0h] [ebp-50h]
  int v170; // [esp+0h] [ebp-50h]
  int v171; // [esp+0h] [ebp-50h]
  int v172; // [esp+10h] [ebp-40h]
  int v173; // [esp+14h] [ebp-3Ch]
  int v174; // [esp+18h] [ebp-38h]
  int v175; // [esp+1Ch] [ebp-34h]
  int v176; // [esp+20h] [ebp-30h]
  _DWORD *v177; // [esp+24h] [ebp-2Ch]
  int v178; // [esp+28h] [ebp-28h]
  int v179; // [esp+2Ch] [ebp-24h]
  int v180; // [esp+30h] [ebp-20h]
  int v181; // [esp+34h] [ebp-1Ch]
  int v182; // [esp+38h] [ebp-18h]
  _DWORD *v183; // [esp+3Ch] [ebp-14h]
  int v184; // [esp+40h] [ebp-10h]
  int v185; // [esp+44h] [ebp-Ch]
  int v186; // [esp+48h] [ebp-8h]

  //fix
  v63 = 0;
  //fix

  if ( !byte_B5D3E )
  {
    if ( a1 )
    {
      if ( a1 <= 1 )
      {
        dword_B5CB8 -= (((dword_B5CA8 * dword_B5CE8) >> 1) + dword_B5CD4 * dword_B5CC8) >> 16;
        v55 = dword_B5CB4 - ((dword_B5CE8 * dword_B5CC8 - ((dword_B5CD4 * dword_B5CA8) >> 1)) >> 16);
LABEL_136:
        dword_B5CB4 = v55;
        goto LABEL_137;
      }
      if ( a1 != 2 )
      {
LABEL_137:
        v56 = (dword_B5CE0 * dword_B5CA8) >> 16;
        v57 = dword_B5CC8 << 16;
        v58 = dword_B5CCC << 16;
        v59 = (dword_B5D18 * dword_B5CA8) >> 16;
        switch ( dword_B5D28 )
        {
          case 0:
            v60 = (dword_B5CE0 * dword_B5CA8) >> 16;
            if ( v60 <= 0 )
              goto LABEL_404;
            v61 = (dword_B5CC8 << 16) / dword_B5CE0;
            if ( v61 <= 0 )
              goto LABEL_404;
            v176 = (dword_B5CCC << 16) / v61;
            if ( a1 == 1 )
            {
              dword_B5CC0 = 0;
            }
            else
            {
              dword_B5CC0 = (v61 - 1) * v176;
              v176 = -v176;
            }
            v182 = dword_B5CB8 << 16;
            v174 = dword_B5D18 * dword_B5CC8 / v61;
            v62 = dword_B5CB4 - ((dword_B5CF4 * dword_B5CB8) >> 16);
            v63 = (int *)(dword_AE3FC + 45920);
            if ( v62 >= dword_B5D2C )
              goto LABEL_146;
            v64 = dword_B5D2C - v62;
            v61 -= v64;
            if ( v61 <= 0 )
              goto LABEL_404;
            dword_B5CC0 += v64 * v176;
            v65 = v182 - v174 * v64;
            v62 = dword_B5D2C;
            v182 = v65;
LABEL_146:
            v186 = v62 * dword_93AD4 + dword_93ACC;
            goto LABEL_147;
          case 1:
            v60 = (dword_B5D18 * dword_B5CA8) >> 16;
            if ( v60 <= 0 )
              goto LABEL_404;
            v61 = (dword_B5CC8 << 16) / dword_B5D18;
            if ( v61 <= 0 )
              goto LABEL_404;
            v176 = (dword_B5CCC << 16) / v61;
            if ( a1 == 1 )
            {
              dword_B5CC0 = 0;
            }
            else
            {
              dword_B5CC0 = (v61 - 1) * v176;
              v176 = -v176;
            }
            v138 = dword_B5CB4 << 16;
            v173 = dword_B5CE0 * dword_B5CC8 / v61;
            v175 = dword_B5CB8 - ((dword_B5CF4 * dword_B5CB4) >> 16);
            v139 = (int *)(dword_AE3FC + 45920);
            if ( v175 < dword_B5D30 )
            {
              if ( v175 < dword_B5D2C )
                goto LABEL_404;
            }
            else
            {
              v140 = v175 - dword_B5D30;
              v61 -= v175 - dword_B5D30;
              if ( v61 <= 0 )
                goto LABEL_404;
              dword_B5CC0 += v140 * v176;
              v138 += v173 * v140;
              v175 = dword_B5D30;
            }
            v141 = v175 + dword_93ACC;
            goto LABEL_310;
          case 2:
            v60 = (dword_B5CE0 * dword_B5CA8) >> 16;
            if ( v56 <= 0 )
              goto LABEL_404;
            v61 = v57 / dword_B5CE0;
            if ( v57 / dword_B5CE0 <= 0 )
              goto LABEL_404;
            v176 = v58 / v61;
            if ( a1 == 1 )
            {
              dword_B5CC0 = 0;
            }
            else
            {
              dword_B5CC0 = (v61 - 1) * v176;
              v176 = -v176;
            }
            v182 = dword_B5CB4 << 16;
            v174 = dword_B5D18 * dword_B5CC8 / v61;
            v62 = dword_B5D30 - dword_B5CB8 - ((dword_B5CF4 * dword_B5CB4) >> 16);
            v63 = (int *)(dword_AE3FC + 45920);
            if ( v62 >= dword_B5D2C )
              goto LABEL_354;
            v156 = dword_B5D2C - v62;
            v61 -= v156;
            if ( v61 <= 0 )
              goto LABEL_404;
            dword_B5CC0 += v156 * v176;
            v157 = v182 - v174 * v156;
            v62 = dword_B5D2C;
            v182 = v157;
LABEL_354:
            v186 = dword_B5D30 + dword_93ACC - 1 - v62;
            goto LABEL_147;
          case 3:
            v60 = (dword_B5D18 * dword_B5CA8) >> 16;
            if ( v59 <= 0 )
              goto LABEL_404;
            v61 = v57 / dword_B5D18;
            if ( v57 / dword_B5D18 <= 0 )
              goto LABEL_404;
            v176 = v58 / v61;
            if ( a1 == 1 )
            {
              dword_B5CC0 = 0;
            }
            else
            {
              dword_B5CC0 = (v61 - 1) * v176;
              v176 = -v176;
            }
            v173 = dword_B5CE0 * dword_B5CC8 / v61;
            v139 = (int *)(dword_AE3FC + 45920);
            v175 = dword_B5CB4 - ((dword_B5CF4 * (dword_B5D34 - dword_B5CB8)) >> 16);
            v138 = (dword_B5D34 - dword_B5CB8) << 16;
            if ( v175 < dword_B5D30 )
            {
              if ( v175 < dword_B5D2C )
                goto LABEL_404;
            }
            else
            {
              v158 = v175 - dword_B5D30;
              v61 -= v175 - dword_B5D30;
              if ( v61 <= 0 )
                goto LABEL_404;
              dword_B5CC0 += v158 * v176;
              v138 += v173 * v158;
              v175 = dword_B5D30;
            }
            v186 = dword_B5D34 + dword_93AD4 * v175 - 1 + dword_93ACC;
            goto LABEL_311;
          case 4:
            v60 = (dword_B5CE0 * dword_B5CA8) >> 16;
            if ( v56 <= 0 )
              goto LABEL_404;
            v61 = v57 / dword_B5CE0;
            if ( v57 / dword_B5CE0 <= 0 )
              goto LABEL_404;
            v176 = v58 / v61;
            if ( a1 == 1 )
            {
              dword_B5CC0 = 0;
            }
            else
            {
              dword_B5CC0 = (v61 - 1) * v176;
              v176 = -v176;
            }
            v182 = (dword_B5D34 - dword_B5CB8) << 16;
            v174 = dword_B5D18 * dword_B5CC8 / v61;
            v62 = dword_B5D30 - dword_B5CB4 - (((dword_B5D34 - dword_B5CB8) * dword_B5CF4) >> 16);
            v63 = (int *)(dword_AE3FC + 45920);
            if ( v62 >= dword_B5D2C )
              goto LABEL_373;
            v159 = dword_B5D2C - v62;
            v61 -= v159;
            if ( v61 <= 0 )
              goto LABEL_404;
            dword_B5CC0 += v159 * v176;
            v160 = v182 - v174 * v159;
            v62 = dword_B5D2C;
            v182 = v160;
LABEL_373:
            v186 = dword_B5D34 + dword_93ACC + dword_93AD4 * (dword_B5D30 - v62 - 1) - 1;
            goto LABEL_147;
          case 5:
            v60 = (dword_B5D18 * dword_B5CA8) >> 16;
            if ( v59 <= 0 )
              goto LABEL_404;
            v61 = v57 / dword_B5D18;
            if ( v57 / dword_B5D18 <= 0 )
              goto LABEL_404;
            v176 = v58 / v61;
            if ( a1 == 1 )
            {
              dword_B5CC0 = 0;
            }
            else
            {
              dword_B5CC0 = (v61 - 1) * v176;
              v176 = -v176;
            }
            v173 = dword_B5CE0 * dword_B5CC8 / v61;
            v139 = (int *)(dword_AE3FC + 45920);
            v138 = (dword_B5D34 - dword_B5CB4) << 16;
            v161 = dword_B5D30 - dword_B5CB8 - ((dword_B5CF4 * (dword_B5D34 - dword_B5CB4)) >> 16);
            v175 = v161;
            if ( v161 < dword_B5D30 )
            {
              if ( v161 < dword_B5D2C )
                goto LABEL_404;
            }
            else
            {
              v162 = v161 - dword_B5D30;
              v61 -= v162;
              if ( v61 <= 0 )
                goto LABEL_404;
              dword_B5CC0 += v162 * v176;
              v138 += v173 * v162;
              v175 = dword_B5D30;
            }
            v141 = (dword_B5D34 - 1) * dword_93AD4 + dword_B5D30 + dword_93ACC - 1 - v175;
LABEL_310:
            v186 = v141;
            goto LABEL_311;
          case 6:
            v60 = (dword_B5CE0 * dword_B5CA8) >> 16;
            if ( v56 <= 0 )
              goto LABEL_404;
            v61 = v57 / dword_B5CE0;
            if ( v57 / dword_B5CE0 <= 0 )
              goto LABEL_404;
            v176 = v58 / v61;
            if ( a1 == 1 )
            {
              dword_B5CC0 = 0;
            }
            else
            {
              dword_B5CC0 = (v61 - 1) * v176;
              v176 = -v176;
            }
            v182 = (dword_B5D34 - dword_B5CB4) << 16;
            v174 = dword_B5D18 * dword_B5CC8 / v61;
            v163 = dword_B5CB8 - ((dword_B5CF4 * (dword_B5D34 - dword_B5CB4)) >> 16);
            v63 = (int *)(dword_AE3FC + 45920);
            v62 = v163;
            if ( v163 >= dword_B5D2C )
              goto LABEL_392;
            v164 = dword_B5D2C - v163;
            v61 -= dword_B5D2C - v163;
            if ( v61 <= 0 )
              goto LABEL_404;
            dword_B5CC0 += v164 * v176;
            v165 = v182 - v174 * v164;
            v62 = dword_B5D2C;
            v182 = v165;
LABEL_392:
            v186 = v62 + dword_93ACC + dword_93AD4 * (dword_B5D34 - 1);
LABEL_147:
            v66 = dword_B5D30 - dword_B5D2C;
            if ( v62 <= 0 )
            {
              if ( v61 > v66 )
                v61 = dword_B5D30 - dword_B5D2C;
            }
            else if ( v66 < v61 + v62 )
            {
              v61 = v66 - v62;
              if ( v66 - v62 <= 0 )
                goto LABEL_404;
            }
            v180 = v61;
            v184 = 9999999;
            if ( !v61 )
              goto LABEL_163;
            while ( 1 )
            {
              v67 = v182 >> 16;
              if ( v182 >> 16 >= 0 )
                break;
              v68 = -v67;
              *v63 = 0;
              v63[1] = v60 - v68;
              if ( v60 - v68 <= 0 )
              {
                v61 -= v180;
LABEL_163:
                if ( v61 + v62 > dword_B5D1C )
                {
                  v69 = dword_B5D1C - v62;
                  if ( dword_B5D1C - v62 <= 0 )
                  {
                    v71 = (_DWORD *)(dword_B5CD8 + 4 * v69);
                    v72 = v61;
                    v70 = (_DWORD *)(dword_AE3FC + 45920);
                    goto LABEL_172;
                  }
                  v181 = v61 + v62 - dword_B5D1C;
                  v70 = (_DWORD *)(12 * v69 + dword_AE3FC + 45920);
                  v71 = (_DWORD *)dword_B5CD8;
                  while ( v181 )
                  {
                    if ( *v70 + v70[1] > *v71 )
                    {
                      if ( *v70 >= *v71 )
                      {
                        v61 -= v181;
                        break;
                      }
                      v70[1] = *v71 - *v70;
                    }
                    v70 += 3;
                    v72 = v181 - 1;
                    --v71;
LABEL_172:
                    v181 = v72;
                  }
                }
                if ( v62 < 0 )
                {
                  v73 = (_DWORD *)(dword_AE3FC + 45920);
                  v74 = (_DWORD *)(dword_AE3FC + 59360 + 4 * (-1 - v62));
                  do
                  {
                    if ( *v74 > *v73 )
                    {
                      if ( *v74 <= v73[1] + *v73 )
                      {
                        v75 = *v74 - *v73;
                        *v73 = *v74;
                        v73[2] += v75;
                        v73[1] -= v75;
                      }
                      else
                      {
                        v73[1] = 0;
                      }
                    }
                    --v74;
                    v73 += 3;
                    ++v62;
                  }
                  while ( v62 );
                }
LABEL_181:
                v76 = (dword_B5CBC << 16) / v60;
                dword_B5CC4 = 0;
                if ( dword_B5CBC < 0 )
                  dword_B5CC4 = -(v76 * (v60 - 1));
                v170 = v60 - v184;
                if ( v60 - v184 > 0 )
                {
                  if ( v170 > dword_B5D20 )
                    v170 = dword_B5D20;
                  dword_B5CC4 += v76 * v184;
                  for ( i = dword_AE3FC + 36960; v170 >= 0; --v170 )
                  {
                    v78 = *(_DWORD *)(i - 4);
                    i += 8;
                    v79 = dword_B5CC4 >> 16;
                    v80 = v76 + dword_B5CC4;
                    *(_DWORD *)(i - 4) = dword_B5CC4 >> 16;
                    dword_B5CC4 = v80;
                    *(_DWORD *)(i - 8) = v79 - v78;
                  }
                  v178 = v61;
                  v183 = (_DWORD *)(dword_AE3FC + 45920);
                  for ( j = v61 == 0; !j; j = v178-- == 1 )
                  {
                    v171 = v183[1];
                    if ( v171 > 0 )
                    {
                      v82 = (_DWORD *)(8 * (v183[2] - v184) + dword_AE3FC + 36960);
                      v83 = (dword_B5CC0 >> 16) * dword_B5CD0 + dword_B5CB0;
                      v84 = (_DWORD *)((char *)&unk_B3EA0 + 12 * *v183);
                      switch ( dword_B5CAC )
                      {
                        case 0:
                          v85 = (char *)(v83 + v82[1]);
                          v86 = (_BYTE *)(v84[1] + v186);
                          v87 = v171 >> 1;
                          if ( !(v171 & 1) )
                          {
                            v17 = v87 & 1;
                            v88 = v171 >> 2;
                            if ( v17 )
                            {
                              ++v88;
                              v82 -= 2;
                              v84 -= 3;
                              goto LABEL_204;
                            }
                            v82 += 2;
                            v84 += 3;
                            goto LABEL_198;
                          }
                          v89 = v87 + 2;
                          v17 = v89 & 1;
                          v88 = v89 >> 1;
                          if ( v17 )
                            goto LABEL_201;
                          v82 -= 4;
                          for ( v84 -= 6; ; v86 += v84[6] )
                          {
                            v93 = *v85;
                            v85 += v82[6];
                            if ( v93 )
                              *v86 = v93;
                            v86 += v84[9];
                            v82 += 8;
                            v84 += 12;
                            if ( !--v88 )
                              break;
LABEL_198:
                            v90 = *v85;
                            v85 += *v82;
                            if ( v90 )
                              *v86 = v90;
                            v86 += *v84;
LABEL_201:
                            v91 = *v85;
                            v85 += v82[2];
                            if ( v91 )
                              *v86 = v91;
                            v86 += v84[3];
LABEL_204:
                            v92 = *v85;
                            v85 += v82[4];
                            if ( v92 )
                              *v86 = v92;
                          }
                          break;
                        case 1:
                          v94 = (_BYTE *)(v83 + v82[1]);
                          v95 = (_BYTE *)(v84[1] + v186);
                          v96 = dword_B5CA4;
                          v97 = v171 >> 1;
                          if ( !(v171 & 1) )
                          {
                            v82 += 2;
                            v84 += 3;
                            goto LABEL_214;
                          }
                          ++v97;
                          while ( 1 )
                          {
                            LOBYTE(v96) = *v94;
                            v94 += v82[2];
                            if ( (_BYTE)v96 )
                              *v95 = byte_B7934[v96];
                            v95 += v84[3];
                            v82 += 4;
                            v84 += 6;
                            if ( !--v97 )
                              break;
LABEL_214:
                            LOBYTE(v96) = *v94;
                            v94 += *v82;
                            if ( (_BYTE)v96 )
                              *v95 = byte_B7934[v96];
                            v95 += *v84;
                          }
                          break;
                        case 2:
                          v98 = (_BYTE *)(v83 + v82[1]);
                          v99 = (_BYTE *)(v84[1] + v186);
                          HIWORD(v83) = 0;
                          v100 = v171 >> 1;
                          if ( !(v171 & 1) )
                          {
                            v82 += 2;
                            v84 += 3;
                            goto LABEL_224;
                          }
                          ++v100;
                          while ( 1 )
                          {
                            BYTE1(v83) = *v98;
                            v98 += v82[2];
                            if ( BYTE1(v83) )
                            {
                              LOBYTE(v83) = *v99;
                              *v99 = byte_BB934[v83];
                            }
                            v99 += v84[3];
                            v82 += 4;
                            v84 += 6;
                            if ( !--v100 )
                              break;
LABEL_224:
                            BYTE1(v83) = *v98;
                            v98 += *v82;
                            if ( BYTE1(v83) )
                            {
                              LOBYTE(v83) = *v99;
                              *v99 = byte_BB934[v83];
                            }
                            v99 += *v84;
                          }
                          break;
                        case 3:
                          v101 = (_BYTE *)(v83 + v82[1]);
                          v102 = (_BYTE *)(v84[1] + v186);
                          HIWORD(v83) = 0;
                          v103 = v171 >> 1;
                          if ( !(v171 & 1) )
                          {
                            v82 += 2;
                            v84 += 3;
                            goto LABEL_234;
                          }
                          ++v103;
                          while ( 1 )
                          {
                            LOBYTE(v83) = *v101;
                            v101 += v82[2];
                            if ( (_BYTE)v83 )
                            {
                              BYTE1(v83) = *v102;
                              *v102 = byte_BB934[v83];
                            }
                            v102 += v84[3];
                            v82 += 4;
                            v84 += 6;
                            if ( !--v103 )
                              break;
LABEL_234:
                            LOBYTE(v83) = *v101;
                            v101 += *v82;
                            if ( (_BYTE)v83 )
                            {
                              BYTE1(v83) = *v102;
                              *v102 = byte_BB934[v83];
                            }
                            v102 += *v84;
                          }
                          break;
                        case 4:
                          v104 = (_BYTE *)(v83 + v82[1]);
                          v105 = (_BYTE *)(v84[1] + v186);
                          v106 = 0;
                          v107 = v171 >> 1;
                          if ( !(v171 & 1) )
                          {
                            v82 += 2;
                            v84 += 3;
                            goto LABEL_244;
                          }
                          ++v107;
                          while ( 1 )
                          {
                            LOBYTE(v106) = *v104;
                            v104 += v82[2];
                            if ( (_BYTE)v106 )
                              *v105 = byte_BB934[v106];
                            v105 += v84[3];
                            v82 += 4;
                            v84 += 6;
                            if ( !--v107 )
                              break;
LABEL_244:
                            LOBYTE(v106) = *v104;
                            v104 += *v82;
                            if ( (_BYTE)v106 )
                              *v105 = byte_BB934[v106];
                            v105 += *v84;
                          }
                          break;
                        case 5:
                          v108 = (_BYTE *)(v83 + v82[1]);
                          v109 = (_BYTE *)(v84[1] + v186);
                          v110 = 0;
                          v111 = v171 >> 1;
                          if ( !(v171 & 1) )
                          {
                            v82 += 2;
                            v84 += 3;
                            goto LABEL_254;
                          }
                          ++v111;
                          while ( 1 )
                          {
                            BYTE1(v110) = *v108;
                            v108 += v82[2];
                            if ( BYTE1(v110) )
                              *v109 = byte_BB934[v110];
                            v109 += v84[3];
                            v82 += 4;
                            v84 += 6;
                            if ( !--v111 )
                              break;
LABEL_254:
                            BYTE1(v110) = *v108;
                            v108 += *v82;
                            if ( BYTE1(v110) )
                              *v109 = byte_BB934[v110];
                            v109 += *v84;
                          }
                          break;
                        case 6:
                          v112 = (_BYTE *)(v83 + v82[1]);
                          v113 = dword_B5CA4;
                          v114 = (_BYTE *)(v84[1] + v186);
                          HIWORD(v83) = 0;
                          v115 = v82 + 2;
                          v116 = v84 + 3;
                          do
                          {
                            BYTE1(v83) = *v112;
                            v112 += *v115;
                            if ( BYTE1(v83) )
                            {
                              LOBYTE(v83) = *v114;
                              LOBYTE(v113) = byte_BB934[v83];
                              *v114 = byte_B7934[v113];
                            }
                            v114 += *v116;
                            v115 += 2;
                            v116 += 3;
                            --v171;
                          }
                          while ( v171 );
                          break;
                        case 7:
                          v117 = (_BYTE *)(v83 + v82[1]);
                          v118 = dword_B5CA4;
                          v119 = (_BYTE *)(v84[1] + v186);
                          HIWORD(v83) = 0;
                          v120 = v82 + 2;
                          v121 = v84 + 3;
                          do
                          {
                            LOBYTE(v83) = *v117;
                            v117 += *v120;
                            if ( (_BYTE)v83 )
                            {
                              BYTE1(v83) = *v119;
                              LOBYTE(v118) = byte_BB934[v83];
                              *v119 = byte_B7934[v118];
                            }
                            v119 += *v121;
                            v120 += 2;
                            v121 += 3;
                            --v171;
                          }
                          while ( v171 );
                          break;
                        case 8:
                          v122 = (char *)(v83 + v82[1]);
                          v123 = dword_B5CA4;
                          v124 = (_BYTE *)(v84[1] + v186);
                          v125 = v171 >> 1;
                          if ( !(v171 & 1) )
                          {
                            v82 += 2;
                            v84 += 3;
                            goto LABEL_274;
                          }
                          ++v125;
                          while ( 1 )
                          {
                            v127 = *v122;
                            v122 += v82[2];
                            if ( v127 )
                            {
                              LOBYTE(v123) = *v124;
                              *v124 = byte_B7934[v123];
                            }
                            v124 += v84[3];
                            v82 += 4;
                            v84 += 6;
                            if ( !--v125 )
                              break;
LABEL_274:
                            v126 = *v122;
                            v122 += *v82;
                            if ( v126 )
                            {
                              LOBYTE(v123) = *v124;
                              *v124 = byte_B7934[v123];
                            }
                            v124 += *v84;
                          }
                          break;
                        case 9:
                          v128 = (char *)(v83 + v82[1]);
                          v129 = dword_B5CA4 >> 8;
                          v130 = (_BYTE *)(v84[1] + v186);
                          v131 = v171 >> 1;
                          if ( !(v171 & 1) )
                          {
                            v17 = v131 & 1;
                            v132 = v171 >> 2;
                            if ( v17 )
                            {
                              ++v132;
                              v82 -= 2;
                              v84 -= 3;
                              goto LABEL_293;
                            }
                            v82 += 2;
                            v84 += 3;
                            goto LABEL_287;
                          }
                          v133 = v131 + 2;
                          v17 = v133 & 1;
                          v132 = v133 >> 1;
                          if ( v17 )
                            goto LABEL_290;
                          v82 -= 4;
                          for ( v84 -= 6; ; v130 += v84[6] )
                          {
                            v137 = *v128;
                            v128 += v82[6];
                            if ( v137 )
                              *v130 = BYTE1(v129);
                            v130 += v84[9];
                            v82 += 8;
                            v84 += 12;
                            if ( !--v132 )
                              break;
LABEL_287:
                            v134 = *v128;
                            v128 += *v82;
                            if ( v134 )
                              *v130 = BYTE1(v129);
                            v130 += *v84;
LABEL_290:
                            v135 = *v128;
                            v128 += v82[2];
                            if ( v135 )
                              *v130 = BYTE1(v129);
                            v130 += v84[3];
LABEL_293:
                            v136 = *v128;
                            v128 += v82[4];
                            if ( v136 )
                              *v130 = BYTE1(v129);
                          }
                          break;
                        default:
                          break;
                      }
                    }
                    dword_B5CC0 += v176;
                    v186 += dword_B5D04;
                    v183 += 3;
                  }
                }
LABEL_404:
                JUMPOUT(0x2A6E8);
              }
              v63[2] = v68;
              if ( v68 < v184 )
                goto LABEL_159;
LABEL_160:
              if ( v63[1] + *v63 > dword_B5D34 )
                v63[1] = dword_B5D34 - *v63;
              v63 += 3;
              v182 -= v174;
              if ( !--v180 )
                goto LABEL_163;
            }
            v63[2] = 0;
            *v63 = v67;
            v68 = 0;
            v63[1] = v60;
LABEL_159:
            v184 = v68;
            goto LABEL_160;
          case 7:
            v60 = (dword_B5D18 * dword_B5CA8) >> 16;
            if ( v59 <= 0 )
              goto LABEL_404;
            v61 = v57 / dword_B5D18;
            if ( v57 / dword_B5D18 <= 0 || dword_B5CB8 >= dword_B5D34 )
              goto LABEL_404;
            v176 = v58 / v61;
            if ( a1 == 1 )
            {
              dword_B5CC0 = 0;
            }
            else
            {
              v166 = (v61 - 1) * v176;
              v176 = -v176;
              dword_B5CC0 = v166;
            }
            v138 = dword_B5CB8 << 16;
            v173 = dword_B5CE0 * dword_B5CC8 / v61;
            v139 = (int *)(dword_AE3FC + 45920);
            v167 = dword_B5D30 - dword_B5CB4 - ((dword_B5CB8 * dword_B5CF4) >> 16);
            v175 = v167;
            if ( v167 < dword_B5D30 )
            {
              if ( v167 < dword_B5D2C )
                goto LABEL_404;
            }
            else
            {
              v168 = v167 - dword_B5D30;
              v61 -= v168;
              if ( v61 <= 0 )
                goto LABEL_404;
              dword_B5CC0 += v168 * v176;
              v138 += v173 * v168;
              v175 = dword_B5D30;
            }
            v186 = dword_93AD4 * (dword_B5D30 - 1 - v175) + dword_93ACC;
LABEL_311:
            v142 = dword_B5D30 - dword_B5D2C;
            if ( v175 < dword_B5D30 )
            {
              if ( v61 > v142 )
                v61 = dword_B5D30 - dword_B5D2C;
            }
            else if ( v142 < v61 + v175 - dword_B5D30 )
            {
              v61 = v142 - v175 + dword_B5D30;
              if ( v61 <= 0 )
                goto LABEL_404;
            }
            v179 = v61;
            v184 = 9999999;
            if ( !v61 )
            {
LABEL_325:
              v145 = v175 + dword_B5D24 - dword_B5D30 + 1;
              if ( v145 > 0 )
              {
                v146 = (_DWORD *)(dword_AE3FC + 45920 + 12 * v145);
                v147 = (_DWORD *)dword_B5CD8;
                v148 = v175 + dword_B5D24 - dword_B5D30 + 2;
                if ( v175 + dword_B5D24 - dword_B5D30 != -2 )
                {
                  do
                  {
                    v146 -= 3;
                    if ( (unsigned int)v146 < dword_AE3FC + 45920 )
                      break;
                    if ( v146[1] + *v146 - *v147 > 0 )
                    {
                      v146[1] -= v146[1] + *v146 - *v147;
                      if ( (int)v146[1] < 0 )
                        v146[1] = 0;
                    }
                    --v147;
                    --v148;
                  }
                  while ( v148 );
                }
              }
              if ( v175 - v61 >= 0 )
                goto LABEL_181;
              v149 = (_DWORD *)(dword_AE3FC + 45920 + 12 * v175);
              v177 = (_DWORD *)(dword_AE3FC + 59360);
              v150 = v175 - v61 - dword_B5D2C;
              v151 = v61 - v175;
              if ( v150 < 0 )
              {
                v61 = v175 - dword_B5D2C;
                if ( v175 - dword_B5D2C <= 0 )
                  goto LABEL_404;
                v151 += v150;
              }
              v152 = v151;
              v153 = v151 - 1;
              if ( v152 > 0 )
              {
                while ( v153 )
                {
                  v149 += 3;
                  if ( (unsigned int)v149 >= dword_AE3FC + 45920 )
                  {
                    v154 = *v177 - *v149;
                    if ( v154 > 0 )
                    {
                      *v149 = *v177;
                      v155 = v149[1] - v154;
                      v149[1] = v155;
                      if ( v155 < 0 )
                        v149[1] = 0;
                      v149[2] += v154;
                    }
                  }
                  --v153;
                  ++v177;
                }
              }
              goto LABEL_181;
            }
            break;
          default:
            goto LABEL_404;
        }
        while ( 1 )
        {
          v143 = v138 >> 16;
          if ( v138 >> 16 >= 0 )
            break;
          v144 = -v143;
          *v139 = 0;
          v139[1] = v60 - v144;
          v139[2] = v144;
          if ( v144 < v184 )
            goto LABEL_321;
LABEL_322:
          if ( v139[1] + *v139 > dword_B5D34 )
            v139[1] = dword_B5D34 - *v139;
          v139 += 3;
          v138 += v173;
          if ( !--v179 )
            goto LABEL_325;
        }
        v139[2] = 0;
        *v139 = v143;
        v144 = 0;
        v139[1] = v60;
LABEL_321:
        v184 = v144;
        goto LABEL_322;
      }
    }
    v55 = dword_B5CB4 - (-(dword_B5CD4 * dword_B5CA8) >> 17);
    dword_B5CB8 -= (dword_B5CE8 * dword_B5CA8) >> 17;
    goto LABEL_136;
  }
  v1 = (dword_B5CC8 + dword_B5CA8) >> 2;
  if ( a1 )
  {
    v2 = (v1 * dword_B5CE8) >> 16;
    v3 = (v1 * dword_B5CD4) >> 16;
    if ( a1 <= 1 )
    {
      dword_B5CB8 += -v3 - v1;
      dword_B5CB4 += -v2 - v1;
    }
    else if ( a1 == 2 )
    {
      dword_B5CB8 += v3 - v1;
      dword_B5CB4 += v2 - v1;
    }
  }
  v4 = (unsigned __int16)dword_93AD8;
  if ( (unsigned __int16)dword_93AD8 <= dword_B5CB8 )
    goto LABEL_404;
  v5 = dword_B5CA8;
  v6 = (dword_B5CBC << 16) / dword_B5CA8;
  if ( -dword_B5CB8 < 0 || dword_B5CB8 == 0 )
  {
    dword_B5CC4 = 0;
    if ( dword_B5CA8 + dword_B5CB8 - (unsigned __int16)dword_93AD8 <= 0 )
      goto LABEL_16;
    v4 = (unsigned __int16)dword_93AD8 - dword_B5CB8;
    goto LABEL_15;
  }
  v7 = dword_B5CA8 + dword_B5CB8;
  dword_B5CA8 += dword_B5CB8;
  if ( v5 + dword_B5CB8 <= 0 )
    goto LABEL_404;
  dword_B5CC4 = v6 * -dword_B5CB8;
  dword_B5CB8 = 0;
  if ( (unsigned __int16)dword_93AD8 <= v7 )
LABEL_15:
    dword_B5CA8 = v4;
LABEL_16:
  v8 = (unsigned __int16)dword_93ADC;
  if ( (unsigned __int16)dword_93ADC <= dword_B5CB4 )
    goto LABEL_404;
  v9 = dword_B5CC8;
  v172 = (dword_B5CCC << 16) / dword_B5CC8;
  if ( -dword_B5CB4 < 0 || dword_B5CB4 == 0 )
  {
    dword_B5CC0 = 0;
    if ( dword_B5CB4 + dword_B5CC8 - (unsigned __int16)dword_93ADC <= 0 )
      goto LABEL_24;
    v8 = (unsigned __int16)dword_93ADC - dword_B5CB4;
    goto LABEL_23;
  }
  v10 = dword_B5CC8 + dword_B5CB4;
  dword_B5CC8 += dword_B5CB4;
  if ( v9 + dword_B5CB4 <= 0 )
    goto LABEL_404;
  dword_B5CC0 = -dword_B5CB4 * v172;
  dword_B5CB4 = 0;
  if ( (unsigned __int16)dword_93ADC <= v10 )
LABEL_23:
    dword_B5CC8 = v8;
LABEL_24:
  v11 = (_DWORD *)(dword_AE3FC + 36960);
  for ( k = dword_B5CA8; k; --k )
  {
    v11[1] = dword_B5CC4 >> 16;
    if ( v11 == (_DWORD *)(dword_AE3FC + 36960) )
      *(_DWORD *)(dword_AE3FC + 36960) = 22;
    else
      *v11 = v11[1] - *(v11 - 1);
    v11 += 2;
    dword_B5CC4 += v6;
  }
  v185 = dword_93AD4 * dword_B5CB4 + dword_B5CB8 + dword_93ACC;
  if ( !dword_B5CC8 )
    goto LABEL_404;
  do
  {
    v12 = (char *)(*(_DWORD *)(dword_AE3FC + 36964) + dword_B5CB0 + dword_B5CD0 * (dword_B5CC0 >> 16));
    v13 = dword_B5CAC;
    v14 = (_DWORD *)(dword_AE3FC + 36960);
    switch ( dword_B5CAC )
    {
      case 0:
        v15 = (_BYTE *)v185;
        v16 = dword_B5CA8 >> 1;
        if ( !(dword_B5CA8 & 1) )
        {
          v17 = v16 & 1;
          v18 = dword_B5CA8 >> 2;
          if ( v17 )
          {
            ++v18;
            v14 = (_DWORD *)(dword_AE3FC + 36952);
            v15 = (_BYTE *)(v185 - 2);
            goto LABEL_42;
          }
          v14 = (_DWORD *)(dword_AE3FC + 36968);
          goto LABEL_38;
        }
        v19 = v16 + 2;
        v17 = v19 & 1;
        v18 = v19 >> 1;
        if ( !v17 )
        {
          v14 = (_DWORD *)(dword_AE3FC + 36944);
          v15 = (_BYTE *)(v185 - 3);
          goto LABEL_44;
        }
        v15 = (_BYTE *)(v185 - 1);
        while ( 1 )
        {
          v21 = *v12;
          v12 += v14[2];
          if ( v21 )
            v15[1] = v21;
LABEL_42:
          v22 = *v12;
          v12 += v14[4];
          if ( v22 )
            v15[2] = v22;
LABEL_44:
          v23 = *v12;
          v12 += v14[6];
          if ( v23 )
            v15[3] = v23;
          v15 += 4;
          v14 += 8;
          if ( !--v18 )
            break;
LABEL_38:
          v20 = *v12;
          v12 += *v14;
          if ( v20 )
            *v15 = v20;
        }
        break;
      case 1:
        v24 = (_BYTE *)v185;
        v25 = dword_B5CA4;
        v26 = dword_B5CA8 >> 1;
        if ( !(dword_B5CA8 & 1) )
        {
          v14 = (_DWORD *)(dword_AE3FC + 36968);
          goto LABEL_51;
        }
        ++v26;
        v24 = (_BYTE *)(v185 - 1);
        while ( 1 )
        {
          LOBYTE(v25) = *v12;
          v12 += v14[2];
          if ( (_BYTE)v25 )
            v24[1] = byte_B7934[v25];
          v24 += 2;
          v14 += 4;
          if ( !--v26 )
            break;
LABEL_51:
          LOBYTE(v25) = *v12;
          v12 += *v14;
          if ( (_BYTE)v25 )
            *v24 = byte_B7934[v25];
        }
        break;
      case 2:
        v27 = (_BYTE *)v185;
        HIWORD(v28) = 0;
        v29 = dword_B5CA8 >> 1;
        if ( !(dword_B5CA8 & 1) )
        {
          v14 = (_DWORD *)(dword_AE3FC + 36968);
          goto LABEL_60;
        }
        ++v29;
        v27 = (_BYTE *)(v185 - 1);
        while ( 1 )
        {
          BYTE1(v28) = *v12;
          v12 += v14[2];
          if ( BYTE1(v28) )
          {
            LOBYTE(v28) = v27[1];
            v27[1] = byte_BB934[v28];
          }
          v27 += 2;
          v14 += 4;
          if ( !--v29 )
            break;
LABEL_60:
          BYTE1(v28) = *v12;
          v12 += *v14;
          if ( BYTE1(v28) )
          {
            LOBYTE(v28) = *v27;
            *v27 = byte_BB934[v28];
          }
        }
        break;
      case 3:
        v30 = (_BYTE *)v185;
        HIWORD(v31) = 0;
        v32 = dword_B5CA8 >> 1;
        if ( !(dword_B5CA8 & 1) )
        {
          v14 = (_DWORD *)(dword_AE3FC + 36968);
          goto LABEL_69;
        }
        ++v32;
        v30 = (_BYTE *)(v185 - 1);
        while ( 1 )
        {
          LOBYTE(v31) = *v12;
          v12 += v14[2];
          if ( (_BYTE)v31 )
          {
            BYTE1(v31) = v30[1];
            v30[1] = byte_BB934[v31];
          }
          v30 += 2;
          v14 += 4;
          if ( !--v32 )
            break;
LABEL_69:
          LOBYTE(v31) = *v12;
          v12 += *v14;
          if ( (_BYTE)v31 )
          {
            BYTE1(v31) = *v30;
            *v30 = byte_BB934[v31];
          }
        }
        break;
      case 4:
        v33 = (_BYTE *)v185;
        BYTE1(v13) = dword_B5CAC;
        v34 = dword_B5CA8 >> 1;
        if ( !(dword_B5CA8 & 1) )
        {
          v14 = (_DWORD *)(dword_AE3FC + 36968);
          goto LABEL_78;
        }
        ++v34;
        v33 = (_BYTE *)(v185 - 1);
        while ( 1 )
        {
          LOBYTE(v13) = *v12;
          v12 += v14[2];
          if ( (_BYTE)v13 )
            v33[1] = byte_BB934[v13];
          v33 += 2;
          v14 += 4;
          if ( !--v34 )
            break;
LABEL_78:
          LOBYTE(v13) = *v12;
          v12 += *v14;
          if ( (_BYTE)v13 )
            *v33 = byte_BB934[v13];
        }
        break;
      case 5:
        v35 = (_BYTE *)v185;
        v36 = dword_B5CA8 >> 1;
        if ( !(dword_B5CA8 & 1) )
        {
          v14 = (_DWORD *)(dword_AE3FC + 36968);
          goto LABEL_87;
        }
        ++v36;
        v35 = (_BYTE *)(v185 - 1);
        while ( 1 )
        {
          BYTE1(v13) = *v12;
          v12 += v14[2];
          if ( BYTE1(v13) )
            v35[1] = byte_BB934[v13];
          v35 += 2;
          v14 += 4;
          if ( !--v36 )
            break;
LABEL_87:
          BYTE1(v13) = *v12;
          v12 += *v14;
          if ( BYTE1(v13) )
            *v35 = byte_BB934[v13];
        }
        break;
      case 6:
        v37 = (_BYTE *)v185;
        v38 = dword_B5CA4;
        HIWORD(v39) = 0;
        v40 = dword_B5CA8 >> 1;
        if ( !(dword_B5CA8 & 1) )
        {
          v14 = (_DWORD *)(dword_AE3FC + 36968);
          goto LABEL_96;
        }
        ++v40;
        v37 = (_BYTE *)(v185 - 1);
        while ( 1 )
        {
          BYTE1(v39) = *v12;
          v12 += v14[2];
          if ( BYTE1(v39) )
          {
            LOBYTE(v39) = v37[1];
            LOBYTE(v38) = byte_BB934[v39];
            v37[1] = byte_B7934[v38];
          }
          v37 += 2;
          v14 += 4;
          if ( !--v40 )
            break;
LABEL_96:
          BYTE1(v39) = *v12;
          v12 += *v14;
          if ( BYTE1(v39) )
          {
            LOBYTE(v39) = *v37;
            LOBYTE(v38) = byte_BB934[v39];
            *v37 = byte_B7934[v38];
          }
        }
        break;
      case 7:
        v41 = (_BYTE *)v185;
        v42 = dword_B5CA4;
        HIWORD(v43) = 0;
        v44 = dword_B5CA8 >> 1;
        if ( !(dword_B5CA8 & 1) )
        {
          v14 = (_DWORD *)(dword_AE3FC + 36968);
          goto LABEL_105;
        }
        ++v44;
        v41 = (_BYTE *)(v185 - 1);
        while ( 1 )
        {
          LOBYTE(v43) = *v12;
          v12 += v14[2];
          if ( (_BYTE)v43 )
          {
            BYTE1(v43) = v41[1];
            LOBYTE(v42) = byte_BB934[v43];
            v41[1] = byte_B7934[v42];
          }
          v41 += 2;
          v14 += 4;
          if ( !--v44 )
            break;
LABEL_105:
          LOBYTE(v43) = *v12;
          v12 += *v14;
          if ( (_BYTE)v43 )
          {
            BYTE1(v43) = *v41;
            LOBYTE(v42) = byte_BB934[v43];
            *v41 = byte_B7934[v42];
          }
        }
        break;
      case 9:
        v45 = (_BYTE *)v185;
        v46 = dword_B5CA4 >> 8;
        v47 = dword_B5CA8 >> 1;
        if ( !(dword_B5CA8 & 1) )
        {
          v17 = v47 & 1;
          v48 = dword_B5CA8 >> 2;
          if ( v17 )
          {
            ++v48;
            v14 = (_DWORD *)(dword_AE3FC + 36952);
            v45 = (_BYTE *)(v185 - 2);
            goto LABEL_122;
          }
          v14 = (_DWORD *)(dword_AE3FC + 36968);
          goto LABEL_118;
        }
        v49 = v47 + 2;
        v17 = v49 & 1;
        v48 = v49 >> 1;
        if ( !v17 )
        {
          v14 = (_DWORD *)(dword_AE3FC + 36944);
          v45 = (_BYTE *)(v185 - 3);
          goto LABEL_124;
        }
        v45 = (_BYTE *)(v185 - 1);
        while ( 1 )
        {
          v51 = *v12;
          v12 += v14[2];
          if ( v51 )
            v45[1] = BYTE1(v46);
LABEL_122:
          v52 = *v12;
          v12 += v14[4];
          if ( v52 )
            v45[2] = BYTE1(v46);
LABEL_124:
          v53 = *v12;
          v12 += v14[6];
          if ( v53 )
            v45[3] = BYTE1(v46);
          v45 += 4;
          v14 += 8;
          if ( !--v48 )
            break;
LABEL_118:
          v50 = *v12;
          v12 += *v14;
          if ( v50 )
            *v45 = BYTE1(v46);
        }
        break;
      default:
        break;
    }
    result = dword_93AD4;
    dword_B5CC0 += v172;
    v185 += dword_93AD4;
    --dword_B5CC8;
  }
  while ( dword_B5CC8 );
  return result;
}
// 2CAB3: control flows out of bounds to 2A6E8
// 2CD40: conditional instruction was optimized away because edx.4<0
// 93ACC: using guessed type int dword_93ACC;
// 93AD4: using guessed type int dword_93AD4;
// 93AD8: using guessed type int dword_93AD8;
// 93ADC: using guessed type int dword_93ADC;
// AE3FC: using guessed type int dword_AE3FC;
// B5CA4: using guessed type int dword_B5CA4;
// B5CA8: using guessed type int dword_B5CA8;
// B5CAC: using guessed type int dword_B5CAC;
// B5CB0: using guessed type int dword_B5CB0;
// B5CB4: using guessed type int dword_B5CB4;
// B5CB8: using guessed type int dword_B5CB8;
// B5CBC: using guessed type int dword_B5CBC;
// B5CC0: using guessed type int dword_B5CC0;
// B5CC4: using guessed type int dword_B5CC4;
// B5CC8: using guessed type int dword_B5CC8;
// B5CCC: using guessed type int dword_B5CCC;
// B5CD0: using guessed type int dword_B5CD0;
// B5CD4: using guessed type int dword_B5CD4;
// B5CD8: using guessed type int dword_B5CD8;
// B5CE0: using guessed type int dword_B5CE0;
// B5CE8: using guessed type int dword_B5CE8;
// B5CF4: using guessed type int dword_B5CF4;
// B5D04: using guessed type int dword_B5D04;
// B5D18: using guessed type int dword_B5D18;
// B5D1C: using guessed type int dword_B5D1C;
// B5D20: using guessed type int dword_B5D20;
// B5D24: using guessed type int dword_B5D24;
// B5D28: using guessed type int dword_B5D28;
// B5D2C: using guessed type int dword_B5D2C;
// B5D30: using guessed type int dword_B5D30;
// B5D34: using guessed type int dword_B5D34;
// B5D3E: using guessed type char byte_B5D3E;

//----- (0002DCB0) --------------------------------------------------------
unsigned __int16 sub_2DCB0fix(int a1, int a2)
{
  unsigned __int16 result; // ax
  int v3; // ebp
  __int16 v4; // bx
  int v5; // ecx
  int v6; // ebx
  int v7; // edx
  unsigned __int16 *v8; // edi
  int v9; // ebx
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  int v13; // ebx
  int v14; // eax
  int v15; // eax
  int v16; // edx
  int v17; // eax
  int v18; // eax
  int v19; // ebx
  int v20; // eax
  int v21; // eax
  int v22; // ebx
  int v23; // eax
  int v24; // ebx
  int v25; // eax
  int v26; // eax
  char v27; // dh
  int v28; // eax
  unsigned __int8 v29; // al
  int v30; // edx
  int v31; // ecx
  int v32; // ebx
  int v33; // edx
  unsigned __int16 *v34; // edi
  int v35; // ebx
  int v36; // ecx
  char v37; // al
  int v38; // eax
  int *v39; // esi
  int v40; // eax
  int v41; // edx
  int v42; // eax
  int v43; // ebx
  int v44; // eax
  int v45; // eax
  int v46; // edx
  int v47; // eax
  int v48; // eax
  int v49; // edx
  int v50; // ebx
  int v51; // eax
  int v52; // eax
  int v53; // eax
  int v54; // ebx
  int v55; // eax
  int v56; // eax
  char v57; // ch
  int v58; // eax
  unsigned __int8 v59; // al
  int v60; // [esp+0h] [ebp-24h]
  int v61; // [esp+4h] [ebp-20h]
  int v62; // [esp+8h] [ebp-1Ch]
  int v63; // [esp+Ch] [ebp-18h]
  int v64; // [esp+10h] [ebp-14h]

  //fix
  v60 = 0;
  //fix

  result = *(_WORD *)(a2 + 36);
  do
  {
    v3 = dword_AE400 + 29795 + 164 * result;
    if ( (*(_BYTE *)(v3 + 16) & 0x21) == 0 )
    {
      nullsub_1(v3, v60);
      v4 = *(_WORD *)(v3 + 74);
      v62 = (__int16)(*(_WORD *)(v3 + 72) - word_B5D3C);
      v61 = (__int16)(word_B5D3A - v4);
      if ( byte_B5D3F )
      {
        if ( !*(_BYTE *)(a2 + 43) )
        {
          v5 = sub_724C0(*(_WORD *)(v3 + 72), v4) - dword_B5CF8;
          v6 = (v62 * dword_B5CDC - dword_B5D10 * v61) >> 16;
          v63 = (dword_B5D10 * v62 + dword_B5CDC * v61) >> 16;
          v7 = v63 * v63 + v6 * v6;
          if ( v63 > 64 && v7 < dword_B5D00 )
          {
            if ( v7 <= dword_B5CF0 )
              dword_B5CA4 = 0x2000;
            else
              dword_B5CA4 = v7 < dword_B5D0C ? (32 * (dword_B5D0C - v7) / dword_B5CEC) << 8 : 0;
            v8 = (unsigned __int16 *)((char *)&unk_99BA0 + 14 * *(__int16 *)(v3 + 86));
            if ( !*((_BYTE *)v8 + 10) )
            {
              v9 = v6 * dword_B5D14 / v63;
              v10 = v5 * dword_B5D14 / v63 + dword_B5CFC;
              v60 = (v9 * dword_B5CE8 - v10 * dword_B5CD4) >> 16;
              dword_B5CB8 = v60 + dword_B5D08;
              dword_B5CB4 = dword_B5CE4 - ((dword_B5CE8 * v10 + dword_B5CD4 * v9) >> 16);
              byte_B5D3E = 0;
              switch ( *((_BYTE *)v8 + 12) )
              {
                case 0:
                  if ( !dword_12DF8C[*v8] && !sub_59050(*v8) )
                    goto LABEL_140;
                  dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * *v8 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                  a1 = *(_DWORD *)dword_12DF8C[*v8];
                  goto LABEL_35;
                case 1:
                  if ( !dword_12DF8C[*v8] && !sub_59050(*v8) )
                    goto LABEL_140;
                  dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * *v8 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                  a1 = *(_DWORD *)dword_12DF8C[*v8];
                  goto LABEL_35;
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 0xA:
                case 0xB:
                case 0xC:
                case 0xD:
                case 0xE:
                case 0xF:
                case 0x10:
                  goto LABEL_25;
                case 0x11:
                  v19 = (((*(unsigned __int16 *)(v3 + 30) - (unsigned __int16)word_B5D38) >> 3) & 0xF0) >> 4;
                  if ( v19 < 8 )
                  {
                    if ( dword_12DF8C[v19 + *v8] || sub_59050(v19 + *v8) )
                    {
                      dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * (v19 + *v8) + 8)] = *(_DWORD *)(dword_AE408 + 4);
                      a1 = *(_DWORD *)dword_12DF8C[v19 + *v8];
                      dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
                      dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
                      dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v8[4]) / v63;
                      dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
                      v15 = dword_B5CD0;
                      goto LABEL_64;
                    }
                    goto LABEL_140;
                  }
                  v20 = *v8 + 15 - v19;
                  if ( dword_12DF8C[v20] )
                  {
                    dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v20 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                  }
                  else
                  {
                    if ( !sub_59050(*v8 + 15 - v19) )
                      goto LABEL_140;
                    dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * (*v8 + 15 - v19) + 8)] = *(_DWORD *)(dword_AE408 + 4);
                  }
                  v21 = *v8 + 15 - v19;
                  goto LABEL_63;
                case 0x12:
                  v22 = (((*(unsigned __int16 *)(v3 + 30) - (unsigned __int16)word_B5D38) >> 3) & 0xF0) >> 4;
                  v23 = v22 + *v8;
                  if ( dword_12DF8C[v23] )
                    goto LABEL_52;
                  if ( !sub_59050(v22 + *v8) )
                    goto LABEL_140;
                  v23 = v22 + *v8;
LABEL_52:
                  dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v23 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                  a1 = *(_DWORD *)dword_12DF8C[v22 + *v8];
                  dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
                  dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
                  dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v8[4]) / v63;
                  dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
                  v15 = dword_B5CD0;
                  goto LABEL_64;
                case 0x13:
                  v13 = (((*(unsigned __int16 *)(v3 + 30) - (unsigned __int16)word_B5D38) >> 3) & 0xF0) >> 4;
                  if ( v13 < 8 )
                  {
                    v14 = (unsigned __int8)byte_906E8[v13] + *v8;
                    if ( dword_12DF8C[v14] )
                    {
                      dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v14 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                    }
                    else
                    {
                      if ( !sub_59050(*v8 + (unsigned __int8)byte_906E8[v13]) )
                        goto LABEL_140;
                      dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * (*v8 + (unsigned __int8)byte_906E8[v13]) + 8)] = *(_DWORD *)(dword_AE408 + 4);
                    }
                    a1 = *(_DWORD *)dword_12DF8C[*v8 + (unsigned __int8)byte_906E8[v13]];
LABEL_35:
                    dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
                    dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
                    dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v8[4]) / v63;
                    dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
                    v15 = dword_B5CD0;
                    goto LABEL_64;
                  }
                  v16 = (unsigned __int8)byte_906E8[v13];
                  v17 = v16 + *v8;
                  if ( !dword_12DF8C[v17] )
                  {
                    if ( !sub_59050(*v8 + (unsigned __int8)v16) )
                      goto LABEL_140;
                    v17 = *v8 + (unsigned __int8)byte_906E8[v13];
                  }
                  dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v17 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                  v18 = (unsigned __int8)byte_906E8[v13];
                  goto LABEL_62;
                case 0x14:
                  v24 = (((*(unsigned __int16 *)(v3 + 30) - (unsigned __int16)word_B5D38) >> 3) & 0xF0) >> 4;
                  if ( v24 >= 8 )
                  {
                    v26 = *v8 + (unsigned __int8)byte_906F8[v24];
                    if ( !dword_12DF8C[v26] )
                    {
                      if ( !sub_59050(*v8 + (unsigned __int8)byte_906F8[v24]) )
                        goto LABEL_140;
                      v26 = *v8 + (unsigned __int8)byte_906F8[v24];
                    }
                    dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v26 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                    v18 = (unsigned __int8)byte_906F8[v24];
LABEL_62:
                    v21 = *v8 + v18;
LABEL_63:
                    a1 = *(_DWORD *)dword_12DF8C[v21];
                    dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
                    dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
                    dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v8[4]) / v63;
                    dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
                    v15 = -dword_B5CD0;
                  }
                  else
                  {
                    v25 = (unsigned __int8)byte_906F8[v24] + *v8;
                    if ( !dword_12DF8C[v25] )
                    {
                      if ( !sub_59050(*v8 + (unsigned __int8)byte_906F8[v24]) )
                        goto LABEL_140;
                      v25 = *v8 + (unsigned __int8)byte_906F8[v24];
                    }
                    dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v25 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                    a1 = *(_DWORD *)dword_12DF8C[*v8 + (unsigned __int8)byte_906F8[v24]];
                    dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
                    dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
                    dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v8[4]) / v63;
                    dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
                    v15 = dword_B5CD0;
                  }
LABEL_64:
                  dword_B5CBC = v15;
LABEL_65:
                  v27 = *(_BYTE *)a1 | 8;
                  dword_B5CB0 = a1 + 6;
                  v28 = dword_B5CA4;
                  *(_BYTE *)a1 = v27;
                  if ( v28 == 0x2000 )
                    v29 = byte_906DC[*((unsigned __int8 *)v8 + 10)];
                  else
                    v29 = byte_906E2[*((unsigned __int8 *)v8 + 10)];
                  dword_B5CAC = v29;
                  v30 = dword_B5CC8 >> 2;
                  dword_B5CC8 >>= 2;
                  if ( dword_B5CA8 > 0 && v30 > 0 )
                  {
                    dword_B5CAC = 8;
                    dword_B5CA4 = (dword_B5CA4 >> 2) + 0x2000;
                    sub_2C410(0);
                  }
                  break;
                case 0x15:
                  v11 = *v8;
                  if ( dword_12DF8C[v11] )
                    goto LABEL_20;
                  if ( !sub_59050(v11) )
                    goto LABEL_140;
                  v11 = *v8;
LABEL_20:
                  dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v11 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                  a1 = *(_DWORD *)dword_12DF8C[*v8];
                  goto LABEL_35;
                case 0x16:
                case 0x17:
                case 0x18:
                case 0x19:
                case 0x1A:
                case 0x1B:
                case 0x1C:
                case 0x1D:
                case 0x1E:
                case 0x1F:
                case 0x20:
                case 0x21:
                case 0x22:
                case 0x23:
                case 0x24:
                  byte_B5D3E = 1;
LABEL_25:
                  v12 = *(unsigned __int8 *)(v3 + 88) + *v8;
                  if ( dword_12DF8C[v12] )
                    goto LABEL_28;
                  if ( !sub_59050(*v8 + *(unsigned __int8 *)(v3 + 88)) )
                    goto LABEL_140;
                  v12 = *v8 + *(unsigned __int8 *)(v3 + 88);
LABEL_28:
                  dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v12 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                  a1 = *(_DWORD *)dword_12DF8C[*v8 + *(unsigned __int8 *)(v3 + 88)];
                  goto LABEL_35;
                default:
                  goto LABEL_65;
              }
            }
          }
        }
      }
      v31 = *(__int16 *)(v3 + 76) - dword_B5CF8;
      v32 = (v62 * dword_B5CDC - dword_B5D10 * v61) >> 16;
      v64 = (dword_B5CDC * v61 + dword_B5D10 * v62) >> 16;
      v33 = v64 * v64 + v32 * v32;
      if ( v64 > 64 && v33 < dword_B5D00 )
      {
        if ( v33 <= dword_B5CF0 )
        {
          dword_B5CA4 = 0x2000;
        }
        else if ( v33 < dword_B5D0C )
        {
          dword_B5CA4 = (32 * (dword_B5D0C - v33) / dword_B5CEC) << 8;
        }
        else
        {
          dword_B5CA4 = 0;
        }
        v34 = (unsigned __int16 *)((char *)&unk_99BA0 + 14 * *(__int16 *)(v3 + 86));
        v35 = v32 * dword_B5D14 / v64;
        v36 = v31 * dword_B5D14 / v64 + dword_B5CFC;
        v60 = (v35 * dword_B5CE8 - v36 * dword_B5CD4) >> 16;
        dword_B5CB8 = v60 + dword_B5D08;
        dword_B5CB4 = dword_B5CE4 - ((dword_B5CE8 * v36 + dword_B5CD4 * v35) >> 16);
        v37 = *((_BYTE *)v34 + 12);
        byte_B5D3E = 0;
        switch ( v37 )
        {
          case 0:
            if ( dword_12DF8C[*v34] )
            {
              dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * *v34 + 8)] = *(_DWORD *)(dword_AE408 + 4);
              goto LABEL_83;
            }
            if ( sub_59050(*v34) )
            {
              dword_12CF00[*(unsigned __int16 *)(10 * *v34 + dword_12D744 + 8)] = *(_DWORD *)(dword_AE408 + 4);
LABEL_83:
              a1 = *(_DWORD *)dword_12DF8C[*v34];
              goto LABEL_103;
            }
            break;
          case 1:
            if ( dword_12DF8C[*v34] )
            {
              v40 = *(unsigned __int16 *)(10 * *v34 + dword_12D744 + 8);
              v41 = *(_DWORD *)(dword_AE408 + 4);
            }
            else
            {
              if ( !sub_59050(*v34) )
                break;
              v40 = *(unsigned __int16 *)(dword_12D744 + 10 * *v34 + 8);
              v41 = *(_DWORD *)(dword_AE408 + 4);
            }
            dword_12CF00[v40] = v41;
            a1 = *(_DWORD *)dword_12DF8C[*v34];
            goto LABEL_103;
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
          case 15:
          case 16:
            goto LABEL_94;
          case 17:
            v50 = (((*(unsigned __int16 *)(v3 + 30) - (unsigned __int16)word_B5D38) >> 3) & 0xF0) >> 4;
            if ( v50 < 8 )
            {
              if ( dword_12DF8C[v50 + *v34] )
              {
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * (v50 + *v34) + 8)] = *(_DWORD *)(dword_AE408 + 4);
              }
              else
              {
                if ( !sub_59050(v50 + *v34) )
                  break;
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * (v50 + *v34) + 8)] = *(_DWORD *)(dword_AE408 + 4);
              }
              goto LABEL_114;
            }
            v51 = *v34 + 15 - v50;
            if ( dword_12DF8C[v51] )
            {
              dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v51 + 8)] = *(_DWORD *)(dword_AE408 + 4);
            }
            else
            {
              if ( !sub_59050(*v34 + 15 - v50) )
                break;
              dword_12CF00[*(unsigned __int16 *)(10 * (*v34 + 15 - v50) + dword_12D744 + 8)] = *(_DWORD *)(dword_AE408 + 4);
            }
            v52 = *v34 + 15 - v50;
            goto LABEL_134;
          case 18:
            v50 = (((*(unsigned __int16 *)(v3 + 30) - (unsigned __int16)word_B5D38) >> 3) & 0xF0) >> 4;
            v53 = v50 + *v34;
            if ( dword_12DF8C[v53] )
            {
              dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v53 + 8)] = *(_DWORD *)(dword_AE408 + 4);
              goto LABEL_114;
            }
            if ( sub_59050(v50 + *v34) )
            {
              dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * (v50 + *v34) + 8)] = *(_DWORD *)(dword_AE408 + 4);
LABEL_114:
              a1 = *(_DWORD *)dword_12DF8C[v50 + *v34];
              dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
              dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
              dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v34[4]) / v64;
              dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
              v45 = dword_B5CD0;
              goto LABEL_135;
            }
            break;
          case 19:
            v43 = (((*(unsigned __int16 *)(v3 + 30) - (unsigned __int16)word_B5D38) >> 3) & 0xF0) >> 4;
            if ( v43 < 8 )
            {
              v44 = (unsigned __int8)byte_906E8[v43] + *v34;
              if ( !dword_12DF8C[v44] )
              {
                if ( !sub_59050(*v34 + (unsigned __int8)byte_906E8[v43]) )
                  break;
                v44 = *v34 + (unsigned __int8)byte_906E8[v43];
              }
              dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v44 + 8)] = *(_DWORD *)(dword_AE408 + 4);
              a1 = *(_DWORD *)dword_12DF8C[*v34 + (unsigned __int8)byte_906E8[v43]];
LABEL_103:
              dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
              dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
              dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v34[4]) / v64;
              dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
              v45 = dword_B5CD0;
              goto LABEL_135;
            }
            v46 = (unsigned __int8)byte_906E8[v43];
            v47 = v46 + *v34;
            if ( dword_12DF8C[v47] )
            {
              dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v47 + 8)] = *(_DWORD *)(dword_AE408 + 4);
            }
            else
            {
              if ( !sub_59050(*v34 + (unsigned __int8)v46) )
                break;
              dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * ((unsigned __int8)byte_906E8[v43] + *v34) + 8)] = *(_DWORD *)(dword_AE408 + 4);
            }
            v48 = (unsigned __int8)byte_906E8[v43];
            v49 = *v34;
            goto LABEL_133;
          case 20:
            v54 = (((*(unsigned __int16 *)(v3 + 30) - (unsigned __int16)word_B5D38) >> 3) & 0xF0) >> 4;
            if ( v54 >= 8 )
            {
              v56 = *v34 + (unsigned __int8)byte_906F8[v54];
              if ( !dword_12DF8C[v56] )
              {
                if ( !sub_59050(*v34 + (unsigned __int8)byte_906F8[v54]) )
                  break;
                v56 = *v34 + (unsigned __int8)byte_906F8[v54];
              }
              dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v56 + 8)] = *(_DWORD *)(dword_AE408 + 4);
              v49 = (unsigned __int8)byte_906F8[v54];
              v48 = *v34;
LABEL_133:
              v52 = v49 + v48;
LABEL_134:
              a1 = *(_DWORD *)dword_12DF8C[v52];
              dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
              dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
              dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v34[4]) / v64;
              dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
              v45 = -dword_B5CD0;
            }
            else
            {
              v55 = *v34 + (unsigned __int8)byte_906F8[v54];
              if ( !dword_12DF8C[v55] )
              {
                if ( !sub_59050(*v34 + (unsigned __int8)byte_906F8[v54]) )
                  break;
                v55 = *v34 + (unsigned __int8)byte_906F8[v54];
              }
              dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v55 + 8)] = *(_DWORD *)(dword_AE408 + 4);
              a1 = *(_DWORD *)dword_12DF8C[*v34 + (unsigned __int8)byte_906F8[v54]];
              dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
              dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
              dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v34[4]) / v64;
              dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
              v45 = dword_B5CD0;
            }
LABEL_135:
            dword_B5CBC = v45;
LABEL_136:
            v57 = *(_BYTE *)a1 | 8;
            dword_B5CB0 = a1 + 6;
            v58 = dword_B5CA4;
            *(_BYTE *)a1 = v57;
            if ( v58 == 0x2000 )
              v59 = byte_906DC[*((unsigned __int8 *)v34 + 10)];
            else
              v59 = byte_906E2[*((unsigned __int8 *)v34 + 10)];
            dword_B5CAC = v59;
            ++dword_B5CA8;
            ++dword_B5CC8;
            sub_2C410(1u);
            break;
          case 21:
            v38 = *v34;
            if ( dword_12DF8C[v38] )
              goto LABEL_87;
            if ( !sub_59050(v38) )
              break;
            v38 = *v34;
LABEL_87:
            dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v38 + 8)] = *(_DWORD *)(dword_AE408 + 4);
            v39 = (int *)dword_12DF8C[*v34];
            byte_B5D3E = 1;
            a1 = *v39;
            goto LABEL_103;
          case 22:
          case 23:
          case 24:
          case 25:
          case 26:
          case 27:
          case 28:
          case 29:
          case 30:
          case 31:
          case 32:
          case 33:
          case 34:
          case 35:
          case 36:
            byte_B5D3E = 1;
LABEL_94:
            v42 = *(unsigned __int8 *)(v3 + 88) + *v34;
            if ( dword_12DF8C[v42] )
              goto LABEL_97;
            if ( !sub_59050(*v34 + *(unsigned __int8 *)(v3 + 88)) )
              break;
            v42 = *v34 + *(unsigned __int8 *)(v3 + 88);
LABEL_97:
            dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v42 + 8)] = *(_DWORD *)(dword_AE408 + 4);
            a1 = *(_DWORD *)dword_12DF8C[*v34 + *(unsigned __int8 *)(v3 + 88)];
            goto LABEL_103;
          default:
            goto LABEL_136;
        }
      }
    }
LABEL_140:
    result = *(_WORD *)(v3 + 20);
  }
  while ( result );
  return result;
}
// 2DCE1: variable 'v60' is possibly undefined
// 20F80: using guessed type int nullsub_1(_DWORD, _DWORD);
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// B5CA4: using guessed type int dword_B5CA4;
// B5CA8: using guessed type int dword_B5CA8;
// B5CAC: using guessed type int dword_B5CAC;
// B5CB0: using guessed type int dword_B5CB0;
// B5CB4: using guessed type int dword_B5CB4;
// B5CB8: using guessed type int dword_B5CB8;
// B5CBC: using guessed type int dword_B5CBC;
// B5CC8: using guessed type int dword_B5CC8;
// B5CCC: using guessed type int dword_B5CCC;
// B5CD0: using guessed type int dword_B5CD0;
// B5CD4: using guessed type int dword_B5CD4;
// B5CDC: using guessed type int dword_B5CDC;
// B5CE4: using guessed type int dword_B5CE4;
// B5CE8: using guessed type int dword_B5CE8;
// B5CEC: using guessed type int dword_B5CEC;
// B5CF0: using guessed type int dword_B5CF0;
// B5CF8: using guessed type int dword_B5CF8;
// B5CFC: using guessed type int dword_B5CFC;
// B5D00: using guessed type int dword_B5D00;
// B5D08: using guessed type int dword_B5D08;
// B5D0C: using guessed type int dword_B5D0C;
// B5D10: using guessed type int dword_B5D10;
// B5D14: using guessed type int dword_B5D14;
// B5D38: using guessed type __int16 word_B5D38;
// B5D3A: using guessed type __int16 word_B5D3A;
// B5D3C: using guessed type __int16 word_B5D3C;
// B5D3E: using guessed type char byte_B5D3E;
// B5D3F: using guessed type char byte_B5D3F;
// 12CF00: using guessed type int dword_12CF00[529];
// 12D744: using guessed type int dword_12D744;
// 12DF8C: using guessed type int dword_12DF8C[529];

//----- (0002F170) --------------------------------------------------------
unsigned __int16 sub_2F170fix(int a1, int a2)
{
  unsigned __int16 result; // ax
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // ebp
  int v7; // esi
  int v8; // eax
  unsigned __int16 *v9; // ebx
  int v10; // esi
  int v11; // ecx
  int v12; // eax
  int *v13; // edi
  int v14; // eax
  int v15; // esi
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // esi
  int v21; // ecx
  unsigned __int16 v22; // dx
  int v23; // ebx
  int v24; // eax
  int v25; // eax
  int v26; // esi
  int v27; // edx
  int v28; // eax
  int v29; // eax
  char v30; // al
  int v31; // esi
  int v32; // [esp+4h] [ebp-14h]

  result = *(_WORD *)(a2 + 36);
  do
  {
    if ( result < 0x3E8u )
    {
      v3 = 164 * result + dword_AE400 + 29795;
      v32 = v3;
      if ( (*(_BYTE *)(v3 + 16) & 0x21) == 0 )
      {
        v4 = (__int16)(*(_WORD *)(v3 + 72) - word_B5D3C);
        v5 = *(__int16 *)(v3 + 76) - dword_B5CF8;
        v6 = (dword_B5D10 * v4 + dword_B5CDC * (__int16)(word_B5D3A - *(_WORD *)(v3 + 74))) >> 16;
        v7 = (v4 * dword_B5CDC - (__int16)(word_B5D3A - *(_WORD *)(v3 + 74)) * dword_B5D10) >> 16;
        if ( v6 > 64 )
        {
          v8 = 14 * *(__int16 *)(v3 + 86);
          dword_B5CA4 = 0x400000 - 350 * (5120 - v6);
          v9 = (unsigned __int16 *)((char *)&unk_99BA0 + v8);
          v10 = v7 * dword_B5D14 / v6;
          v11 = v5 * dword_B5D14 / v6 + dword_B5CFC;
          dword_B5CB8 = ((v10 * dword_B5CE8 - v11 * dword_B5CD4) >> 16) + dword_B5D08;
          dword_B5CB4 = dword_B5CE4 - ((dword_B5CD4 * v10 + dword_B5CE8 * v11) >> 16);
          LOBYTE(v8) = *((_BYTE *)&unk_99BA0 + v8 + 12);
          byte_B5D3E = 0;
          switch ( (char)v8 )
          {
            case 0:
              if ( dword_12DF8C[*v9] )
              {
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * *v9 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                goto LABEL_10;
              }
              if ( sub_59050(*v9) )
              {
                dword_12CF00[*(unsigned __int16 *)(10 * *v9 + dword_12D744 + 8)] = *(_DWORD *)(dword_AE408 + 4);
LABEL_10:
                a1 = *(_DWORD *)dword_12DF8C[*v9];
                goto LABEL_31;
              }
              break;
            case 1:
              if ( dword_12DF8C[*v9] )
              {
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * *v9 + 8)] = *(_DWORD *)(dword_AE408 + 4);
              }
              else
              {
                if ( !sub_59050(*v9) )
                  break;
                dword_12CF00[*(unsigned __int16 *)(10 * *v9 + dword_12D744 + 8)] = *(_DWORD *)(dword_AE408 + 4);
              }
              a1 = *(_DWORD *)dword_12DF8C[*v9];
              goto LABEL_31;
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
              goto LABEL_21;
            case 17:
              v20 = (((*(unsigned __int16 *)(v32 + 30) - (unsigned __int16)word_B5D38) >> 3) & 0xF0) >> 4;
              if ( v20 < 8 )
              {
                if ( dword_12DF8C[v20 + *v9] )
                {
                  dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * (v20 + *v9) + 8)] = *(_DWORD *)(dword_AE408 + 4);
                }
                else
                {
                  if ( !sub_59050(v20 + *v9) )
                    break;
                  dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * (v20 + *v9) + 8)] = *(_DWORD *)(dword_AE408 + 4);
                }
                goto LABEL_41;
              }
              if ( dword_12DF8C[*v9 + 15 - v20] || sub_59050(*v9 + 15 - v20) )
              {
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * (*v9 + 15 - v20) + 8)] = *(_DWORD *)(dword_AE408 + 4);
                a1 = *(_DWORD *)dword_12DF8C[*v9 + 15 - v20];
                dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
                v21 = v6;
                dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
                v22 = v9[4];
                v23 = dword_B5D14;
                v24 = v22;
                goto LABEL_59;
              }
              break;
            case 18:
              v20 = (((*(unsigned __int16 *)(v32 + 30) - (unsigned __int16)word_B5D38) >> 3) & 0xF0) >> 4;
              v25 = v20 + *v9;
              if ( dword_12DF8C[v25] )
              {
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v25 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                goto LABEL_41;
              }
              if ( sub_59050(v20 + *v9) )
              {
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * (v20 + *v9) + 8)] = *(_DWORD *)(dword_AE408 + 4);
LABEL_41:
                a1 = *(_DWORD *)dword_12DF8C[v20 + *v9];
                dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
                dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
                dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v9[4]) / v6;
                dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
                v17 = dword_B5CD0;
                goto LABEL_60;
              }
              break;
            case 19:
              v15 = (((*(unsigned __int16 *)(v32 + 30) - (unsigned __int16)word_B5D38) >> 3) & 0xF0) >> 4;
              if ( v15 < 8 )
              {
                v16 = *v9 + (unsigned __int8)byte_906E8[v15];
                if ( !dword_12DF8C[v16] )
                {
                  if ( !sub_59050(*v9 + (unsigned __int8)byte_906E8[v15]) )
                    break;
                  v16 = *v9 + (unsigned __int8)byte_906E8[v15];
                }
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v16 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                a1 = *(_DWORD *)dword_12DF8C[*v9 + (unsigned __int8)byte_906E8[v15]];
                goto LABEL_31;
              }
              v18 = (unsigned __int8)byte_906E8[v15] + *v9;
              if ( !dword_12DF8C[v18] )
              {
                if ( !sub_59050(*v9 + (unsigned __int8)byte_906E8[v15]) )
                  break;
                v18 = *v9 + (unsigned __int8)byte_906E8[v15];
              }
              dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v18 + 8)] = *(_DWORD *)(dword_AE408 + 4);
              v19 = (unsigned __int8)byte_906E8[v15];
              goto LABEL_58;
            case 20:
              v26 = (((*(unsigned __int16 *)(v32 + 30) - (unsigned __int16)word_B5D38) >> 3) & 0xF0) >> 4;
              if ( v26 >= 8 )
              {
                v29 = (unsigned __int8)byte_906F8[v26] + *v9;
                if ( !dword_12DF8C[v29] )
                {
                  if ( !sub_59050(*v9 + (unsigned __int8)byte_906F8[v26]) )
                    break;
                  v29 = *v9 + (unsigned __int8)byte_906F8[v26];
                }
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v29 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                v19 = (unsigned __int8)byte_906F8[v26];
LABEL_58:
                a1 = *(_DWORD *)dword_12DF8C[*v9 + v19];
                dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
                v21 = v6;
                dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
                v24 = v9[4];
                v23 = dword_B5D14;
LABEL_59:
                dword_B5CC8 = v23 * (__int64)v24 / v21;
                dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
                v17 = -dword_B5CD0;
              }
              else
              {
                v27 = (unsigned __int8)byte_906F8[v26];
                v28 = v27 + *v9;
                if ( !dword_12DF8C[v28] )
                {
                  if ( !sub_59050(*v9 + (unsigned __int8)v27) )
                    break;
                  v28 = *v9 + (unsigned __int8)byte_906F8[v26];
                }
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v28 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                a1 = *(_DWORD *)dword_12DF8C[*v9 + (unsigned __int8)byte_906F8[v26]];
                dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
                dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
                dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v9[4]) / v6;
                dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
                v17 = dword_B5CD0;
              }
              goto LABEL_60;
            case 21:
              v12 = *v9;
              if ( dword_12DF8C[v12] )
                goto LABEL_14;
              if ( !sub_59050(v12) )
                break;
              v12 = *v9;
LABEL_14:
              dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v12 + 8)] = *(_DWORD *)(dword_AE408 + 4);
              v13 = (int *)dword_12DF8C[*v9];
              byte_B5D3E = 1;
              a1 = *v13;
              goto LABEL_31;
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
              byte_B5D3E = 1;
LABEL_21:
              v14 = *(unsigned __int8 *)(v32 + 88) + *v9;
              if ( dword_12DF8C[v14] )
              {
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v14 + 8)] = *(_DWORD *)(dword_AE408 + 4);
              }
              else
              {
                if ( !sub_59050(*v9 + *(unsigned __int8 *)(v32 + 88)) )
                  break;
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * (*v9 + *(unsigned __int8 *)(v32 + 88)) + 8)] = *(_DWORD *)(dword_AE408 + 4);
              }
              a1 = *(_DWORD *)dword_12DF8C[*v9 + *(unsigned __int8 *)(v32 + 88)];
LABEL_31:
              dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
              dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
              dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v9[4]) / v6;
              dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
              v17 = dword_B5CD0;
LABEL_60:
              dword_B5CBC = v17;
LABEL_61:
              v30 = *(_BYTE *)a1 | 8;
              dword_B5CAC = 9;
              v31 = dword_B5CC8 + 1;
              ++dword_B5CA8;
              *(_BYTE *)a1 = v30;
              dword_B5CC8 = v31;
              dword_B5CB0 = a1 + 6;
              sub_2C410(1u);
              break;
            default:
              goto LABEL_61;
          }
        }
      }
    }
    result = *(_WORD *)(v32 + 20);
  }
  while ( result );
  return result;
}
// 2FBA1: variable 'v32' is possibly undefined
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// B5CA4: using guessed type int dword_B5CA4;
// B5CA8: using guessed type int dword_B5CA8;
// B5CAC: using guessed type int dword_B5CAC;
// B5CB0: using guessed type int dword_B5CB0;
// B5CB4: using guessed type int dword_B5CB4;
// B5CB8: using guessed type int dword_B5CB8;
// B5CBC: using guessed type int dword_B5CBC;
// B5CC8: using guessed type int dword_B5CC8;
// B5CCC: using guessed type int dword_B5CCC;
// B5CD0: using guessed type int dword_B5CD0;
// B5CD4: using guessed type int dword_B5CD4;
// B5CDC: using guessed type int dword_B5CDC;
// B5CE4: using guessed type int dword_B5CE4;
// B5CE8: using guessed type int dword_B5CE8;
// B5CF8: using guessed type int dword_B5CF8;
// B5CFC: using guessed type int dword_B5CFC;
// B5D08: using guessed type int dword_B5D08;
// B5D10: using guessed type int dword_B5D10;
// B5D14: using guessed type int dword_B5D14;
// B5D38: using guessed type __int16 word_B5D38;
// B5D3A: using guessed type __int16 word_B5D3A;
// B5D3C: using guessed type __int16 word_B5D3C;
// B5D3E: using guessed type char byte_B5D3E;
// 12CF00: using guessed type int dword_12CF00[529];
// 12D744: using guessed type int dword_12D744;
// 12DF8C: using guessed type int dword_12DF8C[529];

//----- (0002FC50) --------------------------------------------------------
unsigned __int16 sub_2FC50fix(int a1, int a2)
{
  unsigned __int16 result; // ax
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // ecx
  int v7; // ebx
  int v8; // ebp
  int v9; // edx
  unsigned __int16 *v10; // esi
  int v11; // ebx
  int v12; // ecx
  char v13; // al
  int v14; // eax
  int v15; // eax
  int *v16; // edi
  int v17; // eax
  int v18; // ebx
  int v19; // eax
  int v20; // edx
  int v21; // eax
  int v22; // eax
  int v23; // ebx
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // ebx
  int v28; // eax
  int v29; // eax
  int v30; // ebp
  char v31; // cl
  unsigned __int8 v32; // al
  int v33; // [esp+4h] [ebp-14h]

  result = *(_WORD *)(a2 + 36);
  do
  {
    if ( result < 0x3E8u )
    {
      v3 = 164 * result + dword_AE400 + 29795;
      v33 = v3;
      if ( (*(_BYTE *)(v3 + 16) & 0x21) == 0 )
      {
        v4 = (__int16)(*(_WORD *)(v3 + 72) - word_B5D3C);
        v5 = (__int16)(word_B5D3A - *(_WORD *)(v3 + 74));
        v6 = -*(__int16 *)(v33 + 76) - dword_B5CF8;
        v7 = (v4 * dword_B5CDC - v5 * dword_B5D10) >> 16;
        v8 = (dword_B5D10 * v4 + v5 * dword_B5CDC) >> 16;
        v9 = v8 * v8 + v7 * v7;
        if ( v8 > 64 && v9 < dword_B5D00 )
        {
          if ( v9 <= dword_B5CF0 )
          {
            dword_B5CA4 = 0x2000;
          }
          else if ( v9 < dword_B5D0C )
          {
            dword_B5CA4 = (32 * (dword_B5D0C - v9) / dword_B5CEC) << 8;
          }
          else
          {
            dword_B5CA4 = 0;
          }
          v10 = (unsigned __int16 *)((char *)&unk_99BA0 + 14 * *(__int16 *)(v33 + 86));
          v11 = v7 * dword_B5D14 / v8;
          v12 = v6 * dword_B5D14 / v8 + dword_B5CFC;
          dword_B5CB8 = ((v11 * dword_B5CE8 - v12 * dword_B5CD4) >> 16) + dword_B5D08;
          dword_B5CB4 = dword_B5CE4 - ((dword_B5CE8 * v12 + dword_B5CD4 * v11) >> 16);
          v13 = *((_BYTE *)v10 + 12);
          byte_B5D3E = 0;
          switch ( v13 )
          {
            case 0:
              if ( dword_12DF8C[*v10] )
              {
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * *v10 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                goto LABEL_16;
              }
              if ( sub_59050(*v10) )
              {
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * *v10 + 8)] = *(_DWORD *)(dword_AE408 + 4);
LABEL_16:
                a1 = *(_DWORD *)dword_12DF8C[*v10];
                goto LABEL_17;
              }
              break;
            case 1:
              if ( dword_12DF8C[*v10] )
              {
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * *v10 + 8)] = *(_DWORD *)(dword_AE408 + 4);
              }
              else
              {
                if ( !sub_59050(*v10) )
                  break;
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * *v10 + 8)] = *(_DWORD *)(dword_AE408 + 4);
              }
              a1 = *(_DWORD *)dword_12DF8C[*v10];
              goto LABEL_17;
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
              goto LABEL_28;
            case 17:
              v23 = (((*(unsigned __int16 *)(v33 + 30) - (unsigned __int16)word_B5D38) >> 3) & 0xF0) >> 4;
              if ( v23 < 8 )
              {
                if ( dword_12DF8C[v23 + *v10] )
                {
                  dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * (v23 + *v10) + 8)] = *(_DWORD *)(dword_AE408 + 4);
                }
                else
                {
                  if ( !sub_59050(v23 + *v10) )
                    break;
                  dword_12CF00[*(unsigned __int16 *)(10 * (v23 + *v10) + dword_12D744 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                }
                goto LABEL_48;
              }
              v24 = *v10 + 15 - v23;
              if ( !dword_12DF8C[v24] )
              {
                if ( !sub_59050(*v10 + 15 - v23) )
                  break;
                v24 = *v10 + 15 - v23;
              }
              dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v24 + 8)] = *(_DWORD *)(dword_AE408 + 4);
              v25 = *v10 + 15 - v23;
              goto LABEL_67;
            case 18:
              v23 = (((*(unsigned __int16 *)(v33 + 30) - (unsigned __int16)word_B5D38) >> 3) & 0xF0) >> 4;
              v26 = v23 + *v10;
              if ( dword_12DF8C[v26] )
              {
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v26 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                goto LABEL_48;
              }
              if ( sub_59050(v23 + *v10) )
              {
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * (v23 + *v10) + 8)] = *(_DWORD *)(dword_AE408 + 4);
LABEL_48:
                a1 = *(_DWORD *)dword_12DF8C[v23 + *v10];
                dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
                dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
                dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v10[4]) / v8;
                dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
                v14 = dword_B5CD0;
                goto LABEL_68;
              }
              break;
            case 19:
              v18 = (((*(unsigned __int16 *)(v33 + 30) - (unsigned __int16)word_B5D38) >> 3) & 0xF0) >> 4;
              if ( v18 < 8 )
              {
                v19 = *v10 + (unsigned __int8)byte_906E8[v18];
                if ( dword_12DF8C[v19] )
                {
                  dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v19 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                }
                else
                {
                  if ( !sub_59050(*v10 + (unsigned __int8)byte_906E8[v18]) )
                    break;
                  dword_12CF00[*(unsigned __int16 *)(10 * (*v10 + (unsigned __int8)byte_906E8[v18]) + dword_12D744 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                }
                a1 = *(_DWORD *)dword_12DF8C[*v10 + (unsigned __int8)byte_906E8[v18]];
                dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
                dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
                dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v10[4]) / v8;
                dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
                v14 = dword_B5CD0;
                goto LABEL_68;
              }
              v20 = (unsigned __int8)byte_906E8[v18];
              v21 = v20 + *v10;
              if ( !dword_12DF8C[v21] )
              {
                if ( !sub_59050(*v10 + (unsigned __int8)v20) )
                  break;
                v21 = *v10 + (unsigned __int8)byte_906E8[v18];
              }
              dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v21 + 8)] = *(_DWORD *)(dword_AE408 + 4);
              v22 = (unsigned __int8)byte_906E8[v18];
              goto LABEL_66;
            case 20:
              v27 = (((*(unsigned __int16 *)(v33 + 30) - (unsigned __int16)word_B5D38) >> 3) & 0xF0) >> 4;
              if ( v27 >= 8 )
              {
                v29 = *v10 + (unsigned __int8)byte_906F8[v27];
                if ( !dword_12DF8C[v29] )
                {
                  if ( !sub_59050(*v10 + (unsigned __int8)byte_906F8[v27]) )
                    break;
                  v29 = *v10 + (unsigned __int8)byte_906F8[v27];
                }
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v29 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                v22 = (unsigned __int8)byte_906F8[v27];
LABEL_66:
                v25 = *v10 + v22;
LABEL_67:
                a1 = *(_DWORD *)dword_12DF8C[v25];
                dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
                dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
                dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v10[4]) / v8;
                dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
                v14 = -dword_B5CD0;
              }
              else
              {
                v28 = *v10 + (unsigned __int8)byte_906F8[v27];
                if ( !dword_12DF8C[v28] )
                {
                  if ( !sub_59050(*v10 + (unsigned __int8)byte_906F8[v27]) )
                    break;
                  v28 = *v10 + (unsigned __int8)byte_906F8[v27];
                }
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v28 + 8)] = *(_DWORD *)(dword_AE408 + 4);
                a1 = *(_DWORD *)dword_12DF8C[*v10 + (unsigned __int8)byte_906F8[v27]];
                dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
                dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
                dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v10[4]) / v8;
                dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
                v14 = dword_B5CD0;
              }
              goto LABEL_68;
            case 21:
              v15 = *v10;
              if ( dword_12DF8C[v15] )
                goto LABEL_21;
              if ( !sub_59050(v15) )
                break;
              v15 = *v10;
LABEL_21:
              dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v15 + 8)] = *(_DWORD *)(dword_AE408 + 4);
              v16 = (int *)dword_12DF8C[*v10];
              byte_B5D3E = 1;
              a1 = *v16;
              goto LABEL_17;
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
              byte_B5D3E = 1;
LABEL_28:
              v17 = *v10 + *(unsigned __int8 *)(v33 + 88);
              if ( dword_12DF8C[v17] )
              {
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * v17 + 8)] = *(_DWORD *)(dword_AE408 + 4);
              }
              else
              {
                if ( !sub_59050(*v10 + *(unsigned __int8 *)(v33 + 88)) )
                  break;
                dword_12CF00[*(unsigned __int16 *)(dword_12D744 + 10 * (*(unsigned __int8 *)(v33 + 88) + *v10) + 8)] = *(_DWORD *)(dword_AE408 + 4);
              }
              a1 = *(_DWORD *)dword_12DF8C[*v10 + *(unsigned __int8 *)(v33 + 88)];
LABEL_17:
              dword_B5CD0 = *(unsigned __int16 *)(a1 + 2);
              dword_B5CCC = *(unsigned __int16 *)(a1 + 4);
              dword_B5CC8 = (__int64)(dword_B5D14 * (unsigned __int64)v10[4]) / v8;
              dword_B5CA8 = dword_B5CC8 * dword_B5CD0 / dword_B5CCC;
              v14 = dword_B5CD0;
LABEL_68:
              dword_B5CBC = v14;
LABEL_69:
              v30 = dword_B5CA4;
              v31 = *(_BYTE *)a1 | 8;
              dword_B5CB0 = a1 + 6;
              *(_BYTE *)a1 = v31;
              if ( v30 == 0x2000 )
                v32 = byte_906DC[*((unsigned __int8 *)v10 + 10)];
              else
                v32 = byte_906E2[*((unsigned __int8 *)v10 + 10)];
              dword_B5CAC = v32;
              ++dword_B5CA8;
              ++dword_B5CC8;
              sub_2C410(2u);
              break;
            default:
              goto LABEL_69;
          }
        }
      }
    }
    result = *(_WORD *)(v33 + 20);
  }
  while ( result );
  return result;
}
// 30718: variable 'v33' is possibly undefined
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// B5CA4: using guessed type int dword_B5CA4;
// B5CA8: using guessed type int dword_B5CA8;
// B5CAC: using guessed type int dword_B5CAC;
// B5CB0: using guessed type int dword_B5CB0;
// B5CB4: using guessed type int dword_B5CB4;
// B5CB8: using guessed type int dword_B5CB8;
// B5CBC: using guessed type int dword_B5CBC;
// B5CC8: using guessed type int dword_B5CC8;
// B5CCC: using guessed type int dword_B5CCC;
// B5CD0: using guessed type int dword_B5CD0;
// B5CD4: using guessed type int dword_B5CD4;
// B5CDC: using guessed type int dword_B5CDC;
// B5CE4: using guessed type int dword_B5CE4;
// B5CE8: using guessed type int dword_B5CE8;
// B5CEC: using guessed type int dword_B5CEC;
// B5CF0: using guessed type int dword_B5CF0;
// B5CF8: using guessed type int dword_B5CF8;
// B5CFC: using guessed type int dword_B5CFC;
// B5D00: using guessed type int dword_B5D00;
// B5D08: using guessed type int dword_B5D08;
// B5D0C: using guessed type int dword_B5D0C;
// B5D10: using guessed type int dword_B5D10;
// B5D14: using guessed type int dword_B5D14;
// B5D38: using guessed type __int16 word_B5D38;
// B5D3A: using guessed type __int16 word_B5D3A;
// B5D3C: using guessed type __int16 word_B5D3C;
// B5D3E: using guessed type char byte_B5D3E;
// 12CF00: using guessed type int dword_12CF00[529];
// 12D744: using guessed type int dword_12D744;
// 12DF8C: using guessed type int dword_12DF8C[529];

//----- (00030730) --------------------------------------------------------
__int16 sub_30730(__int16 a1)
{
  int v1; // ebx
  int v2; // edx
  __int64 v3; // rtt
  int v4; // ebp
  int v5; // ebx
  _BYTE *v6; // edx
  int v7; // eax
  unsigned __int8 v8; // ch
  int v9; // edx
  int v10; // eax
  __int16 result; // ax
  int v12; // ebp
  int v13; // eax
  _BYTE *v14; // esi
  int *v15; // edi
  int v16; // edx
  int v17; // ecx
  int v18; // ebx
  int v19; // eax
  _BYTE v20[1280]; // [esp+0h] [ebp-538h] BYREF
  int v21; // [esp+500h] [ebp-38h]
  int v22; // [esp+504h] [ebp-34h]
  int v23; // [esp+508h] [ebp-30h]
  int v24; // [esp+50Ch] [ebp-2Ch]
  int v25; // [esp+510h] [ebp-28h]
  int v26; // [esp+514h] [ebp-24h]
  int v27; // [esp+518h] [ebp-20h]
  unsigned __int8 v28; // [esp+51Ch] [ebp-1Ch]
  unsigned __int8 v29; // [esp+520h] [ebp-18h]
  char v30; // [esp+524h] [ebp-14h]

  v1 = a1 & 0x7FF;
  v2 = (_DWORD)off_9134C[v1] << 8;
  v26 = (dword_90B4C[v1] << 8) / (unsigned __int16)dword_93AD8;
  v3 = v2;
  v4 = 0;
  v30 = 0;
  v29 = 0;
  v5 = (unsigned __int16)dword_93AD8;
  v6 = v20;
  v25 = v3 / (unsigned __int16)dword_93AD8;
  v7 = 0;
  if ( (_WORD)dword_93AD8 )
  {
    do
    {
      LOBYTE(v23) = BYTE2(v4);
      *v6 = BYTE2(v7) - v30;
      v8 = v23;
      v23 = (unsigned __int8)v23 - v29;
      v28 = v8;
      v6 += 2;
      v30 = BYTE2(v7);
      *(v6 - 1) = v23;
      v29 = v28;
      v4 += v26;
      v7 += v25;
      --v5;
    }
    while ( v5 );
  }
  v9 = (-(dword_B5CD4 * dword_B5CFC) >> 16) + dword_B5D08;
  v10 = dword_B5CE4 - ((dword_B5CE8 * dword_B5CFC) >> 16);
  v21 = ((unsigned __int16)word_B5D38 << 15) - (v9 * v25 - v10 * v26);
  v27 = -(v26 * v9 + v25 * v10);
  result = dword_93ADC;
  v12 = dword_93ACC;
  v22 = (unsigned __int16)dword_93ADC;
  if ( (_WORD)dword_93ADC )
  {
    do
    {
      v13 = (int)(unsigned __int16)dword_93AD8 >> 2;
      v14 = v20;
      v23 = v27 >> 16;
      v15 = (int *)v12;
      v24 = v21 >> 16;
      v16 = dword_AE3D8;
      BYTE1(v18) = BYTE2(v27);
      v17 = v13;
      LOBYTE(v18) = BYTE2(v21);
      v18 = (unsigned __int16)v18;
      do
      {
        LOBYTE(v13) = *(_BYTE *)(v18 + v16);
        LOBYTE(v18) = *v14 + v18;
        BYTE1(v18) += v14[1];
        BYTE1(v13) = *(_BYTE *)(v18 + v16);
        LOBYTE(v18) = v14[2] + v18;
        BYTE1(v18) += v14[3];
        v19 = v13 << 16;
        LOBYTE(v19) = *(_BYTE *)(v18 + v16);
        LOBYTE(v18) = v14[4] + v18;
        BYTE1(v18) += v14[5];
        BYTE1(v19) = *(_BYTE *)(v18 + v16);
        LOBYTE(v18) = v14[6] + v18;
        BYTE1(v18) += v14[7];
        v13 = __ROL4__(v19, 16);
        *v15++ = v13;
        v14 += 8;
        --v17;
      }
      while ( v17 );
      result = v25;
      v12 += dword_93AD4;
      v21 -= v26;
      v27 += v25;
      --v22;
    }
    while ( v22 );
  }
  return result;
}
// 90B4C: using guessed type int dword_90B4C[256];
// 9134C: using guessed type void (*off_9134C[2])();
// 93ACC: using guessed type int dword_93ACC;
// 93AD4: using guessed type int dword_93AD4;
// 93AD8: using guessed type int dword_93AD8;
// 93ADC: using guessed type int dword_93ADC;
// AE3D8: using guessed type int dword_AE3D8;
// B5CD4: using guessed type int dword_B5CD4;
// B5CE4: using guessed type int dword_B5CE4;
// B5CE8: using guessed type int dword_B5CE8;
// B5CFC: using guessed type int dword_B5CFC;
// B5D08: using guessed type int dword_B5D08;
// B5D38: using guessed type __int16 word_B5D38;

//----- (000309D0) --------------------------------------------------------
int sub_309D0(int a1)
{
  int result; // eax

  if ( (word_12F02E & 1) != 0 )
  {
    dword_B5CA0 = dword_12EFF0 - 8 * a1;
    result = dword_12EFF0 - 8 * a1 + dword_12EFF4;
    sub_79495(result, 0, dword_12EFF0, (unsigned __int16)(8 * a1), (unsigned __int16)(5 * a1));
  }
  else
  {
    dword_B5CA0 = dword_12EFF0 - 16 * a1;
    result = dword_12EFF0 - 16 * a1 + dword_12EFF4;
    sub_79495(result, 0, dword_12EFF0, (unsigned __int16)(16 * a1), (unsigned __int16)(12 * a1));
  }
  return result;
}
// B5CA0: using guessed type int dword_B5CA0;
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00030A70) --------------------------------------------------------
int sub_30A70(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // eax
  unsigned __int16 v4; // bx
  int result; // eax
  int v6; // [esp-4h] [ebp-Ch]

  v1 = 40 - a1;
  if ( (word_12F02E & 1) != 0 )
  {
    v2 = dword_12EFF0 * (5 * v1 / 2) + 4 * v1;
    v3 = (unsigned __int16)(5 * a1);
    v4 = 8 * a1;
  }
  else
  {
    v2 = dword_12EFF0 * (12 * v1 / 2) + 8 * v1;
    v3 = (unsigned __int16)(12 * a1);
    v4 = 16 * a1;
  }
  v6 = v3;
  result = v2 + dword_12EFF4;
  dword_B5CA0 = v2;
  sub_79495(v2 + dword_12EFF4, 0, dword_12EFF0, v4, v6);
  return result;
}
// B5CA0: using guessed type int dword_B5CA0;
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00030B30) --------------------------------------------------------
void sub_30B30()
{
  int v0; // eax
  int v1; // ebp
  int v2; // ecx
  _BYTE *v3; // edi
  _BYTE *v4; // esi
  int v5; // edx
  int v6; // ebx
  _BYTE *v7; // ebp
  _BYTE *v8; // esi
  int v9; // edx
  int v10; // ecx
  _BYTE *v11; // edi
  int v12; // ebx
  int v13; // [esp+0h] [ebp-1Ch]
  int i; // [esp+4h] [ebp-18h]
  int v15; // [esp+8h] [ebp-14h]
  _BYTE *v16; // [esp+8h] [ebp-14h]

  if ( *(_BYTE *)(dword_AE400 + 8603) == 1 && !byte_90708 )
  {
    v13 = (int)(unsigned __int16)dword_93AD8 >> 2;
    v15 = dword_93ACC;
    v0 = (unsigned __int16)dword_93ADC / 2;
    v1 = dword_AE404;
    for ( i = v0; i; --i )
    {
      v2 = v13;
      v3 = (_BYTE *)v15;
      v4 = (_BYTE *)v1;
      v5 = 0;
      v6 = 0;
      do
      {
        LOBYTE(v6) = v4[2];
        LOBYTE(v5) = v3[2];
        LOBYTE(v0) = byte_B36A0[v5] + byte_B37A0[v6];
        LOBYTE(v6) = v4[3];
        LOBYTE(v5) = v3[3];
        BYTE1(v0) = byte_B39A0[v5] + byte_B34A0[v6];
        v0 <<= 16;
        LOBYTE(v6) = *v4;
        LOBYTE(v5) = *v3;
        LOBYTE(v0) = byte_B36A0[v5] + byte_B37A0[v6];
        LOBYTE(v6) = v4[1];
        LOBYTE(v5) = v3[1];
        BYTE1(v0) = byte_B39A0[v5] + byte_B34A0[v6];
        *(_DWORD *)v3 = v0;
        v3 += 4;
        v4 += 4;
        --v2;
      }
      while ( v2 );
      v7 = (_BYTE *)(dword_93AD4 + v1);
      v16 = (_BYTE *)(dword_93AD4 + v15);
      v8 = v7;
      v9 = 0;
      v10 = v13;
      v11 = v16;
      v12 = 0;
      do
      {
        LOBYTE(v12) = v8[2];
        LOBYTE(v9) = v11[2];
        LOBYTE(v0) = byte_B33A0[v9] + byte_B32A0[v12];
        LOBYTE(v12) = v8[3];
        LOBYTE(v9) = v11[3];
        BYTE1(v0) = byte_B38A0[v9] + byte_B35A0[v12];
        v0 <<= 16;
        LOBYTE(v12) = *v8;
        LOBYTE(v9) = *v11;
        LOBYTE(v0) = byte_B33A0[v9] + byte_B32A0[v12];
        LOBYTE(v12) = v8[1];
        LOBYTE(v9) = v11[1];
        BYTE1(v0) = byte_B38A0[v9] + byte_B35A0[v12];
        *(_DWORD *)v11 = v0;
        v11 += 4;
        v8 += 4;
        --v10;
      }
      while ( v10 );
      v1 = (int)&v7[dword_93AD4];
      v15 = (int)&v16[dword_93AD4];
      v0 = i - 1;
    }
  }
  if ( (word_12F02E & 1) != 0 )
  {
    if ( byte_90708 )
    {
      sub_79A1B((int)&unk_B3AA0);
      return;
    }
    if ( (word_12F02E & 1) != 0 )
    {
LABEL_20:
      sub_5CDA0();
      return;
    }
  }
  else
  {
    if ( *(_BYTE *)(dword_AE400 + 8606) && *(_BYTE *)(dword_AE400 + 8603) )
    {
      sub_79B2D();
      return;
    }
    if ( byte_90708 )
    {
      sub_79906((int)&unk_B3AA0);
      return;
    }
    if ( (word_12F02E & 1) != 0 )
      goto LABEL_20;
  }
  sub_599B0(480);
}
// 90708: using guessed type char byte_90708;
// 93ACC: using guessed type int dword_93ACC;
// 93AD4: using guessed type int dword_93AD4;
// 93AD8: using guessed type int dword_93AD8;
// 93ADC: using guessed type int dword_93ADC;
// AE400: using guessed type int dword_AE400;
// AE404: using guessed type int dword_AE404;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00030D30) --------------------------------------------------------
int sub_30D30(__int16 a1)
{
  _WORD *v1; // eax
  __int16 v3; // si

  if ( (unsigned __int16)sub_61AB0() )
    return 0;
  v1 = (_WORD *)(16 * *(unsigned __int16 *)(dword_12F080 + 16) + *(unsigned __int16 *)(dword_12F080 + 14));
  if ( *v1 == 0xFFFF )
    return 0;
  while ( a1 != *v1 )
  {
    v3 = v1[1];
    ++v1;
    if ( v3 == -1 )
      return 0;
  }
  return 1;
}
// 12F080: using guessed type int dword_12F080;

//----- (00030D90) --------------------------------------------------------
char sub_30D90(int a1, int a2, int a3, __int16 a4, int a5, int a6, int a7, int a8)
{
  unsigned __int16 v8; // ax
  unsigned __int16 v9; // cx
  int v10; // edx
  int v11; // ecx
  int v12; // ebx
  int v13; // edx
  int v14; // ecx
  int v15; // ebx
  int v16; // edx
  int v17; // ecx
  int v18; // ebx
  int v19; // edx
  int v20; // edi
  int v21; // edx
  int v22; // esi
  int v23; // ebx
  int v24; // eax
  int v25; // esi
  int v26; // ecx
  int v27; // esi
  int v28; // eax
  char *v29; // ebx
  char v30; // dl
  int v31; // eax
  int v32; // esi
  int v33; // ebx
  unsigned __int8 *v34; // ecx
  int i; // eax
  _BYTE *v36; // edi
  int v37; // edx
  int v38; // esi
  _BYTE *v39; // ebx
  unsigned __int8 *v40; // ecx
  _BOOL1 j; // zf
  int v42; // eax
  _BYTE *k; // ebx
  char v44; // dl
  int v45; // edx
  int v46; // esi
  int v47; // ebx
  int v48; // eax
  __int64 v49; // rax
  int v50; // eax
  _BYTE *v51; // edi
  _BYTE *v52; // esi
  int v53; // edx
  int v54; // ebx
  int v55; // ecx
  _BYTE *v56; // edi
  _BYTE *v57; // esi
  int v58; // edx
  int v59; // ebx
  int v60; // ecx
  _BYTE *v61; // edi
  int v62; // esi
  int v63; // ecx
  int v64; // eax
  int v65; // ebx
  int v66; // edx
  int v68; // [esp+0h] [ebp-24h]
  int v69; // [esp+4h] [ebp-20h]
  int v70; // [esp+8h] [ebp-1Ch]
  int v71; // [esp+Ch] [ebp-18h]
  char v72; // [esp+10h] [ebp-14h]
  int v73; // [esp+14h] [ebp-10h]
  int v74; // [esp+18h] [ebp-Ch]
  int v75; // [esp+1Ch] [ebp-8h]
  unsigned __int8 v76; // [esp+20h] [ebp-4h]
  int v77; // [esp+3Ch] [ebp+18h]
  int v78; // [esp+40h] [ebp+1Ch]

  LOBYTE(v8) = BYTE1(a2);
  HIBYTE(v8) = BYTE1(a3);
  if ( (unsigned __int8)a2 < 0x80u )
    LOBYTE(v8) = BYTE1(a2) - 1;
  if ( (unsigned __int8)a3 < 0x80u )
    HIBYTE(v8) = BYTE1(a3) - 1;
  v9 = v8;
  LOBYTE(v8) = v8 + 2;
  v10 = (unsigned __int8)byte_DC1E0[v9];
  v11 = (unsigned __int8)byte_DC1E0[v8];
  HIBYTE(v8) += 2;
  v12 = v10 - v11;
  v13 = v11 + v10;
  v14 = (unsigned __int8)byte_DC1E0[v8];
  LOBYTE(v8) = v8 - 2;
  v15 = v12 - v14;
  v16 = v13 - v14;
  v17 = (unsigned __int8)byte_DC1E0[v8];
  v18 = 2 * (v17 + v15);
  v19 = 2 * (v16 - v17);
  if ( v18 <= 100 )
  {
    if ( v18 < -100 )
      v18 = -100;
  }
  else
  {
    v18 = 100;
  }
  if ( v19 <= 100 )
  {
    if ( v19 < -100 )
      v19 = -100;
  }
  else
  {
    v19 = 100;
  }
  dword_90710 += (v18 - dword_90710) >> 3;
  dword_90714 += (v19 - dword_90714) >> 3;
  v77 = dword_90710 + a2;
  v78 = dword_90714 + a3;
  v20 = a4 & 0x7FF;
  if ( *(_BYTE *)(dword_AE400 + 8606) && *(_BYTE *)(dword_AE400 + 8603) && dword_12EFF0 == 640 )
  {
    sub_79495(
      dword_12EFF4,
      0,
      2 * dword_12EFF0,
      (unsigned __int16)(dword_12EFF0 / 2 - 8),
      (unsigned __int16)(dword_12EFF8 / 2 - 40));
    v21 = dword_90B4C[v20];
    dword_9070C = 20;
    v22 = 5 * (_DWORD)off_9134C[v20];
    dword_902B0 = -5;
    v23 = (__int16)((5 * v21) >> 14);
    LOWORD(v22) = v22 >> 14;
    sub_2A700(v23, v77 - v22, v78 - v23, v20, a5, a6, a7, a8);
    sub_79495(dword_12EFF4 + dword_12EFF0 / 2, 0, 0, 0, 0);
    dword_902B0 = 5;
    sub_2A700(v78 + v23, v77 + v22, v78 + v23, a4 & 0x7FF, a5, a6, a7, a8);
    dword_902B0 = 0;
    LOBYTE(v24) = dword_12EFF0;
    sub_79495(dword_12EFF4, 0, dword_12EFF0, (unsigned __int16)dword_12EFF0, (unsigned __int16)dword_12EFF8);
  }
  else if ( *(_BYTE *)(dword_AE400 + 8603) != 2 || *(_BYTE *)(dword_AE400 + 8606) )
  {
    if ( *(_BYTE *)(dword_AE400 + 8603) != 1 || *(_BYTE *)(dword_AE400 + 8606) )
    {
      v72 = *(_BYTE *)(dword_AE400 + 8604);
      if ( word_12F02E == 1 )
      {
        v48 = dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8);
        if ( !*(_BYTE *)(v48 + 14421) )
        {
          if ( *(_BYTE *)(dword_AE408 + 8) )
          {
            if ( dword_AE404 )
            {
              if ( *(_BYTE *)(dword_AE400 + 8600) == 40 )
              {
                v49 = *(__int16 *)(dword_AE400 + 164 * *(unsigned __int16 *)(v48 + 13333) + 29921);
                if ( (int)((HIDWORD(v49) ^ v49) - HIDWORD(v49)) > 80 )
                  *(_BYTE *)(dword_AE400 + 8604) = 1;
              }
            }
          }
        }
      }
      if ( *(_BYTE *)(dword_AE400 + 8604) && dword_AE404 )
      {
        v73 = dword_93ACC;
        sub_79495(dword_AE404, 0, 0, 0, 0);
        sub_2A700(a7, v77, v78, v20, a5, a6, a7, a8);
        sub_79495(v73, 0, 0, 0, 0);
        v70 = (int)(unsigned __int16)dword_93AD8 >> 2;
        v68 = dword_93AD4 - (unsigned __int16)dword_93AD8;
        v69 = (unsigned __int16)dword_93ADC;
        HIWORD(v50) = HIWORD(dword_AE400);
        if ( *(_BYTE *)(dword_AE400 + 8604) == 1 )
        {
          v51 = (_BYTE *)v73;
          v52 = (_BYTE *)dword_AE404;
          HIWORD(v53) = 0;
          HIWORD(v54) = 0;
          do
          {
            v55 = v70;
            do
            {
              LOBYTE(v54) = v52[2];
              BYTE1(v54) = v51[2];
              LOBYTE(v53) = v52[3];
              LOBYTE(v50) = byte_BB934[v54];
              BYTE1(v53) = v51[3];
              BYTE1(v50) = byte_BB934[v53];
              v50 <<= 16;
              LOBYTE(v54) = *v52;
              BYTE1(v54) = *v51;
              LOBYTE(v53) = v52[1];
              LOBYTE(v50) = byte_BB934[v54];
              BYTE1(v53) = v51[1];
              BYTE1(v50) = byte_BB934[v53];
              *(_DWORD *)v51 = v50;
              v51 += 4;
              v52 += 4;
              --v55;
            }
            while ( v55 );
            HIWORD(v50) = HIWORD(v68);
            v52 += v68;
            v51 += v68;
            --v69;
          }
          while ( v69 );
        }
        else
        {
          v56 = (_BYTE *)v73;
          v57 = (_BYTE *)dword_AE404;
          HIWORD(v58) = 0;
          HIWORD(v59) = 0;
          do
          {
            v60 = v70;
            do
            {
              BYTE1(v59) = v57[2];
              LOBYTE(v59) = v56[2];
              BYTE1(v58) = v57[3];
              LOBYTE(v50) = byte_BB934[v59];
              LOBYTE(v58) = v56[3];
              BYTE1(v50) = byte_BB934[v58];
              v50 <<= 16;
              BYTE1(v59) = *v57;
              LOBYTE(v59) = *v56;
              BYTE1(v58) = v57[1];
              LOBYTE(v50) = byte_BB934[v59];
              LOBYTE(v58) = v56[1];
              BYTE1(v50) = byte_BB934[v58];
              *(_DWORD *)v56 = v50;
              v56 += 4;
              v57 += 4;
              --v60;
            }
            while ( v60 );
            HIWORD(v50) = HIWORD(v68);
            v57 += v68;
            v56 += v68;
            --v69;
          }
          while ( v69 );
        }
      }
      else
      {
        sub_2A700(a5, v77, v78, v20, a5, a6, a7, a8);
        if ( *(_BYTE *)(dword_AE400 + 8605) )
        {
          v74 = dword_93ACC;
          v75 = (unsigned __int16)dword_93ADC - 1;
          if ( (unsigned __int16)dword_93ADC != 1 )
          {
            do
            {
              v61 = (_BYTE *)v74;
              v62 = dword_93AD4;
              v63 = (unsigned __int16)dword_93AD8 - 1;
              HIWORD(v64) = 0;
              HIWORD(v65) = 0;
              HIWORD(v66) = 0;
              do
              {
                LOBYTE(v64) = *v61;
                LOBYTE(v65) = v61[1];
                BYTE1(v64) = v61[v62];
                LOBYTE(v66) = byte_BB934[v64];
                BYTE1(v65) = v61[v62 + 1];
                BYTE1(v66) = byte_BB934[v65];
                *v61++ = byte_BB934[v66];
                --v63;
              }
              while ( v63 );
              v74 += dword_93AD4;
              --v75;
            }
            while ( v75 );
          }
        }
      }
      LOBYTE(v24) = dword_AE400;
      *(_BYTE *)(dword_AE400 + 8604) = v72;
    }
    else
    {
      v45 = dword_90B4C[v20];
      dword_9070C = 20;
      v46 = 5 * (_DWORD)off_9134C[v20];
      dword_902B0 = dword_93AD4 / 0x28u;
      v47 = (20 * v45) >> 16;
      LOWORD(v46) = v46 >> 14;
      sub_2A700(v47, v46 + v77, v47 + v78, v20, a5, a6, a7, a8);
      v71 = dword_93ACC;
      sub_79495(dword_AE404, 0, 0, 0, 0);
      //fix dword_902B0 = -(dword_93AD4 / 0x28u);
      LOBYTE(v24) = sub_2A700(v47, v77 - v46, v78 - v47, v20, a5, a6, a7, a8);
      sub_79495(v71, 0, 0, 0, 0);
      dword_902B0 = 0;
    }
  }
  else
  {
    v25 = dword_93ACC;
    sub_79495(dword_AE404, 0, 0, 0, 0);
    sub_2A700(v77, v77, v78, v20, a5, a6, a7, a8);
    sub_79495(v25, 0, 0, 0, 0);
    v26 = (unsigned __int16)dword_93ADC;
    v27 = dword_93ACC + (unsigned __int16)dword_93AD8 / 2 - 64;
    if ( (_WORD)dword_93ADC )
    {
      do
      {
        word_12C1E0 = 9377 * word_12C1E0 + 9439;
        v28 = 64;
        v29 = (char *)off_9359C + 256 * (v26 & 0x1F) + (unsigned __int16)word_12C1E0 % 7u;
        do
        {
          ++v27;
          v30 = *v29++;
          *(_BYTE *)(v27 - 1) = v30;
          --v28;
        }
        while ( v28 );
        v27 += dword_93AD4 - 64;
        --v26;
      }
      while ( v26 );
    }
    v31 = (unsigned __int16)dword_93AD8 / 2;
    v32 = (unsigned __int16)dword_93ADC;
    v33 = v31 + dword_93ACC;
    v34 = (unsigned __int8 *)(v31 + dword_AE404);
    if ( (_WORD)dword_93ADC )
    {
      do
      {
        for ( i = (unsigned __int16)dword_93AD8 / 2; i; --i )
        {
          v36 = (_BYTE *)(v33 - *v34);
          ++v33;
          ++v34;
          *(_BYTE *)(v33 - 1) = *v36;
        }
        v37 = dword_93AD4 - (unsigned __int16)dword_93AD8 / 2;
        v33 += v37;
        v34 += v37;
        --v32;
      }
      while ( v32 );
    }
    v24 = (unsigned __int16)dword_93AD8 / 2;
    v38 = (unsigned __int16)dword_93ADC;
    v39 = (_BYTE *)(v24 + dword_93ACC);
    v40 = (unsigned __int8 *)(v24 + dword_AE404);
    for ( j = (unsigned __int16)dword_93ADC == 0; !j; j = v38 == 0 )
    {
      v76 = *v40;
      v42 = (unsigned __int16)dword_93AD8 / 2 - *v40;
      for ( k = &v39[-*v40]; v42; --v42 )
      {
        --k;
        v44 = k[*--v40];
        *k = v44;
      }
      v24 = dword_93AD4 + (unsigned __int16)dword_93AD8 / 2;
      v39 = &k[v24];
      v40 = &v40[v24 - v76];
      --v38;
    }
  }
  return v24;
}
// 902B0: using guessed type int dword_902B0;
// 9070C: using guessed type int dword_9070C;
// 90710: using guessed type int dword_90710;
// 90714: using guessed type int dword_90714;
// 90B4C: using guessed type int dword_90B4C[256];
// 9134C: using guessed type void (*off_9134C[2])();
// 9359C: using guessed type void *off_9359C;
// 93ACC: using guessed type int dword_93ACC;
// 93AD4: using guessed type int dword_93AD4;
// 93AD8: using guessed type int dword_93AD8;
// 93ADC: using guessed type int dword_93ADC;
// AE400: using guessed type int dword_AE400;
// AE404: using guessed type int dword_AE404;
// AE408: using guessed type int dword_AE408;
// 12C1E0: using guessed type __int16 word_12C1E0;
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12EFF8: using guessed type int dword_12EFF8;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (000315C0) --------------------------------------------------------
int sub_315C0()
{
  int result; // eax

  if ( (word_12F02E & 1) != 0 )
    result = sub_61B90((unsigned __int8 *)dword_AE428);
  else
    result = sub_61C30((unsigned __int8 *)dword_AE428);
  byte_90708 = 0;
  return result;
}
// 90708: using guessed type char byte_90708;
// AE428: using guessed type int dword_AE428;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00031600) --------------------------------------------------------
void sub_31600()
{
  __int16 v0; // bx
  _WORD *v1; // esi
  _WORD *v2; // edi
  int v3; // ecx
  _BYTE *v4; // ebx
  char v5; // bp
  int v6; // eax
  int v7; // ecx
  char *v8; // esi
  char *v9; // ebx
  _BYTE *v10; // edx
  char v11; // al
  char v12; // al
  char v13; // al
  int v14; // edi
  char v15; // al
  int v16; // ecx
  char *v17; // esi
  char *v18; // ebx
  _BYTE *v19; // edx
  char v20; // al
  char v21; // al
  char v22; // al
  int v23; // edi
  char v24; // al
  int v25; // ecx
  char *v26; // esi
  char *v27; // ebx
  _BYTE *v28; // edx
  char v29; // al
  char v30; // al
  char v31; // al
  int v32; // edi
  char v33; // al
  int v34; // esi
  char *v35; // ecx
  char *v36; // ebx
  _BYTE *v37; // edx
  char v38; // al
  char v39; // al
  char v40; // al
  int v41; // edi
  char v42; // al
  unsigned __int8 *v43; // edx
  char v44; // ch
  int v45; // ebx
  char v46; // cl
  char v47; // al
  _BYTE *v48; // edx
  unsigned __int8 v49[768]; // [esp+0h] [ebp-324h] BYREF
  int v50; // [esp+300h] [ebp-24h]
  int v51; // [esp+304h] [ebp-20h]
  int v52; // [esp+308h] [ebp-1Ch]
  char v53; // [esp+30Ch] [ebp-18h]
  char v54; // [esp+310h] [ebp-14h]

  if ( *(_BYTE *)(dword_AE400 + 8603) && dword_93AD4 == 640 )
    sub_5B500();
  if ( dword_AE404 && !*(_BYTE *)(dword_AE400 + 8606) )
  {
    if ( dword_12EFF0 == 320 )
      v0 = 270;
    else
      v0 = 273;
    if ( sub_30D30(v0) )
    {
      v1 = (uint16*)&unk_B3AA0;
      v2 = (uint16*)&unk_B3CA0;
      sub_619B8(v0);
      v3 = 256;
      byte_90708 = 1;
      v4 = (_BYTE *)dword_AE428;
      dword_12EFF0 = dword_93AD4;
      do
      {
        *v1 = (*v4 & 0x3E) << 10;
        v5 = (3 * (unsigned __int8)v4[1]
            - (__CFSHL__((3 * (unsigned __int8)v4[1]) >> 31, 2)
             + 4 * ((3 * (unsigned __int8)v4[1]) >> 31))) >> 2;
        v6 = 3 * (unsigned __int8)v4[2];
        v4 += 3;
        ++v2;
        ++v1;
        *(v2 - 1) = 32 * (v5 & 0x3F) + ((((v6 - (__CFSHL__(v6 >> 31, 2) + 4 * (v6 >> 31))) >> 2) & 0x3E) >> 1);
        --v3;
      }
      while ( v3 );
    }
    else
    {
      v7 = 256;
      v8 = (char*)&byte_B37A0;
      v9 = (char*)&byte_B36A0;
      v10 = (_BYTE *)dword_AE428;
      do
      {
        v11 = *v10 + 3;
        if ( v11 > 63 )
          v11 = 63;
        *v8 = 4 * (v11 & 0x38);
        v12 = v10[1] - 3;
        if ( v12 < 0 )
          v12 = 0;
        v52 = (v12 & 0x38) >> 1;
        *v9 = v52;
        v13 = v10[2] + 3;
        if ( v13 > 63 )
          v13 = 63;
        v10 += 3;
        v14 = (v13 & 0x30) >> 4;
        v15 = *v9++;
        ++v8;
        *(v9 - 1) = v14 + v15;
        --v7;
      }
      while ( v7 );
      v16 = 256;
      v17 = (char*)&byte_B35A0;
      v18 = (char*)&byte_B38A0;
      v19 = (_BYTE *)dword_AE428;
      do
      {
        v20 = *v19 + 1;
        if ( v20 > 63 )
          v20 = 63;
        *v17 = 4 * (v20 & 0x38);
        v21 = v19[1] - 1;
        if ( v21 < 0 )
          v21 = 0;
        v52 = (v21 & 0x38) >> 1;
        *v18 = v52;
        v22 = v19[2] + 1;
        if ( v22 > 63 )
          v22 = 63;
        v19 += 3;
        v23 = (v22 & 0x30) >> 4;
        v24 = *v18++;
        ++v17;
        *(v18 - 1) = v23 + v24;
        --v16;
      }
      while ( v16 );
      v25 = 256;
      v26 = (char*)&byte_B34A0;
      v27 = (char*)&byte_B39A0;
      v28 = (_BYTE *)dword_AE428;
      do
      {
        v29 = *v28 - 1;
        if ( v29 < 0 )
          v29 = 0;
        *v26 = 4 * (v29 & 0x38);
        v30 = v28[1] + 1;
        if ( v30 > 63 )
          v30 = 63;
        v52 = (v30 & 0x38) >> 1;
        *v27 = v52;
        v31 = v28[2] - 1;
        if ( v31 < 0 )
          v31 = 0;
        v28 += 3;
        v32 = (v31 & 0x30) >> 4;
        v33 = *v27++;
        ++v26;
        *(v27 - 1) = v32 + v33;
        --v25;
      }
      while ( v25 );
      v34 = 256;
      v35 = (char*)&byte_B32A0;
      v36 = (char*)&byte_B33A0;
      v37 = (_BYTE *)dword_AE428;
      do
      {
        v38 = *v37 - 3;
        if ( v38 < 0 )
          v38 = 0;
        *v35 = 4 * (v38 & 0x38);
        v39 = v37[1] + 3;
        if ( v39 > 63 )
          v39 = 63;
        v52 = (v39 & 0x38) >> 1;
        *v36 = v52;
        v40 = v37[2] - 3;
        if ( v40 < 0 )
          v40 = 0;
        v37 += 3;
        v41 = (v40 & 0x30) >> 4;
        v42 = *v36++;
        ++v35;
        *(v36 - 1) = v41 + v42;
        --v34;
      }
      while ( v34 );
      v50 = 0;
      v43 = v49;
      v53 = 0;
      do
      {
        v51 = 0;
        v44 = v53;
        v54 = 0;
        do
        {
          v45 = 0;
          v46 = v54;
          v47 = 0;
          do
          {
            v48 = v43 + 2;
            *(v48 - 2) = v44;
            *(v48 - 1) = v46;
            ++v45;
            *v48 = v47;
            v43 = v48 + 1;
            v47 += 14;
          }
          while ( v45 < 4 );
          v54 += 7;
          ++v51;
        }
        while ( v51 < 8 );
        v53 += 9;
        ++v50;
      }
      while ( v50 < 8 );
      sub_319A0(v49);
    }
  }
}
// 90708: using guessed type char byte_90708;
// 93AD4: using guessed type int dword_93AD4;
// AE400: using guessed type int dword_AE400;
// AE404: using guessed type int dword_AE404;
// AE428: using guessed type int dword_AE428;
// B32A0: using guessed type char byte_B32A0;
// B33A0: using guessed type char byte_B33A0;
// B34A0: using guessed type char byte_B34A0;
// B35A0: using guessed type char byte_B35A0;
// B36A0: using guessed type char byte_B36A0;
// B37A0: using guessed type char byte_B37A0;
// B38A0: using guessed type char byte_B38A0;
// B39A0: using guessed type char byte_B39A0;
// 12EFF0: using guessed type int dword_12EFF0;

//----- (000319A0) --------------------------------------------------------
unsigned __int8 sub_319A0(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // ebx
  int v2; // ecx
  unsigned __int8 v3; // al
  unsigned __int8 *v4; // ebx
  unsigned __int8 v5; // al
  unsigned __int8 result; // al

  v1 = a1;
  __outbyte(0x3C6u, 0xFFu);
  v2 = 0;
  do
  {
    __outbyte(0x3C8u, v2);
    v3 = *v1;
    v4 = v1 + 1;
    __outbyte(0x3C9u, v3);
    v5 = *v4++;
    __outbyte(0x3C9u, v5);
    ++v2;
    result = *v4;
    v1 = v4 + 1;
    __outbyte(0x3C9u, result);
  }
  while ( (unsigned __int16)v2 < 0x100u );
  if ( byte_9AD08 )
    return sub_5B310(2, a1);
  return result;
}
// 9AD08: using guessed type char byte_9AD08;

//----- (00031A00) --------------------------------------------------------
unsigned __int8 sub_31A00()
{
  unsigned __int8 result; // al
  unsigned __int8 *v1; // [esp-4h] [ebp-8h]

  result = dword_AE400;
  if ( *(_BYTE *)(dword_AE400 + 8603) )
  {
    if ( *(_BYTE *)(dword_AE400 + 8606) )
    {
      if ( dword_93AD4 == 640 )
        sub_5B560();
    }
    byte_90754 = *(_BYTE *)(dword_AE400 + 8603);
    sub_315C0();
    v1 = (unsigned __int8 *)dword_AE428;
    *(_BYTE *)(dword_AE400 + 8603) = 0;
    return sub_319A0(v1);
  }
  return result;
}
// 90754: using guessed type char byte_90754;
// 93AD4: using guessed type int dword_93AD4;
// AE400: using guessed type int dword_AE400;
// AE428: using guessed type int dword_AE428;

//----- (00031A60) --------------------------------------------------------
void sub_31A60()
{
  char v0; // dl

  v0 = byte_90754;
  *(_BYTE *)(dword_AE400 + 8603) = byte_90754;
  if ( v0 == 1 )
    sub_31600();
  byte_90754 = 0;
}
// 90754: using guessed type char byte_90754;
// AE400: using guessed type int dword_AE400;

//----- (00031AA0) --------------------------------------------------------
int sub_31AA0(int a1)
{
  word_12C1E0 = *(_WORD *)(a1 + 4);
  *(_DWORD *)(dword_AE400 + 4) = *(_DWORD *)(a1 + 4);
  if ( (void (*)())sub_3EEA0(aCCarpetCdSaveS, byte_DC1E0) != sub_10000 )
  {
    sub_725C8(word_12C1E0, *(_WORD *)(a1 + 8), *(_WORD *)(a1 + 12));
    sub_32A50();
  }
  memset(word_10C1E0, 0, (size_t)&loc_1FFFE + 2);
  sub_32AE0(*(_DWORD *)(a1 + 20), *(_WORD *)(a1 + 24));
  sub_33500();
  sub_320A0(*(_WORD *)(a1 + 32));
  sub_32D00(*(_WORD *)(a1 + 36), *(_WORD *)(a1 + 40));
  sub_32300();
  sub_32EB0(*(_WORD *)(a1 + 36), *(_WORD *)(a1 + 40));
  sub_33180(*(_WORD *)(a1 + 44));
  sub_31FA0();
  memset(byte_CC1E0, 0, (size_t)sub_10000);
  sub_31BB0();
  sub_31EC0();
  sub_32560();
  sub_31D40();
  return sub_329C0();
}
// 10000: using guessed type void sub_10000();
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// AE400: using guessed type int dword_AE400;
// 10C1E0: using guessed type __int16 word_10C1E0[7953];
// 12C1E0: using guessed type __int16 word_12C1E0;

//----- (00031BB0) --------------------------------------------------------
unsigned __int16 sub_31BB0()
{
  unsigned __int16 result; // ax
  int v1; // edx
  unsigned __int8 v2; // dl
  unsigned __int8 v3; // dh
  unsigned __int8 v4; // ch
  unsigned __int8 v5; // cl
  int v6; // ebx
  unsigned __int8 v7; // cl
  int v8; // ebx
  unsigned __int8 v9; // cl
  int v10; // ebx
  unsigned __int8 v11; // cl
  int v12; // ebx
  unsigned __int8 v13; // cl
  int v14; // ebx
  unsigned __int8 v15; // cl
  int v16; // ebx
  unsigned __int8 v17; // cl
  int v18; // ebx
  unsigned __int8 v19; // cl
  unsigned int v20; // ebx
  unsigned int v21; // ebx
  unsigned __int8 v22; // dl

  result = 0;
  do
  {
    while ( 1 )
    {
      v1 = result;
      if ( (byte_FC1E0[result] & 7) == 0 )
        goto LABEL_44;
      --HIBYTE(result);
      v2 = byte_DC1E0[v1];
      v3 = v2;
      v4 = v2;
      v5 = byte_DC1E0[result];
      v6 = v5;
      if ( v5 > v2 )
        v2 = byte_DC1E0[result];
      if ( v5 < v3 )
        v3 = byte_DC1E0[result];
      LOBYTE(result) = result + 1;
      v7 = byte_DC1E0[result];
      v8 = v7 + v6;
      if ( v7 > v2 )
        v2 = byte_DC1E0[result];
      if ( v7 < v3 )
        v3 = byte_DC1E0[result];
      ++HIBYTE(result);
      v9 = byte_DC1E0[result];
      v10 = v9 + v8;
      if ( v9 > v2 )
        v2 = byte_DC1E0[result];
      if ( v9 < v3 )
        v3 = byte_DC1E0[result];
      ++HIBYTE(result);
      v11 = byte_DC1E0[result];
      v12 = v11 + v10;
      if ( v11 > v2 )
        v2 = byte_DC1E0[result];
      if ( v11 < v3 )
        v3 = byte_DC1E0[result];
      LOBYTE(result) = result - 1;
      v13 = byte_DC1E0[result];
      v14 = v13 + v12;
      if ( v13 > v2 )
        v2 = byte_DC1E0[result];
      if ( v13 < v3 )
        v3 = byte_DC1E0[result];
      LOBYTE(result) = result - 1;
      v15 = byte_DC1E0[result];
      v16 = v15 + v14;
      if ( v15 > v2 )
        v2 = byte_DC1E0[result];
      if ( v15 < v3 )
        v3 = byte_DC1E0[result];
      --HIBYTE(result);
      v17 = byte_DC1E0[result];
      v18 = v17 + v16;
      if ( v17 > v2 )
        v2 = byte_DC1E0[result];
      if ( v17 < v3 )
        v3 = byte_DC1E0[result];
      --HIBYTE(result);
      v19 = byte_DC1E0[result];
      v20 = v19 + v18;
      if ( v19 > v2 )
        v2 = byte_DC1E0[result];
      if ( v19 < v3 )
        v3 = byte_DC1E0[result];
      LOBYTE(result) = result + 1;
      v21 = v20 >> 3;
      ++HIBYTE(result);
      if ( (unsigned __int8)(v4 - v3) > 4u )
        break;
      v22 = v2 - v4;
      if ( v22 <= 4u )
        goto LABEL_44;
      if ( v22 <= 0xAu )
      {
        byte_DC1E0[result] = (v21 + v4) >> 1;
        goto LABEL_44;
      }
      byte_DC1E0[result++] = v21;
      if ( !result )
        return result;
    }
    if ( (unsigned __int8)(v4 - v3) <= 0xAu )
      LOBYTE(v21) = (v21 + v4) >> 1;
    byte_DC1E0[result] = v21;
LABEL_44:
    ++result;
  }
  while ( result );
  return result;
}

//----- (00031D40) --------------------------------------------------------
unsigned __int16 sub_31D40()
{
  unsigned __int16 result; // ax
  _BOOL1 v1; // dl
  unsigned __int16 v2; // bx
  char v3; // dl
  unsigned __int16 v4; // bx
  char v5; // dl
  unsigned __int16 v6; // bx
  char v7; // dl
  unsigned __int16 v8; // bx
  char v9; // dl
  unsigned __int16 v10; // bx
  char v11; // dl
  unsigned __int16 v12; // bx
  char v13; // dl
  unsigned __int16 v14; // dx
  unsigned __int16 v15; // bx
  unsigned __int16 v16; // bx

  result = 0;
  do
  {
    byte_FC1E0[result] &= ~8u;
    if ( !byte_DC1E0[result] )
    {
      --HIBYTE(result);
      v1 = byte_DC1E0[result] != 0;
      LOBYTE(result) = result + 1;
      v2 = result;
      ++HIBYTE(result);
      v3 = (byte_DC1E0[v2] != 0) + v1;
      v4 = result;
      ++HIBYTE(result);
      v5 = (byte_DC1E0[v4] != 0) + v3;
      v6 = result;
      LOBYTE(result) = result - 1;
      v7 = (byte_DC1E0[v6] != 0) + v5;
      v8 = result;
      LOBYTE(result) = result - 1;
      v9 = (byte_DC1E0[v8] != 0) + v7;
      v10 = result;
      --HIBYTE(result);
      v11 = (byte_DC1E0[v10] != 0) + v9;
      v12 = result;
      --HIBYTE(result);
      v13 = (byte_DC1E0[v12] != 0) + v11;
      LOBYTE(v12) = byte_DC1E0[result] != 0;
      LOBYTE(result) = result + 1;
      ++HIBYTE(result);
      if ( !((_BYTE)v12 + v13) )
      {
        v14 = result;
        LOBYTE(result) = result - 1;
        v15 = result;
        --HIBYTE(result);
        LOBYTE(v14) = (byte_CC1E0[v15] != 0) + (byte_CC1E0[v14] != 0);
        v16 = result;
        LOBYTE(result) = result + 1;
        LOBYTE(v14) = (byte_CC1E0[result] != 0) + (byte_CC1E0[v16] != 0) + v14;
        ++HIBYTE(result);
        if ( !(_BYTE)v14 )
          byte_FC1E0[result] |= 8u;
      }
    }
    ++result;
  }
  while ( result );
  return result;
}

//----- (00031EC0) --------------------------------------------------------
unsigned __int16 sub_31EC0()
{
  unsigned __int16 result; // ax
  unsigned __int16 v1; // cx
  char v2; // dh
  unsigned __int8 v3; // dl
  int v4; // ecx
  char v5; // bl
  char v6; // bh
  unsigned __int8 v7; // cl
  char v8; // bh
  char v9; // bh
  unsigned __int16 v10; // cx
  unsigned __int16 v11; // cx
  unsigned __int16 v12; // cx
  unsigned __int16 v13; // cx

  result = 0;
  do
  {
    v1 = result;
    v2 = 0;
    LOBYTE(result) = result + 1;
    v3 = byte_DC1E0[v1];
    v4 = v1;
    LOWORD(v4) = result;
    v5 = 0;
    v6 = byte_FC1E0[result];
    if ( v6 )
    {
      if ( v6 == 4 )
        v2 = 1;
    }
    else
    {
      v7 = byte_DC1E0[v4];
      v5 = 1;
      if ( v7 < v3 )
        v3 = v7;
    }
    ++HIBYTE(result);
    v8 = byte_FC1E0[result];
    if ( v8 )
    {
      if ( v8 == 4 )
        ++v2;
    }
    else
    {
      ++v5;
      if ( (unsigned __int8)byte_DC1E0[result] < v3 )
        v3 = byte_DC1E0[result];
    }
    LOBYTE(result) = result - 1;
    v9 = byte_FC1E0[result];
    if ( v9 )
    {
      if ( v9 == 4 )
        ++v2;
    }
    else
    {
      ++v5;
      if ( (unsigned __int8)byte_DC1E0[result] < v3 )
        v3 = byte_DC1E0[result];
    }
    --HIBYTE(result);
    if ( v2 && v5 && !v3 )
    {
      v10 = result;
      LOBYTE(result) = result + 1;
      byte_DC1E0[v10] = 0;
      v11 = result;
      ++HIBYTE(result);
      byte_DC1E0[v11] = 0;
      v12 = result;
      LOBYTE(result) = result - 1;
      byte_DC1E0[v12] = 0;
      v13 = result;
      --HIBYTE(result);
      byte_DC1E0[v13] = 0;
    }
    ++result;
  }
  while ( result );
  return result;
}

//----- (00031FA0) --------------------------------------------------------
unsigned __int16 sub_31FA0()
{
  unsigned __int16 result; // ax
  unsigned __int16 v1; // dx
  unsigned __int16 v2; // bx
  char v3; // cl
  char v4; // dh
  unsigned __int16 v5; // bx
  unsigned __int16 v6; // bx
  unsigned __int16 v7; // bx
  unsigned __int16 v8; // bx
  unsigned __int16 v9; // bx
  char v10; // bl
  unsigned __int16 v11; // ax

  result = 0;
  do
  {
    --HIBYTE(result);
    v1 = result;
    LOBYTE(result) = result + 1;
    v2 = result;
    ++HIBYTE(result);
    v3 = byte_FC1E0[v2];
    v4 = byte_FC1E0[v1];
    v5 = result;
    ++HIBYTE(result);
    LOBYTE(v1) = (v4 == byte_FC1E0[v5]) + (v4 == v3);
    v6 = result;
    LOBYTE(result) = result - 1;
    LOBYTE(v1) = (v4 == byte_FC1E0[v6]) + v1;
    v7 = result;
    LOBYTE(result) = result - 1;
    LOBYTE(v1) = (v4 == byte_FC1E0[v7]) + v1;
    v8 = result;
    --HIBYTE(result);
    LOBYTE(v1) = (v4 == byte_FC1E0[v8]) + v1;
    v9 = result;
    --HIBYTE(result);
    v10 = (v4 == byte_FC1E0[result]) + (v4 == byte_FC1E0[v9]) + v1;
    LOBYTE(result) = result + 1;
    HIBYTE(v11) = HIBYTE(result) + 1;
    if ( v4 )
    {
      if ( v10 == 7 )
        byte_FC1E0[v11] = v4;
    }
    result = v11 + 1;
  }
  while ( result );
  return result;
}

//----- (000320A0) --------------------------------------------------------
unsigned __int16 sub_320A0(unsigned __int16 a1)
{
  unsigned __int16 result; // ax
  unsigned __int8 v2; // dh
  unsigned __int8 v3; // dl
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // ax
  int v6; // edx
  char v7; // bl
  char v8; // dl
  char v9; // dh

  //fix
  v4 = 0;
  v5 = 0;
  //fix

  result = 0;
  do
  {
    if ( byte_FC1E0[result] == 5 )
    {
      v2 = 0;
      v3 = -1;
      if ( byte_DC1E0[result] )
        v2 = byte_DC1E0[result];
      if ( byte_DC1E0[result] != -1 )
        v3 = byte_DC1E0[result];
      --HIBYTE(result);
      if ( v2 < (unsigned __int8)byte_DC1E0[result] )
        v2 = byte_DC1E0[result];
      if ( v3 > (unsigned __int8)byte_DC1E0[result] )
        v3 = byte_DC1E0[result];
      LOBYTE(result) = result + 1;
      ++HIBYTE(result);
      if ( v2 < (unsigned __int8)byte_DC1E0[result] )
        v2 = byte_DC1E0[v4];
      if ( v3 > (unsigned __int8)byte_DC1E0[v4] )
        v3 = byte_DC1E0[v4];
      LOBYTE(v4) = v4 - 1;
      ++HIBYTE(v4);
      if ( v2 < (unsigned __int8)byte_DC1E0[v4] )
        v2 = byte_DC1E0[v5];
      if ( v3 > (unsigned __int8)byte_DC1E0[v5] )
        v3 = byte_DC1E0[v5];
      LOBYTE(result) = v5 - 1;
      HIBYTE(result) = HIBYTE(v5) - 1;
      if ( v2 < (unsigned __int8)byte_DC1E0[result] )
        v2 = byte_DC1E0[result];
      if ( v3 > (unsigned __int8)byte_DC1E0[result] )
        v3 = byte_DC1E0[result];
      v6 = v2 - v3;
      LOBYTE(result) = result + 1;
      if ( v6 <= a1 )
      {
        if ( v6 == a1 )
        {
          LOWORD(v6) = result;
          byte_FC1E0[v6] = 4;
        }
        else
        {
          byte_FC1E0[result] = 3;
        }
      }
    }
    ++result;
  }
  while ( result );
  do
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    if ( byte_FC1E0[result] == 3 )
      v7 = 1;
    if ( byte_FC1E0[result] == 2 )
      v8 = 1;
    if ( byte_FC1E0[result] == 5 )
      v9 = 1;
    LOBYTE(result) = result + 1;
    if ( byte_FC1E0[result] == 3 )
      ++v7;
    if ( byte_FC1E0[result] == 2 )
      ++v8;
    if ( byte_FC1E0[result] == 5 )
      ++v9;
    ++HIBYTE(result);
    if ( byte_FC1E0[result] == 3 )
      ++v7;
    if ( byte_FC1E0[result] == 2 )
      ++v8;
    if ( byte_FC1E0[result] == 5 )
      ++v9;
    LOBYTE(result) = result - 1;
    if ( byte_FC1E0[result] == 3 )
      ++v7;
    if ( byte_FC1E0[result] == 2 )
      ++v8;
    if ( byte_FC1E0[result] == 5 )
      ++v9;
    --HIBYTE(result);
    if ( !v8 && v7 && v9 )
    {
      if ( byte_FC1E0[result] == 3 )
        byte_FC1E0[result] = 4;
      LOBYTE(result) = result + 1;
      if ( byte_FC1E0[result] == 3 )
        byte_FC1E0[result] = 4;
      ++HIBYTE(result);
      if ( byte_FC1E0[result] == 3 )
        byte_FC1E0[result] = 4;
      LOBYTE(result) = result - 1;
      if ( byte_FC1E0[result] == 3 )
        byte_FC1E0[result] = 4;
      --HIBYTE(result);
    }
    ++result;
  }
  while ( result );
  return result;
}

//----- (00032300) --------------------------------------------------------
unsigned __int16 sub_32300()
{
  unsigned __int16 result; // ax
  char v1; // bl
  char v2; // dh
  char v3; // dl

  result = 0;
  do
  {
    v1 = 0;
    v2 = 0;
    v3 = 0;
    if ( !byte_FC1E0[result] )
      v1 = 1;
    if ( byte_FC1E0[result] == 5 )
      v3 = 1;
    if ( byte_FC1E0[result] == 3 )
      v2 = 1;
    LOBYTE(result) = result + 1;
    if ( !byte_FC1E0[result] )
      ++v1;
    if ( byte_FC1E0[result] == 5 )
      ++v3;
    if ( byte_FC1E0[result] == 3 )
      ++v2;
    ++HIBYTE(result);
    if ( !byte_FC1E0[result] )
      ++v1;
    if ( byte_FC1E0[result] == 5 )
      ++v3;
    if ( byte_FC1E0[result] == 3 )
      ++v2;
    LOBYTE(result) = result - 1;
    if ( !byte_FC1E0[result] )
      ++v1;
    if ( byte_FC1E0[result] == 5 )
      ++v3;
    if ( byte_FC1E0[result] == 3 )
      ++v2;
    --HIBYTE(result);
    if ( v2 && v3 )
    {
      if ( byte_FC1E0[result] == 5 )
        byte_FC1E0[result] = 4;
      LOBYTE(result) = result + 1;
      if ( byte_FC1E0[result] == 5 )
        byte_FC1E0[result] = 4;
      ++HIBYTE(result);
      if ( byte_FC1E0[result] == 5 )
        byte_FC1E0[result] = 4;
      LOBYTE(result) = result - 1;
      if ( byte_FC1E0[result] == 5 )
        byte_FC1E0[result] = 4;
      --HIBYTE(result);
    }
    if ( v2 && v1 )
    {
      if ( byte_FC1E0[result] == 3 )
        byte_FC1E0[result] = 4;
      LOBYTE(result) = result + 1;
      if ( byte_FC1E0[result] == 3 )
        byte_FC1E0[result] = 4;
      ++HIBYTE(result);
      if ( byte_FC1E0[result] == 3 )
        byte_FC1E0[result] = 4;
      LOBYTE(result) = result - 1;
      if ( byte_FC1E0[result] == 3 )
        byte_FC1E0[result] = 4;
      --HIBYTE(result);
    }
    if ( v1 && v3 )
    {
      if ( byte_FC1E0[result] )
        byte_FC1E0[result] = 4;
      LOBYTE(result) = result + 1;
      if ( byte_FC1E0[result] )
        byte_FC1E0[result] = 4;
      ++HIBYTE(result);
      if ( byte_FC1E0[result] )
        byte_FC1E0[result] = 4;
      LOBYTE(result) = result - 1;
      if ( byte_FC1E0[result] )
        byte_FC1E0[result] = 4;
      --HIBYTE(result);
    }
    ++result;
  }
  while ( result );
  return result;
}

//----- (00032560) --------------------------------------------------------
char sub_32560()
{
  _BYTE *v0; // edx
  int v1; // ebx
  char *v2; // edi
  int v3; // esi
  unsigned __int16 i; // bx
  char v5; // al
  char v6; // ah
  char v7; // dh
  char v8; // dl
  unsigned __int8 *v9; // ebp
  unsigned __int8 *v10; // ebp
  char v11; // cl
  char v12; // al
  char v13; // ah
  char v14; // cl
  char v15; // dl
  char v16; // dh
  unsigned __int8 *v17; // ebp
  unsigned __int8 *v18; // ebp
  char v19; // cl
  char v20; // al
  char v21; // dl
  char v22; // cl
  char v23; // ah
  char v24; // dh
  unsigned __int8 *v25; // ebp
  unsigned __int8 v26; // cl
  char v27; // cl
  char v28; // al
  char v29; // ah
  char v30; // cl
  char v31; // dl
  char v32; // dh
  unsigned __int8 *v33; // ebp
  unsigned __int8 v34; // cl
  char v35; // cl
  char v36; // al
  char v37; // dh
  unsigned __int8 *v38; // ebp
  unsigned __int8 *v39; // ebp
  char v40; // cl
  char v41; // al
  char v42; // ah
  char v43; // cl
  char v44; // dl
  char v45; // dh
  unsigned __int8 *v46; // ebp
  unsigned __int8 v47; // cl
  unsigned __int8 *v48; // ebp
  unsigned __int8 *v49; // ebp
  unsigned __int8 *v50; // edx
  unsigned __int8 v51; // al
  char *v52; // edx
  char m; // al
  char *v54; // ebx
  char v55; // ah
  char result; // al
  unsigned __int16 v57; // cx
  int v58; // edx
  char v59; // al
  unsigned __int16 v60; // dx
  char v61; // al
  unsigned __int16 v62; // dx
  int v63; // edi
  unsigned __int8 v64; // al
  int v65; // ebx
  char v66; // [esp+4h] [ebp-38h]
  unsigned __int8 v67; // [esp+8h] [ebp-34h]
  char v68; // [esp+10h] [ebp-2Ch]
  char j; // [esp+14h] [ebp-28h]
  char k; // [esp+18h] [ebp-24h]
  unsigned __int8 v71; // [esp+1Ch] [ebp-20h]
  unsigned __int8 v72; // [esp+20h] [ebp-1Ch]
  unsigned __int8 v73; // [esp+24h] [ebp-18h]
  unsigned __int8 v74; // [esp+28h] [ebp-14h]

  v0 = (_BYTE *)dword_12EFF4;
  v1 = 0;
  do
  {
    ++v1;
    *v0 = 0;
    v0 += 25;
  }
  while ( (unsigned __int16)v1 < 0x961u );
  v2 = (char *)&unk_9075C;
  v3 = dword_12EFF4;
  for ( i = 0; i < 0x94u; ++i )
  {
    v5 = *v2;
    if ( *v2 >= 0 )
    {
      v6 = v2[1];
      if ( v6 >= 0 )
      {
        v7 = v2[2];
        if ( v7 >= 0 )
        {
          v8 = v2[3];
          if ( v8 >= 0 )
          {
            v9 = (unsigned __int8 *)(v3 + 25 * (49 * v6 + 7 * v7 + v8 + 343 * v5));
            v72 = *v9;
            if ( *v9 < 0xCu )
            {
              ++*v9;
              v10 = &v9[v72];
              v10[13] = 0;
              v10[1] = i;
            }
            v11 = v5;
            v12 = v6;
            v13 = v11;
            v14 = v8;
            v15 = v7;
            v16 = v14;
            v17 = (unsigned __int8 *)(v3 + 25 * (49 * v13 + 7 * v14 + v15 + 343 * v12));
            v73 = *v17;
            if ( *v17 < 0xCu )
            {
              ++*v17;
              v18 = &v17[v73];
              v18[13] = 16;
              v18[1] = i;
            }
            v19 = v12;
            v20 = v15;
            v21 = v19;
            v22 = v13;
            v23 = v16;
            v24 = v22;
            v25 = (unsigned __int8 *)(v3 + 25 * (49 * v23 + v21 + 7 * v22 + 343 * v20));
            v26 = *v25;
            if ( *v25 < 0xCu )
            {
              *v25 = v26 + 1;
              v25[v26 + 13] = 48;
              v25[v26 + 1] = i;
            }
            v27 = v20;
            v28 = v23;
            v29 = v27;
            v30 = v21;
            v31 = v24;
            v32 = v30;
            v33 = (unsigned __int8 *)(v3 + 25 * (49 * v29 + 7 * v30 + v31 + 343 * v28));
            v34 = *v33;
            if ( *v33 < 0xCu )
            {
              *v33 = v34 + 1;
              v33[v34 + 13] = 32;
              v33[v34 + 1] = i;
            }
            v35 = v28;
            v36 = v32;
            v37 = v35;
            v38 = (unsigned __int8 *)(v3 + 25 * (v31 + 7 * v35 + 49 * v29 + 343 * v36));
            v71 = *v38;
            if ( *v38 < 0xCu )
            {
              ++*v38;
              v39 = &v38[v71];
              v39[13] = 96;
              v39[1] = i;
            }
            v40 = v36;
            v41 = v29;
            v42 = v40;
            v43 = v31;
            v44 = v37;
            v45 = v43;
            v46 = (unsigned __int8 *)(v3 + 25 * (49 * v42 + v44 + 7 * v43 + 343 * v41));
            v47 = *v46;
            if ( *v46 < 0xCu )
            {
              *v46 = v47 + 1;
              v46[v47 + 13] = 112;
              v46[v47 + 1] = i;
            }
            v48 = (unsigned __int8 *)(v3 + 25 * (49 * v45 + 7 * v42 + v41 + 343 * v44));
            v67 = *v48;
            if ( *v48 < 0xCu )
            {
              ++*v48;
              v49 = &v48[v67];
              v49[13] = 80;
              v49[1] = i;
            }
            v50 = (unsigned __int8 *)(v3 + 25 * (343 * v45 + v42 + 7 * v41 + 49 * v44));
            v51 = *v50;
            if ( *v50 < 0xCu )
            {
              *v50 = v51 + 1;
              v50[v51 + 13] = 64;
              v50[v51 + 1] = i;
            }
          }
        }
      }
    }
    v2 += 4;
  }
  v52 = (char*)&byte_B5D40;
  v66 = 0;
  do
  {
    for ( j = 0; j < 7; ++j )
    {
      for ( k = 0; k < 7; ++k )
      {
        for ( m = 0; m < 7; ++m )
        {
          v54 = (char *)(v3 + 25 * (49 * j + m + 7 * k + 343 * v66));
          v55 = *v54;
          if ( *v54 )
          {
            *v52 = v54[1];
            v55 = v54[13];
          }
          else
          {
            *v52 = 1;
          }
          v52[1] = v55;
          v52 += 2;
        }
      }
    }
    result = v66 + 1;
    v66 = result;
  }
  while ( result < 7 );
  v57 = 0;
  do
  {
    v58 = v57;
    if ( !byte_CC1E0[v57] )
    {
      LOBYTE(v57) = v57 + 1;
      v59 = byte_FC1E0[v58];
      v60 = v57;
      v68 = v59 & 7;
      ++HIBYTE(v57);
      v61 = byte_FC1E0[v60];
      v62 = v57;
      LOBYTE(v57) = v57 - 1;
      v63 = 49 * (v61 & 7) + 7 * (byte_FC1E0[v62] & 7) + (byte_FC1E0[v57] & 7) + 343 * v68;
      result = *(_BYTE *)(25 * v63 + v3);
      --HIBYTE(v57);
      v74 = result;
      if ( result )
      {
        word_12C1E0 = 9377 * word_12C1E0 + 9439;
        v64 = (unsigned __int16)word_12C1E0 % (unsigned __int16)((unsigned __int8)result + 1);
        if ( v64 >= v74 )
          v64 = 0;
        v65 = v64 + v3 + 25 * v63;
        byte_CC1E0[v57] = *(_BYTE *)(v65 + 1);
        result = *(_BYTE *)(v65 + 13) + (byte_FC1E0[v57] & 7);
        byte_FC1E0[v57] = result;
      }
      else
      {
        byte_CC1E0[v57] = 1;
      }
    }
    ++v57;
  }
  while ( v57 );
  return result;
}
// B5D40: using guessed type char byte_B5D40;
// 12C1E0: using guessed type __int16 word_12C1E0;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (000329C0) --------------------------------------------------------
int sub_329C0()
{
  unsigned __int16 v0; // cx
  unsigned __int16 v1; // dx
  int result; // eax
  unsigned __int16 v3; // cx
  unsigned __int16 v4; // tt

  v0 = 0;
  word_12C1E0 = 0;
  do
  {
    LOBYTE(v0) = v0 + 1;
    HIWORD(result) = 0;
    ++HIBYTE(v0);
    LOWORD(result) = v0;
    LOBYTE(v0) = v0 - 2;
    HIBYTE(v0) -= 2;
    v1 = v0;
    LOBYTE(v0) = v0 + 1;
    LOBYTE(result) = byte_DC1E0[v1] - byte_DC1E0[(unsigned __int16)result] + 32;
    HIBYTE(v3) = HIBYTE(v0) + 1;
    if ( (_BYTE)result == 32 )
    {
      result = 9377 * (unsigned __int16)word_12C1E0;
      word_12C1E0 = result + 9439;
      v4 = result + 9439;
      BYTE1(result) = (unsigned __int16)(result + 9439) / 0x900u;
      LOBYTE(result) = v4 % 9u + 28;
    }
    else if ( (char)result >= 28 )
    {
      if ( (char)result > 40 )
        LOBYTE(result) = (result & 7) + 40;
    }
    else
    {
      LOBYTE(result) = (result & 3) + 28;
    }
    byte_EC1E0[v3] = result;
    v0 = v3 + 1;
  }
  while ( v0 );
  return result;
}
// 12C1E0: using guessed type __int16 word_12C1E0;

//----- (00032A50) --------------------------------------------------------
int sub_32A50()
{
  __int16 v0; // dx
  __int16 v1; // cx
  unsigned __int16 v2; // bx
  __int16 v3; // ax
  int v4; // ecx
  int result; // eax

  v0 = -32000;
  v1 = 32000;
  v2 = 0;
  do
  {
    v3 = word_10C1E0[v2];
    if ( v3 > v0 )
      v0 = word_10C1E0[v2];
    if ( v3 < v1 )
      v1 = word_10C1E0[v2];
    ++v2;
  }
  while ( v2 );
  if ( v0 )
    v4 = 12845056 / v0;
  else
    v4 = 0;
  do
  {
    result = (v4 * word_10C1E0[v2]) >> 16;
    word_10C1E0[v2] = 0;
    if ( (result & 0x8000u) != 0 )
      result = 0;
    if ( (__int16)result > 196 )
      result = 196;
    byte_DC1E0[v2++] = result;
  }
  while ( v2 );
  return result;
}
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (00032AE0) --------------------------------------------------------
unsigned __int16 sub_32AE0(int a1, unsigned __int8 a2)
{
  unsigned __int16 v3; // si
  int v4; // ecx
  int v5; // eax
  int v6; // ebx
  unsigned __int16 result; // ax

  v3 = 0;
  do
  {
    if ( byte_DC1E0[v3] )
      byte_FC1E0[v3] = 5;
    else
      byte_FC1E0[v3] = 0;
    ++v3;
  }
  while ( v3 );
LABEL_12:
  if ( a1 > 0 )
  {
    v4 = 1000;
    while ( 1 )
    {
      v6 = 0xFFFF;
      word_12C1E0 = 9377 * word_12C1E0 + 9439;
      HIWORD(v5) = 0;
      LOBYTE(v6) = byte_DC1E0[(unsigned __int16)word_12C1E0 % 0xFFFFu];
      if ( !--v4 )
        break;
      if ( (unsigned __int8)v6 > a2 )
      {
        LOWORD(v5) = (unsigned __int16)word_12C1E0 % 0xFFFFu;
        if ( byte_FC1E0[v5] )
        {
          --a1;
          sub_32B90(v6, (unsigned __int16)word_12C1E0 % 0xFFFFu);
          goto LABEL_12;
        }
      }
    }
  }
  do
  {
    result = v3;
    byte_CC1E0[v3++] = -1;
  }
  while ( v3 );
  return result;
}
// 12C1E0: using guessed type __int16 word_12C1E0;

//----- (00032B90) --------------------------------------------------------
unsigned __int16 sub_32B90fix(int a1, int a2)
{
  int v2; // eax
  unsigned __int16 v3; // dx
  unsigned __int8 v4; // dh
  unsigned __int16 v5; // si
  int v6; // esi
  unsigned __int8 v7; // dl
  unsigned __int16 result; // ax

  v2 = a2;
  v3 = 0;
  do
    byte_CC1E0[v3++] = 3;
  while ( v3 );
  v4 = byte_DC1E0[(unsigned __int16)a2];
  do
  {
    v5 = v2;
    --BYTE1(v2);
    byte_CC1E0[v5] = 0;
    v6 = v5;
    LOWORD(v6) = v2;
    v7 = -1;
    if ( byte_CC1E0[(unsigned __int16)v2] && byte_DC1E0[v6] != -1 )
    {
      v7 = byte_DC1E0[v6];
      a1 = v2;
    }
    LOBYTE(v2) = v2 + 1;
    if ( byte_CC1E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_DC1E0[(unsigned __int16)v2] )
    {
      v7 = byte_DC1E0[(unsigned __int16)v2];
      a1 = v2;
    }
    ++BYTE1(v2);
    if ( byte_CC1E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_DC1E0[(unsigned __int16)v2] )
    {
      v7 = byte_DC1E0[(unsigned __int16)v2];
      a1 = v2;
    }
    ++BYTE1(v2);
    if ( byte_CC1E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_DC1E0[(unsigned __int16)v2] )
    {
      v7 = byte_DC1E0[(unsigned __int16)v2];
      a1 = v2;
    }
    LOBYTE(v2) = v2 - 1;
    if ( byte_CC1E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_DC1E0[(unsigned __int16)v2] )
    {
      v7 = byte_DC1E0[(unsigned __int16)v2];
      a1 = v2;
    }
    LOBYTE(v2) = v2 - 1;
    if ( byte_CC1E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_DC1E0[(unsigned __int16)v2] )
    {
      v7 = byte_DC1E0[(unsigned __int16)v2];
      a1 = v2;
    }
    --BYTE1(v2);
    if ( byte_CC1E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_DC1E0[(unsigned __int16)v2] )
    {
      v7 = byte_DC1E0[(unsigned __int16)v2];
      a1 = v2;
    }
    --BYTE1(v2);
    if ( byte_CC1E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_DC1E0[(unsigned __int16)v2] )
    {
      v7 = byte_DC1E0[(unsigned __int16)v2];
      a1 = v2;
    }
    if ( !byte_FC1E0[(unsigned __int16)a1] || v7 == 0xFF )
      break;
    if ( v7 > v4 )
      byte_DC1E0[(unsigned __int16)a1] = v4;
    v4 = byte_DC1E0[(unsigned __int16)a1];
    v2 = a1;
  }
  while ( v4 );
  result = 0;
  do
  {
    if ( !byte_CC1E0[result] )
      byte_FC1E0[result] = 0;
    ++result;
  }
  while ( result );
  return result;
}

//----- (00032D00) --------------------------------------------------------
unsigned __int8 sub_32D00(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int16 v2; // dx
  unsigned __int8 v3; // ah
  unsigned __int8 result; // al
  unsigned __int16 v5; // dx

  qmemcpy(byte_CC1E0, byte_FC1E0, (unsigned int)sub_10000);
  v2 = 0;
  do
  {
    v3 = 0;
    result = -1;
    if ( byte_DC1E0[v2] )
      v3 = byte_DC1E0[v2];
    if ( byte_DC1E0[v2] != -1 )
      result = byte_DC1E0[v2];
    --HIBYTE(v2);
    if ( v3 < (unsigned __int8)byte_DC1E0[v2] )
      v3 = byte_DC1E0[v2];
    if ( result > (unsigned __int8)byte_DC1E0[v2] )
      result = byte_DC1E0[v2];
    LOBYTE(v2) = v2 + 1;
    if ( v3 < (unsigned __int8)byte_DC1E0[v2] )
      v3 = byte_DC1E0[v2];
    if ( result > (unsigned __int8)byte_DC1E0[v2] )
      result = byte_DC1E0[v2];
    ++HIBYTE(v2);
    if ( v3 < (unsigned __int8)byte_DC1E0[v2] )
      v3 = byte_DC1E0[v2];
    if ( result > (unsigned __int8)byte_DC1E0[v2] )
      result = byte_DC1E0[v2];
    ++HIBYTE(v2);
    if ( v3 < (unsigned __int8)byte_DC1E0[v2] )
      v3 = byte_DC1E0[v2];
    if ( result > (unsigned __int8)byte_DC1E0[v2] )
      result = byte_DC1E0[v2];
    LOBYTE(v2) = v2 - 1;
    if ( v3 < (unsigned __int8)byte_DC1E0[v2] )
      v3 = byte_DC1E0[v2];
    if ( result > (unsigned __int8)byte_DC1E0[v2] )
      result = byte_DC1E0[v2];
    LOBYTE(v2) = v2 - 1;
    if ( v3 < (unsigned __int8)byte_DC1E0[v2] )
      v3 = byte_DC1E0[v2];
    if ( result > (unsigned __int8)byte_DC1E0[v2] )
      result = byte_DC1E0[v2];
    --HIBYTE(v2);
    if ( v3 < (unsigned __int8)byte_DC1E0[v2] )
      v3 = byte_DC1E0[v2];
    if ( result > (unsigned __int8)byte_DC1E0[v2] )
      result = byte_DC1E0[v2];
    --HIBYTE(v2);
    if ( v3 < (unsigned __int8)byte_DC1E0[v2] )
      v3 = byte_DC1E0[v2];
    if ( result > (unsigned __int8)byte_DC1E0[v2] )
      result = byte_DC1E0[v2];
    LOBYTE(v2) = v2 + 1;
    HIBYTE(v5) = HIBYTE(v2) + 1;
    if ( v3 < a1 && v3 - result <= a2 )
    {
      if ( byte_FC1E0[v5] )
        byte_FC1E0[v5] = 5;
    }
    v2 = v5 + 1;
  }
  while ( v2 );
  return result;
}
// 10000: using guessed type void sub_10000();

//----- (00032EB0) --------------------------------------------------------
char sub_32EB0(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int16 v2; // dx
  int v3; // eax
  unsigned __int8 v4; // bh
  unsigned __int8 v5; // bl
  unsigned __int16 v6; // dx
  int v7; // ecx

  qmemcpy(byte_CC1E0, byte_FC1E0, (unsigned int)sub_10000);
  v2 = 0;
  do
  {
    LOWORD(v3) = -256;
    v4 = 0;
    v5 = 0;
    if ( byte_DC1E0[v2] )
      LOBYTE(v3) = byte_DC1E0[v2];
    if ( byte_DC1E0[v2] != -1 )
      BYTE1(v3) = byte_DC1E0[v2];
    --HIBYTE(v2);
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_DC1E0[v2] )
      LOBYTE(v3) = byte_DC1E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_DC1E0[v2] )
      BYTE1(v3) = byte_DC1E0[v2];
    if ( byte_FC1E0[v2] == 5 )
      v5 = 1;
    if ( byte_FC1E0[v2] == 2 )
      v4 = 1;
    LOBYTE(v2) = v2 + 1;
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_DC1E0[v2] )
      LOBYTE(v3) = byte_DC1E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_DC1E0[v2] )
      BYTE1(v3) = byte_DC1E0[v2];
    if ( byte_FC1E0[v2] == 5 )
      ++v5;
    if ( byte_FC1E0[v2] == 2 )
      ++v4;
    ++HIBYTE(v2);
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_DC1E0[v2] )
      LOBYTE(v3) = byte_DC1E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_DC1E0[v2] )
      BYTE1(v3) = byte_DC1E0[v2];
    if ( byte_FC1E0[v2] == 5 )
      ++v5;
    if ( byte_FC1E0[v2] == 2 )
      ++v4;
    ++HIBYTE(v2);
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_DC1E0[v2] )
      LOBYTE(v3) = byte_DC1E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_DC1E0[v2] )
      BYTE1(v3) = byte_DC1E0[v2];
    if ( byte_FC1E0[v2] == 5 )
      ++v5;
    if ( byte_FC1E0[v2] == 2 )
      ++v4;
    LOBYTE(v2) = v2 - 1;
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_DC1E0[v2] )
      LOBYTE(v3) = byte_DC1E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_DC1E0[v2] )
      BYTE1(v3) = byte_DC1E0[v2];
    if ( byte_FC1E0[v2] == 5 )
      ++v5;
    if ( byte_FC1E0[v2] == 2 )
      ++v4;
    LOBYTE(v2) = v2 - 1;
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_DC1E0[v2] )
      LOBYTE(v3) = byte_DC1E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_DC1E0[v2] )
      BYTE1(v3) = byte_DC1E0[v2];
    if ( byte_FC1E0[v2] == 5 )
      ++v5;
    if ( byte_FC1E0[v2] == 2 )
      ++v4;
    --HIBYTE(v2);
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_DC1E0[v2] )
      LOBYTE(v3) = byte_DC1E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_DC1E0[v2] )
      BYTE1(v3) = byte_DC1E0[v2];
    if ( byte_FC1E0[v2] == 5 )
      ++v5;
    if ( byte_FC1E0[v2] == 2 )
      ++v4;
    --HIBYTE(v2);
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_DC1E0[v2] )
      LOBYTE(v3) = byte_DC1E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_DC1E0[v2] )
      BYTE1(v3) = byte_DC1E0[v2];
    if ( byte_FC1E0[v2] == 5 )
      ++v5;
    if ( byte_FC1E0[v2] == 2 )
      ++v4;
    LOBYTE(v2) = v2 + 1;
    HIBYTE(v6) = HIBYTE(v2) + 1;
    if ( (unsigned __int8)v3 < a1 )
    {
      v7 = (unsigned __int8)v3 - BYTE1(v3);
      LOBYTE(v3) = a2;
      if ( v7 <= a2 && byte_FC1E0[v6] == 5 )
      {
        v3 = v4 + v5;
        if ( v3 == 8 )
          byte_FC1E0[v6] = 2;
      }
    }
    v2 = v6 + 1;
  }
  while ( v2 );
  return v3;
}
// 10000: using guessed type void sub_10000();

//----- (00033180) --------------------------------------------------------
unsigned __int16 sub_33180(unsigned __int8 a1)
{
  unsigned __int16 result; // ax
  unsigned __int8 v2; // dh
  unsigned __int8 v3; // dl
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // ax
  unsigned __int16 v6; // ax
  __int16 v7; // bx
  char v8; // dl
  char v9; // dh

  //fix
  v4 = 0;
  v5 = 0;
  v6 = 0;
  //fix

  qmemcpy(byte_CC1E0, byte_FC1E0, (unsigned int)sub_10000);
  result = 0;
  do
  {
    v2 = 0;
    v3 = -1;
    if ( byte_DC1E0[result] )
      v2 = byte_DC1E0[result];
    if ( byte_DC1E0[result] != -1 )
      v3 = byte_DC1E0[result];
    --HIBYTE(result);
    if ( v2 < (unsigned __int8)byte_DC1E0[result] )
      v2 = byte_DC1E0[result];
    if ( v3 > (unsigned __int8)byte_DC1E0[result] )
      v3 = byte_DC1E0[result];
    LOBYTE(result) = result + 1;
    ++HIBYTE(result);
    if ( v2 < (unsigned __int8)byte_DC1E0[result] )
      v2 = byte_DC1E0[v4];
    if ( v3 > (unsigned __int8)byte_DC1E0[v4] )
      v3 = byte_DC1E0[v4];
    ++HIBYTE(v4);
    LOBYTE(v4) = v4 - 1;
    if ( v2 < (unsigned __int8)byte_DC1E0[v4] )
      v2 = byte_DC1E0[v5];
    if ( v3 > (unsigned __int8)byte_DC1E0[v5] )
      v3 = byte_DC1E0[v5];
    LOBYTE(v5) = v5 - 1;
    --HIBYTE(v5);
    if ( v2 < (unsigned __int8)byte_DC1E0[v5] )
      v2 = byte_DC1E0[v6];
    if ( v3 > (unsigned __int8)byte_DC1E0[v6] )
      v3 = byte_DC1E0[v6];
    LOBYTE(v6) = v6 + 1;
    if ( byte_FC1E0[v6] && v2 - v3 >= a1 )
      byte_FC1E0[v6] = 6;
    result = v6 + 1;
  }
  while ( result );
  do
  {
    if ( byte_FC1E0[result] != 6 )
      goto LABEL_100;
    v7 = 0;
    --HIBYTE(result);
    v8 = 0;
    v9 = 0;
    if ( byte_FC1E0[result] == 3 )
      HIBYTE(v7) = 1;
    if ( byte_FC1E0[result] == 2 )
      v9 = 1;
    if ( byte_FC1E0[result] == 5 )
      LOBYTE(v7) = 1;
    if ( byte_FC1E0[result] == 4 )
      v8 = 1;
    LOBYTE(result) = result + 1;
    if ( byte_FC1E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_FC1E0[result] == 2 )
      ++v9;
    if ( byte_FC1E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    if ( byte_FC1E0[result] == 4 )
      ++v8;
    ++HIBYTE(result);
    if ( byte_FC1E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_FC1E0[result] == 2 )
      ++v9;
    if ( byte_FC1E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    if ( byte_FC1E0[result] == 4 )
      ++v8;
    ++HIBYTE(result);
    if ( byte_FC1E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_FC1E0[result] == 2 )
      ++v9;
    if ( byte_FC1E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    if ( byte_FC1E0[result] == 4 )
      ++v8;
    LOBYTE(result) = result - 1;
    if ( byte_FC1E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_FC1E0[result] == 2 )
      ++v9;
    if ( byte_FC1E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    if ( byte_FC1E0[result] == 4 )
      ++v8;
    LOBYTE(result) = result - 1;
    if ( byte_FC1E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_FC1E0[result] == 2 )
      ++v9;
    if ( byte_FC1E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    if ( byte_FC1E0[result] == 4 )
      ++v8;
    --HIBYTE(result);
    if ( byte_FC1E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_FC1E0[result] == 2 )
      ++v9;
    if ( byte_FC1E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    if ( byte_FC1E0[result] == 4 )
      ++v8;
    --HIBYTE(result);
    if ( byte_FC1E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_FC1E0[result] == 2 )
      ++v9;
    if ( byte_FC1E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    if ( byte_FC1E0[result] == 4 )
      ++v8;
    LOBYTE(result) = result + 1;
    ++HIBYTE(result);
    if ( HIBYTE(v7) )
    {
      if ( v9 || (_BYTE)v7 || v8 )
        goto LABEL_99;
    }
    else if ( v9 || (_BYTE)v7 && v8 )
    {
LABEL_99:
      byte_FC1E0[result] = 1;
    }
LABEL_100:
    ++result;
  }
  while ( result );
  return result;
}
// 10000: using guessed type void sub_10000();

//----- (00033500) --------------------------------------------------------
unsigned __int16 sub_33500()
{
  unsigned __int16 result; // ax
  char v1; // dh
  unsigned __int16 v2; // cx
  unsigned __int8 v3; // dl
  unsigned __int8 v4; // bl
  unsigned __int16 v5; // cx
  unsigned __int16 v6; // cx
  unsigned __int16 v7; // cx
  unsigned __int16 v8; // cx
  char v9; // [esp+0h] [ebp-8h]

  do
  {
    result = 0;
    v9 = 0;
    do
    {
      v1 = byte_FC1E0[result] == 0;
      v2 = result;
      LOBYTE(result) = result + 1;
      v3 = byte_DC1E0[v2];
      v4 = v3;
      if ( !byte_FC1E0[result] )
        ++v1;
      if ( v3 > (unsigned __int8)byte_DC1E0[result] )
        v3 = byte_DC1E0[result];
      if ( v4 < (unsigned __int8)byte_DC1E0[result] )
        v4 = byte_DC1E0[result];
      ++HIBYTE(result);
      if ( !byte_FC1E0[result] )
        ++v1;
      if ( v3 > (unsigned __int8)byte_DC1E0[result] )
        v3 = byte_DC1E0[result];
      if ( v4 < (unsigned __int8)byte_DC1E0[result] )
        v4 = byte_DC1E0[result];
      LOBYTE(result) = result - 1;
      if ( !byte_FC1E0[result] )
        ++v1;
      if ( v3 > (unsigned __int8)byte_DC1E0[result] )
        v3 = byte_DC1E0[result];
      if ( v4 < (unsigned __int8)byte_DC1E0[result] )
        v4 = byte_DC1E0[result];
      --HIBYTE(result);
      if ( v4 != v3 && v1 == 4 )
      {
        v9 = 1;
        v5 = result;
        LOBYTE(result) = result + 1;
        byte_DC1E0[v5] = v3;
        v6 = result;
        ++HIBYTE(result);
        byte_DC1E0[v6] = v3;
        v7 = result;
        LOBYTE(result) = result - 1;
        byte_DC1E0[v7] = v3;
        v8 = result;
        --HIBYTE(result);
        byte_DC1E0[v8] = v3;
      }
      ++result;
    }
    while ( result );
  }
  while ( v9 );
  return result;
}

//----- (00033640) --------------------------------------------------------
char sub_33640(char a1, char a2, unsigned __int16 a3)
{
  unsigned __int16 v3; // ax
  unsigned __int8 v4; // bl
  unsigned __int8 v5; // dh
  unsigned __int8 v6; // bh
  unsigned __int8 v7; // al
  char result; // al

  HIBYTE(v3) = HIBYTE(a3);
  v4 = -1;
  v5 = 0;
  if ( byte_DC1E0[a3] )
  {
    v5 = byte_DC1E0[a3];
    a1 = 0;
  }
  if ( byte_DC1E0[a3] != -1 )
    v4 = byte_DC1E0[a3];
  LOBYTE(v3) = a3 + 1;
  if ( (unsigned __int8)byte_DC1E0[v3] > v5 )
  {
    v5 = byte_DC1E0[v3];
    a1 = 1;
  }
  if ( (unsigned __int8)byte_DC1E0[v3] < v4 )
    v4 = byte_DC1E0[v3];
  HIBYTE(v3) = HIBYTE(a3) + 1;
  if ( (unsigned __int8)byte_DC1E0[v3] > v5 )
  {
    v5 = byte_DC1E0[v3];
    a1 = 2;
  }
  if ( (unsigned __int8)byte_DC1E0[v3] < v4 )
    v4 = byte_DC1E0[v3];
  LOBYTE(v3) = a3;
  if ( (unsigned __int8)byte_DC1E0[v3] > v5 )
  {
    v5 = byte_DC1E0[v3];
    a1 = 3;
  }
  if ( (unsigned __int8)byte_DC1E0[v3] < v4 )
    v4 = byte_DC1E0[v3];
  HIBYTE(v3) = HIBYTE(a3);
  v6 = 0;
  if ( a1 && byte_DC1E0[v3] )
  {
    v6 = byte_DC1E0[v3];
    a2 = 0;
  }
  LOBYTE(v3) = a3 + 1;
  if ( a1 != 1 && (unsigned __int8)byte_DC1E0[v3] > v6 )
  {
    v6 = byte_DC1E0[v3];
    a2 = 1;
  }
  HIBYTE(v3) = HIBYTE(a3) + 1;
  if ( a1 != 2 && (unsigned __int8)byte_DC1E0[v3] > v6 )
  {
    v6 = byte_DC1E0[v3];
    a2 = 2;
  }
  LOBYTE(v3) = a3;
  if ( a1 != 3 )
  {
    v7 = byte_DC1E0[v3];
    if ( v7 > v6 )
    {
      a2 = 3;
      v6 = v7;
    }
  }
  dword_90758 = v5 - v4 <= 8;
  if ( v5 - v6 >= 8 )
    return a1;
  switch ( a1 )
  {
    case 0:
      if ( a2 != 1 )
        goto LABEL_39;
      goto LABEL_33;
    case 1:
      if ( a2 == 2 )
        goto LABEL_35;
LABEL_33:
      result = 4;
      break;
    case 2:
      if ( a2 == 3 )
        goto LABEL_37;
LABEL_35:
      result = 5;
      break;
    case 3:
      if ( a2 )
LABEL_37:
        result = 6;
      else
LABEL_39:
        result = 7;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 90758: using guessed type int dword_90758;

//----- (00033800) --------------------------------------------------------
char sub_33800fix(char a1, char a2, unsigned __int16 a3, unsigned __int8 a4)
{
  unsigned __int16 v4; // bx
  char result; // al
  char v6; // dl
  char *v7; // eax
  char v8; // al
  char v9; // ah
  unsigned __int8 v10; // al
  unsigned __int16 v11; // ax
  char v12; // dl
  unsigned __int16 v13; // ax
  char v14; // dh
  unsigned __int8 v15; // [esp+0h] [ebp-14h]

  HIBYTE(v4) = HIBYTE(a3);
  v15 = 8 * ((HIBYTE(a3) + a3) & 1);
  if ( a4 >= 8u )
  {
    switch ( a4 )
    {
      case 8u:
        byte_CC1E0[a3] = 8;
        goto LABEL_30;
      case 9u:
        byte_CC1E0[a3] = 9;
        goto LABEL_30;
      case 0xAu:
        v8 = sub_33640(a1, a2, a3);
        v9 = v8;
        if ( dword_90758 )
          v9 = v8 + 8;
        v10 = v9;
        goto LABEL_28;
      case 0xBu:
        v10 = sub_33640(a1, a2, a3) + 16;
        if ( dword_90758 )
          v10 += 8;
        goto LABEL_28;
      case 0xCu:
        v10 = sub_33640(a1, a2, a3) + 32;
        if ( dword_90758 )
          v10 += 8;
        goto LABEL_28;
      case 0xDu:
        v10 = sub_33640(a1, a2, a3) + 48;
        if ( dword_90758 )
          v10 += 8;
        goto LABEL_28;
      case 0xEu:
        v10 = sub_33640(a1, a2, a3) + 64;
        if ( dword_90758 )
          v10 += 8;
LABEL_28:
        v7 = (char *)&unk_90A2C + 2 * v10;
        goto LABEL_29;
      case 0xFu:
        byte_CC1E0[a3] = 11;
        goto LABEL_30;
      case 0x10u:
        v6 = byte_CC1E0[a3];
        if ( v6 == 10 || v6 == 11 || v6 == 12 )
          goto LABEL_30;
        v7 = (char *)&unk_909AC + 2 * (unsigned __int8)sub_33640(v6, a2, a3);
LABEL_29:
        byte_CC1E0[a3] = *v7;
        byte_FC1E0[a3] = byte_FC1E0[a3] & 0x8F | v7[1];
LABEL_30:
        LOBYTE(v4) = a3 + 1;
        byte_FC1E0[a3] = byte_FC1E0[a3] & 0x77 | 0x80;
        v11 = v4;
        v12 = byte_FC1E0[v4] & 0xF7;
        HIBYTE(v4) = HIBYTE(a3) + 1;
        byte_FC1E0[v11] = v12;
        v13 = v4;
        v14 = byte_FC1E0[v4] & 0xF7;
        LOBYTE(v4) = a3;
        byte_FC1E0[v13] = v14;
        result = a3;
        byte_FC1E0[v4] &= ~8u;
        break;
      case 0x11u:
        v7 = (char *)&unk_909EC + 2 * (unsigned __int8)sub_33640(a1, a2, a3);
        goto LABEL_29;
      case 0x12u:
        v7 = (char *)&unk_909FC + 2 * (unsigned __int8)sub_33640(a1, a2, a3) + 2 * v15;
        goto LABEL_29;
      case 0x13u:
        v7 = (char *)&unk_909FC + 2 * (unsigned __int8)sub_33640(a1, a2, a3) + 2 * v15 + 16;
        goto LABEL_29;
      case 0x14u:
        v7 = (char *)&unk_909BC + 2 * (unsigned __int8)sub_33640(a1, a2, a3);
        goto LABEL_29;
      case 0x15u:
        v7 = (char *)&unk_909BC + 2 * (unsigned __int8)sub_33640(a1, a2, a3) + 16;
        goto LABEL_29;
      case 0x16u:
        v7 = (char *)&unk_909BC + 2 * (unsigned __int8)sub_33640(a1, a2, a3) + 32;
        goto LABEL_29;
      default:
        goto LABEL_30;
    }
  }
  else
  {
    byte_FC1E0[a3] = a4 | byte_FC1E0[a3] & 0xF0;
    return sub_33B90(a3, a3);
  }
  return result;
}
// 90758: using guessed type int dword_90758;

//----- (00033AE0) --------------------------------------------------------
unsigned __int16 sub_33AE0(unsigned __int16 a1, char a2)
{
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // bx
  unsigned __int16 v4; // bx
  unsigned __int16 v5; // bx
  char v6; // cl
  unsigned __int16 result; // ax
  char v8; // dh
  unsigned __int16 v9; // bx
  char v10; // dl
  unsigned __int16 v11; // bx
  char v12; // dl
  unsigned __int16 v13; // bx
  char v14; // dl

  HIBYTE(v2) = HIBYTE(a1);
  LOBYTE(v2) = a1 - 1;
  byte_CC1E0[a1] = a2;
  v3 = v2;
  HIBYTE(result) = HIBYTE(a1) - 1;
  byte_CC1E0[v3] = a2;
  v4 = result;
  LOBYTE(result) = a1;
  byte_CC1E0[v4] = a2;
  v5 = result;
  v6 = 3;
  LOBYTE(result) = a1 - 1;
  byte_CC1E0[v5] = a2;
  do
  {
    v8 = 3;
    do
    {
      LOBYTE(result) = result + 1;
      ++HIBYTE(result);
      v9 = result;
      LOBYTE(result) = result - 2;
      v10 = byte_DC1E0[v9];
      HIBYTE(result) -= 2;
      v11 = result;
      LOBYTE(result) = result + 1;
      v12 = byte_DC1E0[v11] - v10 + 32;
      ++HIBYTE(result);
      if ( v12 >= 32 )
      {
        if ( v12 > 40 )
          v12 = (v12 & 7) + 40;
      }
      else
      {
        v12 = 32;
      }
      v13 = result;
      byte_EC1E0[result] = v12;
      v14 = byte_FC1E0[result] & 0xF7;
      LOBYTE(result) = result + 1;
      byte_FC1E0[v13] = v14;
      --v8;
    }
    while ( v8 );
    LOBYTE(result) = result - 3;
    ++HIBYTE(result);
    --v6;
  }
  while ( v6 );
  return result;
}

//----- (00033B90) --------------------------------------------------------
char sub_33B90(unsigned __int16 a1, __int16 a2)
{
  unsigned __int16 v2; // cx
  char v3; // ah
  char v4; // al
  int v5; // eax
  unsigned __int16 v6; // cx
  _BOOL1 v7; // zf
  unsigned __int16 v8; // dx
  int v9; // eax
  unsigned __int16 v10; // dx
  int v11; // eax
  int v12; // edx
  unsigned __int16 v13; // cx
  char v14; // bl
  unsigned __int16 v15; // dx
  char v16; // al
  unsigned __int16 v17; // dx
  unsigned __int16 v18; // si
  char v19; // dl
  char v21; // [esp+0h] [ebp-20h]
  char v22; // [esp+4h] [ebp-1Ch]
  char v23; // [esp+4h] [ebp-1Ch]
  char v24; // [esp+8h] [ebp-18h]
  char v25; // [esp+Ch] [ebp-14h]
  char v26; // [esp+Ch] [ebp-14h]
  char v27; // [esp+Ch] [ebp-14h]
  char i; // [esp+10h] [ebp-10h]
  unsigned __int16 v29; // [esp+24h] [ebp+4h]

  //fix
  v29 = 0;
  //fix

  v2 = a1;
  v25 = a2 - a1 + 1;
  v3 = HIBYTE(a2) - HIBYTE(a1) + 1;
  v22 = v3;
  if ( HIBYTE(a2) - HIBYTE(a1) != 0xFF )
  {
    do
    {
      v4 = a2 - a1 + 1;
      if ( (_BYTE)a2 - (_BYTE)a1 != 0xFF )
      {
        do
        {
          if ( (byte_FC1E0[v2] & 0x80) == 0 )
            byte_CC1E0[v2] = 1;
          LOBYTE(v2) = v2 - 1;
          if ( (byte_FC1E0[v2] & 0x80) == 0 )
            byte_CC1E0[v2] = 1;
          --HIBYTE(v2);
          if ( (byte_FC1E0[v2] & 0x80) == 0 )
            byte_CC1E0[v2] = 1;
          LOBYTE(v2) = v2 + 1;
          if ( (byte_FC1E0[v2] & 0x80) == 0 )
            byte_CC1E0[v2] = 1;
          ++HIBYTE(v2);
          LOBYTE(v2) = v2 + 1;
          --v4;
        }
        while ( v4 );
      }
      LOBYTE(v2) = v2 - v25;
      ++HIBYTE(v2);
      --v3;
    }
    while ( v3 );
  }
  LOBYTE(a1) = a1 - 1;
  LOBYTE(v5) = v25 + 1;
  v26 = v25 + 1;
  --HIBYTE(a1);
  v6 = a1;
  v7 = v22 == -1;
  v23 = v22 + 1;
  v24 = v23;
  if ( !v7 )
  {
    do
    {
      LOBYTE(v5) = v26;
      for ( i = v26; i; --i )
      {
        v5 = v6;
        if ( byte_CC1E0[v6] == 1 )
        {
          LOBYTE(v6) = v6 + 1;
          v8 = v6;
          ++HIBYTE(v6);
          v9 = 49 * (byte_FC1E0[v8] & 7) + 343 * (byte_FC1E0[v5] & 7);
          v10 = v6;
          LOBYTE(v6) = v6 - 1;
          v11 = 7 * (byte_FC1E0[v10] & 7) + v9;
          v12 = byte_FC1E0[v6] & 7;
          --HIBYTE(v6);
          v5 = 2 * (v12 + v11);
          LOBYTE(v12) = byte_B5D40[v5];
          byte_CC1E0[v6] = v12;
          if ( (unsigned __int8)v12 >= 8u )
          {
            LOBYTE(v5) = (byte_FC1E0[v6] & 0x87) + byte_B5D41[v5];
          }
          else
          {
            v21 = byte_FC1E0[v6] & 0x87;
            word_12C1E0 = 9377 * word_12C1E0 + 9439;
            LOBYTE(v5) = v21 + 16 * ((unsigned __int16)word_12C1E0 % 7u);
          }
          byte_FC1E0[v6] = v5;
        }
        LOBYTE(v6) = v6 + 1;
      }
      LOBYTE(v6) = v6 - v26;
      ++HIBYTE(v6);
      --v24;
    }
    while ( v24 );
  }
  v13 = v29;
  v27 = v26 + 1;
  v14 = v23 + 1;
  if ( v23 != -1 )
  {
    do
    {
      for ( BYTE1(v5) = v27; BYTE1(v5); --BYTE1(v5) )
      {
        LOBYTE(v13) = v13 + 1;
        ++HIBYTE(v13);
        v15 = v13;
        LOBYTE(v13) = v13 - 2;
        v16 = byte_DC1E0[v15];
        HIBYTE(v13) -= 2;
        v17 = v13;
        LOBYTE(v13) = v13 + 1;
        LOBYTE(v5) = byte_DC1E0[v17] - v16 + 32;
        ++HIBYTE(v13);
        if ( (char)v5 >= 28 )
        {
          if ( (char)v5 > 40 )
            LOBYTE(v5) = (v5 & 7) + 40;
        }
        else
        {
          LOBYTE(v5) = (v5 & 3) + 28;
        }
        v18 = v13;
        LOBYTE(v13) = v13 + 1;
        v19 = byte_FC1E0[v18] & 0xF7;
        byte_EC1E0[v18] = v5;
        byte_FC1E0[v18] = v19;
      }
      LOBYTE(v13) = v13 - v27;
      ++HIBYTE(v13);
      --v14;
    }
    while ( v14 );
  }
  return v5;
}
// 12C1E0: using guessed type __int16 word_12C1E0;

//----- (00033E10) --------------------------------------------------------
char sub_33E10(unsigned __int16 a1, __int16 a2)
{
  unsigned __int16 v2; // cx
  char v3; // ah
  char v4; // al
  unsigned __int16 v5; // dx
  unsigned __int16 v6; // dx
  unsigned __int16 v7; // dx
  unsigned __int16 v8; // dx
  int v9; // eax
  unsigned __int16 v10; // cx
  _BOOL1 v11; // zf
  unsigned __int16 v12; // dx
  int v13; // eax
  unsigned __int16 v14; // dx
  int v15; // eax
  unsigned __int16 v16; // dx
  int v17; // edx
  unsigned __int16 v18; // cx
  char v19; // bl
  unsigned __int16 v20; // dx
  char v21; // al
  unsigned __int16 v22; // dx
  unsigned __int16 v23; // si
  char v24; // dh
  char v26; // [esp+0h] [ebp-20h]
  char v27; // [esp+4h] [ebp-1Ch]
  char v28; // [esp+4h] [ebp-1Ch]
  char v29; // [esp+8h] [ebp-18h]
  char v30; // [esp+Ch] [ebp-14h]
  char v31; // [esp+Ch] [ebp-14h]
  char v32; // [esp+Ch] [ebp-14h]
  char i; // [esp+10h] [ebp-10h]
  unsigned __int16 v34; // [esp+24h] [ebp+4h]

  //fix
  v34 = 0;
  //fix

  v2 = a1;
  v30 = a2 - a1 + 1;
  v3 = HIBYTE(a2) - HIBYTE(a1) + 1;
  v27 = v3;
  if ( HIBYTE(a2) - HIBYTE(a1) != 0xFF )
  {
    do
    {
      v4 = a2 - a1 + 1;
      if ( (_BYTE)a2 - (_BYTE)a1 != 0xFF )
      {
        do
        {
          v5 = v2;
          LOBYTE(v2) = v2 - 1;
          byte_CC1E0[v5] = 1;
          v6 = v2;
          --HIBYTE(v2);
          byte_CC1E0[v6] = 1;
          v7 = v2;
          LOBYTE(v2) = v2 + 1;
          byte_CC1E0[v7] = 1;
          v8 = v2;
          ++HIBYTE(v2);
          byte_CC1E0[v8] = 1;
          LOBYTE(v2) = v2 + 1;
          --v4;
        }
        while ( v4 );
      }
      LOBYTE(v2) = v2 - v30;
      ++HIBYTE(v2);
      --v3;
    }
    while ( v3 );
  }
  LOBYTE(a1) = a1 - 1;
  LOBYTE(v9) = v30 + 1;
  v31 = v30 + 1;
  --HIBYTE(a1);
  v10 = a1;
  v11 = v27 == -1;
  v28 = v27 + 1;
  v29 = v28;
  if ( !v11 )
  {
    do
    {
      LOBYTE(v9) = v31;
      for ( i = v31; i; --i )
      {
        v9 = v10;
        if ( byte_CC1E0[v10] == 1 )
        {
          LOBYTE(v10) = v10 + 1;
          v12 = v10;
          ++HIBYTE(v10);
          v13 = 49 * (byte_FC1E0[v12] & 7) + 343 * (byte_FC1E0[v9] & 7);
          v14 = v10;
          LOBYTE(v10) = v10 - 1;
          v15 = 7 * (byte_FC1E0[v14] & 7) + v13;
          v16 = v10;
          --HIBYTE(v10);
          v17 = 2 * ((byte_FC1E0[v16] & 7) + v15);
          LOBYTE(v15) = byte_B5D40[v17];
          byte_CC1E0[v10] = v15;
          if ( (unsigned __int8)v15 >= 8u )
          {
            LOBYTE(v9) = byte_B5D41[v17] + (byte_FC1E0[v10] & 0x87);
          }
          else
          {
            v26 = byte_FC1E0[v10] & 0x87;
            word_12C1E0 = 9377 * word_12C1E0 + 9439;
            LOBYTE(v9) = v26 + 16 * ((unsigned __int16)word_12C1E0 % 7u);
          }
          byte_FC1E0[v10] = v9;
        }
        LOBYTE(v10) = v10 + 1;
      }
      LOBYTE(v10) = v10 - v31;
      ++HIBYTE(v10);
      --v29;
    }
    while ( v29 );
  }
  v18 = v34;
  v32 = v31 + 1;
  v19 = v28 + 1;
  if ( v28 != -1 )
  {
    do
    {
      for ( BYTE1(v9) = v32; BYTE1(v9); --BYTE1(v9) )
      {
        LOBYTE(v18) = v18 + 1;
        ++HIBYTE(v18);
        v20 = v18;
        LOBYTE(v18) = v18 - 2;
        v21 = byte_DC1E0[v20];
        HIBYTE(v18) -= 2;
        v22 = v18;
        LOBYTE(v18) = v18 + 1;
        LOBYTE(v9) = byte_DC1E0[v22] - v21 + 32;
        ++HIBYTE(v18);
        if ( (char)v9 >= 28 )
        {
          if ( (char)v9 > 40 )
            LOBYTE(v9) = (v9 & 7) + 40;
        }
        else
        {
          LOBYTE(v9) = (v9 & 3) + 28;
        }
        v23 = v18;
        LOBYTE(v18) = v18 + 1;
        v24 = byte_FC1E0[v23] & 0xF7;
        byte_EC1E0[v23] = v9;
        byte_FC1E0[v23] = v24;
      }
      LOBYTE(v18) = v18 - v32;
      ++HIBYTE(v18);
      --v19;
    }
    while ( v19 );
  }
  return v9;
}
// 12C1E0: using guessed type __int16 word_12C1E0;

//----- (00034070) --------------------------------------------------------
unsigned __int16 sub_34070()
{
  unsigned __int16 result; // ax

  result = *(_WORD *)(dword_AE408 + 17);
  if ( result >= 0x1Cu )
  {
    if ( result > 0x1Cu && (result < 0x21u || result > 0x21u && result != 39) )
      return result;
LABEL_10:
    result = dword_AE408;
    ++*(_WORD *)(dword_AE408 + 17);
    return result;
  }
  if ( result >= 8u && (result <= 8u || result == 17) )
    goto LABEL_10;
  return result;
}
// AE408: using guessed type int dword_AE408;

//----- (000340B0) --------------------------------------------------------
int sub_340B0(int a1, __int16 a2, __int16 a3, unsigned __int16 a4, int a5)
{
  int v5; // edx
  int *v7; // eax
  int v8; // ebx
  __int16 v9; // ax
  int v10; // ebx
  int v11; // ebx
  int v12; // eax

  v5 = a5;
  if ( sub_34DD0(a3, a4, a5) == -1 )
    return -1;
  sub_34B40();
  if ( (*(_BYTE *)dword_AE408 & 8) != 0 )
  {
    nullsub_2();
  }
  else
  {
    *(_BYTE *)(dword_AE408 + 23) = 0;
    sub_3F1D0();
    sub_58F90();
    v7 = sub_41230();
    sub_44730((int)v7);
    if ( (*(_BYTE *)(dword_AE408 + 1) & 1) != 0 )
    {
      byte_939CD = 0;
      byte_939E5 = 0;
      byte_939CC = 0;
      byte_939E4 = 0;
      sub_40440((int)aDataFtextDat);
      sub_44700((const char *)dword_AE41C, (int)dword_AE238, 80);
    }
    else
    {
      sub_4A980();
    }
    *(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13327) = 0;
    while ( 1 )
    {
      v5 = 2049 * *(__int16 *)(dword_AE400 + 8);
      if ( *(_BYTE *)(v5 + dword_AE400 + 13327) )
        break;
      sub_61CC0(0, 0x10u, 0);
      if ( (*(_BYTE *)(dword_AE408 + 1) & 1) == 0 )
      {
        sub_31A00();
        v8 = 1;
        if ( word_12F02E == 8 )
        {
          sub_34C80();
          v8 = 8;
        }
        sub_41490();
        sub_42530(2);
        LOWORD(a1) = 1;
        byte_939E5 = byte_939E4;
        LOBYTE(dword_12CA7C) = 1;
        LOBYTE(v9) = byte_939CC;
        byte_939CD = byte_939CC;
        LOBYTE(dword_96880) = 0;
        do
          sub_4AB20(v9, (const char *)a1, (const char *)4, a2, a3);
        while ( !(_BYTE)dword_96880 );
        sub_34070();
        sub_61CC0(0, 0x10u, 0);
        a1 = dword_AE450;
        sub_5C05C(dword_AE450);
        LOBYTE(a1) = *(_BYTE *)(2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 13327);
        if ( !(_BYTE)a1 )
          sub_34460();
        sub_34B00();
        sub_61610((int)aDataSnds00Dat);
        sub_61610((int)aDataMusic00Dat);
        sub_41540();
        if ( !*(_BYTE *)(2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 13327) )
        {
          sub_5D070(0);
          sub_5CEF0(0);
        }
        if ( (*(_DWORD *)dword_AE408 & 4) == 0 )
        {
          sub_31A00();
          if ( v8 == 8 )
            sub_34C80();
          sub_31A60();
        }
        sub_42530(3);
      }
      if ( !*(_BYTE *)(2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 13327) )
      {
        a2 = *(_WORD *)(dword_AE408 + 17);
        sub_407A0();
        if ( word_12F02E == 1 && !dword_AE404 )
          dword_AE404 = sub_42540(64000);
      }
      while ( 1 )
      {
        v11 = dword_AE400;
        if ( *(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13327) )
          break;
        if ( byte_939CC && byte_939CD && word_939D6 )
        {
          a1 = 3;
          a2 = 9377 * a2 + 9439;
          *(_DWORD *)(dword_AE400 + 576) = a2 % 3u + 1;
          sub_5D290(*(_WORD *)(v11 + 576));
        }
        sub_59720();
        sub_34610(a1, 4, a2);
        sub_5D010();
        sub_20E60();
        sub_61CC0(0, 0x10u, 0);
        v10 = 2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400;
        if ( (*(_WORD *)(v10 + 13325) & 6) != 4 )
        {
          if ( (*(_BYTE *)(v10 + 13325) & 2) != 0 )
          {
            *(_WORD *)(v10 + 13325) = 2;
            sub_448E0();
            ++*(_WORD *)(dword_AE408 + 17);
          }
          else
          {
            *(_WORD *)(v10 + 13325) = 8;
          }
          break;
        }
        sub_408D0();
        *(_WORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13325) = 4;
      }
      sub_61CC0(0, 0x10u, 0);
    }
    sub_358A0();
  }
  LOWORD(v12) = sub_61CC0(0, 0x10u, 0);
  sub_34C60(v12, v5);
  sub_433C0();
  return 0;
}
// 341F3: variable 'v9' is possibly undefined
// 3444C: variable 'v12' is possibly undefined
// 24E1B: using guessed type int nullsub_2(void);
// 939CC: using guessed type char byte_939CC;
// 939CD: using guessed type char byte_939CD;
// 939D6: using guessed type __int16 word_939D6;
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// 96880: using guessed type int dword_96880;
// AE238: using guessed type int dword_AE238[17];
// AE400: using guessed type int dword_AE400;
// AE404: using guessed type int dword_AE404;
// AE408: using guessed type int dword_AE408;
// AE41C: using guessed type int dword_AE41C;
// AE450: using guessed type int dword_AE450;
// 12CA7C: using guessed type int dword_12CA7C;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00034460) --------------------------------------------------------
int sub_34460()
{
  int result; // eax

  sub_3EEA0(aDataSmatitleDa, (char *)dword_12EFF4);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  sub_3EEA0(aDataSmatitlePa, (char *)dword_AE428);
  sub_61CC0((unsigned __int8 *)dword_AE428, 0x20u, 0);
  result = dword_AE400;
  *(_DWORD *)(dword_AE400 + 581) = 1;
  *(_DWORD *)(result + 585) = 0;
  *(_DWORD *)(result + 589) = 0;
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE428: using guessed type int dword_AE428;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (000344F0) --------------------------------------------------------
int sub_344F0()
{
  char *v1; // [esp-4h] [ebp-4h]

  sub_61CC0(0, 0x10u, 0);
  v1 = (char *)dword_AE428;
  *(_DWORD *)(dword_AE400 + 581) = 0;
  return sub_3EEA0(aDataPal00Dat, v1);
}
// AE400: using guessed type int dword_AE400;
// AE428: using guessed type int dword_AE428;

//----- (00034530) --------------------------------------------------------
void sub_34530(__int16 a1, __int16 a2, __int16 a3)
{
  unsigned __int8 v3; // bl
  int j; // ebx
  int i; // ebx

  if ( !*(_BYTE *)(dword_AE400 + 8603) )
    sub_34690();
  if ( (*(_BYTE *)(dword_AE408 + 2) & 1) == 0 )
    sub_590D0();
  if ( (*(_BYTE *)dword_AE408 & 4) == 0 )
    sub_17C20(a1, a2, a3);
  sub_3C9D0();
  if ( (*(_BYTE *)(dword_AE408 + 2) & 1) == 0 )
    sub_415C0();
  v3 = *(_BYTE *)(dword_AE408 + 150);
  if ( v3 )
  {
    if ( v3 <= 1u )
    {
      for ( i = 0; i < 4; ++i )
        sub_41780();
    }
    else if ( v3 == 2 )
    {
      for ( j = 0; j < 16; ++j )
        sub_41780();
    }
  }
  else
  {
    sub_41780();
  }
  sub_55100();
  sub_20FB0();
  *(_DWORD *)(dword_AE408 + 153) = dword_AC5D4 - *(_DWORD *)(dword_AE408 + 153);
  sub_5A560();
  *(_DWORD *)(dword_AE408 + 153) = dword_AC5D4;
  sub_30B30();
}
// AC5D4: using guessed type int dword_AC5D4;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00034610) --------------------------------------------------------
int sub_34610(__int16 a1, __int16 a2, __int16 a3)
{
  int v3; // ebx
  int result; // eax

  v3 = dword_AE400;
  *(_BYTE *)(dword_AE408 + 23) = 0;
  *(_WORD *)(v3 + 2049 * *(__int16 *)(v3 + 8) + 13325) = 0;
  while ( 1 )
  {
    result = 2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400;
    if ( *(_BYTE *)(result + 13327) || (*(_BYTE *)(result + 13325) & 8) != 0 )
      break;
    sub_34530(a1, a2, a3);
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00034690) --------------------------------------------------------
char sub_34690()
{
  int v0; // ebx
  __int16 v1; // ax
  int i; // eax
  int v3; // edx
  int j; // eax
  int v5; // edx
  int k; // eax
  int v7; // edx
  int m; // eax
  int n; // eax
  int ii; // ebx
  char v11; // al

  v0 = dword_AE408;
  LOBYTE(v1) = *(_BYTE *)(dword_AE408 + 23);
  if ( (unsigned __int8)v1 < 2u )
  {
    sub_344F0();
    LOBYTE(v1) = dword_AE408;
    ++*(_BYTE *)(dword_AE408 + 23);
  }
  else if ( (unsigned __int8)v1 <= 2u )
  {
    LOBYTE(v1) = v1 + 1;
    *(_BYTE *)(dword_AE408 + 152) = 1;
    *(_BYTE *)(v0 + 23) = v1;
  }
  else if ( (_BYTE)v1 == 3 )
  {
    if ( *(_BYTE *)(dword_AE400 + 8603) )
      sub_61EC8();
    LOBYTE(v1) = *(_BYTE *)(dword_AE408 + 152);
    switch ( (char)v1 )
    {
      case 1:
        v1 = sub_61CC0((unsigned __int8 *)dword_AE428, 4u, 1);
        if ( v1 == 4 )
        {
          LOBYTE(v1) = dword_AE408;
          *(_BYTE *)(dword_AE408 + 152) = 0;
        }
        return v1;
      case 2:
        for ( i = 3; i != 768; byte_B700F[i] = *(_BYTE *)(v3 + i - 1) )
        {
          v3 = dword_AE428;
          i += 3;
          dword_B7310 = 255;
          byte_B700D[i] = 63;
          byte_B700E[i] = *(_BYTE *)(v3 + i - 2);
        }
        goto LABEL_61;
      case 3:
        for ( j = 3; j != 768; byte_B700F[j] = dword_B7310 )
        {
          dword_B7310 = *(unsigned __int8 *)(dword_AE428 + j) + 48;
          if ( dword_B7310 < 0 )
            dword_B7310 = 0;
          if ( dword_B7310 > 63 )
            dword_B7310 = 63;
          byte_B7010[j] = dword_B7310;
          v5 = dword_AE428;
          byte_B7011[j] = *(_BYTE *)(dword_AE428 + j + 1);
          dword_B7310 = *(unsigned __int8 *)(v5 + j + 2) + 64;
          if ( dword_B7310 < 0 )
            dword_B7310 = 0;
          if ( dword_B7310 > 63 )
            dword_B7310 = 63;
          j += 3;
        }
        goto LABEL_61;
      case 4:
        for ( k = 3; k != 768; byte_B700F[k] = 63 )
        {
          v7 = dword_AE428;
          k += 3;
          dword_B7310 = 255;
          byte_B700D[k] = *(_BYTE *)(dword_AE428 + k - 3);
          byte_B700E[k] = *(_BYTE *)(v7 + k - 2);
        }
        goto LABEL_61;
      case 5:
        for ( m = 3; m != 768; byte_B700F[m] = dword_B7310 )
        {
          dword_B7310 = *(unsigned __int8 *)(dword_AE428 + m + 2) - 32;
          if ( dword_B7310 < 0 )
            dword_B7310 = 0;
          if ( dword_B7310 > 63 )
            dword_B7310 = 63;
          byte_B7010[m] = dword_B7310;
          dword_B7310 = *(unsigned __int8 *)(dword_AE428 + m + 1) - 32;
          if ( dword_B7310 < 0 )
            dword_B7310 = 0;
          if ( dword_B7310 > 63 )
            dword_B7310 = 63;
          byte_B7011[m] = dword_B7310;
          dword_B7310 = *(unsigned __int8 *)(dword_AE428 + m + 2) - 32;
          if ( dword_B7310 < 0 )
            dword_B7310 = 0;
          if ( dword_B7310 > 63 )
            dword_B7310 = 63;
          m += 3;
        }
        goto LABEL_61;
      case 6:
        for ( n = 3; n != 768; byte_B700F[n] = dword_B7310 )
        {
          dword_B7310 = *(unsigned __int8 *)(dword_AE428 + n + 2) + 48;
          if ( dword_B7310 < 0 )
            dword_B7310 = 0;
          if ( dword_B7310 > 63 )
            dword_B7310 = 63;
          byte_B7010[n] = dword_B7310;
          dword_B7310 = *(unsigned __int8 *)(dword_AE428 + n + 1) + 32;
          if ( dword_B7310 < 0 )
            dword_B7310 = 0;
          if ( dword_B7310 > 63 )
            dword_B7310 = 63;
          byte_B7011[n] = dword_B7310;
          dword_B7310 = *(unsigned __int8 *)(dword_AE428 + n + 2) + 32;
          if ( dword_B7310 < 0 )
            dword_B7310 = 0;
          if ( dword_B7310 > 63 )
            dword_B7310 = 63;
          n += 3;
        }
        goto LABEL_61;
      case 7:
        for ( ii = 3; ii != 768; byte_B700F[ii] = v11 )
        {
          dword_B7310 = (*(unsigned __int8 *)(ii + dword_AE428 + 1)
                       + *(unsigned __int8 *)(ii + dword_AE428)
                       + *(unsigned __int8 *)(ii + dword_AE428 + 2))
                      / 3;
          ii += 3;
          v11 = dword_B7310;
          byte_B700D[ii] = dword_B7310;
          byte_B700E[ii] = v11;
        }
LABEL_61:
        sub_61EC8();
        sub_319A0((unsigned __int8 *)byte_B7010);
        LOBYTE(v1) = dword_AE408;
        *(_BYTE *)(dword_AE408 + 152) = 1;
        break;
      default:
        return v1;
    }
  }
  return v1;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE428: using guessed type int dword_AE428;
// B7310: using guessed type int dword_B7310;

//----- (00034B00) --------------------------------------------------------
int sub_34B00()
{
  sub_40440((int)aSearchd);
  if ( word_12F02E == 1 )
    sub_40440((int)aWscreen);
  else
    sub_40440((int)aWscreen_0);
  sub_59500((unsigned int **)&off_99974);
  return sub_11540();
}
// 99974: using guessed type int *off_99974;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00034B40) --------------------------------------------------------
int sub_34B40()
{
  int v0; // ebp
  int v1; // edi
  int v2; // ebx
  int v3; // esi
  int v5; // [esp+0h] [ebp-2Ch]
  int v6; // [esp+4h] [ebp-28h]
  unsigned __int8 v7; // [esp+8h] [ebp-24h]
  unsigned __int8 v8; // [esp+14h] [ebp-18h]
  unsigned __int8 v9; // [esp+18h] [ebp-14h]

  sub_5ACA0();
  sub_5AD10((int)aLoadAllDataFil);
  sub_34B00();
  sub_5AD10((int)aInitialiseColo);
  v5 = 0;
  v0 = 0;
  v8 = 3;
  do
  {
    v6 = 0;
    v1 = v0;
    v7 = 3;
    do
    {
      v2 = 0;
      v3 = v1;
      v9 = 3;
      do
      {
        ++v3;
        ++v2;
        byte_AD167[v3] = sub_5CC70((unsigned __int8 *)dword_AE428, v8, v7, v9);
        v9 += 4;
      }
      while ( v2 < 16 );
      v1 += 16;
      v7 += 4;
      ++v6;
    }
    while ( v6 < 16 );
    v0 += 256;
    v8 += 4;
    ++v5;
  }
  while ( v5 < 16 );
  *(_BYTE *)(dword_AE408 + 23) = 1;
  return sub_5A3C0(0);
}
// AE408: using guessed type int dword_AE408;
// AE428: using guessed type int dword_AE428;

//----- (00034C60) --------------------------------------------------------
int sub_34C60(int a1, int a2)
{
  sub_58F00(a1, a2);
  sub_44840();
  sub_61610((int)aSearchd);
  return sub_5ACA0();
}

//----- (00034C80) --------------------------------------------------------
int sub_34C80()
{
  int v0; // eax
  int v1; // eax
  int result; // eax

  sub_61CC0(0, 0x10u, 0);
  sub_315C0();
  sub_426E0(dword_AE404);
  dword_AE404 = 0;
  sub_3F370();
  sub_59560((unsigned int **)&off_99974);
  if ( word_12F02E == 1 )
  {
    sub_61610((int)aWscreen);
    word_12F02E = 8;
    sub_40440((int)aWscreen_0);
    v0 = sub_42540((int)&loc_4AFFD + 3);
  }
  else
  {
    sub_61610((int)aWscreen_0);
    word_12F02E = 1;
    sub_40440((int)aWscreen);
    v0 = sub_42540(64000);
  }
  dword_AE404 = v0;
  sub_59500((unsigned int **)&off_99974);
  if ( (word_12F02E & 1) != 0 )
    v1 = sub_61B90((unsigned __int8 *)dword_12EFF4);
  else
    v1 = sub_61C30((unsigned __int8 *)dword_12EFF4);
  if ( (word_12F02E & 1) != 0 )
    sub_411D7(v1, (void *)dword_12EFF4, 0xC8u, 0);
  else
    sub_411FD(v1, (void *)dword_12EFF4, 0x1E0u, 0);
  sub_5C214();
  sub_5C05C(dword_AE450);
  result = dword_AE408;
  *(_BYTE *)(dword_AE408 + 23) = 0;
  return result;
}
// 99974: using guessed type int *off_99974;
// AE404: using guessed type int dword_AE404;
// AE408: using guessed type int dword_AE408;
// AE450: using guessed type int dword_AE450;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00034DD0) --------------------------------------------------------
__int16 sub_34DD0fix(__int16 a1, unsigned __int16 a2, int a3)
{
  _DWORD *v3; // edx
  __int16 v4; // cx
  int i; // ebx
  char *v6; // edi
  char *v7; // esi
  char v8; // al
  char v9; // al
  int *v10; // edi
  char *v11; // esi
  char v12; // al
  char v13; // al
  int *v14; // esi
  char *v15; // edi
  char v16; // al
  char v17; // al
  int *v18; // esi
  char *v19; // edi
  char v20; // al
  char v21; // al
  int v22; // eax
  char v23; // dh
  _BYTE *v24; // eax
  int v25; // eax
  int v26; // eax
  __int16 v27; // dx
  char *v28; // esi
  int v29; // edi
  char *v30; // edi
  char v31; // al
  char v32; // al
  _BYTE *v33; // eax
  __int16 v34; // dx
  __int16 v35; // dx
  int v36; // eax
  char v37; // ch
  int v38; // eax
  int v39; // esi
  __int16 *v40; // eax
  __int16 v41; // bx
  int v43; // [esp+0h] [ebp-E0h] BYREF
  int v44; // [esp+4h] [ebp-DCh]
  int v45; // [esp+8h] [ebp-D8h]
  char v46; // [esp+Ch] [ebp-D4h]
  char v47[32]; // [esp+20h] [ebp-C0h] BYREF
  char v48[32]; // [esp+40h] [ebp-A0h] BYREF
  char v49[32]; // [esp+60h] [ebp-80h] BYREF
  int v50; // [esp+80h] [ebp-60h]
  int v51; // [esp+84h] [ebp-5Ch]
  int v52; // [esp+88h] [ebp-58h]
  int v53; // [esp+8Ch] [ebp-54h]
  int v54; // [esp+90h] [ebp-50h]
  int v55; // [esp+94h] [ebp-4Ch]
  int v56; // [esp+98h] [ebp-48h]
  int v57; // [esp+9Ch] [ebp-44h]
  int v58; // [esp+A0h] [ebp-40h]
  int v59; // [esp+A4h] [ebp-3Ch]
  int v60; // [esp+A8h] [ebp-38h]
  int v61; // [esp+ACh] [ebp-34h]
  int v62; // [esp+B0h] [ebp-30h]
  int v63; // [esp+B4h] [ebp-2Ch]
  int v64; // [esp+B8h] [ebp-28h]
  int v65; // [esp+BCh] [ebp-24h]
  char v66; // [esp+C0h] [ebp-20h]
  char v67; // [esp+C4h] [ebp-1Ch]
  char v68; // [esp+C8h] [ebp-18h]
  char v69; // [esp+CCh] [ebp-14h]

  //fix
  v44 = 0;
  v45 = 0;
  v46 = 0;
  //fix;

  LOWORD(v3) = 0;
  v4 = 0;
  v68 = 0;
  v64 = 0;
  v55 = 0;
  v54 = 0;
  v50 = 0;
  v59 = 1;
  v53 = 0;
  v58 = 1;
  v60 = 0;
  v56 = 0;
  v52 = 0;
  v51 = 0;
  v63 = 0;
  v62 = 0;
  v61 = 0;
  v57 = 0;
  byte_AE45A = 0;
  strcpy(v48, "PLAYER");
  v65 = 2;
  v67 = 0;
  v69 = 0;
  strcpy(v49, "CARPET");
  v66 = 0;
  for ( i = 1; i < a2; ++i )
  {
    LOBYTE(v4) = **(_BYTE **)(a3 + 4 * i);
    if ( (_BYTE)v4 != 45 && (_BYTE)v4 != 47 )
    {
      printf("ERROR : Incorrect command : %d\n", i);
      v68 = -1;
      break;
    }
    v3 = (_DWORD *)(a3 + 4 * i);
    v6 = v47;
    v7 = (char *)(*v3 + 1);
    do
    {
      v8 = *v7;
      *v6 = *v7;
      if ( !v8 )
        break;
      v9 = v7[1];
      v7 += 2;
      v6[1] = v9;
      v6 += 2;
    }
    while ( v9 );
    LOBYTE(v43) = 0;
    if ( i + 1 < a2 )
    {
      v10 = &v43;
      v11 = (char *)v3[1];
      do
      {
        v12 = *v11;
        *(_BYTE *)v10 = *v11;
        if ( !v12 )
          break;
        v13 = v11[1];
        v11 += 2;
        *((_BYTE *)v10 + 1) = v13;
        v10 = (int *)((char *)v10 + 2);
      }
      while ( v13 );
    }
    if ( !stricmp(aDigijoy, v47) )
    {
      v67 = 1;
    }
    else if ( !stricmp(aAnojoy, v47) )
    {
      v69 = 1;
    }
    else if ( !stricmp(aAnojoy4, v47) )
    {
      v69 = 1;
    }
    else if ( !stricmp(aVfx, v47) )
    {
      v61 = 1;
    }
    else if ( !stricmp(aHelp, v47) )
    {
      v64 = 1;
    }
    else if ( !stricmp(aDebug, v47) )
    {
      byte_AE45A = 1;
    }
    else if ( !stricmp(aNetwork, v47) )
    {
      v54 = 1;
    }
    else if ( !stricmp(aCustom, v47) )
    {
      v55 = 1;
    }
    else if ( !stricmp(aSetsound, v47) )
    {
      v53 = 1;
    }
    else if ( !stricmp(aDemo, v47) )
    {
      ++i;
      v57 = unknown_libname_1((uint32)&v43);
    }
    else if ( !stricmp(aDetail, v47) )
    {
      ++i;
      v58 = unknown_libname_1((uint32)&v43);
    }
    else if ( !stricmp(aCheat, v47) )
    {
      ++i;
      v60 = unknown_libname_1((uint32)&v43);
    }
    else if ( !stricmp(aName, v47) )
    {
      v14 = &v43;
      v15 = v48;
      ++i;
      do
      {
        v16 = *(_BYTE *)v14;
        *v15 = *(_BYTE *)v14;
        if ( !v16 )
          break;
        v17 = *((_BYTE *)v14 + 1);
        v14 = (int *)((char *)v14 + 2);
        v15[1] = v17;
        v15 += 2;
      }
      while ( v17 );
    }
    else if ( !stricmp(aLevel, v47) )
    {
      ++i;
      v56 = unknown_libname_1((uint32)&v43);
    }
    else if ( !stricmp(aMovie, v47) )
    {
      ++i;
      v52 = unknown_libname_1((uint32)&v43);
    }
    else if ( !stricmp(aRoll, v47) )
    {
      ++i;
      v51 = unknown_libname_1((uint32)&v43);
    }
    else if ( !stricmp(aTime, v47) )
    {
      v63 = 1;
    }
    else if ( !stricmp(aPassword, v47) )
    {
      ++i;
      v62 = unknown_libname_1((uint32)&v43);
    }
    else if ( !stricmp(aPlayers, v47) )
    {
      ++i;
      v65 = unknown_libname_1((uint32)&v43);
    }
    else
    {
      if ( stricmp(aSession, v47) )
      {
        printf("ERROR : Incorrect command : %d\n", i);
        LOBYTE(v3) = -1;
        v68 = -1;
        break;
      }
      v18 = &v43;
      v19 = v49;
      ++i;
      do
      {
        v20 = *(_BYTE *)v18;
        *v19 = *(_BYTE *)v18;
        if ( !v20 )
          break;
        v21 = *((_BYTE *)v18 + 1);
        v18 = (int *)((char *)v18 + 2);
        v19[1] = v21;
        v19 += 2;
      }
      while ( v21 );
    }
  }
  LOWORD(v22) = v68;
  if ( v68 != -1 )
  {
    if ( v54 )
    {
      LOWORD(v22) = sub_43270(v68, (__int16)v3);
      v54 = 0;
    }
    if ( v61 )
    {
      v22 = sub_5AF50();
      if ( v22 )
      {
        v23 = byte_90B23 | 8;
        *(_BYTE *)(dword_AE400 + 8606) = 1;
        byte_90B23 = v23;
        LOWORD(v22) = printf("VFX\n");
      }
    }
    if ( v67 )
    {
      LOBYTE(v22) = sub_3F7D0(v43);
      if ( byte_B7700 )
        byte_90B23 |= 2u;
    }
    if ( v69 )
    {
      LOBYTE(v22) = sub_3F820(v22, v4, v43, v44, v45, v46);
      if ( byte_B7700 )
      {
        BYTE1(v22) = 1;
        byte_B7700 = 1;
        byte_90B23 |= 1u;
      }
    }
    if ( v66 )
    {
      sub_3F820(v22, v4, v43, v44, v45, v46);
      if ( byte_B7700 )
      {
        byte_B7700 = 1;
        byte_90B23 |= 0x20u;
      }
    }
    dword_12F080 = sub_425C0(256);
    dword_AE400 = sub_42540((int)sub_38D09);
    dword_AE408 = sub_42540(36478);
    v24 = (_BYTE *)dword_AE400;
    *(_BYTE *)(dword_AE400 + 8621) = 1;
    v24[8622] = 1;
    v24[8623] = 1;
    v24[8624] = 1;
    v24[8625] = 1;
    v24[8626] = 1;
    v24[8627] = 1;
    v24[8628] = 1;
    v24[8629] = 1;
    v24[8630] = 1;
    v24[8631] = 1;
    sub_19470(a1);
    v25 = dword_AE400;
    if ( *(_BYTE *)(dword_AE408 + 8) )
    {
      *(_BYTE *)(dword_AE400 + 8597) = 1;
      *(_BYTE *)(v25 + 8599) = 1;
    }
    else
    {
      *(_BYTE *)(dword_AE400 + 8597) = 0;
      *(_BYTE *)(v25 + 8599) = 0;
    }
    v26 = dword_AE400;
    *(_BYTE *)(dword_AE400 + 8598) = 1;
    v27 = v65;
    *(_BYTE *)(v26 + 8602) = 1;
    v28 = v49;
    *(_BYTE *)(v26 + 8601) = 1;
    v29 = dword_AE408;
    *(_BYTE *)(v26 + 8600) = 40;
    v30 = (char *)(v29 + 117);
    *(_WORD *)(v26 + 10) = v27;
    do
    {
      v31 = *v28;
      *v30 = *v28;
      if ( !v31 )
        break;
      v32 = v28[1];
      v28 += 2;
      v30[1] = v32;
      v30 += 2;
    }
    while ( v32 );
    *(_BYTE *)(dword_AE408 + 29) = byte_A9058;
    if ( !v58 )
    {
      v33 = (_BYTE *)dword_AE400;
      *(_BYTE *)(dword_AE400 + 8597) = 0;
      v33[8599] = 0;
      v33[8598] = 0;
      v33[8600] = 40;
    }
    if ( v57 )
    {
      switch ( v57 )
      {
        case 1:
          *(_BYTE *)(dword_AE408 + 1) |= 2u;
          break;
        case 2:
          *(_BYTE *)(dword_AE408 + 1) |= 4u;
          break;
        case 3:
          *(_BYTE *)(dword_AE408 + 1) |= 8u;
          break;
        case 4:
          *(_BYTE *)(dword_AE408 + 1) |= 0x10u;
          break;
        case 5:
          *(_BYTE *)(dword_AE408 + 1) |= 0x20u;
          break;
        default:
          break;
      }
      *(_BYTE *)(dword_AE408 + 1) |= 1u;
    }
    if ( v63 )
      *(_BYTE *)dword_AE408 |= 0x40u;
    if ( v55 )
      *(_BYTE *)(dword_AE408 + 1) |= 1u;
    if ( v64 )
      v68 = -1;
    if ( v54 )
    {
      v34 = *(_WORD *)(dword_AE400 + 10);
      if ( (unsigned __int16)v34 > 1u )
      {
        v35 = sub_43430((char *)(dword_AE408 + 117), v34);
        v36 = dword_AE400;
        *(_WORD *)(dword_AE400 + 8) = v35;
        if ( v35 >= 0 )
          *(_BYTE *)dword_AE408 |= 0x10u;
        else
          *(_WORD *)(v36 + 8) = 0;
      }
      *(_BYTE *)(dword_AE408 + 1) |= 1u;
    }
    if ( v50 )
    {
      v37 = *(_BYTE *)dword_AE408;
      v59 = 8;
      v53 = 0;
      *(_BYTE *)dword_AE408 = v37 | 8;
    }
    *(_DWORD *)(2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 13347) = v60;
    v38 = dword_AE408;
    v39 = v52;
    *(_WORD *)(dword_AE408 + 17) = v56;
    if ( v39 )
      *(_WORD *)(v38 + 13) = v52;
    if ( v51 )
    {
      v40 = (__int16 *)dword_AE408;
      *(_WORD *)(dword_AE408 + 13) = 0;
      v41 = *v40;
      *(__int16 *)((char *)v40 + 15) = v51;
      *v40 = v41 | 0x120;
    }
    if ( byte_AE45A )
    {
      byte_AE45A = 0;
      *(_BYTE *)dword_AE408 |= 0x80u;
    }
    *(_DWORD *)(dword_AE408 + 25) = v62;
    if ( v68 != -1 )
      word_12F02E = v59;
  }
  return v68;
}
// 3532C: variable 'v22' is possibly undefined
// 38D09: using guessed type int sub_38D09();
// 5CC03: using guessed type _DWORD printf(const char *, ...);
// 61EF5: using guessed type _DWORD stricmp(_DWORD, _DWORD);
// 61F36: using guessed type _DWORD unknown_libname_1(_DWORD);
// 90B23: using guessed type char byte_90B23;
// A9058: using guessed type char byte_A9058;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE45A: using guessed type char byte_AE45A;
// B7700: using guessed type char byte_B7700;
// 12F02E: using guessed type __int16 word_12F02E;
// 12F080: using guessed type int dword_12F080;

//----- (000356E0) --------------------------------------------------------
int sub_356E0()
{
  int result; // eax

  word_B7314 = word_9AD90;
  word_B7316 = word_9AD92;
  result = (unsigned __int8)byte_12EF70;
  word_B7318 = (unsigned __int8)byte_12EF70;
  dword_AE410 = 0;
  return result;
}
// 9AD90: using guessed type __int16 word_9AD90;
// 9AD92: using guessed type __int16 word_9AD92;
// AE410: using guessed type int dword_AE410;
// B7314: using guessed type __int16 word_B7314;
// B7316: using guessed type __int16 word_B7316;
// B7318: using guessed type __int16 word_B7318;
// 12EF70: using guessed type char byte_12EF70;

//----- (00035710) --------------------------------------------------------
int sub_35710()
{
  __int16 v0; // ax

  if ( !dword_AE410 )
  {
    if ( word_9AD90 != word_B7314
      || word_9AD92 != word_B7316
      || word_12EFE4
      || word_12EFE2
      || (HIBYTE(v0) = HIBYTE(word_B7316) ^ HIBYTE(word_9AD92), LOBYTE(v0) = byte_12EF70, v0 != word_B7318) )
    {
      word_B7314 = word_9AD90;
      word_B7316 = word_9AD92;
      word_B7318 = (unsigned __int8)byte_12EF70;
      dword_AE410 = 1;
    }
  }
  return dword_AE410;
}
// 9AD90: using guessed type __int16 word_9AD90;
// 9AD92: using guessed type __int16 word_9AD92;
// AE410: using guessed type int dword_AE410;
// B7314: using guessed type __int16 word_B7314;
// B7316: using guessed type __int16 word_B7316;
// B7318: using guessed type __int16 word_B7318;
// 12EF70: using guessed type char byte_12EF70;
// 12EFE2: using guessed type __int16 word_12EFE2;
// 12EFE4: using guessed type __int16 word_12EFE4;

//----- (000357C0) --------------------------------------------------------
void sub_357C0(__int16 a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  int v4; // eax

  if ( !byte_90AD4 )
  {
    LOBYTE(a1) = 1;
    byte_90AD4 = 1;
    if ( (*(_BYTE *)dword_AE408 & 0x48) != 0 )
    {
      v4 = sub_5AD10((int)aSoundDisabled);
      byte_939CD = 0;
      byte_939E5 = 0;
      byte_939CC = 0;
      byte_939E4 = 0;
    }
    else
    {
      sub_5AD10((int)aInitialiseMusi);
      sub_3C570();
      sub_5AD10((int)aInitialiseSoun);
      v4 = sub_3C800(a2, a3, a4);
    }
    if ( byte_939E4 || byte_939CC )
    {
        //fix sub_5D97B(0x78u, (int)sub_357A0, __CS__, (unsigned int)&dword_80010);
      byte_90AD5 = 1;
    }
    else
    {
      sub_5A459(v4, a1);
    }
    switch ( *(_BYTE *)(dword_AE408 + 151) )
    {
      case 0:
        if ( !byte_939E4 )
          goto LABEL_11;
        break;
      case 1:
      case 2:
      case 3:
LABEL_11:
        byte_90090 = 1;
        break;
      default:
        return;
    }
  }
}
// 357A0: using guessed type int sub_357A0();
// 80010: using guessed type int dword_80010;
// 90090: using guessed type char byte_90090;
// 90AD4: using guessed type char byte_90AD4;
// 90AD5: using guessed type char byte_90AD5;
// 939CC: using guessed type char byte_939CC;
// 939CD: using guessed type char byte_939CD;
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// AE408: using guessed type int dword_AE408;

//----- (000358A0) --------------------------------------------------------
int sub_358A0()
{
  if ( !byte_90AD5 )
    return sub_5A4EA();
  sub_5DC91(dword_80010);
  sub_61F90();
  return sub_62020();
}
// 80010: using guessed type int dword_80010;
// 90AD5: using guessed type char byte_90AD5;

//----- (000358D0) --------------------------------------------------------
int sub_358D0(__int16 a1, __int16 a2, __int16 a3)
{
  int result; // eax
  int v4; // ebx
  int v5; // edx

  LOWORD(result) = a2 - a1;
  v4 = (__int16)(a2 - a1);
  v5 = a3 >> 1;
  if ( v4 > v5 )
    return (__int16)(result - a3);
  if ( v4 < -v5 )
    LOWORD(result) = a3 + result;
  return (__int16)result;
}

//----- (00035900) --------------------------------------------------------
int sub_35900(__int16 a1, int a2, char a3, char a4)
{
  unsigned __int16 v4; // ax
  __int16 v5; // bx
  unsigned __int16 v6; // ax
  int result; // eax

  LOBYTE(v4) = a1;
  HIBYTE(v4) = a2;
  LOBYTE(v5) = byte_DC1E0[v4];
  LOBYTE(v6) = a3;
  v5 = (unsigned __int8)v5;
  HIBYTE(v6) = a4;
  if ( (unsigned __int8)byte_DC1E0[v6] > (int)(unsigned __int8)v5 )
    LOBYTE(v5) = byte_DC1E0[v6];
  word_AE454 = a1 << 8;
  result = a2 << 8;
  word_AE458 = 32 * v5;
  word_AE456 = (_WORD)a2 << 8;
  return result;
}
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;
// AE458: using guessed type __int16 word_AE458;

//----- (00035960) --------------------------------------------------------
int sub_35960(__int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4)
{
  __int16 v4; // si
  int result; // eax
  int v6; // edi
  char v7; // al
  int v8; // ebp
  int v9; // ebx
  int v10; // edi
  _BOOL1 i; // zf
  int v12; // eax
  int v13; // eax
  int v14; // edx
  signed int v15; // ebp
  int v16; // ebx
  int v17; // edi
  int v18; // eax
  int v19; // edx
  __int16 v20; // dx
  int v21; // [esp+0h] [ebp-28h]
  int v22; // [esp+10h] [ebp-18h]
  int v23; // [esp+10h] [ebp-18h]
  int v24; // [esp+14h] [ebp-14h]
  int v25; // [esp+14h] [ebp-14h]

  v4 = a1;
  v21 = sub_358D0(a1, a3, 256);
  result = sub_358D0(a2, a4, 256);
  v6 = result;
  if ( v21 || result )
  {
    if ( v21 < 0 )
    {
      v6 = -result;
      v4 = a3;
      v21 = -v21;
      LOBYTE(a3) = a1;
      v7 = a2;
      a2 = a4;
      LOBYTE(a4) = v7;
    }
    if ( (int)abs32(v6) >= v21 )
    {
      v15 = abs32(v6 / 10) + 1;
      v16 = v6 / v15;
      v17 = v6 % v15;
      v25 = v21 / v15;
      v23 = v21 % v15;
      do
      {
        sub_35900(v4, a2, a3, a4);
        v18 = sub_373F0((int)&word_AE454, 10, 27);
        if ( v16 >= 0 )
        {
          *(_BYTE *)(v18 + 70) = 28;
          LOWORD(v19) = v17 + v16;
        }
        else
        {
          *(_BYTE *)(v18 + 70) = 27;
          v19 = -v16 - v17;
        }
        *(_WORD *)(v18 + 26) = v19;
        a2 += v16 + v17;
        sub_35900(v4, a2, a3, a4);
        result = sub_373F0((int)&word_AE454, 10, 27);
        v17 = 0;
        *(_BYTE *)(result + 70) = 29;
        v20 = v23 + v25;
        LOWORD(v23) = 0;
        v4 += v20;
        *(_WORD *)(result + 26) = v20;
        --v15;
      }
      while ( v15 );
    }
    else
    {
      v8 = v21 / 10 + 1;
      v24 = v21 / v8;
      v22 = v21 % v8;
      v9 = v6 / v8;
      result = v8 * (v6 / v8);
      v10 = v6 % v8;
      for ( i = v8 == 0; !i; i = v8 == 0 )
      {
        sub_35900(v4, a2, a3, a4);
        v12 = sub_373F0((int)&word_AE454, 10, 27);
        v4 += v22 + v24;
        *(_WORD *)(v12 + 26) = v22 + v24;
        *(_BYTE *)(v12 + 70) = 29;
        sub_35900(v4, a2, a3, a4);
        v13 = sub_373F0((int)&word_AE454, 10, 27);
        if ( v9 >= 0 )
        {
          *(_BYTE *)(v13 + 70) = 28;
          LOWORD(v14) = v10 + v9;
        }
        else
        {
          *(_BYTE *)(v13 + 70) = 27;
          v14 = -v9 - v10;
        }
        *(_WORD *)(v13 + 26) = v14;
        a2 += v9 + v10;
        result = 0;
        v10 = 0;
        LOWORD(v22) = 0;
        --v8;
      }
    }
  }
  return result;
}
// 35B20: conditional instruction was optimized away because ebp.4!=0
// AE454: using guessed type __int16 word_AE454;

//----- (00035BF0) --------------------------------------------------------
_WORD *sub_35BF0(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  int v4; // ebx
  int v5; // edi
  __int16 v6; // si
  int v7; // eax
  __int16 v8; // bx
  signed int v9; // ecx
  __int16 v10; // di
  _WORD *v11; // eax
  _WORD *result; // eax
  signed int v13; // [esp+0h] [ebp-18h]
  __int16 v14; // [esp+4h] [ebp-14h]
  __int16 v15; // [esp+8h] [ebp-10h]

  v4 = sub_358D0(a1, a3, 256);
  v5 = v4;
  v6 = 0;
  v7 = sub_358D0(a2, a4, 256);
  if ( v4 )
  {
    v6 = -1;
    if ( v4 > 0 )
      v6 = 1;
  }
  v8 = 0;
  if ( v7 )
  {
    v8 = -1;
    if ( v7 > 0 )
      v8 = 1;
  }
  v9 = abs32(v7);
  v13 = abs32(v5);
  v14 = abs32(v9 - v13);
  if ( v13 <= v9 )
  {
    v15 = v8;
    v10 = 0;
  }
  else
  {
    LOWORD(v13) = v9;
    v10 = v6;
    v15 = 0;
  }
  word_AE454 = a1 << 8;
  word_AE456 = a2 << 8;
  v11 = (_WORD *)sub_373F0((int)&word_AE454, 10, 30);
  if ( v11 )
  {
    v11[15] = v6;
    v11[16] = v8;
    v11[13] = v13;
  }
  word_AE454 = ((_WORD)v13 * v6 + a1) << 8;
  word_AE456 = ((_WORD)v13 * v8 + a2) << 8;
  result = (_WORD *)sub_373F0((int)&word_AE454, 10, 30);
  if ( result )
  {
    result[15] = v10;
    result[13] = v14;
    result[16] = v15;
  }
  return result;
}
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;

//----- (00035D30) --------------------------------------------------------
int sub_35D30(unsigned __int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4)
{
  __int16 v4; // bx
  unsigned __int16 v5; // si
  int result; // eax
  __int16 v7[4]; // [esp+0h] [ebp-18h] BYREF
  __int16 v8[8]; // [esp+8h] [ebp-10h] BYREF

  v7[0] = a1 << 8;
  v7[1] = a2 << 8;
  v7[2] = 32 * (unsigned __int8)byte_DC1E0[256 * a2 + a1];
  v8[0] = a3 << 8;
  v8[1] = a4 << 8;
  v4 = sub_42150((uint16*)v7, (uint16*)v8);
  v5 = sub_423D0((uint16*)v7, (uint16*)v8);
  result = sub_373F0((int)v7, 10, 32);
  if ( result )
  {
    *(_WORD *)(result + 30) = v4;
    *(_DWORD *)(result + 12) = (int)v5 >> 8;
  }
  return result;
}

//----- (00035DE0) --------------------------------------------------------
int sub_35DE0(unsigned __int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4)
{
  __int16 v4; // si
  unsigned __int16 v5; // di
  int result; // eax
  int v7; // ebx
  int v8; // ecx
  __int16 v9[4]; // [esp+0h] [ebp-1Ch] BYREF
  __int16 v10[10]; // [esp+8h] [ebp-14h] BYREF

  v9[0] = a1 << 8;
  v9[1] = a2 << 8;
  v9[2] = 16 * (unsigned __int8)byte_DC1E0[256 * a2 + a1];
  v10[0] = a3 << 8;
  v10[1] = a4 << 8;
  v4 = sub_42150((uint16*)v9, (uint16*)v10);
  v5 = sub_423D0((uint16*)v9, (uint16*)v10);
  result = sub_373F0((int)v9, 10, 51);
  v7 = result;
  if ( result )
  {
    v8 = *(__int16 *)(result + 126);
    *(_WORD *)(result + 30) = v4;
    result = v5 / v8;
    *(_DWORD *)(v7 + 12) = result;
  }
  return result;
}

//----- (00035EA0) --------------------------------------------------------
unsigned int sub_35EA0(char a1, char a2, char a3, char a4)
{
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // dx
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // ecx
  unsigned int v9; // ecx
  unsigned int v10; // ecx

  LOBYTE(v4) = a1;
  HIBYTE(v4) = a2;
  HIBYTE(v5) = a2;
  LOBYTE(v5) = a4 + a1;
  v6 = (unsigned __int8)byte_DC1E0[v4];
  v7 = v6;
  v8 = (unsigned __int8)byte_DC1E0[v5];
  if ( v8 <= v6 )
  {
    if ( v8 < v6 )
      v7 = (unsigned __int8)byte_DC1E0[v5];
  }
  else
  {
    v6 = (unsigned __int8)byte_DC1E0[v5];
  }
  HIBYTE(v5) = a3 + a2;
  v9 = (unsigned __int8)byte_DC1E0[v5];
  if ( v9 <= v6 )
  {
    if ( v9 < v7 )
      v7 = (unsigned __int8)byte_DC1E0[v5];
  }
  else
  {
    v6 = (unsigned __int8)byte_DC1E0[v5];
  }
  LOBYTE(v5) = a1;
  v10 = (unsigned __int8)byte_DC1E0[v5];
  if ( v10 > v6 )
    return v10 - v7;
  if ( v10 < v7 )
    v7 = (unsigned __int8)byte_DC1E0[v5];
  return v6 - v7;
}

//----- (00035F30) --------------------------------------------------------
char sub_35F30fix(int a1, char a2, char a3, int a4, int a5, unsigned __int8 a6)
{
  int v6; // eax
  int v7; // edi
  unsigned __int16 v8; // bx
  unsigned __int16 v9; // bx
  int v10; // edi
  char result; // al
  char v12; // [esp+0h] [ebp-24h]
  char v13; // [esp+1h] [ebp-23h]
  __int16 v14; // [esp+2h] [ebp-22h]
  unsigned __int16 v15; // [esp+4h] [ebp-20h]
  unsigned __int16 v16; // [esp+4h] [ebp-20h]

  //fix
  v14 = 0;
  //fix

  v12 = a2 - a5;
  v13 = a3 - a4;
  HIWORD(v6) = v14;
  v7 = 2 * a4;
  HIBYTE(v15) = a3 - a4;
  HIBYTE(v8) = a3 - a4;
  LOBYTE(v8) = a2 - a5 - a6;
  LOBYTE(v15) = 2 * a5 + a2 - a5;
  while ( (_WORD)--v7 != 0xFFFF )
  {
    LOWORD(a1) = a6;
    ++a1;
    while ( (_WORD)--a1 != 0xFFFF )
    {
      sub_360C0(v8);
      v6 = sub_360C0(v15);
      LOBYTE(v8) = v8 + 1;
      LOBYTE(v15) = v15 + 1;
    }
    LOBYTE(v8) = a2 - a5 - a6;
    LOBYTE(v15) = 2 * a5 + a2 - a5;
    ++HIBYTE(v8);
    ++HIBYTE(v15);
  }
  LOBYTE(v9) = v12 - a6;
  HIBYTE(v16) = 2 * a4 + v13;
  LOBYTE(v16) = v12 - a6;
  LOWORD(v6) = a6;
  HIBYTE(v9) = v13 - a6;
  v10 = 2 * v6 + 2 * a5;
  result = HIBYTE(v16);
  while ( (_WORD)--v10 != 0xFFFF )
  {
    LOWORD(a1) = a6;
    ++a1;
    while ( (_WORD)--a1 != 0xFFFF )
    {
      sub_360C0(v9);
      sub_360C0(v16);
      ++HIBYTE(v9);
      ++HIBYTE(v16);
    }
    result = 2 * a4 + v13;
    HIBYTE(v16) = result;
    HIBYTE(v9) = v13 - a6;
    LOBYTE(v9) = v9 + 1;
    LOBYTE(v16) = v16 + 1;
  }
  return result;
}
// 35F53: variable 'v14' is possibly undefined

//----- (00036080) --------------------------------------------------------
void sub_36080(unsigned __int8 a1, char a2, int a3, int a4)
{
  unsigned __int16 v5; // bx
  int v6; // esi

  LOBYTE(v5) = a1;
  HIBYTE(v5) = a2;
  while ( (_WORD)--a3 != 0xFFFF )
  {
    v6 = a4;
    while ( (_WORD)--v6 != 0xFFFF )
    {
      sub_360C0(v5);
      LOBYTE(v5) = v5 + 1;
    }
    v5 = __PAIR16__(HIBYTE(v5), a1) + 256;
  }
  JUMPOUT(0x36079);
}
// 36094: control flows out of bounds to 36079

//----- (000360C0) --------------------------------------------------------
int sub_360C0(int a1)
{
  int result; // eax
  unsigned int v2; // ecx
  unsigned int v3; // esi
  char v4; // dl
  char v5; // dl
  char v6; // dl
  char v7; // dl
  char v8; // dl
  char v9; // dh
  char v10; // [esp+0h] [ebp-10h]

  result = a1;
  v2 = 0;
  v3 = 0;
  if ( (byte_FC1E0[(unsigned __int16)a1] & 7) != 0 )
  {
    if ( byte_DC1E0[(unsigned __int16)a1] )
    {
      v4 = byte_CC0DF[(unsigned __int16)a1];
      if ( (unsigned __int8)v4 <= 5u || (unsigned __int8)v4 > 0x22u )
      {
        v5 = byte_CC0E0[(unsigned __int16)a1];
        if ( (unsigned __int8)v5 <= 5u || (unsigned __int8)v5 > 0x22u )
        {
          v6 = byte_CC1DF[(unsigned __int16)a1];
          if ( (unsigned __int8)v6 <= 5u || (unsigned __int8)v6 > 0x22u )
          {
            v7 = byte_CC1E0[(unsigned __int16)a1];
            if ( (unsigned __int8)v7 <= 5u || (unsigned __int8)v7 > 0x22u )
            {
              result = a1 - 257;
              v10 = 3;
              while ( --v10 != -1 )
              {
                v8 = 3;
                while ( --v8 != -1 )
                {
                  v9 = byte_CC1E0[(unsigned __int16)result];
                  if ( (unsigned __int8)v9 <= 5u || (unsigned __int8)v9 > 0x22u )
                  {
                    ++v3;
                    v2 += (unsigned __int8)byte_DC1E0[(unsigned __int16)result];
                  }
                  ++result;
                }
                result += 253;
              }
              if ( v3 )
              {
                result = v2 / v3;
                byte_DC1E0[(unsigned __int16)a1] = v2 / v3;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (000361C0) --------------------------------------------------------
__int16 sub_361C0(char a1, char a2, char a3, char a4)
{
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // dx
  int v6; // eax
  unsigned __int16 v7; // bx

  LOBYTE(v4) = a1;
  HIBYTE(v4) = a2;
  HIBYTE(v5) = a2;
  LOBYTE(v5) = a4 + a1;
  v6 = (unsigned __int8)byte_DC1E0[v5] + (unsigned __int8)byte_DC1E0[v4];
  HIBYTE(v5) = a3 + a2;
  v7 = v5;
  LOBYTE(v5) = a1;
  return ((unsigned __int8)byte_DC1E0[v5] + (unsigned int)(unsigned __int8)byte_DC1E0[v7] + v6) >> 2;
}

//----- (000362C0) --------------------------------------------------------
int sub_362C0(int a1, _WORD *a2)
{
  int result; // eax
  unsigned __int16 v3; // di
  _WORD *v4; // ebx
  unsigned __int16 v5; // si
  unsigned __int16 v6; // cx
  unsigned __int16 v7; // dx
  void *v8; // [esp+4h] [ebp-14h]
  __int16 v9; // [esp+8h] [ebp-10h]

  result = (int)a2;
  v9 = *a2;
  v8 = 0;
  v3 = a2[1];
  if ( *a2 == 10 )
  {
    if ( v3 < 0x1Du )
    {
      if ( v3 == 28 )
        v8 = sub_35960;
    }
    else if ( v3 <= 0x1Du )
    {
      v8 = sub_35BF0;
    }
    else if ( v3 >= 0x1Fu )
    {
      if ( v3 <= 0x1Fu )
      {
        v8 = sub_35D30;
      }
      else if ( v3 == 50 )
      {
        v8 = sub_35DE0;
      }
    }
  }
  if ( v8 )
  {
    v4 = a2;
    if ( a2[7] )
    {
      result = a1 + 1072;
      do
        v4 = (_WORD *)(result + 18 * (unsigned __int16)v4[7]);
      while ( v4[7] );
    }
    do
    {
      if ( v9 == *v4 && v3 == v4[1] && (v5 = v4[8], v4[6] = 0, v5) )
      {
        v6 = v4[2];
        v7 = v4[3];
        v4 = (_WORD *)(a1 + 1072 + 18 * v5);
        result = ((int (*)(_DWORD, _DWORD, _DWORD, _DWORD))v8)(
                   v6,
                   v7,
                   (unsigned __int16)v4[2],
                   (unsigned __int16)v4[3]);
      }
      else
      {
        v4 = 0;
      }
    }
    while ( v4 );
  }
  return result;
}

//----- (00036430) --------------------------------------------------------
int sub_36430(int a1)
{
  _WORD *v1; // ebx

  v1 = (_WORD *)(a1 + 1090);
  if ( a1 + 1090 < (unsigned int)(a1 + 37072) )
  {
    do
    {
      if ( v1[4] == 0xFFFF && *v1 == 10 )
      {
        sub_36480(a1, v1);
        *v1 = 0;
      }
      v1 += 9;
    }
    while ( (unsigned int)v1 < a1 + 37072 );
  }
  return sub_36620();
}

//----- (00036480) --------------------------------------------------------
char sub_36480(int a1, _WORD *a2)
{
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // dx
  int v4; // eax
  int v5; // ebx

  v2 = a2[1];
  if ( v2 < 0x1Fu )
  {
    if ( v2 < 0x1Cu || v2 > 0x1Du )
    {
LABEL_15:
      word_AE454 = a2[2] << 8;
      word_AE456 = a2[3] << 8;
      word_AE458 = sub_11F50(&word_AE454);
      v5 = (unsigned __int16)a2[1];
      LOBYTE(v4) = 14 * v5;
      if ( *(int (**)(int))((char *)&off_97D12 + 14 * v5) )
        LOBYTE(v4) = (*(int (**)(int))((char *)&off_97D12 + 14 * v5))((int)&word_AE454);
      return v4;
    }
LABEL_13:
    if ( a2[6] )
    {
      LOBYTE(v4) = sub_362C0(a1, a2);
      return v4;
    }
    goto LABEL_15;
  }
  if ( v2 <= 0x1Fu )
    goto LABEL_13;
  if ( v2 < 0x2Du )
    goto LABEL_15;
  if ( v2 > 0x2Du )
  {
    if ( v2 != 50 )
      goto LABEL_15;
    goto LABEL_13;
  }
  word_AE454 = a2[2] << 8;
  word_AE456 = a2[3] << 8;
  LOWORD(v4) = sub_11F50(&word_AE454);
  v3 = a2[1];
  word_AE458 = v4;
  LOBYTE(v4) = 14 * v3;
  if ( *(int (**)(int))((char *)&off_97D12 + 14 * v3) )
  {
    v4 = (*(int (**)(int))((char *)&off_97D12 + 14 * v3))((int)&word_AE454);
    if ( v4 )
      LOBYTE(v4) = sub_36DF0(v4, a2[7] + 16);
  }
  return v4;
}
// 97D12: using guessed type int (*off_97D12)(int);
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;
// AE458: using guessed type __int16 word_AE458;

//----- (000365C0) --------------------------------------------------------
_WORD *sub_365C0(int a1)
{
  _WORD *result; // eax
  unsigned __int16 v2; // dx

  result = (_WORD *)(a1 + 1090);
  if ( a1 + 1090 < (unsigned int)(a1 + 37072) )
  {
    do
    {
      if ( result[4] != 0xFFFF || *result != 10 )
        goto LABEL_11;
      v2 = result[1];
      if ( v2 < 0x1Fu )
      {
        if ( v2 < 0x1Cu || v2 > 0x1Du )
          goto LABEL_11;
      }
      else if ( v2 > 0x1Fu && v2 != 50 )
      {
        goto LABEL_11;
      }
      result[6] = 1;
LABEL_11:
      result += 9;
    }
    while ( (unsigned int)result < a1 + 37072 );
  }
  return result;
}

//----- (00036620) --------------------------------------------------------
int sub_36620()
{
  int v0; // esi
  _BYTE *i; // ebx
  int v2; // eax
  int result; // eax
  int (*v4)(_BYTE *, _DWORD); // [esp+0h] [ebp-10h]

  *(_DWORD *)(dword_AE400 + 4) = 9377 * *(_DWORD *)(dword_AE400 + 4) + 9439;
  do
  {
    v0 = 0;
    for ( i = (_BYTE *)(dword_AE400 + 29959); ; i += 164 )
    {
      result = dword_AE400 + 193795;
      if ( (unsigned int)i >= dword_AE400 + 193795 )
        break;
      BYTE1(v2) = i[64];
      if ( !BYTE1(v2) )
        continue;
      if ( BYTE1(v2) != 10 )
        goto LABEL_19;
      LOBYTE(v2) = i[65];
      if ( (unsigned __int8)v2 < 0x1Bu )
      {
        if ( (unsigned __int8)v2 >= 9u && (unsigned __int8)v2 <= 0xBu )
        {
LABEL_16:
          v2 = *(int *)((char *)&dword_96902 + 18 * (char)i[64]) + 14 * (char)i[70];
          v0 = 1;
          v4 = *(int (**)(_BYTE *, _DWORD))(v2 + 6);
          if ( v4 && *(_DWORD *)(v2 + 10) )
            LOWORD(v2) = v4(i, (uint32)v4);
          goto LABEL_20;
        }
        goto LABEL_19;
      }
      if ( (unsigned __int8)v2 <= 0x20u )
        goto LABEL_16;
      if ( (unsigned __int8)v2 < 0x2Du )
        goto LABEL_19;
      if ( (unsigned __int8)v2 > 0x2Du )
      {
        if ( (unsigned __int8)v2 >= 0x32u && (unsigned __int8)v2 <= 0x33u )
          goto LABEL_16;
LABEL_19:
        LOWORD(v2) = sub_41E80((int)i);
        goto LABEL_20;
      }
      if ( i[70] == 51 )
        goto LABEL_16;
LABEL_20:
      if ( (i[17] & 4) != 0 )
        sub_41E90(v2, (int)i);
    }
  }
  while ( v0 );
  return result;
}
// 96902: using guessed type int dword_96902;
// AE400: using guessed type int dword_AE400;

//----- (00036700) --------------------------------------------------------
int sub_36700(int a1, unsigned __int16 a2, int a3)
{
  unsigned __int16 v3; // bx
  int v5; // edx
  int v6; // esi
  int v7; // edx
  int v8; // edi
  int v9; // eax
  int v10; // eax
  int v11; // eax

  v3 = a2;
  if ( a3 )
  {
    v5 = a1 - (4 * a2 + 14 * a2 + 26);
    if ( a1 == 4 * a2 + 14 * a2 + 26 )
    {
      return 0;
    }
    else
    {
      *(_WORD *)(a3 + 20) = 0;
      *(_WORD *)(a3 + 24) = 2;
      *(_DWORD *)a3 = v5;
      *(_DWORD *)(a3 + 4) = v5;
      v6 = a3;
      *(_WORD *)(a3 + 22) = a2;
      *(_DWORD *)(a3 + 8) = a3 + 26;
      v7 = 14 * a2 + a3 + 26;
      *(_DWORD *)(a3 + 12) = v7;
      *(_DWORD *)(a3 + 16) = 4 * a2 + v7;
    }
  }
  else
  {
    v8 = sub_42540(26);
    v6 = v8;
    if ( !v8
      || (v9 = sub_42540(a1), (*(_DWORD *)(v8 + 16) = v9) == 0)
      || (v10 = sub_42540(14 * a2), (*(_DWORD *)(v8 + 8) = v10) == 0)
      || (v11 = sub_42540(4 * a2), (*(_DWORD *)(v8 + 12) = v11) == 0) )
    {
      if ( v8 )
      {
        if ( *(_DWORD *)(v8 + 16) )
        {
          if ( *(_DWORD *)(v8 + 8) )
            sub_426E0(*(_DWORD *)(v8 + 8));
          sub_426E0(*(_DWORD *)(v8 + 16));
        }
        sub_426E0(v8);
      }
      exit(1);
    }
    *(_WORD *)(v8 + 20) = 0;
    *(_WORD *)(v8 + 24) = 1;
    *(_WORD *)(v8 + 22) = a2;
    *(_DWORD *)v8 = a1;
    *(_DWORD *)(v8 + 4) = a1;
    while ( --v3 != 0xFFFF )
      *(_DWORD *)(*(_DWORD *)(v8 + 8) + 14 * v3 + 4) = 0;
  }
  return v6;
}

//----- (00036850) --------------------------------------------------------
int sub_36850(int a1)
{
  int result; // eax

  for ( result = 0; (__int16)result < (int)*(unsigned __int16 *)(a1 + 22); ++result )
  {
    if ( !*(_DWORD *)(*(_DWORD *)(a1 + 8) + 14 * (__int16)result + 4) )
      return result;
  }
  return -1;
}

//----- (000369E0) --------------------------------------------------------
int sub_369E0(int a1, unsigned int a2, __int16 a3)
{
  __int16 v3; // si
  __int16 v4; // ax
  __int16 v5; // dx
  int v6; // ecx
  int v7; // eax

  v3 = -1;
  if ( a2 < *(_DWORD *)(a1 + 4) )
  {
    v4 = sub_36850(a1);
    v5 = v4;
    v6 = v4;
    v3 = v4;
    if ( v4 > -1 )
    {
      v7 = 14 * v4;
      *(_WORD *)(*(_DWORD *)(a1 + 8) + v7 + 10) = v5;
      *(_DWORD *)(*(_DWORD *)(a1 + 8) + v7 + 4) = a2;
      *(_DWORD *)(*(_DWORD *)(a1 + 8) + v7) = *(_DWORD *)a1 + *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 4);
      *(_WORD *)(*(_DWORD *)(a1 + 8) + v7 + 12) = a3;
      *(_DWORD *)(a1 + 4) -= a2;
      *(_WORD *)(*(_DWORD *)(a1 + 8) + v7 + 8) = *(_WORD *)(a1 + 20);
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * (unsigned __int16)(*(_WORD *)(a1 + 20))++) = *(_DWORD *)(a1 + 8) + 14 * v6;
    }
  }
  if ( v3 <= -1 )
    return 0;
  else
    return 14 * v3 + *(_DWORD *)(a1 + 8);
}

//----- (00036A90) --------------------------------------------------------
__int16 sub_36A90(int a1, int a2)
{
  int v2; // ecx
  int v3; // eax
  int v4; // ebx
  int v5; // esi
  int v6; // ebx
  char *v7; // ebp
  unsigned __int16 v8; // di
  __int16 v9; // cx
  int v10; // esi
  unsigned __int16 v11; // bx
  int v12; // eax
  const void *v13; // esi
  int v15; // [esp+0h] [ebp-18h]
  int v16; // [esp+4h] [ebp-14h]

  LOWORD(v3) = *(_WORD *)(a2 + 10);
  if ( (unsigned __int16)v3 < *(_WORD *)(a1 + 22) )
  {
    v3 = 14 * (unsigned __int16)v3;
    v4 = v3 + *(_DWORD *)(a1 + 8);
    if ( *(_DWORD *)(v4 + 4) )
    {
      LOWORD(v2) = *(_WORD *)(v4 + 8);
      v5 = *(_DWORD *)(v4 + 4) + *(_DWORD *)(a1 + 4);
      v6 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 4) = v5;
      *(_DWORD *)(v6 + v3 + 4) = 0;
      v7 = *(char **)(*(_DWORD *)(a1 + 8) + v3);
      v15 = v2;
      v16 = v2 - 1;
      while ( 1 )
      {
        v8 = *(_WORD *)(a1 + 20);
        v9 = v16 + 1;
        v10 = v15 + 1;
        ++v16;
        v15 = v10;
        if ( (unsigned __int16)v10 >= v8 )
          break;
        v11 = v10;
        *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * (unsigned __int16)v10 - 4) = *(_DWORD *)(*(_DWORD *)(a1 + 12)
                                                                                      + 4 * (unsigned __int16)v10);
        v12 = *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * (unsigned __int16)v10);
        *(_WORD *)(v12 + 8) = v9;
        v13 = *(const void **)v12;
        **(_DWORD **)(*(_DWORD *)(a1 + 12) + 4 * v11) = (uint32)v7;
        qmemcpy(v7, v13, *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * v11) + 4));
        v7 += *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * v11) + 4);
      }
      LOWORD(v3) = v8 - 1;
      *(_WORD *)(a1 + 20) = v8 - 1;
    }
  }
  return v3;
}
// 36AF0: variable 'v2' is possibly undefined

//----- (00036C10) --------------------------------------------------------
int *sub_36C10(int *a1)
{
  int v1; // edx
  int *result; // eax

  //fix
  result = 0;
  //fix

  v1 = *a1;
  if ( *a1 )
  {
    result = (int *)*a1;
    if ( *(_WORD *)(v1 + 24) == 1 )
    {
      sub_426E0(*(_DWORD *)(v1 + 16));
      sub_426E0(*(_DWORD *)(*a1 + 8));
      sub_426E0(*(_DWORD *)(*a1 + 12));
      result = sub_426E0(*a1);
    }
    *a1 = 0;
  }
  return result;
}

//----- (00036C65) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_36C65(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7)
{
  int v7; // [esp-4h] [ebp-4h] BYREF
  //fix
  /*
  ((void (*)(_DWORD, _DWORD, _DWORD, _DWORD, int, int, int, int, int *, int, int, int))_GETDS)(
    (unsigned __int16)__GS__,
    (unsigned __int16)__FS__,
    (unsigned __int16)__ES__,
    (unsigned __int16)__DS__,
    a1,
    a2,
    a3,
    a4,
    &v7,
    a5,
    a6,
    a7);*/
}
// 36D82: positive sp value 4 has been found
// 6244D: using guessed type _DWORD inp(_DWORD);
// 62455: using guessed type _DWORD outp(_DWORD, char);
// 62460: using guessed type _DWORD chain_intr(_DWORD);
// AE408: using guessed type int dword_AE408;
// AE45A: using guessed type char byte_AE45A;
// B7320: using guessed type int dword_B7320;
// B7324: using guessed type __int16 word_B7324;
// B7326: using guessed type char byte_B7326;
// B7327: using guessed type char byte_B7327;
// 12EF70: using guessed type char byte_12EF70;

//----- (00036D83) --------------------------------------------------------
int sub_36D83(int a1, __int16 a2)
{
  __int16 i; // ax
  int v3; // eax

  for ( i = 0; i < 128; ++i )
  {
    a2 = i;
    byte_12EEF0[i] = 0;
  }
  v3 = dos_getvect(9);
  word_B7324 = a2;
  dword_B7320 = v3;
  //fix return dos_setvect(9, sub_36C65, (unsigned __int16)__CS__);
}
// 62481: using guessed type _DWORD dos_getvect(_DWORD);
// 624B5: using guessed type _DWORD dos_setvect(_DWORD, _DWORD, _DWORD);
// B7320: using guessed type int dword_B7320;
// B7324: using guessed type __int16 word_B7324;

//----- (00036DC2) --------------------------------------------------------
int sub_36DC2()
{
  return dos_setvect(9, dword_B7320, (unsigned __int16)word_B7324);
}
// 624B5: using guessed type _DWORD dos_setvect(_DWORD, _DWORD, _DWORD);
// B7320: using guessed type int dword_B7320;
// B7324: using guessed type __int16 word_B7324;

//----- (00036DE0) --------------------------------------------------------
int sub_36DE0(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 12) = result;
  return result;
}

//----- (00036DF0) --------------------------------------------------------
char sub_36DF0(int a1, unsigned __int16 a2)
{
  int v2; // eax
  unsigned __int16 v3; // ax
  __int16 v4; // dx
  int v5; // eax
  __int16 v6; // ax
  char v7; // dh
  char result; // al
  unsigned __int16 v9; // [esp+0h] [ebp-1Ch]
  unsigned __int16 v10; // [esp+4h] [ebp-18h]
  unsigned __int8 v11; // [esp+8h] [ebp-14h]
  unsigned __int8 v12; // [esp+Ch] [ebp-10h]

  v2 = dword_AE440 + 6 * a2;
  v9 = *(unsigned __int8 *)(v2 + 5);
  v3 = *(unsigned __int8 *)(v2 + 4);
  v10 = v3;
  *(_WORD *)(a1 + 26) = 2;
  v4 = word_12F02E;
  *(_WORD *)(a1 + 128) = ((unsigned __int8)v3 * v9) >> 4;
  if ( v4 == 1 )
  {
    v9 >>= 1;
    v10 = v3 >> 1;
  }
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  word_AE454 = *(__int16 *)(a1 + 72) >> 8 << 8;
  word_AE456 = *(__int16 *)(a1 + 74) >> 8 << 8;
  sub_41C70(word_AE456, a1, (int)&word_AE454);
  v12 = HIBYTE(*(_WORD *)(a1 + 72)) - ((int)v10 >> 1);
  v11 = HIBYTE(*(_WORD *)(a1 + 74)) - ((int)v9 >> 1);
  v5 = (v12 + v11) / 2;
  if ( (v12 + v11) % 2 )
  {
    *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
    *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
    BYTE1(v5) = ++HIBYTE(word_AE454);
    sub_41C70(v5, a1, (int)&word_AE454);
    ++v12;
  }
  sub_37150((_WORD *)a1, a2);
  v6 = sub_361C0(v12, v11, v9, v10);
  *(_DWORD *)(a1 + 12) = 30;
  v7 = *(_BYTE *)(a1 + 28);
  *(_WORD *)(a1 + 44) = 2000;
  *(_WORD *)(a1 + 76) = 32 * v6;
  result = a2;
  *(_BYTE *)(a1 + 28) = v7 | 2;
  *(_BYTE *)(a1 + 71) = a2;
  return result;
}
// AE440: using guessed type int dword_AE440;
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00036F90) --------------------------------------------------------
int sub_36F90(int a1)
{
  int result; // eax

  result = *(int *)(a1 + 8) >> 1;
  *(_DWORD *)(a1 + 140) = result;
  return result;
}

//----- (00036FA0) --------------------------------------------------------
int sub_36FA0(int a1, __int16 a2)
{
  int v2; // ecx
  int result; // eax

  *(_BYTE *)(a1 + 88) = 0;
  v2 = 7 * a2;
  *(_WORD *)(a1 + 86) = a2;
  *(_BYTE *)(a1 + 89) = byte_90AD8[(unsigned __int8)byte_99BAC[v2 * 2]];
  *(_WORD *)(a1 + 78) = (unsigned __int16)word_99BA8[v2] / 2;
  *(_WORD *)(a1 + 80) = (unsigned __int16)word_99BA6[v2] / 2;
  *(_WORD *)(a1 + 82) = (unsigned __int16)word_99BA6[v2] / 2;
  result = (unsigned __int16)word_99BA8[v2] / 2;
  *(_WORD *)(a1 + 84) = result;
  return result;
}
// 99BA6: using guessed type __int16 word_99BA6[];
// 99BA8: using guessed type __int16 word_99BA8[];

//----- (00037030) --------------------------------------------------------
int sub_37030(_WORD *a1, __int16 a2)
{
  int v2; // ebx
  int result; // eax

  sub_36FA0((int)a1, a2);
  v2 = 7 * a2;
  a1[40] = (unsigned __int16)word_99BA6[v2] / 2;
  a1[41] = (unsigned __int16)word_99BA6[v2] / 2;
  result = (unsigned __int16)word_99BA8[v2] / 2;
  a1[42] = result;
  return result;
}
// 99BA6: using guessed type __int16 word_99BA6[];
// 99BA8: using guessed type __int16 word_99BA8[];

//----- (000370A0) --------------------------------------------------------
int sub_370A0(_WORD *a1, __int16 a2)
{
  int result; // eax
  __int16 v3; // cx
  __int16 v4; // si

  result = sub_36FA0((int)a1, a2);
  v3 = a1[41];
  v4 = a1[42];
  a1[40] *= 2;
  a1[41] = 2 * v3;
  a1[42] = 2 * v4;
  return result;
}

//----- (000370E0) --------------------------------------------------------
__int16 sub_370E0(__int16 *a1, __int16 a2)
{
  __int16 result; // ax

  sub_36FA0((int)a1, a2);
  a1[40] /= 2;
  a1[41] /= 2;
  result = a1[42] / 2;
  a1[42] = result;
  return result;
}

//----- (00037130) --------------------------------------------------------
_WORD *sub_37130(_WORD *a1, __int16 a2, __int16 a3)
{
  _WORD *result; // eax

  result = a1;
  a1[40] = a2;
  a1[41] = a2;
  a1[42] = a3;
  return result;
}

//----- (00037150) --------------------------------------------------------
unsigned int sub_37150(_WORD *a1, __int16 a2)
{
  int v2; // eax
  unsigned int v3; // edx
  unsigned int v4; // eax
  unsigned int result; // eax

  v2 = dword_AE440 + 6 * a2;
  v3 = *(unsigned __int8 *)(v2 + 5);
  v4 = *(unsigned __int8 *)(v2 + 4);
  if ( word_12F02E == 1 )
  {
    v3 >>= 1;
    v4 >>= 1;
  }
  a1[40] = ((v4 << 8) + 1280) >> 1;
  a1[39] = -8192;
  a1[42] = 0x4000;
  result = ((v3 << 8) + 1280) >> 1;
  a1[41] = result;
  return result;
}
// AE440: using guessed type int dword_AE440;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (000371C0) --------------------------------------------------------
int sub_371C0()
{
  int v0; // esi
  char *v1; // edx
  int result; // eax
  int v3; // ebx

  v0 = dword_AE400;
  *(_DWORD *)(dword_AE400 + 29955) = (uint32)&unk_B7330;
  v1 = (char *)&loc_27FFC;
  *(_DWORD *)(v0 + 40) = -1;
  result = v0;
  *(_DWORD *)(v0 + 4593) = -1;
  do
  {
    v3 = *(_DWORD *)(v0 + 40) + 1;
    *(_DWORD *)(v0 + 40) = v3;
    *(_DWORD *)(v0 + 4 * v3 + 593) = (uint32)&v1[v0 + 29795];
    v1 -= 164;
  }
  while ( v1 );
  dword_AE400 = v0;
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00037220) --------------------------------------------------------
int sub_37220()
{
  int v0; // edi
  _BYTE *v1; // edx
  int result; // eax
  char *v3; // esi
  int v4; // ebx
  int v5; // ebp

  v0 = dword_AE400;
  v1 = (uint8*)&loc_27FFC;
  *(_DWORD *)(dword_AE400 + 40) = -1;
  result = v0;
  *(_DWORD *)(v0 + 4593) = -1;
  do
  {
    v3 = (char*)&v1[v0 + 29795];
    if ( v1[v0 + 29859] )
    {
      if ( ((unsigned int)sub_20400 & *(_DWORD *)&v1[v0 + 29811]) != 0 )
      {
        v5 = *(_DWORD *)(v0 + 4593) + 1;
        *(_DWORD *)(v0 + 4593) = v5;
        *(_DWORD *)(v0 + 4 * v5 + 4597) = (uint32)v3;
      }
    }
    else
    {
      v4 = *(_DWORD *)(v0 + 40) + 1;
      *(_DWORD *)(v0 + 40) = v4;
      *(_DWORD *)(v0 + 4 * v4 + 593) = (uint32)v3;
    }
    v1 -= 164;
  }
  while ( v1 );
  dword_AE400 = v0;
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (000372C0) --------------------------------------------------------
int sub_372C0()
{
  int v0; // edx
  int v1; // ebx
  int v3; // eax
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // edx

  v0 = *(_DWORD *)(dword_AE400 + 40);
  if ( v0 < 0 )
  {
    if ( *(int *)(dword_AE400 + 4593) < 0 )
      return 0;
    memset((void*)(dword_AE408 + 36382), 0, 80);
    v3 = dword_AE408;
    *(_DWORD *)(dword_AE408 + 36466) = 0;
    *(_DWORD *)(v3 + 36470) = 0;
    *(_DWORD *)(v3 + 36462) = 0;
    *(_DWORD *)(v3 + 36474) = 0;
    v1 = *(_DWORD *)(dword_AE400 + 4 * *(_DWORD *)(dword_AE400 + 4593) + 4597);
    sub_41DD0(dword_AE400, v1);
    v4 = dword_AE400;
    *(_BYTE *)(v1 + 64) = 0;
    --*(_DWORD *)(v4 + 4593);
  }
  else
  {
    v1 = *(_DWORD *)(dword_AE400 + 4 * v0 + 593);
    *(_DWORD *)(dword_AE400 + 40) = v0 - 1;
  }
  memset((void*)v1, 0, 164);
  v5 = dword_AE400;
  v6 = (v1 - (dword_AE400 + 29795)) / 164;
  *(_DWORD *)(v1 + 8) = 300;
  *(_DWORD *)(v1 + 16) = 8;
  *(_WORD *)(v1 + 126) = 16;
  *(_WORD *)(v1 + 44) = 100;
  *(_WORD *)(v1 + 24) = v6;
  v7 = *(_DWORD *)(v5 + 4);
  *(_BYTE *)(v1 + 66) = -1;
  *(_BYTE *)(v1 + 67) = -1;
  *(_DWORD *)(v1 + 156) = (uint32)&unk_98F38;
  *(_DWORD *)(v1 + 160) = (uint32)&unk_B7330;
  *(_BYTE *)(v1 + 68) = 10;
  *(_BYTE *)(v1 + 58) = -6;
  *(_DWORD *)(v1 + 4) = v6 + v7;
  *(_BYTE *)(v1 + 63) = v6;
  return v1;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (000373F0) --------------------------------------------------------
int sub_373F0(int a1, int a2, int a3)
{
  int v3; // eax

  v3 = *(int *)((char *)&dword_96906 + 18 * a2) + 14 * a3;
  if ( *(_DWORD *)(v3 + 10) && *(__int16 *)(v3 + 4) == a3 )
    return (*(int (**)(int))(v3 + 6))(a1);
  else
    return 0;
}
// 96906: using guessed type int dword_96906;

//----- (00037440) --------------------------------------------------------
int sub_37440(int a1, char a2)
{
  unsigned __int16 *i; // ebx
  unsigned __int16 v3; // dx
  unsigned __int16 *j; // ebx
  int result; // eax
  char *v6; // [esp-Ch] [ebp-14h]

  if ( !a1 )
  {
    v6 = (char *)dword_38CA3 + dword_AE400;
    *((_DWORD *)v6 - 1) = 0;
    memset(v6, 0, 96);
    sub_59140();
    for ( i = (unsigned __int16 *)((char *)&loc_2F945 + dword_AE400);
          i < (unsigned __int16 *)&byte_385D3[dword_AE400];
          i += 9 )
    {
      sub_59160(*i, i[1], -1);
      if ( *i >= 5u )
      {
        if ( *i <= 5u )
        {
          v3 = i[1];
          if ( v3 != 12 && v3 != 13 && v3 != 14 && v3 != 15 && v3 != 9 )
            ++*(int *)((char *)&dword_38C9F + dword_AE400);
        }
        else if ( *i == 12 )
        {
          ++*(int *)((char *)&dword_38CA3[i[1]] + dword_AE400);
        }
      }
    }
    sub_59230();
  }
  sub_37220();
  for ( j = (unsigned __int16 *)((char *)&loc_2F945 + dword_AE400); ; j += 9 )
  {
    result = dword_AE400;
    if ( j >= (unsigned __int16 *)&byte_385D3[dword_AE400] )
      break;
    if ( *j )
    {
      if ( j[4] == a1 )
      {
        sub_37560(j);
        if ( a2 )
          *j = 0;
      }
    }
  }
  *(_DWORD *)(dword_AE400 + 4593) = -1;
  return result;
}
// 38C9F: using guessed type int dword_38C9F;
// 38CA3: using guessed type int dword_38CA3[];
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// AE400: using guessed type int dword_AE400;

//----- (00037560) --------------------------------------------------------
char sub_37560(unsigned __int16 *a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // dh
  __int16 v5[8]; // [esp+0h] [ebp-10h] BYREF

  v1 = *(int *)((char *)&dword_96906 + 18 * *a1);
  if ( *(_DWORD *)(v1 + 14 * a1[1] + 10) )
  {
    v5[0] = (a1[2] << 8) + 128;
    v5[1] = (a1[3] << 8) + 128;
    v5[2] = sub_11F50(v5);
    v1 = sub_373F0((int)v5, *a1, a1[1]);
    v2 = v1;
    if ( v1 )
    {
      LOBYTE(v1) = *(_BYTE *)(v1 + 64);
      if ( (unsigned __int8)v1 < 0xBu )
      {
        if ( (_BYTE)v1 == 10 )
        {
          LOBYTE(v1) = *(_BYTE *)(v2 + 65);
          if ( (unsigned __int8)v1 < 0x22u )
          {
            if ( (_BYTE)v1 == 4 )
            {
              *(_WORD *)(v2 + 24) = a1[6];
              sub_37130((_WORD *)v2, a1[5] << 8, a1[5] << 8);
              LOBYTE(v1) = sub_36DE0(v2);
            }
          }
          else if ( (unsigned __int8)v1 <= 0x22u )
          {
            *(_WORD *)(v2 + 150) = (a1[8] << 8) + 128;
            LOWORD(v1) = (a1[7] << 8) + 128;
            *(_WORD *)(v2 + 152) = v1;
          }
          else if ( (_BYTE)v1 == 45 )
          {
            LOBYTE(v1) = sub_36DF0(v2, a1[7] + 16);
          }
        }
      }
      else if ( (unsigned __int8)v1 <= 0xBu )
      {
        *(_WORD *)(v2 + 24) = a1[6];
        sub_37130((_WORD *)v2, a1[5] << 8, 4096);
        LOBYTE(v1) = sub_36DE0(v2);
        *(_BYTE *)(v2 + 16) |= 1u;
      }
      else if ( (_BYTE)v1 == 12 )
      {
        LOBYTE(v1) = *((_BYTE *)a1 + 12);
        BYTE1(v1) = v1 + *(_BYTE *)(v2 + 70);
        *(_BYTE *)(v2 + 70) = BYTE1(v1);
        if ( a1[6] >= 3u )
        {
          *(_BYTE *)(v2 + 70) = BYTE1(v1) - 3;
          v3 = *(_BYTE *)(v2 + 18);
          *(_WORD *)(v2 + 86) = 280;
          *(_BYTE *)(v2 + 18) = v3 | 4;
        }
      }
    }
  }
  return v1;
}
// 96906: using guessed type int dword_96906;

//----- (00037710) --------------------------------------------------------
int sub_37710()
{
  return *(_DWORD *)(dword_AE400 + 40) + 1;
}
// AE400: using guessed type int dword_AE400;

//----- (00037720) --------------------------------------------------------
int sub_37720(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_AE400 + 9177;
  result = 0;
  *(_DWORD *)(dword_AE400 + 9177) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00037740) --------------------------------------------------------
int sub_37740(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_AE400 + 9183;
  result = 0;
  *(_DWORD *)(dword_AE400 + 9183) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00037760) --------------------------------------------------------
int sub_37760(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_AE400 + 9189;
  result = 0;
  *(_DWORD *)(dword_AE400 + 9189) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00037780) --------------------------------------------------------
int sub_37780(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_AE400 + 9195;
  result = 0;
  *(_DWORD *)(dword_AE400 + 9195) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (000377A0) --------------------------------------------------------
int sub_377A0(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_AE400 + 9201;
  result = 0;
  *(_DWORD *)(dword_AE400 + 9201) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (000377C0) --------------------------------------------------------
int sub_377C0(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_AE400 + 9207;
  result = 0;
  *(_DWORD *)(dword_AE400 + 9207) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (000377E0) --------------------------------------------------------
int sub_377E0(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_AE400 + 9213;
  result = 0;
  *(_DWORD *)(dword_AE400 + 9213) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00037800) --------------------------------------------------------
int sub_37800(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_AE400 + 9219;
  result = 0;
  *(_DWORD *)(dword_AE400 + 9219) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00037820) --------------------------------------------------------
int sub_37820(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // edx

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 0;
    *(_BYTE *)(result + 64) = 3;
    v3 = dword_AE400;
    *(_BYTE *)(result + 65) = 0;
    *(_DWORD *)(result + 8) = 10000;
    *(_WORD *)(result + 128) = 80;
    *(_DWORD *)(result + 156) = (uint32)&unk_99018;
    *(_WORD *)(result + 28) = 29;
    *(_WORD *)(result + 24) = (result - (v3 + 29795)) / 164;
    sub_41CF0(result, a1);
    sub_36FA0(v2, 44);
    sub_36DE0(v2);
    return v2;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (000378A0) --------------------------------------------------------
int sub_378A0(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // edx

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 1;
    *(_BYTE *)(result + 64) = 3;
    v3 = dword_AE400;
    *(_BYTE *)(result + 65) = 1;
    *(_DWORD *)(result + 8) = 10000;
    *(_WORD *)(result + 128) = 80;
    *(_DWORD *)(result + 156) = (uint32)&unk_99038;
    *(_WORD *)(result + 28) = 29;
    *(_WORD *)(result + 24) = (result - (v3 + 29795)) / 164;
    sub_41CF0(result, a1);
    sub_36FA0(v2, 44);
    sub_36DE0(v2);
    return v2;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00037920) --------------------------------------------------------
int sub_37920(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // [esp+0h] [ebp-14h] BYREF
  __int16 v4; // [esp+4h] [ebp-10h]

  *(_DWORD *)&word_AE454 = *(_DWORD *)a1;
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 4);
  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 5;
    *(_BYTE *)(result + 64) = 3;
    *(_BYTE *)(result + 65) = 2;
    *(_DWORD *)(result + 8) = 40000;
    *(_WORD *)(result + 26) = 0;
    *(_WORD *)(result + 28) = 33;
    LOWORD(v3) = HIBYTE(word_AE454);
    HIWORD(v3) = HIBYTE(word_AE456);
    v4 = sub_11F50(&word_AE454);
    if ( ((__int16)v3 + SHIWORD(v3)) % 2 )
      LOWORD(v3) = v3 + 1;
    LOWORD(v3) = (_WORD)v3 << 8;
    HIWORD(v3) <<= 8;
    *(_DWORD *)(v2 + 150) = v3;
    *(_WORD *)(v2 + 154) = v4;
    sub_41CF0(v2, (int)&v3);
    sub_36DE0(v2);
    sub_36FA0(v2, 177);
    return v2;
  }
  return result;
}
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;

//----- (00037A00) --------------------------------------------------------
int sub_37A00(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 7;
    *(_BYTE *)(v1 + 64) = 3;
    *(_BYTE *)(v1 + 65) = 3;
    *(_DWORD *)(v1 + 8) = 10000;
    *(_WORD *)(v1 + 126) = 48;
    *(_DWORD *)(v1 + 136) = 10000;
    *(_DWORD *)(v1 + 140) = 0;
    *(_WORD *)(v1 + 28) = 1;
    *(_DWORD *)(v1 + 156) = (uint32)&unk_99058;
    sub_41CF0(v1, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 169);
  }
  return v2;
}

//----- (00037A80) --------------------------------------------------------
int sub_37A80()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00037AA0) --------------------------------------------------------
int sub_37AA0()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00037AC0) --------------------------------------------------------
int sub_37AC0()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00037AE0) --------------------------------------------------------
int sub_37AE0()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00037B00) --------------------------------------------------------
int sub_37B00()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00037B20) --------------------------------------------------------
int sub_37B20()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00037B40) --------------------------------------------------------
int sub_37B40()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00037B60) --------------------------------------------------------
int sub_37B60()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00037B80) --------------------------------------------------------
int sub_37B80()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00037BA0) --------------------------------------------------------
int sub_37BA0()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00037BC0) --------------------------------------------------------
int sub_37BC0(int *a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // ebp
  int v4; // edx
  int v5; // ecx
  unsigned int v6; // edx
  int v7; // edx
  int v9; // [esp+0h] [ebp-18h] BYREF
  __int16 v10; // [esp+4h] [ebp-14h]

  v1 = sub_372C0();
  v2 = v1;
  v3 = v1;
  if ( !v1 )
    return 0;
  v4 = dword_AE400;
  *(_BYTE *)(v1 + 70) = 0;
  *(_BYTE *)(v1 + 64) = 2;
  *(_BYTE *)(v1 + 65) = 0;
  v5 = *(_DWORD *)(v1 + 4);
  *(_WORD *)(v1 + 26) = (v1 - (v4 + 29795)) / 164 % 11;
  *(_DWORD *)(v1 + 4) = 9377 * v5 + 9439;
  v6 = *(_DWORD *)(v1 + 4) % 0x1388u;
  *(_WORD *)(v1 + 28) = 1;
  *(_DWORD *)(v1 + 12) = v6 + 2500;
  v9 = *a1;
  v10 = *((_WORD *)a1 + 2);
  LOBYTE(v5) = -95 * *(_BYTE *)(v1 + 4) - 33;
  *(_DWORD *)(v1 + 4) = 9377 * *(_DWORD *)(v1 + 4) + 9439;
  LOWORD(v9) = (v5 & 0x3F) - 32 + v9;
  LOBYTE(v5) = -95 * *(_BYTE *)(v1 + 4) - 33;
  *(_DWORD *)(v1 + 4) = 9377 * *(_DWORD *)(v1 + 4) + 9439;
  HIWORD(v9) += (v5 & 0x3F) - 32;
  sub_41CF0(v1, (int)&v9);
  sub_36DE0(v2);
  v7 = 9377 * *(_DWORD *)(v2 + 4) + 9439;
  *(_DWORD *)(v2 + 4) = v7;
  if ( (v7 & 1) != 0 )
    sub_37030((_WORD *)v2, 84);
  else
    sub_37030((_WORD *)v2, 83);
  return v3;
}
// 37CBD: conditional instruction was optimized away because edx.4==1
// AE400: using guessed type int dword_AE400;

//----- (00037CF0) --------------------------------------------------------
int sub_37CF0(int a1)
{
  int result; // eax
  _WORD *v2; // ebx

  result = sub_372C0();
  v2 = (_WORD *)result;
  if ( result )
  {
    *(_BYTE *)(result + 16) &= ~8u;
    *(_WORD *)(result + 26) = (result - (dword_AE400 + 29795)) / 164 % 11;
    *(_BYTE *)(result + 70) = 3;
    *(_BYTE *)(result + 64) = 2;
    *(_BYTE *)(result + 65) = 1;
    sub_41CF0(result, a1);
    sub_36DE0((int)v2);
    sub_37030(v2, 79);
    return (int)v2;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00037D70) --------------------------------------------------------
int sub_37D70(int a1)
{
  int result; // eax
  _WORD *v2; // ebx

  result = sub_372C0();
  v2 = (_WORD *)result;
  if ( result )
  {
    *(_BYTE *)(result + 16) &= ~8u;
    *(_WORD *)(result + 26) = (result - (dword_AE400 + 29795)) / 164 % 11;
    *(_BYTE *)(result + 70) = 6;
    *(_BYTE *)(result + 64) = 2;
    *(_BYTE *)(result + 65) = 2;
    sub_41CF0(result, a1);
    sub_36DE0((int)v2);
    sub_37030(v2, 39);
    sub_37130(v2, 1024, 1024);
    return (int)v2;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00037E00) --------------------------------------------------------
int sub_37E00(int a1)
{
  int result; // eax
  _WORD *v2; // ebx

  result = sub_372C0();
  v2 = (_WORD *)result;
  if ( result )
  {
    *(_BYTE *)(result + 16) &= ~8u;
    *(_WORD *)(result + 26) = (result - (dword_AE400 + 29795)) / 164 % 11;
    *(_BYTE *)(result + 70) = 9;
    *(_BYTE *)(result + 64) = 2;
    *(_BYTE *)(result + 65) = 3;
    sub_41CF0(result, a1);
    sub_36DE0((int)v2);
    sub_37030(v2, 270);
    return (int)v2;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00037E80) --------------------------------------------------------
int sub_37E80(int a1)
{
  int result; // eax
  _WORD *v2; // ebx

  result = sub_372C0();
  v2 = (_WORD *)result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 12;
    *(_BYTE *)(result + 64) = 2;
    *(_BYTE *)(result + 65) = 4;
    *(_WORD *)(result + 26) = (result - (dword_AE400 + 29795)) / 164 % 11;
    sub_41CF0(result, a1);
    sub_36DE0((int)v2);
    sub_37030(v2, 48);
    return (int)v2;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00037EF0) --------------------------------------------------------
int sub_37EF0(int a1)
{
  int result; // eax
  _WORD *v2; // ebx

  result = sub_372C0();
  v2 = (_WORD *)result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 15;
    *(_BYTE *)(result + 64) = 2;
    *(_BYTE *)(result + 65) = 5;
    *(_WORD *)(result + 26) = (result - (dword_AE400 + 29795)) / 164 % 11;
    sub_41CF0(result, a1);
    sub_36DE0((int)v2);
    sub_37030(v2, 48);
    return (int)v2;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00038030) --------------------------------------------------------
_DWORD *sub_38030(int a1)
{
  int v1; // eax
  int v2; // ebx
  _DWORD *v3; // ebp
  __int64 v4; // rax
  int v5; // ecx
  int v6; // ecx
  int v7; // eax
  int v8; // ebx
  int v9; // edx
  int v11; // [esp+0h] [ebp-20h]
  int v12; // [esp+4h] [ebp-1Ch]
  int v13; // [esp+8h] [ebp-18h]
  __int16 v14; // [esp+Ch] [ebp-14h]

  if ( sub_37710() < 16 )
    return 0;
  v1 = sub_372C0();
  v2 = v1;
  v3 = (_DWORD *)v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 70) = 1;
  *(_BYTE *)(v1 + 64) = 5;
  *(_BYTE *)(v1 + 65) = 0;
  *(_WORD *)(v1 + 128) = 80;
  *(_WORD *)(v1 + 130) = 16;
  *(_WORD *)(v1 + 126) = 30;
  *(_DWORD *)(v1 + 8) = 9000;
  sub_36F90(v1);
  v4 = *(int *)(v2 + 140);
  *(_DWORD *)(v2 + 136) = v4;
  LODWORD(v4) = ((int)v4 - HIDWORD(v4)) >> 1;
  HIDWORD(v4) = *(_DWORD *)(v2 + 4);
  *(_DWORD *)(v2 + 140) = v4;
  LODWORD(v4) = 9377 * HIDWORD(v4) + 9439;
  *(_DWORD *)(v2 + 4) = v4;
  LOWORD(v4) = (v4 & 0x7FF) - 1;
  *(_WORD *)(v2 + 34) = v4;
  *(_WORD *)(v2 + 30) = v4;
  v5 = dword_AE400;
  HIDWORD(v4) = dword_AE400 + 29795;
  *(_WORD *)(v2 + 32) = *(_WORD *)(v2 + 34);
  *(_WORD *)(v2 + 36) = 0;
  *(_WORD *)(v2 + 56) = 96;
  LODWORD(v4) = *(char *)(v2 + 65);
  *(_WORD *)(v2 + 28) = 1;
  v6 = v4 + v5;
  *(_WORD *)(v2 + 26) = (v2 - HIDWORD(v4)) / 164 % 100;
  LOBYTE(v4) = *(_BYTE *)(v6 + 12);
  *(_BYTE *)(v6 + 12) = v4 + 1;
  *(_DWORD *)(v2 + 156) = (uint32)&unk_990B8;
  *(_BYTE *)(v2 + 63) = v4;
  *(_BYTE *)(v2 + 58) = *(_WORD *)(*(_DWORD *)(v2 + 156) + 26)
                      - *(unsigned __int8 *)(v2 + 63) % *(_WORD *)(*(_DWORD *)(v2 + 156) + 26)
                      + 4;
  v13 = 0;
  v11 = v2;
  *(_BYTE *)(v2 + 66) = 3;
  v14 = 19;
  do
  {
    v7 = sub_372C0();
    v8 = v7;
    v12 = v7;
    if ( v7 )
    {
      qmemcpy((void *)v7, v3, 0xA4u);
      v9 = v7 - (dword_AE400 + 29795);
      *(_WORD *)(v7 + 52) = (v11 - (dword_AE400 + 29795)) / 164;
      *(_WORD *)(v11 + 54) = v9 / 164;
      *(_WORD *)(v7 + 54) = 0;
      *(_BYTE *)(v7 + 70) = 120;
      v3[35] = (v3[34] - (__CFSHL__((int)v3[34] >> 31, 5) + 32 * ((int)v3[34] >> 31))) >> 5;
      *(_BYTE *)(v7 + 63) = v13;
      sub_36FA0(v7, v14);
      *(_WORD *)(v8 + 56) = *(_WORD *)(v8 + 80);
      sub_41CF0(v8, a1);
      sub_36DE0(v8);
    }
    v11 = v12;
    ++v14;
    ++v13;
  }
  while ( v13 <= 15 );
  sub_41CF0((int)v3, a1);
  sub_36DE0((int)v3);
  sub_36FA0((int)v3, 40);
  return v3;
}
// AE400: using guessed type int dword_AE400;

//----- (00038270) --------------------------------------------------------
int sub_38270(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // ecx
  int v5; // edx
  int v6; // eax

  v1 = sub_372C0();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 70) = 7;
  *(_BYTE *)(v1 + 64) = 5;
  *(_BYTE *)(v1 + 65) = 1;
  *(_WORD *)(v1 + 128) = 100;
  v3 = *(__int16 *)(v1 + 128);
  *(_WORD *)(v1 + 130) = 16;
  *(_DWORD *)(v1 + 8) = 2000;
  *(_WORD *)(v1 + 126) = v3 / 2;
  sub_36F90(v1);
  *(_WORD *)(v2 + 34) = 0;
  *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 34);
  v4 = dword_AE400;
  v5 = dword_AE400 + 29795;
  *(_WORD *)(v2 + 32) = *(_WORD *)(v2 + 34);
  *(_WORD *)(v2 + 36) = 0;
  *(_WORD *)(v2 + 28) = 1;
  v6 = *(char *)(v2 + 65);
  *(_WORD *)(v2 + 26) = (v2 - v5) / 164 % 100;
  LOBYTE(v5) = *(_BYTE *)(v4 + v6 + 12);
  *(_BYTE *)(v4 + v6 + 12) = v5 + 1;
  *(_DWORD *)(v2 + 156) = (uint32)&unk_990D8;
  *(_BYTE *)(v2 + 63) = v5;
  *(_BYTE *)(v2 + 58) = *(_BYTE *)(*(_DWORD *)(v2 + 156) + 26) + 1;
  *(_BYTE *)(v2 + 66) = 3;
  sub_41CF0(v2, a1);
  sub_36DE0(v2);
  sub_36FA0(v2, 86);
  return v2;
}
// AE400: using guessed type int dword_AE400;

//----- (00038370) --------------------------------------------------------
int sub_38370(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  int v7; // eax
  int v8; // ecx

  v1 = sub_372C0();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 70) = 13;
  *(_BYTE *)(v1 + 64) = 5;
  *(_BYTE *)(v1 + 65) = 2;
  *(_WORD *)(v1 + 128) = 70;
  v3 = *(__int16 *)(v1 + 128);
  *(_WORD *)(v1 + 130) = 30;
  *(_DWORD *)(v1 + 8) = 3000;
  *(_WORD *)(v1 + 126) = v3 / 2;
  sub_36F90(v1);
  v4 = 9377 * *(_DWORD *)(v2 + 4) + 9439;
  *(_DWORD *)(v2 + 4) = v4;
  LOWORD(v4) = (v4 & 0x7FF) - 1;
  *(_WORD *)(v2 + 34) = v4;
  *(_WORD *)(v2 + 30) = v4;
  v5 = dword_AE400;
  v6 = dword_AE400 + 29795;
  *(_WORD *)(v2 + 32) = *(_WORD *)(v2 + 34);
  *(_WORD *)(v2 + 36) = 0;
  *(_WORD *)(v2 + 44) = 350;
  *(_BYTE *)(v2 + 66) = 3;
  *(_BYTE *)(v2 + 67) = 0;
  v7 = *(char *)(v2 + 65);
  *(_WORD *)(v2 + 28) = 1;
  v8 = v7 + v5;
  *(_WORD *)(v2 + 26) = (v2 - v6) / 164 % 100;
  LOBYTE(v6) = *(_BYTE *)(v8 + 12);
  *(_BYTE *)(v8 + 12) = v6 + 1;
  *(_DWORD *)(v2 + 156) = (uint32)&unk_990F8;
  *(_BYTE *)(v2 + 63) = v6;
  *(_BYTE *)(v2 + 58) = *(_WORD *)(*(_DWORD *)(v2 + 156) + 26)
                      - *(unsigned __int8 *)(v2 + 63) % *(_WORD *)(*(_DWORD *)(v2 + 156) + 26)
                      + 4;
  *(_BYTE *)(v2 + 66) = 3;
  sub_41CF0(v2, a1);
  sub_36DE0(v2);
  sub_36FA0(v2, 3);
  sub_37130((_WORD *)v2, 128, 128);
  return v2;
}
// AE400: using guessed type int dword_AE400;

//----- (00038820) --------------------------------------------------------
int sub_38820(int a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 140)
     / ((*(_DWORD *)(a1 + 136) - (__CFSHL__(*(int *)(a1 + 136) >> 31, 3) + 8 * (*(int *)(a1 + 136) >> 31))) >> 3);
  if ( (v1 & 0x8000u) != 0 )
    LOWORD(v1) = 0;
  if ( (__int16)v1 > 7 )
    LOWORD(v1) = 7;
  if ( (__int16)v1 > *(__int16 *)(a1 + 86) - 185 )
    *(_DWORD *)(a1 + 8) += 5000;
  return sub_36FA0(a1, v1 + 185);
}

//----- (00038890) --------------------------------------------------------
int sub_38890(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // ecx

  v1 = sub_372C0();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_WORD *)(v1 + 128) = 30;
  v3 = *(_DWORD *)(v1 + 4);
  *(_WORD *)(v1 + 126) = *(_WORD *)(v1 + 128);
  *(_BYTE *)(v1 + 70) = 31;
  *(_BYTE *)(v1 + 64) = 5;
  *(_BYTE *)(v1 + 65) = 5;
  *(_WORD *)(v1 + 130) = 3;
  *(_DWORD *)(v1 + 8) = 5000;
  v4 = 9377 * v3 + 9439;
  *(_DWORD *)(v1 + 4) = v4;
  *(_DWORD *)(v1 + 140) = 500;
  LOWORD(v4) = (v4 & 0x7FF) - 1;
  *(_WORD *)(v1 + 34) = v4;
  *(_WORD *)(v1 + 30) = v4;
  v5 = dword_AE400;
  *(_WORD *)(v1 + 32) = *(_WORD *)(v1 + 34);
  *(_DWORD *)(v1 + 136) = 12000;
  *(_WORD *)(v1 + 36) = 0;
  *(_WORD *)(v1 + 26) = (v1 - (v5 + 29795)) / 164 % 100;
  v6 = *(char *)(v1 + 65);
  *(_WORD *)(v1 + 44) = 500;
  v7 = v6 + v5;
  *(_WORD *)(v1 + 28) = 1;
  LOBYTE(v6) = *(_BYTE *)(v7 + 12);
  *(_BYTE *)(v7 + 12) = v6 + 1;
  *(_DWORD *)(v1 + 156) = (uint32)&unk_99158;
  *(_BYTE *)(v1 + 63) = v6;
  v8 = *(__int16 *)(*(_DWORD *)(v1 + 156) + 26)
     - *(unsigned __int8 *)(v1 + 63) % *(__int16 *)(*(_DWORD *)(v1 + 156) + 26);
  *(_BYTE *)(v1 + 66) = 3;
  *(_BYTE *)(v1 + 58) = v8 + 4;
  sub_41CF0(v1, a1);
  sub_36DE0(v2);
  sub_36FA0(v2, 185);
  sub_37130((_WORD *)v2, 128, 128);
  *(_DWORD *)(v2 + 12) = 5000;
  return v2;
}
// AE400: using guessed type int dword_AE400;

//----- (000389E0) --------------------------------------------------------
_DWORD *sub_389E0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int64 v3; // rax
  int v4; // ecx
  int v5; // eax
  int v6; // ebp
  int v7; // edx
  int v9; // [esp+0h] [ebp-1Ch]
  _DWORD *v10; // [esp+4h] [ebp-18h]
  int i; // [esp+8h] [ebp-14h]

  if ( sub_37710() < 16 )
    return 0;
  v1 = sub_372C0();
  v2 = v1;
  v10 = (_DWORD *)v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 70) = 37;
  *(_BYTE *)(v1 + 64) = 5;
  *(_BYTE *)(v1 + 65) = 6;
  *(_WORD *)(v1 + 128) = 80;
  *(_WORD *)(v1 + 130) = 16;
  *(_WORD *)(v1 + 126) = 30;
  *(_DWORD *)(v1 + 8) = 9000;
  sub_36F90(v1);
  v3 = *(int *)(v2 + 140);
  *(_DWORD *)(v2 + 136) = v3;
  LODWORD(v3) = v3 / 3;
  HIDWORD(v3) = *(_DWORD *)(v2 + 4);
  *(_DWORD *)(v2 + 140) = v3;
  LODWORD(v3) = 9377 * HIDWORD(v3) + 9439;
  *(_DWORD *)(v2 + 4) = v3;
  LOWORD(v3) = (v3 & 0x7FF) - 1;
  *(_WORD *)(v2 + 34) = v3;
  *(_WORD *)(v2 + 30) = v3;
  v4 = dword_AE400;
  HIDWORD(v3) = dword_AE400 + 29795;
  *(_WORD *)(v2 + 32) = *(_WORD *)(v2 + 34);
  *(_WORD *)(v2 + 36) = 0;
  *(_WORD *)(v2 + 56) = 96;
  *(_WORD *)(v2 + 28) = 1;
  LODWORD(v3) = *(char *)(v2 + 65);
  *(_WORD *)(v2 + 26) = (v2 - HIDWORD(v3)) / 164 % 100;
  BYTE4(v3) = *(_BYTE *)(v4 + v3 + 12);
  *(_BYTE *)(v4 + v3 + 12) = BYTE4(v3) + 1;
  *(_DWORD *)(v2 + 156) = (uint32)&unk_99178;
  *(_BYTE *)(v2 + 58) = 64;
  v9 = v2;
  *(_BYTE *)(v2 + 66) = 3;
  *(_BYTE *)(v2 + 63) = BYTE4(v3);
  for ( i = 0; i <= 1; ++i )
  {
    v5 = sub_372C0();
    v6 = v5;
    if ( v5 )
    {
      qmemcpy((void *)v5, v10, 0xA4u);
      v7 = v5 - (dword_AE400 + 29795);
      *(_WORD *)(v5 + 52) = (v9 - (dword_AE400 + 29795)) / 164;
      *(_WORD *)(v9 + 54) = v7 / 164;
      *(_WORD *)(v5 + 54) = 0;
      *(_BYTE *)(v5 + 70) = 120;
      *(_DWORD *)(v5 + 140) = v10[34] / 3;
      *(_BYTE *)(v5 + 63) = i;
      if ( i )
        sub_36FA0(v5, 193);
      else
        sub_36FA0(v5, 50);
      *(_WORD *)(v6 + 56) = 4 * *(_WORD *)(v6 + 80);
      sub_41CF0(v6, a1);
      sub_36DE0(v6);
    }
    v9 = v6;
  }
  sub_41CF0((int)v10, a1);
  sub_36DE0((int)v10);
  sub_36FA0((int)v10, 49);
  return v10;
}
// AE400: using guessed type int dword_AE400;

//----- (00038C00) --------------------------------------------------------
int sub_38C00(int a1)
{
  int result; // eax

  if ( *(unsigned __int8 *)(a1 + 63) % 2 )
  {
    sub_36FA0(a1, 85);
    *(_BYTE *)(a1 + 71) = 1;
    *(_DWORD *)(a1 + 8) = 4000;
  }
  else
  {
    sub_36FA0(a1, 199);
    *(_BYTE *)(a1 + 71) = 2;
    *(_DWORD *)(a1 + 8) = 2000;
  }
  result = sub_36F90(a1);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  return result;
}

//----- (00038D60) --------------------------------------------------------
int sub_38D60(int a1)
{
  int result; // eax
  int v2; // ebx
  __int16 v3; // ax
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  int v7; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 49;
    *(_BYTE *)(result + 64) = 5;
    *(_BYTE *)(result + 65) = 8;
    *(_WORD *)(result + 128) = 40;
    *(_WORD *)(result + 130) = 20;
    v3 = *(_WORD *)(result + 128);
    *(_DWORD *)(v2 + 8) = 10000;
    *(_WORD *)(v2 + 126) = v3;
    sub_36F90(v2);
    v4 = 9377 * *(_DWORD *)(v2 + 4) + 9439;
    *(_DWORD *)(v2 + 4) = v4;
    LOWORD(v4) = (v4 & 0x7FF) - 1;
    *(_WORD *)(v2 + 34) = v4;
    *(_WORD *)(v2 + 30) = v4;
    v5 = dword_AE400;
    v6 = dword_AE400 + 29795;
    *(_WORD *)(v2 + 32) = *(_WORD *)(v2 + 34);
    *(_WORD *)(v2 + 36) = 0;
    *(_WORD *)(v2 + 44) = 1000;
    *(_WORD *)(v2 + 28) = 1;
    v7 = *(char *)(v2 + 65);
    *(_WORD *)(v2 + 26) = (v2 - v6) / 164 % 100;
    LOBYTE(v6) = *(_BYTE *)(v5 + v7 + 12);
    *(_BYTE *)(v5 + v7 + 12) = v6 + 1;
    *(_DWORD *)(v2 + 156) = (uint32)&unk_991B8;
    *(_BYTE *)(v2 + 58) = 64;
    *(_BYTE *)(v2 + 66) = 3;
    *(_BYTE *)(v2 + 63) = v6;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 47);
    sub_37130((_WORD *)v2, 128, 128);
    return v2;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00038E70) --------------------------------------------------------
int sub_38E70(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // ax
  __int16 v4; // dx
  int v5; // esi
  int v6; // ecx

  v1 = sub_372C0();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 70) = 54;
  *(_BYTE *)(v1 + 64) = 5;
  *(_BYTE *)(v1 + 65) = 9;
  *(_WORD *)(v1 + 128) = 20;
  *(_WORD *)(v1 + 130) = 0;
  v3 = *(_WORD *)(v1 + 128);
  *(_DWORD *)(v2 + 8) = 1000;
  *(_WORD *)(v2 + 126) = v3;
  sub_36F90(v2);
  *(_DWORD *)(v2 + 4) = 9377 * *(_DWORD *)(v2 + 4) + 9439;
  v4 = *(_DWORD *)(v2 + 4) % 0x832u;
  *(_WORD *)(v2 + 36) = 0;
  *(_WORD *)(v2 + 44) = 500;
  *(_WORD *)(v2 + 28) = 1;
  *(_WORD *)(v2 + 34) = --v4;
  *(_WORD *)(v2 + 30) = v4;
  v5 = dword_AE400;
  v6 = *(char *)(v2 + 65);
  *(_WORD *)(v2 + 32) = *(_WORD *)(v2 + 34);
  LOBYTE(v4) = *(_BYTE *)(v6 + v5 + 12);
  *(_BYTE *)(v6 + v5 + 12) = v4 + 1;
  *(_DWORD *)(v2 + 156) = (uint32)&unk_991D8;
  *(_BYTE *)(v2 + 63) = v4;
  *(_BYTE *)(v2 + 58) = *(_WORD *)(*(_DWORD *)(v2 + 156) + 26)
                      - *(unsigned __int8 *)(v2 + 63) % *(_WORD *)(*(_DWORD *)(v2 + 156) + 26)
                      + 4;
  *(_BYTE *)(v2 + 66) = 3;
  *(_WORD *)(v2 + 26) = (v2 - (v5 + 29795)) / 164 % 10 + 29;
  sub_41CF0(v2, a1);
  *(_WORD *)(v2 + 76) = sub_11F50((__int16 *)(v2 + 72));
  sub_36DE0(v2);
  sub_36FA0(v2, 220);
  sub_37130((_WORD *)v2, 128, 128);
  return v2;
}
// AE400: using guessed type int dword_AE400;

//----- (00038FC0) --------------------------------------------------------
int sub_38FC0(int a1)
{
  int result; // eax
  int v2; // ebx
  __int16 v3; // ax
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  int v7; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 61;
    *(_BYTE *)(result + 64) = 5;
    *(_BYTE *)(result + 65) = 10;
    *(_WORD *)(result + 128) = 60;
    *(_WORD *)(result + 130) = 20;
    v3 = *(_WORD *)(result + 128);
    *(_DWORD *)(v2 + 8) = 2000;
    *(_WORD *)(v2 + 126) = v3;
    sub_36F90(v2);
    v4 = 9377 * *(_DWORD *)(v2 + 4) + 9439;
    *(_DWORD *)(v2 + 4) = v4;
    LOWORD(v4) = (v4 & 0x7FF) - 1;
    *(_WORD *)(v2 + 34) = v4;
    *(_WORD *)(v2 + 30) = v4;
    v5 = dword_AE400;
    v6 = dword_AE400 + 29795;
    *(_WORD *)(v2 + 32) = *(_WORD *)(v2 + 34);
    *(_WORD *)(v2 + 36) = 0;
    *(_WORD *)(v2 + 44) = 500;
    *(_WORD *)(v2 + 28) = 1;
    v7 = *(char *)(v2 + 65);
    *(_WORD *)(v2 + 26) = (v2 - v6) / 164 % 100;
    LOBYTE(v6) = *(_BYTE *)(v5 + v7 + 12);
    *(_BYTE *)(v5 + v7 + 12) = v6 + 1;
    *(_DWORD *)(v2 + 156) = (uint32)&unk_991F8;
    *(_BYTE *)(v2 + 58) = 64;
    *(_BYTE *)(v2 + 66) = 3;
    *(_BYTE *)(v2 + 63) = v6;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 208);
    sub_37130((_WORD *)v2, 128, 128);
    return v2;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (000390D0) --------------------------------------------------------
int sub_390D0(int a1)
{
  int result; // eax
  int v2; // ebx
  __int16 v3; // ax
  int v4; // edx
  int v5; // eax
  int v6; // ecx
  int v7; // edx
  int v8; // edx

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 66;
    *(_BYTE *)(result + 64) = 5;
    *(_BYTE *)(result + 65) = 11;
    *(_WORD *)(result + 128) = 60;
    *(_WORD *)(result + 130) = 20;
    v3 = *(_WORD *)(result + 128);
    *(_DWORD *)(v2 + 8) = 20000;
    *(_WORD *)(v2 + 126) = v3;
    sub_36F90(v2);
    v4 = *(_DWORD *)(v2 + 4);
    *(_DWORD *)(v2 + 136) = 2 * *(_DWORD *)(v2 + 140);
    v5 = 9377 * v4 + 9439;
    *(_DWORD *)(v2 + 4) = v5;
    LOWORD(v5) = (v5 & 0x7FF) - 1;
    *(_WORD *)(v2 + 34) = v5;
    *(_WORD *)(v2 + 30) = v5;
    v6 = dword_AE400;
    v7 = dword_AE400 + 29795;
    *(_WORD *)(v2 + 32) = *(_WORD *)(v2 + 34);
    *(_WORD *)(v2 + 36) = 0;
    *(_WORD *)(v2 + 44) = 500;
    *(_WORD *)(v2 + 26) = (v2 - v7) / 164 % 100;
    v8 = *(char *)(v2 + 65);
    *(_WORD *)(v2 + 28) = 1;
    LOBYTE(v5) = *(_BYTE *)(v6 + v8 + 12);
    *(_BYTE *)(v6 + v8 + 12) = v5 + 1;
    *(_DWORD *)(v2 + 156) = (uint32)&unk_99218;
    *(_BYTE *)(v2 + 58) = 64;
    *(_BYTE *)(v2 + 66) = 3;
    *(_WORD *)(v2 + 26) = 0;
    *(_BYTE *)(v2 + 63) = v5;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 200);
    sub_37130((_WORD *)v2, 128, 128);
    return v2;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00039200) --------------------------------------------------------
int sub_39200(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  int v7; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 73;
    *(_BYTE *)(result + 64) = 5;
    *(_BYTE *)(result + 65) = 12;
    *(_WORD *)(result + 128) = 40;
    *(_WORD *)(result + 130) = 20;
    v3 = *(_DWORD *)(result + 4);
    *(_WORD *)(result + 126) = *(_WORD *)(result + 128);
    v4 = 9377 * v3 + 9439;
    *(_DWORD *)(v2 + 4) = v4;
    LOWORD(v4) = (v4 & 0x7FF) - 1;
    *(_WORD *)(v2 + 34) = v4;
    *(_WORD *)(v2 + 30) = v4;
    v5 = dword_AE400;
    v6 = dword_AE400 + 29795;
    *(_WORD *)(v2 + 32) = *(_WORD *)(v2 + 34);
    *(_DWORD *)(v2 + 8) = 1000;
    *(_DWORD *)(v2 + 140) = 0;
    *(_WORD *)(v2 + 36) = 0;
    *(_WORD *)(v2 + 44) = 500;
    *(_WORD *)(v2 + 28) = 1;
    v7 = *(char *)(v2 + 65);
    *(_WORD *)(v2 + 26) = (v2 - v6) / 164 % 100;
    LOBYTE(v6) = *(_BYTE *)(v5 + v7 + 12);
    *(_BYTE *)(v5 + v7 + 12) = v6 + 1;
    *(_DWORD *)(v2 + 156) = (uint32)&unk_99078;
    *(_BYTE *)(v2 + 58) = 64;
    *(_BYTE *)(v2 + 66) = 3;
    *(_WORD *)(v2 + 26) = 2;
    *(_BYTE *)(v2 + 63) = v6;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 221);
    sub_37130((_WORD *)v2, 128, 128);
    return v2;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00039490) --------------------------------------------------------
int sub_39490(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  int v7; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 85;
    *(_BYTE *)(result + 64) = 5;
    *(_BYTE *)(result + 65) = 14;
    *(_WORD *)(result + 128) = 40;
    *(_WORD *)(result + 130) = 20;
    v3 = *(_DWORD *)(result + 4);
    *(_WORD *)(result + 126) = *(_WORD *)(result + 128);
    v4 = 9377 * v3 + 9439;
    *(_DWORD *)(v2 + 4) = v4;
    LOWORD(v4) = (v4 & 0x7FF) - 1;
    *(_WORD *)(v2 + 34) = v4;
    *(_WORD *)(v2 + 30) = v4;
    v5 = dword_AE400;
    v6 = dword_AE400 + 29795;
    *(_WORD *)(v2 + 32) = *(_WORD *)(v2 + 34);
    *(_DWORD *)(v2 + 8) = 1000;
    *(_DWORD *)(v2 + 140) = 0;
    *(_WORD *)(v2 + 36) = 0;
    *(_WORD *)(v2 + 44) = 500;
    *(_WORD *)(v2 + 28) = 1;
    v7 = *(char *)(v2 + 65);
    *(_WORD *)(v2 + 26) = (v2 - v6) / 164 % 100;
    LOBYTE(v6) = *(_BYTE *)(v5 + v7 + 12);
    *(_BYTE *)(v5 + v7 + 12) = v6 + 1;
    *(_DWORD *)(v2 + 156) = (uint32)&unk_99078;
    *(_BYTE *)(v2 + 58) = 64;
    *(_BYTE *)(v2 + 66) = 3;
    *(_WORD *)(v2 + 26) = 2;
    *(_BYTE *)(v2 + 63) = v6;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 219);
    sub_37130((_WORD *)v2, 128, 128);
    return v2;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (000395B0) --------------------------------------------------------
int sub_395B0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  char v6; // ah

  v1 = sub_372C0();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 70) = 91;
  *(_BYTE *)(v1 + 64) = 5;
  *(_BYTE *)(v1 + 65) = 15;
  *(_WORD *)(v1 + 128) = 30;
  *(_WORD *)(v1 + 130) = 0;
  *(_DWORD *)(v1 + 8) = 1000;
  *(_WORD *)(v1 + 34) = 0;
  *(_WORD *)(v1 + 126) = *(_WORD *)(v1 + 128);
  *(_WORD *)(v1 + 30) = *(_WORD *)(v1 + 34);
  v3 = dword_AE400;
  *(_WORD *)(v1 + 32) = *(_WORD *)(v1 + 34);
  *(_DWORD *)(v1 + 140) = 0;
  *(_WORD *)(v1 + 36) = 0;
  *(_WORD *)(v1 + 26) = (v1 - (v3 + 29795)) / 164 % 100;
  v4 = *(char *)(v1 + 65);
  *(_WORD *)(v1 + 44) = 500;
  v5 = v4 + v3;
  *(_WORD *)(v1 + 28) = 1;
  LOBYTE(v4) = *(_BYTE *)(v5 + 12);
  *(_BYTE *)(v5 + 12) = v4 + 1;
  *(_DWORD *)(v1 + 156) = (uint32)&unk_99238;
  *(_BYTE *)(v1 + 63) = v4;
  LOWORD(v5) = *(_WORD *)(*(_DWORD *)(v1 + 156) + 26);
  LOWORD(v4) = *(unsigned __int8 *)(v1 + 63) % (__int16)v5;
  *(_BYTE *)(v1 + 66) = 3;
  v6 = *(_BYTE *)(v1 + 18) | 2;
  *(_BYTE *)(v2 + 58) = v5 - v4 + 4;
  *(_BYTE *)(v2 + 18) = v6;
  sub_41CF0(v2, a1);
  sub_36DE0(v2);
  sub_36FA0(v2, 0);
  sub_37130((_WORD *)v2, 128, 128);
  return v2;
}
// AE400: using guessed type int dword_AE400;

//----- (000396E0) --------------------------------------------------------
int sub_396E0(int a1)
{
  int result; // eax
  int v2; // ebx
  __int16 v3; // ax
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  int v7; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 97;
    *(_BYTE *)(result + 64) = 5;
    *(_BYTE *)(result + 65) = 16;
    *(_WORD *)(result + 128) = 60;
    *(_WORD *)(result + 130) = 20;
    v3 = *(_WORD *)(result + 128);
    *(_DWORD *)(v2 + 8) = 100000;
    *(_WORD *)(v2 + 126) = v3;
    sub_36F90(v2);
    v4 = 9377 * *(_DWORD *)(v2 + 4) + 9439;
    *(_DWORD *)(v2 + 4) = v4;
    LOWORD(v4) = (v4 & 0x7FF) - 1;
    *(_WORD *)(v2 + 34) = v4;
    *(_WORD *)(v2 + 30) = v4;
    v5 = dword_AE400;
    v6 = dword_AE400 + 29795;
    *(_WORD *)(v2 + 32) = *(_WORD *)(v2 + 34);
    *(_WORD *)(v2 + 36) = 0;
    *(_WORD *)(v2 + 44) = 500;
    *(_WORD *)(v2 + 28) = 1;
    v7 = *(char *)(v2 + 65);
    *(_WORD *)(v2 + 26) = (v2 - v6) / 164 % 100;
    LOBYTE(v6) = *(_BYTE *)(v5 + v7 + 12);
    *(_BYTE *)(v5 + v7 + 12) = v6 + 1;
    *(_DWORD *)(v2 + 156) = (uint32)&unk_99258;
    *(_BYTE *)(v2 + 58) = 64;
    *(_BYTE *)(v2 + 66) = 3;
    *(_WORD *)(v2 + 26) = 0;
    *(_BYTE *)(v2 + 63) = v6;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 207);
    sub_37130((_WORD *)v2, 128, 128);
    return v2;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00039800) --------------------------------------------------------
int sub_39800()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00039820) --------------------------------------------------------
int sub_39820()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00039840) --------------------------------------------------------
int sub_39840()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00039860) --------------------------------------------------------
int sub_39860()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00039880) --------------------------------------------------------
int sub_39880()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (000398A0) --------------------------------------------------------
int sub_398A0()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (000398C0) --------------------------------------------------------
int sub_398C0()
{
  int result; // eax
  int v1; // ebx
  int v2; // edx
  int v3; // eax
  int v4; // edx
  int v5; // eax

  result = sub_372C0();
  v1 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 4;
    *(_BYTE *)(result + 64) = 7;
    *(_BYTE *)(result + 65) = 4;
    *(_WORD *)(result + 128) = 80;
    v2 = *(__int16 *)(result + 128);
    *(_WORD *)(result + 130) = 16;
    v3 = v2 / 2;
    v4 = *(_DWORD *)(v1 + 4);
    *(_WORD *)(v1 + 126) = v3;
    v5 = 9377 * v4 + 9439;
    *(_DWORD *)(v1 + 4) = v5;
    LOWORD(v5) = (v5 & 0x7FF) - 1;
    *(_WORD *)(v1 + 34) = v5;
    *(_WORD *)(v1 + 30) = v5;
    *(_BYTE *)(v1 + 16) &= ~8u;
    sub_36DE0(v1);
    return v1;
  }
  return result;
}

//----- (00039940) --------------------------------------------------------
int sub_39940()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00039960) --------------------------------------------------------
int sub_39960()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00039980) --------------------------------------------------------
int sub_39980()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (000399A0) --------------------------------------------------------
int sub_399A0()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (000399C0) --------------------------------------------------------
int sub_399C0()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (000399E0) --------------------------------------------------------
int sub_399E0()
{
  int v0; // eax

  v0 = sub_372C0();
  if ( v0 )
    sub_36DE0(v0);
  return 0;
}

//----- (00039A10) --------------------------------------------------------
int sub_39A10(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 0;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 0;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 0x2000 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 156) = (uint32)&off_98FD8;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 42);
    return v2;
  }
  return result;
}
// 98FD8: using guessed type void *off_98FD8;

//----- (00039A90) --------------------------------------------------------
int sub_39A90(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 1;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 1;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 4096 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 156) = (uint32)&unk_98F78;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_BYTE *)(v2 + 66) = 10;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 209);
    sub_37130((_WORD *)v2, 2 * *(_WORD *)(v2 + 80), 2 * *(_WORD *)(v2 + 84));
    return v2;
  }
  return result;
}

//----- (00039B40) --------------------------------------------------------
int sub_39B40(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 2;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 2;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 0x2000 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 156) = (uint32)&unk_98F58;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 211);
    return v2;
  }
  return result;
}

//----- (00039BC0) --------------------------------------------------------
int sub_39BC0(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 3;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 3;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 0x2000 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 156) = (uint32)&unk_98F58;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 76);
    return v2;
  }
  return result;
}

//----- (00039C40) --------------------------------------------------------
int sub_39C40(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 4;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 4;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 0x2000 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 156) = (uint32)&unk_98F58;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 210);
    return v2;
  }
  return result;
}

//----- (00039CC0) --------------------------------------------------------
int sub_39CC0(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 5;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 5;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 0x2000 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 156) = (uint32)&unk_98F58;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 211);
    return v2;
  }
  return result;
}

//----- (00039D40) --------------------------------------------------------
int sub_39D40(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 6;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 6;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 0x2000 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 156) = (uint32)&unk_98F58;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 212);
    return v2;
  }
  return result;
}

//----- (00039DC0) --------------------------------------------------------
int sub_39DC0(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 7;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 7;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 0x2000 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 156) = (uint32)&unk_98F58;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 213);
    return v2;
  }
  return result;
}

//----- (00039E40) --------------------------------------------------------
int sub_39E40(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 8;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 8;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 0x2000 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 156) = (uint32)&off_98FB8;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 214);
    return v2;
  }
  return result;
}
// 98FB8: using guessed type void *off_98FB8;

//----- (00039EC0) --------------------------------------------------------
int sub_39EC0(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 9;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 9;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 3584 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 156) = (uint32)&off_98FB8;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 216);
    return v2;
  }
  return result;
}
// 98FB8: using guessed type void *off_98FB8;

//----- (00039F40) --------------------------------------------------------
int sub_39F40(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 10;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 10;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 0x2000 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 156) = (uint32)&unk_98F58;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 18);
    return v2;
  }
  return result;
}

//----- (00039FC0) --------------------------------------------------------
int sub_39FC0(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 11;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 11;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 0x2000 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 156) = (uint32)&unk_98F58;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 281);
    return v2;
  }
  return result;
}

//----- (0003A040) --------------------------------------------------------
int sub_3A040(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 12;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 12;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 2048 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 156) = (uint32)&unk_98F58;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 216);
    return v2;
  }
  return result;
}

//----- (0003A0C0) --------------------------------------------------------
int sub_3A0C0(int a1)
{
  int result; // eax
  _WORD *v2; // ebx

  result = sub_372C0();
  v2 = (_WORD *)result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 13;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 13;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    *(_DWORD *)(result + 8) = 5120 / *(__int16 *)(result + 126);
    *(_BYTE *)(result + 16) &= ~8u;
    sub_41CF0(result, a1);
    sub_36DE0((int)v2);
    sub_370A0(v2, 195);
    return (int)v2;
  }
  return result;
}

//----- (0003A1A0) --------------------------------------------------------
int sub_3A1A0(int a1)
{
  int result; // eax
  int v2; // ebx

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 15;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 14;
    *(_WORD *)(result + 126) = 128;
    *(_WORD *)(result + 128) = 128;
    *(_DWORD *)(result + 8) = 4096 / *(__int16 *)(result + 126);
    *(_BYTE *)(result + 16) &= ~8u;
    sub_41CF0(result, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 196);
    return v2;
  }
  return result;
}

//----- (0003A210) --------------------------------------------------------
int sub_3A210(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 8) = 80;
    *(_BYTE *)(v1 + 70) = 16;
    *(_BYTE *)(v1 + 64) = 9;
    *(_BYTE *)(v1 + 65) = 15;
    *(_WORD *)(v1 + 126) = 128;
    *(_WORD *)(v1 + 128) = 128;
    *(_BYTE *)(v1 + 16) &= ~8u;
    sub_41CF0(v1, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 215);
  }
  return v2;
}

//----- (0003A270) --------------------------------------------------------
int sub_3A270(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 17;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 16;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 0x2000 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 156) = (uint32)&off_98FD8;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 42);
    return v2;
  }
  return result;
}
// 98FD8: using guessed type void *off_98FD8;

//----- (0003A2F0) --------------------------------------------------------
int sub_3A2F0(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 18;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 17;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 4096 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 156) = (uint32)&unk_98F78;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 209);
    sub_37130((_WORD *)v2, 2 * *(_WORD *)(v2 + 80), 2 * *(_WORD *)(v2 + 84));
    return v2;
  }
  return result;
}

//----- (0003A390) --------------------------------------------------------
int sub_3A390(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 19;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 18;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 0x2000 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 156) = (uint32)&off_98FD8;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 42);
    return v2;
  }
  return result;
}
// 98FD8: using guessed type void *off_98FD8;

//----- (0003A410) --------------------------------------------------------
int sub_3A410(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 20;
    *(_BYTE *)(result + 64) = 9;
    *(_BYTE *)(result + 65) = 19;
    *(_WORD *)(result + 126) = 384;
    *(_WORD *)(result + 128) = 384;
    v3 = 0x2000 / *(__int16 *)(result + 126);
    *(_DWORD *)(v2 + 140) = 50;
    *(_DWORD *)(v2 + 8) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 156) = (uint32)&off_98FD8;
    *(_BYTE *)(v2 + 16) = BYTE1(v3) & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 42);
    return v2;
  }
  return result;
}
// 98FD8: using guessed type void *off_98FD8;

//----- (0003A490) --------------------------------------------------------
_WORD *sub_3A490(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_372C0();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 8) = 8;
    *(_BYTE *)(v1 + 70) = 0;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 0;
    *(_WORD *)(v1 + 44) = 400;
    v3 = *(_DWORD *)(v1 + 16);
    *(_WORD *)(v1 + 28) = 0;
    *(_DWORD *)(v1 + 16) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 18) |= 2u;
    sub_41CF0(v1, a1);
    sub_36DE0((int)v2);
    sub_36FA0((int)v2, 7);
    sub_37130(v2, 128, 128);
  }
  return v2;
}

//----- (0003A510) --------------------------------------------------------
int sub_3A510(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 1;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 1;
    *(_DWORD *)(v1 + 8) = 1;
    v3 = *(_DWORD *)(v1 + 16);
    *(_WORD *)(v1 + 44) = 400;
    *(_DWORD *)(v1 + 16) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 18) |= 2u;
    sub_41CF0(v1, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 41);
  }
  return v2;
}

//----- (0003A570) --------------------------------------------------------
int sub_3A570(int a1)
{
  int v1; // eax
  int v2; // ebx
  unsigned int v3; // edx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 8) = 8;
    *(_BYTE *)(v1 + 70) = 2;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 2;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    v3 = *(_DWORD *)(v1 + 16) & 0xFFFDFFF6;
    *(_WORD *)(v1 + 26) = 0;
    *(_DWORD *)(v1 + 16) = v3 | 0x20001;
    sub_36DE0(v1);
  }
  return v2;
}

//----- (0003A5D0) --------------------------------------------------------
int sub_3A5D0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  char v4; // ah

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 8) = 7;
    *(_BYTE *)(v1 + 70) = 3;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 3;
    v3 = *(_DWORD *)(v1 + 16);
    *(_WORD *)(v1 + 44) = 0;
    *(_DWORD *)(v1 + 16) = v3 & 0xFFFDFFF7;
    v4 = *(_BYTE *)(v1 + 18) | 2;
    *(_WORD *)(v2 + 26) = 0;
    *(_BYTE *)(v2 + 18) = v4;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 36);
  }
  return v2;
}

//----- (0003A640) --------------------------------------------------------
int sub_3A640(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 8) = 100;
    *(_BYTE *)(v1 + 70) = 4;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 4;
    v3 = *(_DWORD *)(v1 + 16);
    *(_WORD *)(v1 + 44) = 0;
    *(_DWORD *)(v1 + 16) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 18) |= 2u;
    *(_WORD *)(v1 + 26) = 0;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 76) = sub_11F50((__int16 *)(v1 + 72));
    sub_36DE0(v2);
  }
  return v2;
}

//----- (0003A6B0) --------------------------------------------------------
int sub_3A6B0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  char v4; // ah

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 8) = 8;
    *(_BYTE *)(v1 + 70) = 5;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 5;
    v3 = *(_DWORD *)(v1 + 16);
    *(_WORD *)(v1 + 44) = 0;
    *(_DWORD *)(v1 + 16) = v3 & 0xFFFDFFF7;
    v4 = *(_BYTE *)(v1 + 18) | 2;
    *(_WORD *)(v2 + 26) = 0;
    *(_BYTE *)(v2 + 18) = v4;
    sub_41CF0(v2, a1);
    *(_WORD *)(v2 + 76) = sub_11F50((__int16 *)(v2 + 72));
    sub_36DE0(v2);
    sub_36FA0(v2, 244);
  }
  return v2;
}

//----- (0003A730) --------------------------------------------------------
_WORD *sub_3A730(__int16 *a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_372C0();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 6;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 6;
    *(_WORD *)(v1 + 44) = 50;
    *(_DWORD *)(v1 + 8) = 240;
    v3 = *(_DWORD *)(v1 + 16);
    *(_WORD *)(v1 + 46) = 0;
    *(_DWORD *)(v1 + 16) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 18) |= 2u;
    sub_41CF0(v1, (int)a1);
    v2[38] = sub_11F50(a1);
    sub_36DE0((int)v2);
    sub_36FA0((int)v2, 228);
    sub_37130(v2, 272, 1536);
    v2[13] = 0;
  }
  return v2;
}

//----- (0003A7D0) --------------------------------------------------------
int sub_3A7D0(__int16 *a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // ecx
  unsigned int v5; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 7;
    *(_BYTE *)(result + 64) = 10;
    *(_BYTE *)(result + 65) = 7;
    v3 = *(_DWORD *)(result + 16);
    *(_DWORD *)(result + 8) = 12;
    *(_DWORD *)(result + 16) = v3 & 0xFFFDFFF7;
    v4 = *(_DWORD *)(result + 4);
    *(_BYTE *)(result + 18) |= 2u;
    v5 = 9377 * v4 + 9439;
    *(_DWORD *)(v2 + 4) = v5;
    *(_BYTE *)(v2 + 66) = 10;
    *(_BYTE *)(v2 + 67) = 7;
    *(_WORD *)(v2 + 126) = v5 % 0x14 + 20;
    sub_41CF0(v2, (int)a1);
    *(_WORD *)(v2 + 76) = sub_11F50(a1);
    sub_37030((_WORD *)v2, 78);
    sub_36DE0(v2);
    result = v2;
    *(_BYTE *)(v2 + 16) |= 1u;
  }
  return result;
}

//----- (0003A870) --------------------------------------------------------
int sub_3A870(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 8;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 8;
    *(_DWORD *)(v1 + 8) = 8;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    v3 = *(_BYTE *)(v1 + 16) & 0xF7;
    *(_WORD *)(v2 + 44) = 100;
    *(_BYTE *)(v2 + 16) = v3;
    sub_36DE0(v2);
    sub_37130((_WORD *)v2, 512, 512);
  }
  return v2;
}

//----- (0003A8D0) --------------------------------------------------------
_WORD *sub_3A8D0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_372C0();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 9;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 9;
    *(_DWORD *)(v1 + 8) = 17;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 44) = 2000;
    *(_BYTE *)(v1 + 16) &= ~8u;
    sub_36DE0(v1);
    sub_37130(v2, 768, 0x2000);
  }
  return v2;
}

//----- (0003A930) --------------------------------------------------------
_WORD *sub_3A930(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_372C0();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 10;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 10;
    *(_DWORD *)(v1 + 8) = 1;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    v3 = *(_DWORD *)(v1 + 16);
    *(_WORD *)(v1 + 44) = 100;
    *(_DWORD *)(v1 + 16) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 18) |= 2u;
    sub_36DE0(v1);
    sub_37130(v2, 128, 128);
  }
  return v2;
}

//----- (0003A9A0) --------------------------------------------------------
_WORD *sub_3A9A0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_372C0();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 11;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 11;
    *(_DWORD *)(v1 + 8) = 40;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    v3 = *(_DWORD *)(v1 + 16);
    *(_WORD *)(v1 + 44) = 200;
    *(_DWORD *)(v1 + 16) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 18) |= 2u;
    sub_36DE0(v1);
    sub_37130(v2, 2304, 0x2000);
  }
  return v2;
}

//----- (0003AA10) --------------------------------------------------------
int sub_3AA10(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 12;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 12;
    *(_DWORD *)(v1 + 8) = 8;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 44) = -1536;
    *(_BYTE *)(v1 + 16) = *(_BYTE *)(v1 + 16) & 0xF6 | 1;
    sub_41CF0(v1, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 41);
    *(_BYTE *)(v2 + 16) |= 1u;
    sub_37130((_WORD *)v2, 512, 512);
  }
  return v2;
}

//----- (0003AAA0) --------------------------------------------------------
int sub_3AAA0(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // edx
  unsigned int v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // eax
  unsigned int v7; // ecx
  unsigned int v8; // et2

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 13;
    *(_BYTE *)(result + 64) = 10;
    v3 = *(_DWORD *)(result + 4);
    *(_BYTE *)(result + 65) = 13;
    v4 = 9377 * v3 + 9439;
    *(_DWORD *)(v2 + 4) = v4;
    v5 = v4 % 0x17;
    v6 = 9377 * *(_DWORD *)(v2 + 4);
    v7 = *(_DWORD *)(v2 + 16) & 0xFFFDFFF7;
    *(_DWORD *)(v2 + 8) = v5 + 17;
    *(_DWORD *)(v2 + 16) = v7;
    v6 += 9439;
    *(_DWORD *)(v2 + 4) = v6;
    v8 = v6 % 0x35;
    *(_BYTE *)(v2 + 66) = 10;
    *(_BYTE *)(v2 + 67) = 13;
    BYTE1(v6) = *(_BYTE *)(v2 + 18) | 2;
    *(_WORD *)(v2 + 126) = v8 + 51;
    *(_BYTE *)(v2 + 18) = BYTE1(v6);
    sub_41CF0(v2, a1);
    sub_37030((_WORD *)v2, 67);
    sub_36DE0(v2);
    return v2;
  }
  return result;
}

//----- (0003AB40) --------------------------------------------------------
int sub_3AB40(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // edx
  unsigned int v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // eax
  unsigned int v7; // ecx
  unsigned int v8; // et2

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 14;
    *(_BYTE *)(result + 64) = 10;
    v3 = *(_DWORD *)(result + 4);
    *(_BYTE *)(result + 65) = 14;
    v4 = 9377 * v3 + 9439;
    *(_DWORD *)(v2 + 4) = v4;
    v5 = v4 % 0x21;
    v6 = 9377 * *(_DWORD *)(v2 + 4);
    v7 = *(_DWORD *)(v2 + 16) & 0xFFFDFFF7;
    *(_DWORD *)(v2 + 8) = v5 + 28;
    *(_DWORD *)(v2 + 16) = v7;
    v6 += 9439;
    *(_DWORD *)(v2 + 4) = v6;
    v8 = v6 % 0x35;
    *(_BYTE *)(v2 + 66) = 10;
    *(_BYTE *)(v2 + 67) = 14;
    BYTE1(v6) = *(_BYTE *)(v2 + 18) | 2;
    *(_WORD *)(v2 + 126) = v8 + 51;
    *(_BYTE *)(v2 + 18) = BYTE1(v6);
    sub_41CF0(v2, a1);
    sub_37030((_WORD *)v2, 9);
    sub_36DE0(v2);
    return v2;
  }
  return result;
}

//----- (0003ABE0) --------------------------------------------------------
int sub_3ABE0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // eax

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 15;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 15;
    *(_DWORD *)(v1 + 8) = 128;
    *(_WORD *)(v1 + 126) = 256;
    v3 = *(_DWORD *)(v1 + 4);
    *(_BYTE *)(v1 + 16) &= ~8u;
    *(_WORD *)(v1 + 44) = 100;
    *(_WORD *)(v1 + 26) = 0;
    v4 = 9377 * v3 + 9439;
    *(_DWORD *)(v2 + 4) = v4;
    *(_WORD *)(v2 + 30) = v4 & 0x7FF;
    *(_DWORD *)(v2 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 76) = *(_WORD *)(a1 + 4);
    sub_36DE0(v2);
    sub_37130((_WORD *)v2, 1024, 0x4000);
  }
  return v2;
}

//----- (0003AC70) --------------------------------------------------------
int sub_3AC70(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 17;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 17;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    *(_DWORD *)(v1 + 8) = 10;
    *(_WORD *)(v1 + 44) = 3000;
    *(_BYTE *)(v1 + 16) &= ~8u;
    sub_36DE0(v1);
  }
  return v2;
}

//----- (0003ACC0) --------------------------------------------------------
int sub_3ACC0(__int16 *a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // ecx
  unsigned int v5; // eax
  unsigned int v6; // edx
  unsigned int v7; // eax
  unsigned int v8; // edx
  int v9; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 16;
    *(_BYTE *)(result + 64) = 10;
    *(_BYTE *)(result + 65) = 16;
    v3 = *(_DWORD *)(result + 16);
    *(_WORD *)(result + 44) = 200;
    v4 = *(_DWORD *)(result + 4);
    *(_DWORD *)(result + 16) = v3 & 0xFFFDFFF7;
    v5 = 9377 * v4 + 9439;
    *(_DWORD *)(v2 + 4) = v5;
    v6 = v5 % 0x64;
    v7 = 9377 * *(_DWORD *)(v2 + 4);
    *(_DWORD *)(v2 + 8) = v6 + 100;
    v7 += 9439;
    *(_DWORD *)(v2 + 4) = v7;
    v8 = v7 % 0x32;
    v9 = 9377 * *(_DWORD *)(v2 + 4);
    *(_WORD *)(v2 + 46) = 256;
    v9 += 9439;
    *(_DWORD *)(v2 + 4) = v9;
    *(_WORD *)(v2 + 30) = v9 & 0x7FF;
    BYTE1(v9) = *(_BYTE *)(v2 + 18);
    *(_WORD *)(v2 + 126) = v8 + 52;
    *(_BYTE *)(v2 + 18) = BYTE1(v9) | 2;
    sub_41CF0(v2, (int)a1);
    *(_WORD *)(v2 + 76) = sub_11F50(a1) + 64;
    sub_41EC0((_WORD *)(v2 + 150), *(_WORD *)(v2 + 30), 0, *(_WORD *)(v2 + 126));
    sub_36DE0(v2);
    sub_36FA0(v2, 210);
    return v2;
  }
  return result;
}

//----- (0003ADB0) --------------------------------------------------------
int sub_3ADB0(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 18;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 18;
    *(_WORD *)(v1 + 44) = 200;
    v3 = *(_BYTE *)(v1 + 16);
    *(_WORD *)(v2 + 26) = 0;
    *(_DWORD *)(v2 + 8) = 10000;
    *(_BYTE *)(v2 + 16) = v3 & 0xF7;
    *(_DWORD *)(v2 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 76) = *(_WORD *)(a1 + 4);
    sub_36DE0(v2);
  }
  return v2;
}

//----- (0003AE00) --------------------------------------------------------
int sub_3AE00(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 19;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 19;
    *(_WORD *)(v1 + 44) = 200;
    v3 = *(_DWORD *)(v1 + 16);
    *(_DWORD *)(v1 + 8) = 240;
    *(_DWORD *)(v1 + 16) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 18) |= 2u;
    sub_41CF0(v1, a1);
    *(_BYTE *)(v2 + 16) |= 1u;
    sub_36DE0(v2);
    sub_36FA0(v2, 228);
    sub_37130((_WORD *)v2, 512, 512);
  }
  return v2;
}

//----- (0003AE80) --------------------------------------------------------
int sub_3AE80(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 8) = 8;
    *(_BYTE *)(v1 + 70) = 23;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 23;
    v3 = *(_DWORD *)(v1 + 16);
    *(_WORD *)(v1 + 44) = 25;
    *(_DWORD *)(v1 + 16) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 18) |= 2u;
    sub_41CF0(v1, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 7);
    sub_37130((_WORD *)v2, 200, 200);
    *(_BYTE *)(v2 + 16) |= 1u;
  }
  return v2;
}

//----- (0003AF00) --------------------------------------------------------
_WORD *sub_3AF00(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_372C0();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 25;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 25;
    *(_DWORD *)(v1 + 8) = 8;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 44) = 2000;
    *(_BYTE *)(v1 + 16) &= ~8u;
    sub_41CF0(v1, a1);
    sub_36DE0((int)v2);
    sub_36FA0((int)v2, 283);
    sub_37130(v2, 512, 512);
  }
  return v2;
}

//----- (0003AF80) --------------------------------------------------------
_WORD *sub_3AF80(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_372C0();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 26;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 26;
    *(_DWORD *)(v1 + 8) = 8;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 44) = 200;
    *(_BYTE *)(v1 + 16) &= ~8u;
    sub_41CF0(v1, a1);
    sub_36DE0((int)v2);
    sub_36FA0((int)v2, 284);
    sub_37130(v2, 512, 512);
  }
  return v2;
}

//----- (0003B000) --------------------------------------------------------
int sub_3B000(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 8) = 2;
    *(_BYTE *)(v1 + 70) = 27;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 27;
    *(_WORD *)(v1 + 44) = (*(__int16 *)(a1 + 4) >> 5) + 48;
    v3 = *(_BYTE *)(v1 + 16);
    *(_WORD *)(v2 + 26) = 10;
    *(_BYTE *)(v2 + 16) = v3 & 0xF7;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
  }
  return v2;
}

//----- (0003B060) --------------------------------------------------------
int sub_3B060(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 8) = 0;
    *(_BYTE *)(v1 + 70) = 30;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 28;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 16) &= ~8u;
    sub_41CF0(v1, a1);
    sub_36DE0(v2);
  }
  return v2;
}

//----- (0003B0C0) --------------------------------------------------------
int sub_3B0C0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 8) = 0;
    *(_BYTE *)(v1 + 70) = 32;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 30;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 16) &= ~8u;
    sub_41CF0(v1, a1);
    sub_36DE0(v2);
  }
  return v2;
}

//----- (0003B120) --------------------------------------------------------
int sub_3B120(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 8) = 0;
    *(_BYTE *)(v1 + 70) = 31;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 29;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 16) &= ~8u;
    sub_41CF0(v1, a1);
    sub_36DE0(v2);
  }
  return v2;
}

//----- (0003B180) --------------------------------------------------------
int sub_3B180(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 8) = 0;
    *(_BYTE *)(v1 + 70) = 34;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 32;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    v3 = *(_BYTE *)(v1 + 16) & 0xF7;
    *(_WORD *)(v2 + 126) = 256;
    *(_BYTE *)(v2 + 16) = v3;
    sub_36DE0(v2);
  }
  return v2;
}

//----- (0003B1D0) --------------------------------------------------------
int sub_3B1D0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 8) = 0;
    *(_BYTE *)(v1 + 70) = 33;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 31;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 16) &= ~8u;
    sub_41CF0(v1, a1);
    sub_36DE0(v2);
  }
  return v2;
}

//----- (0003B230) --------------------------------------------------------
int sub_3B230(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 8) = 0;
    *(_BYTE *)(v1 + 70) = 55;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 51;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    v3 = *(_BYTE *)(v1 + 16);
    *(_WORD *)(v2 + 26) = 256;
    *(_WORD *)(v2 + 126) = 1024;
    *(_BYTE *)(v2 + 16) = v3 & 0xF7;
    sub_37130((_WORD *)v2, 768, 768);
    sub_36DE0(v2);
  }
  return v2;
}

//----- (0003B2A0) --------------------------------------------------------
int sub_3B2A0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 8) = 0;
    *(_BYTE *)(v1 + 70) = 54;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 50;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 16) &= ~8u;
    sub_41CF0(v1, a1);
    sub_36DE0(v2);
  }
  return v2;
}

//----- (0003B300) --------------------------------------------------------
int sub_3B300(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 36;
    *(_BYTE *)(result + 64) = 10;
    *(_BYTE *)(result + 65) = 34;
    *(_DWORD *)(result + 8) = 0;
    *(_BYTE *)(result + 66) = 3;
    *(_BYTE *)(result + 67) = -1;
    *(_BYTE *)(result + 16) &= ~8u;
    *(_DWORD *)(result + 72) = *(_DWORD *)a1;
    *(_WORD *)(result + 76) = *(_WORD *)(a1 + 4);
    sub_36FA0(result, 223);
    sub_37130((_WORD *)v2, 256, 256);
    sub_36DE0(v2);
    sub_41CF0(v2, a1);
    *(_WORD *)(v2 + 76) = sub_11F50((__int16 *)(v2 + 72)) + 640;
    *(_DWORD *)(v2 + 150) = *(_DWORD *)(v2 + 72);
    *(_WORD *)(v2 + 154) = *(_WORD *)(v2 + 76);
    v3 = 9377 * *(_DWORD *)(v2 + 4) + 9439;
    *(_DWORD *)(v2 + 4) = v3;
    sub_41EC0((_WORD *)(v2 + 150), v3 & 0x7FF, 0, -32768);
    return v2;
  }
  return result;
}

//----- (0003B3D0) --------------------------------------------------------
int sub_3B3D0()
{
  return sub_372C0();
}

//----- (0003B3E0) --------------------------------------------------------
_WORD *sub_3B3E0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_372C0();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 38;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 36;
    *(_DWORD *)(v1 + 8) = 8;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 44) = -1536;
    *(_BYTE *)(v1 + 16) &= ~8u;
    sub_41CF0(v1, a1);
    sub_36DE0((int)v2);
    sub_36FA0((int)v2, 41);
    sub_37130(v2, 512, 512);
  }
  return v2;
}

//----- (0003B460) --------------------------------------------------------
int sub_3B460(int a1)
{
  _BYTE *v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = (_BYTE *)sub_372C0();
  v2 = (int)v1;
  if ( v1 )
  {
    v1[70] = 40;
    v1[64] = 10;
    v1[65] = 38;
    v3 = v1[16] & 0xF7;
    *(_DWORD *)(v2 + 8) = 32;
    *(_BYTE *)(v2 + 16) = v3;
    sub_41CF0(v2, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 272);
    sub_37130((_WORD *)v2, 512, 512);
  }
  return v2;
}

//----- (0003B4D0) --------------------------------------------------------
_WORD *sub_3B4D0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_372C0();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 35;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 33;
    *(_BYTE *)(v1 + 16) &= ~8u;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    sub_36DE0(v1);
    sub_37130(v2, 512, 512);
  }
  return v2;
}

//----- (0003B5A0) --------------------------------------------------------
int sub_3B5A0(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // edx

  result = sub_372C0();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 41;
    *(_BYTE *)(result + 64) = 10;
    *(_BYTE *)(result + 65) = 39;
    *(_BYTE *)(result + 66) = 10;
    *(_BYTE *)(result + 67) = 39;
    *(_WORD *)(result + 46) = 128;
    v3 = dword_AE408;
    *(_DWORD *)(result + 140) = 512;
    if ( (*(_BYTE *)(v3 + 1) & 2) != 0 )
      *(_DWORD *)(result + 140) = 2500;
    *(_WORD *)(result + 126) = 32;
    *(_WORD *)(result + 28) = 3;
    *(_BYTE *)(result + 58) = 0x80;
    *(_BYTE *)(result + 59) = 0;
    sub_41CF0(result, a1);
    sub_36DE0(v2);
    sub_274D0(v2);
    return v2;
  }
  return result;
}
// AE408: using guessed type int dword_AE408;

//----- (0003B620) --------------------------------------------------------
int sub_3B620(int a1)
{
  int result; // eax
  _WORD *v2; // ebx

  result = sub_372C0();
  v2 = (_WORD *)result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = 42;
    *(_BYTE *)(result + 64) = 10;
    *(_BYTE *)(result + 65) = 40;
    *(_WORD *)(result + 26) = (result - (dword_AE400 + 29795)) / 164 % 11;
    *(_WORD *)(result + 28) = 2;
    sub_41CF0(result, a1);
    sub_36DE0((int)v2);
    sub_37030(v2, 65);
    return (int)v2;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (0003B690) --------------------------------------------------------
int sub_3B690(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 8) = 30;
    *(_BYTE *)(v1 + 70) = 51;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 45;
    *(_WORD *)(v1 + 44) = 100;
    *(_WORD *)(v1 + 26) = 4;
    *(_DWORD *)(v1 + 16) = 9;
    *(_WORD *)(v1 + 28) = 33;
    sub_41CF0(v1, a1);
    sub_36FA0(v2, 177);
  }
  return v2;
}

//----- (0003B6F0) --------------------------------------------------------
_WORD *sub_3B6F0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_372C0();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 45;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 43;
    *(_DWORD *)(v1 + 8) = 8;
    *(_WORD *)(v1 + 44) = -1536;
    *(_BYTE *)(v1 + 16) &= ~8u;
    sub_41CF0(v1, a1);
    sub_36DE0((int)v2);
    sub_36FA0((int)v2, 41);
    sub_37130(v2, 512, 512);
  }
  return v2;
}

//----- (0003B760) --------------------------------------------------------
int sub_3B760(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 43;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 41;
    *(_DWORD *)(v1 + 8) = 0;
    *(_BYTE *)(v1 + 16) &= ~8u;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    sub_36DE0(v1);
  }
  return v2;
}

//----- (0003B7B0) --------------------------------------------------------
int sub_3B7B0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 44;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 42;
    *(_DWORD *)(v1 + 8) = 0;
    *(_BYTE *)(v1 + 16) &= ~8u;
    *(_DWORD *)(v1 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 76) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 60) = 1;
    sub_36DE0(v1);
  }
  return v2;
}

//----- (0003B800) --------------------------------------------------------
int sub_3B800(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 46;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 44;
    *(_DWORD *)(v1 + 8) = 500;
    *(_WORD *)(v1 + 44) = 500;
    *(_BYTE *)(v1 + 16) &= ~8u;
    sub_41CF0(v1, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 8);
  }
  return v2;
}

//----- (0003B860) --------------------------------------------------------
int sub_3B860(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 56;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 52;
    *(_DWORD *)(v1 + 8) = 100000;
    *(_WORD *)(v1 + 44) = 500;
    *(_WORD *)(v1 + 26) = 600;
    *(_DWORD *)(v1 + 140) = 500;
    *(_DWORD *)(v1 + 136) = 2000;
    *(_BYTE *)(v1 + 16) &= ~8u;
    sub_41CF0(v1, a1);
    sub_36DE0(v2);
    sub_36FA0(v2, 205);
  }
  return v2;
}

//----- (0003B8E0) --------------------------------------------------------
int sub_3B8E0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // eax

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 58;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 53;
    *(_DWORD *)(v1 + 8) = 128;
    *(_WORD *)(v1 + 126) = 256;
    v3 = *(_DWORD *)(v1 + 4);
    *(_BYTE *)(v1 + 16) &= ~8u;
    *(_WORD *)(v1 + 44) = 100;
    *(_WORD *)(v1 + 26) = 0;
    v4 = 9377 * v3 + 9439;
    *(_DWORD *)(v2 + 4) = v4;
    *(_WORD *)(v2 + 30) = v4 & 0x7FF;
    *(_DWORD *)(v2 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 76) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v2 + 16) |= 1u;
    sub_36DE0(v2);
    sub_37130((_WORD *)v2, 1024, 0x4000);
  }
  return v2;
}

//----- (0003B970) --------------------------------------------------------
int sub_3B970(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // eax

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 59;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 54;
    *(_DWORD *)(v1 + 8) = 128;
    *(_WORD *)(v1 + 126) = 256;
    v3 = *(_DWORD *)(v1 + 4);
    *(_BYTE *)(v1 + 16) &= ~8u;
    *(_WORD *)(v1 + 44) = 100;
    *(_WORD *)(v1 + 26) = 0;
    v4 = 9377 * v3 + 9439;
    *(_DWORD *)(v2 + 4) = v4;
    *(_WORD *)(v2 + 30) = v4 & 0x7FF;
    *(_DWORD *)(v2 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 76) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v2 + 16) |= 1u;
    sub_36DE0(v2);
    sub_37130((_WORD *)v2, 1024, 0x4000);
  }
  return v2;
}

//----- (0003BA00) --------------------------------------------------------
int sub_3BA00(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // eax

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 60;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 55;
    *(_DWORD *)(v1 + 8) = 19;
    *(_WORD *)(v1 + 126) = 256;
    v3 = *(_DWORD *)(v1 + 4);
    *(_BYTE *)(v1 + 16) &= ~8u;
    *(_WORD *)(v1 + 44) = 100;
    *(_WORD *)(v1 + 26) = 32;
    v4 = 9377 * v3 + 9439;
    *(_DWORD *)(v2 + 4) = v4;
    *(_WORD *)(v2 + 30) = v4 & 0x7FF;
    *(_DWORD *)(v2 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 76) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v2 + 16) |= 1u;
    sub_36DE0(v2);
    sub_37130((_WORD *)v2, 1024, 0x4000);
  }
  return v2;
}

//----- (0003BA90) --------------------------------------------------------
int sub_3BA90(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // eax

  v1 = sub_372C0();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 70) = 61;
    *(_BYTE *)(v1 + 64) = 10;
    *(_BYTE *)(v1 + 65) = 56;
    *(_DWORD *)(v1 + 8) = 128;
    *(_WORD *)(v1 + 126) = 256;
    v3 = *(_DWORD *)(v1 + 4);
    *(_BYTE *)(v1 + 16) &= ~8u;
    *(_WORD *)(v1 + 44) = 100;
    *(_WORD *)(v1 + 26) = 0;
    v4 = 9377 * v3 + 9439;
    *(_DWORD *)(v2 + 4) = v4;
    *(_WORD *)(v2 + 30) = v4 & 0x7FF;
    *(_DWORD *)(v2 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 76) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v2 + 16) |= 1u;
    sub_36DE0(v2);
    sub_37130((_WORD *)v2, 1024, 0x4000);
  }
  return v2;
}

//----- (0003BB20) --------------------------------------------------------
int sub_3BB20(int a1, char a2, char a3)
{
  int v3; // eax
  int v4; // ebx
  char v5; // dl

  v3 = sub_372C0();
  v4 = v3;
  if ( v3 )
  {
    *(_BYTE *)(v3 + 64) = 11;
    *(_BYTE *)(v3 + 65) = a2;
    *(_BYTE *)(v3 + 70) = a3;
    *(_BYTE *)(v3 + 16) &= 0xF6u;
    v5 = *(_BYTE *)(v3 + 16);
    *(_WORD *)(v3 + 26) = 0;
    *(_BYTE *)(v3 + 16) = v5 | 1;
    *(_DWORD *)(v3 + 72) = *(_DWORD *)a1;
    *(_WORD *)(v3 + 76) = *(_WORD *)(a1 + 4);
    sub_36DE0(v3);
  }
  return v4;
}

//----- (0003BB70) --------------------------------------------------------
int sub_3BB70(int a1)
{
  return sub_3BB20(a1, 0, 0);
}

//----- (0003BB90) --------------------------------------------------------
int sub_3BB90(int a1)
{
  return sub_3BB20(a1, 1, 1);
}

//----- (0003BBB0) --------------------------------------------------------
int sub_3BBB0(int a1)
{
  return sub_3BB20(a1, 2, 2);
}

//----- (0003BBD0) --------------------------------------------------------
int sub_3BBD0(int a1)
{
  return sub_3BB20(a1, 3, 3);
}

//----- (0003BBF0) --------------------------------------------------------
int sub_3BBF0(int a1)
{
  return sub_3BB20(a1, 4, 4);
}

//----- (0003BC10) --------------------------------------------------------
int sub_3BC10(int a1)
{
  return sub_3BB20(a1, 5, 5);
}

//----- (0003BC30) --------------------------------------------------------
int sub_3BC30(int a1)
{
  return sub_3BB20(a1, 6, 6);
}

//----- (0003BC50) --------------------------------------------------------
int sub_3BC50(int a1)
{
  return sub_3BB20(a1, 7, 7);
}

//----- (0003BC70) --------------------------------------------------------
int sub_3BC70(int a1)
{
  return sub_3BB20(a1, 8, 8);
}

//----- (0003BC90) --------------------------------------------------------
int sub_3BC90(int a1)
{
  return sub_3BB20(a1, 9, 9);
}

//----- (0003BCB0) --------------------------------------------------------
int sub_3BCB0(int a1)
{
  return sub_3BB20(a1, 10, 10);
}

//----- (0003BCD0) --------------------------------------------------------
int sub_3BCD0(int a1)
{
  return sub_3BB20(a1, 11, 11);
}

//----- (0003BCF0) --------------------------------------------------------
int sub_3BCF0(int a1)
{
  return sub_3BB20(a1, 12, 12);
}

//----- (0003BD10) --------------------------------------------------------
int sub_3BD10(int a1)
{
  return sub_3BB20(a1, 13, 13);
}

//----- (0003BD30) --------------------------------------------------------
int sub_3BD30(int a1)
{
  return sub_3BB20(a1, 14, 14);
}

//----- (0003BD50) --------------------------------------------------------
int sub_3BD50(int a1)
{
  return sub_3BB20(a1, 15, 15);
}

//----- (0003BD70) --------------------------------------------------------
int sub_3BD70(int a1)
{
  return sub_3BB20(a1, 16, 16);
}

//----- (0003BD90) --------------------------------------------------------
int sub_3BD90(int a1)
{
  return sub_3BB20(a1, 17, 17);
}

//----- (0003BDB0) --------------------------------------------------------
int sub_3BDB0(int a1)
{
  return sub_3BB20(a1, 18, 18);
}

//----- (0003BDD0) --------------------------------------------------------
int sub_3BDD0(int a1)
{
  return sub_3BB20(a1, 19, 19);
}

//----- (0003BDF0) --------------------------------------------------------
int sub_3BDF0(int a1)
{
  return sub_3BB20(a1, 20, 20);
}

//----- (0003BE10) --------------------------------------------------------
int sub_3BE10(int a1)
{
  return sub_3BB20(a1, 21, 21);
}

//----- (0003BE30) --------------------------------------------------------
int sub_3BE30(int a1)
{
  return sub_3BB20(a1, 22, 22);
}

//----- (0003BE50) --------------------------------------------------------
int sub_3BE50(int a1)
{
  return sub_3BB20(a1, 23, 23);
}

//----- (0003BE70) --------------------------------------------------------
int sub_3BE70(int a1)
{
  return sub_3BB20(a1, 24, 24);
}

//----- (0003BE90) --------------------------------------------------------
int sub_3BE90(int a1)
{
  return sub_3BB20(a1, 25, 25);
}

//----- (0003BEB0) --------------------------------------------------------
int sub_3BEB0(int a1)
{
  return sub_3BB20(a1, 26, 26);
}

//----- (0003BED0) --------------------------------------------------------
int sub_3BED0(int a1)
{
  return sub_3BB20(a1, 27, 27);
}

//----- (0003BEF0) --------------------------------------------------------
int sub_3BEF0(int a1)
{
  return sub_3BB20(a1, 28, 28);
}

//----- (0003BF10) --------------------------------------------------------
int sub_3BF10(int a1)
{
  return sub_3BB20(a1, 29, 29);
}

//----- (0003BF30) --------------------------------------------------------
int sub_3BF30(int a1)
{
  return sub_3BB20(a1, 30, 30);
}

//----- (0003BF50) --------------------------------------------------------
int sub_3BF50(int a1)
{
  return sub_3BB20(a1, 31, 31);
}

//----- (0003BF70) --------------------------------------------------------
int sub_3BF70(int a1, char a2, char a3, int a4, __int16 a5, char a6, char a7, int a8, __int16 a9)
{
  int result; // eax
  int v10; // ebx
  int v11; // ecx
  char v12; // ah

  result = sub_372C0();
  v10 = result;
  if ( result )
  {
    *(_BYTE *)(result + 64) = 12;
    *(_BYTE *)(result + 65) = a2;
    *(_BYTE *)(result + 70) = a3;
    *(_WORD *)(result + 44) = a9;
    *(_WORD *)(result + 50) = a5;
    *(_BYTE *)(result + 62) = a7;
    if ( a7 )
      a6 = 0;
    v11 = *(__int16 *)(result + 50);
    *(_BYTE *)(result + 60) = a6;
    *(_BYTE *)(result + 61) = 0;
    *(_DWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 12) = 0;
    *(_DWORD *)(result + 140) = a4 / v11;
    *(_DWORD *)(result + 132) = a8;
    v12 = *(_BYTE *)(result + 16);
    *(_DWORD *)(v10 + 136) = a4;
    *(_BYTE *)(v10 + 16) = v12 & 0xF7;
    sub_41CF0(v10, a1);
    sub_36FA0(v10, 77);
    sub_37130((_WORD *)v10, 4 * *(_WORD *)(v10 + 80), 4 * *(_WORD *)(v10 + 84));
    sub_36DE0(v10);
    return v10;
  }
  return result;
}

//----- (0003C040) --------------------------------------------------------
int sub_3C040(int a1)
{
  return sub_3BF70(a1, 3, 9, 50, 3, 1, 0, 0, 100);
}

//----- (0003C060) --------------------------------------------------------
int sub_3C060(int a1)
{
  return sub_3BF70(a1, 16, 48, 1000, 101, 1, 0, 0, 10000);
}

//----- (0003C090) --------------------------------------------------------
int sub_3C090(int a1)
{
  return sub_3BF70(a1, 0, 0, 200, 5, 1, 0, 0, 125);
}

//----- (0003C0C0) --------------------------------------------------------
int sub_3C0C0(int a1)
{
  return sub_3BF70(a1, 2, 6, 1000, 251, 0, 0, 0, 100);
}

//----- (0003C0F0) --------------------------------------------------------
int sub_3C0F0(int a1)
{
  return sub_3BF70(a1, 1, 3, 1000, 21, 1, 0, 0, 100);
}

//----- (0003C120) --------------------------------------------------------
int sub_3C120(int a1)
{
  return sub_3BF70(a1, 10, 30, 5000, 51, 1, 0, 10000, 100);
}

//----- (0003C150) --------------------------------------------------------
int sub_3C150(int a1)
{
  return sub_3BF70(a1, 6, 18, 6000, 51, 1, 0, 120000, 6000);
}

//----- (0003C180) --------------------------------------------------------
int sub_3C180(int a1)
{
  return sub_3BF70(a1, 19, 57, 4000, 17, 1, 0, 10000, 100);
}

//----- (0003C1B0) --------------------------------------------------------
int sub_3C1B0(int a1)
{
  return sub_3BF70(a1, 4, 12, 2000, 251, 1, 0, 0, 100);
}

//----- (0003C1E0) --------------------------------------------------------
int sub_3C1E0(int a1)
{
  return sub_3BF70(a1, 7, 21, 10000, 11, 1, 0, 100000, 10000);
}

//----- (0003C210) --------------------------------------------------------
int sub_3C210(int a1)
{
  return sub_3BF70(a1, 14, 42, 1000, 101, 1, 0, 8000, 100);
}

//----- (0003C240) --------------------------------------------------------
int sub_3C240(int a1)
{
  return sub_3BF70(a1, 15, 45, 1000, 2, 0, 0, 25000, 500);
}

//----- (0003C270) --------------------------------------------------------
int sub_3C270(int a1)
{
  return sub_3BF70(a1, 11, 33, 2500, 17, 1, 0, 16000, 100);
}

//----- (0003C2A0) --------------------------------------------------------
int sub_3C2A0(int a1)
{
  return sub_3BF70(a1, 13, 39, 500, 11, 1, 0, 20000, 100);
}

//----- (0003C2D0) --------------------------------------------------------
int sub_3C2D0(int a1)
{
  return sub_3BF70(a1, 12, 36, 5000, 251, 1, 0, 50000, 100);
}

//----- (0003C300) --------------------------------------------------------
int sub_3C300(int a1)
{
  return sub_3BF70(a1, 9, 27, 12000, 31, 1, 0, 100000, 6000);
}

//----- (0003C330) --------------------------------------------------------
int sub_3C330(int a1)
{
  return sub_3BF70(a1, 5, 15, 3000, 101, 1, 0, 0, 100);
}

//----- (0003C360) --------------------------------------------------------
int sub_3C360(int a1)
{
  return sub_3BF70(a1, 18, 54, 20000, 33, 1, 0, 90000, 2000);
}

//----- (0003C390) --------------------------------------------------------
int sub_3C390(int a1)
{
  return sub_3BF70(a1, 8, 24, 30000, 65, 1, 0, 180000, 1000);
}

//----- (0003C3C0) --------------------------------------------------------
int sub_3C3C0(int a1)
{
  return sub_3BF70(a1, 17, 51, 13000, 13, 1, 0, 150000, 100);
}

//----- (0003C3F0) --------------------------------------------------------
int sub_3C3F0(int a1)
{
  return sub_3BF70(a1, 20, 60, 5000, 51, 1, 0, 12000, 24464);
}

//----- (0003C420) --------------------------------------------------------
int sub_3C420(int a1)
{
  return sub_3BF70(a1, 21, 63, 1000, 251, 0, 0, 0, 100);
}

//----- (0003C450) --------------------------------------------------------
int sub_3C450(int a1)
{
  return sub_3BF70(a1, 22, 66, 75000, 101, 1, 0, (int)&loc_30D40, 7000);
}

//----- (0003C480) --------------------------------------------------------
int sub_3C480(int a1)
{
  return sub_3BF70(a1, 23, 69, 600, 3, 0, 0, 50000, 50);
}

//----- (0003C4B0) --------------------------------------------------------
int sub_3C4B0()
{
  int v0; // eax
  int v1; // ebx
  int v2; // edx

  v0 = sub_372C0();
  v1 = v0;
  if ( v0 )
  {
    *(_BYTE *)(v0 + 70) = 0;
    *(_BYTE *)(v0 + 64) = 13;
    v2 = *(_DWORD *)(v0 + 16);
    *(_BYTE *)(v0 + 65) = 0;
    *(_DWORD *)(v0 + 16) = v2 & 1;
    sub_36DE0(v0);
  }
  return v1;
}

//----- (0003C4E0) --------------------------------------------------------
int sub_3C4E0()
{
  int v0; // eax
  int v1; // ebx
  int v2; // edx

  v0 = sub_372C0();
  v1 = v0;
  if ( v0 )
  {
    *(_BYTE *)(v0 + 70) = 1;
    *(_BYTE *)(v0 + 64) = 13;
    v2 = *(_DWORD *)(v0 + 16);
    *(_BYTE *)(v0 + 65) = 1;
    *(_DWORD *)(v0 + 16) = v2 & 1;
    sub_36DE0(v0);
  }
  return v1;
}

//----- (0003C510) --------------------------------------------------------
int sub_3C510()
{
  int v0; // eax
  int v1; // ebx
  int v2; // edx

  v0 = sub_372C0();
  v1 = v0;
  if ( v0 )
  {
    *(_BYTE *)(v0 + 70) = 2;
    *(_BYTE *)(v0 + 64) = 13;
    v2 = *(_DWORD *)(v0 + 16);
    *(_BYTE *)(v0 + 65) = 2;
    *(_DWORD *)(v0 + 16) = v2 & 1;
    sub_36DE0(v0);
  }
  return v1;
}

//----- (0003C540) --------------------------------------------------------
int sub_3C540()
{
  int v0; // eax
  int v1; // ebx
  int v2; // edx

  v0 = sub_372C0();
  v1 = v0;
  if ( v0 )
  {
    *(_BYTE *)(v0 + 70) = 3;
    *(_BYTE *)(v0 + 64) = 13;
    v2 = *(_DWORD *)(v0 + 16);
    *(_BYTE *)(v0 + 65) = 3;
    *(_DWORD *)(v0 + 16) = v2 & 1;
    sub_36DE0(v0);
  }
  return v1;
}

//----- (0003C570) --------------------------------------------------------
char sub_3C570()
{
  int v0; // ebx
  int v1; // ebx
  int v2; // eax
  int v3; // eax
  char v5; // [esp+0h] [ebp-ACh] BYREF
  char v6[64]; // [esp+64h] [ebp-48h] BYREF
  char v7; // [esp+A4h] [ebp-8h] BYREF

  //fix
  v5 = 0;
  //fix

  sprintf(v6, "%s%s/sndsetup.inf", &aSc[1], aCarpetCd_2);
  v0 = (int)fopen(v6, &unk_A90B8);
  if ( !v0 )
  {
    v1 = (int)fopen(v6, &unk_A90BC);
    fprintf((FILE*)v1, aSoundfxNone000, v5);
    fprintf((FILE*)v1, aMusicNone38800, v5);
    fclose((FILE*)v1);
    v0 = (int)fopen(v6, &unk_A90B8);
  }
  fscanf((FILE*)v0, "%s = %s %x %d %d", &v5, &v5, &v7, &v7, &v7);
  fscanf((FILE*)v0, "%s = %s %x", &v5, &unk_CBF74, &dword_CBF70);
  fclose((FILE*)v0);
  v2 = (int)getenv(aBfMusic);
  if ( v2 )
    sscanf((const char*)v2, "%s %x", &unk_CBF74, &dword_CBF70);
  v3 = stricmp(&unk_CBF74, aNone_0);
  if ( !v3 )
  {
    byte_939CC = 0;
    byte_939CD = 0;
  }
  if ( byte_939CC )
  {
    if ( !stricmp(&unk_CBF74, aAdlib)
      || !stricmp(&unk_CBF74, aSblast)
      || !stricmp(&unk_CBF74, aSbpro)
      || !stricmp(&unk_CBF74, aAdlibg)
      || !stricmp(&unk_CBF74, aSb16fm)
      || !stricmp(&unk_CBF74, aGravis)
      || !stricmp(&unk_CBF74, aPasfm)
      || !stricmp(&unk_CBF74, aCompatible) )
    {
      LOBYTE(v3) = sub_43B20(v0, 0xA002u);
    }
    else if ( !stricmp(&unk_CBF74, aRoland_0) )
    {
      LOBYTE(v3) = sub_43B20(v0, 0xA004u);
    }
    else if ( !stricmp(&unk_CBF74, aSbawe32_0) )
    {
      LOBYTE(v3) = sub_43B20(v0, 0xA008u);
    }
    else if ( !stricmp(&unk_CBF74, aGeneral_0) || (v3 = stricmp(&unk_CBF74, aWblast_0)) == 0 )
    {
      LOBYTE(v3) = sub_43B20(v0, 0xA001u);
    }
  }
  return v3;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 61EF5: using guessed type _DWORD stricmp(_DWORD, _DWORD);
// 626D2: using guessed type __int64 fopen(_DWORD, _DWORD);
// 62781: using guessed type _DWORD fprintf(_DWORD, _DWORD, char);
// 627A6: using guessed type _DWORD fclose(_DWORD);
// 629CF: using guessed type _DWORD fscanf(_DWORD, _DWORD, ...);
// 629F4: using guessed type _DWORD getenv(_DWORD);
// 62ABD: using guessed type _DWORD sscanf(_DWORD, _DWORD, ...);
// 939CC: using guessed type char byte_939CC;
// 939CD: using guessed type char byte_939CD;
// CBF70: using guessed type int dword_CBF70;

//----- (0003C800) --------------------------------------------------------
int sub_3C800(int a1, unsigned __int16 a2, unsigned __int16 a3)
{
  __int64 v3; // rax
  int v4; // ebx
  int v5; // ebx
  int v6; // eax
  int result; // eax
  char v8; // [esp+0h] [ebp-A8h] BYREF
  char v9[68]; // [esp+64h] [ebp-44h] BYREF

  //fix
  v8 = 0;
  //fix

  sprintf(v9, "%s%s/sndsetup.inf", "C:", aCarpetCd_3);
  v3 = (__int64)fopen(v9, &unk_A91B4);
  v4 = v3;
  if ( !(_DWORD)v3 )
  {
    v5 = (int)fopen(v9, &unk_A91B8);
    fprintf((FILE*)v5, aSoundfxNone000_0, v8);
    fprintf((FILE*)v5, aMusicNone38800_0, v8);
    fclose((FILE*)v5);
    v3 = (__int64)fopen(v9, &unk_A91B4);
    v4 = v3;
  }
  fscanf((FILE*)v4, "%s = %s %x %d %d", &v8, &unk_CC158, &dword_CC14C, &dword_CC150, &dword_CC1BC);
  fclose((FILE*)v4);
  v6 = (int)getenv((const char*)aBfSound);
  if ( v6 )
    sscanf((const char*)v6, "%s %x %d %d", &unk_CC158, &dword_CC14C, &dword_CC150, &dword_CC1BC);
  result = stricmp(&unk_CC158, aNone_1);
  if ( !result )
  {
    BYTE1(result) = 0;
    byte_939E4 = 0;
    byte_939E5 = 0;
  }
  if ( byte_939E4 )
    return sub_43EC0(SWORD2(v3), a1, v4, a2, a3);
  return result;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 61EF5: using guessed type _DWORD stricmp(_DWORD, _DWORD);
// 626D2: using guessed type __int64 fopen(_DWORD, _DWORD);
// 62781: using guessed type _DWORD fprintf(_DWORD, _DWORD, char);
// 627A6: using guessed type _DWORD fclose(_DWORD);
// 629CF: using guessed type _DWORD fscanf(_DWORD, _DWORD, ...);
// 629F4: using guessed type _DWORD getenv(_DWORD);
// 62ABD: using guessed type _DWORD sscanf(_DWORD, _DWORD, ...);
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// CC14C: using guessed type int dword_CC14C;
// CC150: using guessed type int dword_CC150;
// CC1BC: using guessed type int dword_CC1BC;

//----- (0003C9D0) --------------------------------------------------------
int sub_3C9D0()
{
  int v0; // ebx
  _BYTE *v1; // ebp
  char *v2; // edx
  int i; // ebx
  char *v4; // esi
  char *v5; // edi
  int v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // ebx
  int v10; // ecx
  int v11; // eax
  int v12; // ebx
  _BYTE *v13; // edi
  int v14; // ebp
  int v15; // eax
  char *v16; // esi
  _BYTE *v17; // eax
  char v18; // dh
  char *v19; // esi
  char *v20; // edi
  char v21; // al
  char v22; // al
  int v23; // eax
  char v24; // dh
  unsigned int v25; // kr08_4
  char *v26; // esi
  const char *v27; // edi
  char *v28; // edi
  char v29; // al
  char v30; // al
  int v31; // eax
  char v32; // cl
  char v33; // dl
  char v34; // bl
  char v35; // cl
  int v36; // eax
  unsigned __int16 v37; // dx
  int v38; // ebx
  int v39; // eax
  int v40; // edx
  _BYTE *v41; // ebx
  __int16 j; // di
  int v43; // eax
  int v44; // eax
  int v45; // edx
  int v46; // eax
  int v47; // edx
  unsigned __int16 v48; // di
  int k; // eax
  int v50; // eax
  int v51; // esi
  int v52; // ebx
  int v53; // eax
  int v54; // ecx
  int v55; // esi
  __int16 v56; // ax
  __int16 v57; // bx
  int v58; // ecx
  unsigned int m; // ecx
  int v60; // eax
  int v61; // ebx
  int v62; // edx
  int v63; // eax
  int v64; // eax
  int v65; // ebx
  int v66; // edx
  unsigned int n; // eax
  int v68; // edx
  int v69; // ebx
  int v70; // eax
  unsigned int ii; // eax
  int v72; // edx
  int v73; // ebx
  int v74; // eax
  unsigned int jj; // eax
  int v76; // edx
  int v77; // ebx
  int v78; // eax
  int v79; // eax
  int v80; // edx
  int v81; // ebx
  int v82; // edx
  int v83; // eax
  int v84; // ebx
  int v85; // edx
  int v86; // ebx
  int v87; // ecx
  int v88; // esi
  __int64 v89; // rax
  int v90; // esi
  __int64 v91; // rax
  char v92; // bl
  int v93; // eax
  __int16 v94; // cx
  _BYTE *v95; // esi
  int result; // eax
  __int16 v97; // [esp-4h] [ebp-144h]
  __int16 v98; // [esp-4h] [ebp-144h]
  __int16 v99; // [esp-4h] [ebp-144h]
  char v100[256]; // [esp+0h] [ebp-140h] BYREF
  int v101; // [esp+100h] [ebp-40h]
  _BYTE *v102; // [esp+104h] [ebp-3Ch]
  int v103; // [esp+108h] [ebp-38h]
  int v104; // [esp+10Ch] [ebp-34h]
  char *v105; // [esp+110h] [ebp-30h]
  int v106; // [esp+114h] [ebp-2Ch]
  int v107; // [esp+118h] [ebp-28h]
  int v108; // [esp+11Ch] [ebp-24h]
  int v109; // [esp+120h] [ebp-20h]
  char v110; // [esp+124h] [ebp-1Ch]
  char v111; // [esp+128h] [ebp-18h]
  char v112; // [esp+12Ch] [ebp-14h]

  v112 = 0;
  if ( (*(_BYTE *)dword_AE408 & 0x10) != 0 )
  {
    *(_DWORD *)(dword_AE408 + 157) = dword_AC5D4;
    sub_43930((char *)(dword_AE400 + 29715), 0xAu);
    v0 = dword_AE400;
    *(_DWORD *)(dword_AE408 + 157) = dword_AC5D4 - *(_DWORD *)(dword_AE408 + 157);
    v1 = (_BYTE *)(v0 + 29715);
    v111 = 0;
    v2 = (char *)(v0 + 14357);
    v109 = 0;
    for ( i = v0 + 13323; ; i += 2049 )
    {
      v6 = dword_AE400;
      if ( (unsigned __int16)v109 >= *(_WORD *)(dword_AE400 + 10) )
        break;
      if ( *v1 == 1 )
      {
        *(_BYTE *)(i + 6) = 1;
        if ( (unsigned __int16)v109 == *(__int16 *)(v6 + 8) )
        {
          if ( *(_BYTE *)(dword_AE408 + 29) )
          {
            v4 = (char *)(dword_AE408 + 61);
            v5 = v2;
          }
          else
          {
            v5 = v2;
            v4 = off_99B68[(unsigned __int16)v109];
          }
          qmemcpy(v5, v4, 0xCu);
          *(_BYTE *)(i + 1046) = 0;
        }
        v111 = 1;
      }
      v1 += 10;
      v2 += 2049;
      ++v109;
    }
    if ( v111 )
      sub_43930((char *)(dword_AE400 + 13323), 0x801u);
  }
  v7 = dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8);
  v8 = dword_AE408;
  ++*(_DWORD *)(v7 + 13341);
  v9 = 1;
  ++*(_DWORD *)(v8 + 4);
  do
  {
    v10 = dword_AE400;
    v110 = (*(_DWORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13341) / (unsigned int)(__int16)v9) & 1;
    v11 = dword_AE408 + (__int16)v9++;
    *(_BYTE *)(v11 + 93) = v110;
  }
  while ( (__int16)v9 < 16 );
  v102 = (_BYTE *)(v10 + 29715);
  v106 = v10 + 13323;
  v108 = 0;
  v105 = (char *)(v10 + 14357);
  while ( 1 )
  {
    result = dword_AE400;
    if ( (unsigned __int16)v108 >= *(_WORD *)(dword_AE400 + 10) )
      return result;
    v12 = v106;
    v13 = v102;
    v14 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(v106 + 10);
    sub_3E9D0(v102);
    *(_BYTE *)(v12 + 1099) = 0;
    switch ( *v13 )
    {
      case 1:
        v15 = dword_AE400;
        *(_BYTE *)(v12 + 6) = 1;
        if ( (unsigned __int16)v108 == *(__int16 *)(v15 + 8) )
        {
          if ( *(_BYTE *)(dword_AE408 + 29) )
            v16 = (char *)(dword_AE408 + 61);
          else
            v16 = off_99B68[(unsigned __int16)v108];
          qmemcpy(v105, v16, 0xCu);
          *(_BYTE *)(v106 + 1046) = 0;
        }
        goto LABEL_23;
      case 2:
        sub_3DD10();
        if ( *(__int16 *)(dword_AE400 + 8) == (unsigned __int16)v108 )
          *(_BYTE *)(v12 + 4) = 1;
        v97 = v108;
        *(_DWORD *)(v14 + 12) = -1;
        sub_43760(v97);
        *(_BYTE *)(v106 + 6) = 0;
        goto LABEL_150;
      case 3:
        goto LABEL_23;
      case 4:
        *(_BYTE *)(v12 + 5) ^= v13[1];
        goto LABEL_150;
      case 7:
        if ( (char)v13[1] + *(unsigned __int16 *)(v12 + 14) >= 0
          && (char)v13[1] + *(unsigned __int16 *)(v12 + 14) < *(unsigned __int16 *)(v12 + 16) - 1 )
        {
          *(_WORD *)(v12 + 14) += (char)v13[1];
        }
        goto LABEL_150;
      case 8:
        *(_WORD *)(v12 + 584) += (char)v13[1];
        goto LABEL_150;
      case 0xA:
        if ( (*(_BYTE *)dword_AE408 & 0x10) == 0 )
          sub_3E410(10000);
        goto LABEL_150;
      case 0xB:
        if ( (*(_BYTE *)dword_AE408 & 0x10) == 0 )
          sub_3E350(10000);
        goto LABEL_150;
      case 0xC:
        if ( (*(_BYTE *)dword_AE408 & 0x20) == 0 && (unsigned __int16)v108 == *(__int16 *)(dword_AE400 + 8) )
        {
          v17 = (_BYTE *)dword_AE408;
          v18 = *(_BYTE *)dword_AE408;
          *(_DWORD *)(dword_AE408 + 36378) = 0;
          *v17 = v18 | 2;
        }
        goto LABEL_150;
      case 0xE:
        v112 = 1;
        goto LABEL_150;
      case 0xF:
        if ( *(_WORD *)(*(_DWORD *)(v14 + 160) + 50) )
          goto LABEL_23;
        if ( (*(_BYTE *)dword_AE408 & 0x10) != 0 )
          goto LABEL_45;
        *(_BYTE *)(v106 + 2) |= 0xCu;
LABEL_23:
        sub_44D30(v106, v14);
        sub_3DC90(v106, 0);
        goto LABEL_150;
      case 0x10:
        memset((void*)(dword_AE400 + 13323 + 2049 * *(__int16 *)(dword_AE400 + 8) + 28 + 68 * (unsigned __int16)v108), 0, 68);
        sub_3DC90(v12, 3);
        *(_WORD *)(v12 + 68 * (unsigned __int16)v108 + 92) = 32000;
        *(_WORD *)(v12 + 68 * (unsigned __int16)v108 + 94) = 1;
        goto LABEL_150;
      case 0x11:
        v24 = v13[1];
        if ( v24 == 8 )
        {
          v25 = strlen((const char *)(dword_AE400
                                    + 13323
                                    + 2049 * *(__int16 *)(dword_AE400 + 8)
                                    + 28
                                    + 68 * (unsigned __int16)v108))
              + 1;
          if ( v25 != 1 )
            *(_BYTE *)(2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 68 * (unsigned __int16)v108 + v25 - 1 + 13350) = 0;
        }
        else if ( v24
               && strlen((const char *)(2049 * *(__int16 *)(dword_AE400 + 8)
                                      + dword_AE400
                                      + 13323
                                      + 28
                                      + 68 * (unsigned __int16)v108)) < 0x3F )
        {
          sprintf(v100, "%c", (char)v102[1]);
          v26 = v100;
          v27 = (const char *)(dword_AE400
                             + 13323
                             + 2049 * *(__int16 *)(dword_AE400 + 8)
                             + 28
                             + 68 * (unsigned __int16)v108);
          v28 = (char *)&v27[strlen(v27)];
          do
          {
            v29 = *v26;
            *v28 = *v26;
            if ( !v29 )
              break;
            v30 = v26[1];
            v26 += 2;
            v28[1] = v30;
            v28 += 2;
          }
          while ( v30 );
        }
        v31 = v106 + 68 * (unsigned __int16)v108;
        *(_WORD *)(v31 + 92) = 32000;
        *(_WORD *)(v31 + 94) = 1;
        goto LABEL_150;
      case 0x12:
        memset((void*)(68 * (unsigned __int16)v108 + 2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 13323 + 28), 0, 68);
        *(_WORD *)(2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 68 * (unsigned __int16)v108 + 13415) = 0;
        *(_WORD *)(2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 68 * (unsigned __int16)v108 + 13417) = 0;
        sub_3DC90(v12, 0);
        goto LABEL_150;
      case 0x13:
        if ( (*(_BYTE *)(2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 68 * (unsigned __int16)v108 + 13351) == 81
           || *(_BYTE *)(2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 68 * (unsigned __int16)v108 + 13351) == 113)
          && ((v32 = *(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 68 * (unsigned __int16)v108 + 13352),
               v32 == 85)
           || v32 == 117)
          && ((v33 = *(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 68 * (unsigned __int16)v108 + 13353),
               v33 == 73)
           || v33 == 105)
          && ((v34 = *(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 68 * (unsigned __int16)v108 + 13354),
               v34 == 67)
           || v34 == 99)
          && ((v35 = *(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 68 * (unsigned __int16)v108 + 13355),
               v35 == 75)
           || v35 == 107) )
        {
          v36 = dword_AE400;
          v37 = v108;
          v38 = 68 * (unsigned __int16)v108;
          *(_WORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + v38 + 13415) = 0;
          *(_WORD *)(v36 + 2049 * *(__int16 *)(v36 + 8) + v38 + 13417) = 0;
          if ( v37 == *(__int16 *)(v36 + 8) )
            *(_BYTE *)(dword_AE408 + 1) |= 0x80u;
        }
        else
        {
          v39 = dword_AE400;
          v40 = 68 * (unsigned __int16)v108;
          *(_WORD *)(v40 + dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13415) = 200;
          *(_WORD *)(v40 + 2049 * *(__int16 *)(v39 + 8) + v39 + 13417) = 3;
        }
        sub_3DC90(v106, 0);
        goto LABEL_150;
      case 0x14:
        sub_3DC90(v12, v13[1]);
        goto LABEL_150;
      case 0x15:
        if ( (char)v13[1] != -1 )
        {
          *(_WORD *)(*(_DWORD *)(v14 + 160) + 940) = (char)v13[1];
          sub_55370(0, *(_WORD *)(v12 + 7), 14);
          sub_3DC90(v12, 0);
        }
        goto LABEL_150;
      case 0x16:
        if ( (char)v13[1] != -1 )
        {
          *(_WORD *)(*(_DWORD *)(v14 + 160) + 944) = (char)v13[1];
          sub_55370(0, *(_WORD *)(v12 + 7), 14);
          sub_3DC90(v12, 0);
        }
        goto LABEL_150;
      case 0x17:
        if ( (char)v13[2] != -1 )
        {
          v41 = v102;
          for ( j = 0; j < 24; ++j )
          {
            v43 = *(_DWORD *)(v14 + 160) + j;
            if ( v41[2] == *(_BYTE *)(v43 + 772) )
              *(_BYTE *)(v43 + 772) = -1;
          }
          *(_BYTE *)((char)v102[1] + *(_DWORD *)(v14 + 160) + 772) = v102[2];
          sub_55370(0, *(_WORD *)(v106 + 7), 14);
        }
        goto LABEL_150;
      case 0x18:
        sub_3DD10();
        v44 = *(_DWORD *)(v14 + 160);
        v45 = v44 + (char)v13[1];
        if ( *(char *)(v45 + 772) != -1 )
        {
          *(_WORD *)(v44 + 940) = *(char *)(v45 + 772);
          *(_BYTE *)(*(char *)(164
                             * *(_DWORD *)(*(_DWORD *)(v14 + 160)
                                         + 4 * *(char *)((char)v13[1] + *(_DWORD *)(v14 + 160) + 772)
                                         + 532)
                             + dword_AE400
                             + 29860)
                   + *(_DWORD *)(v14 + 160)
                   + 844) = 32;
        }
        goto LABEL_87;
      case 0x19:
        sub_3DD10();
        v46 = *(_DWORD *)(v14 + 160);
        v47 = v46 + (char)v13[1];
        if ( *(char *)(v47 + 772) != -1 )
        {
          *(_WORD *)(v46 + 944) = *(char *)(v47 + 772);
          *(_BYTE *)(*(char *)(164
                             * *(_DWORD *)(*(_DWORD *)(v14 + 160)
                                         + 4 * *(char *)((char)v13[1] + *(_DWORD *)(v14 + 160) + 772)
                                         + 532)
                             + dword_AE400
                             + 29860)
                   + *(_DWORD *)(v14 + 160)
                   + 844) = 32;
        }
LABEL_87:
        sub_55370(0, *(_WORD *)(v106 + 7), 14);
        goto LABEL_150;
      case 0x1A:
        v48 = 0;
        for ( k = dword_AE400; v48 < *(_WORD *)(dword_AE400 + 10); k = dword_AE400 )
        {
          v50 = 2049 * v48 + k;
          if ( *(_BYTE *)(v50 + 13329) )
          {
            *(_BYTE *)(v50 + 13327) = 1;
            sub_43760(v48);
          }
          ++v48;
        }
        goto LABEL_150;
      case 0x1B:
        sub_3DD10();
        v98 = v108;
        *(_WORD *)(v12 + 2) = 10;
        sub_43760(v98);
        goto LABEL_150;
      case 0x1C:
        v99 = v108;
        *(_WORD *)(v12 + 2) = 12;
        sub_43760(v99);
        goto LABEL_150;
      case 0x1D:
LABEL_45:
        v19 = (char *)dword_AE330;
        v20 = (char *)(2049 * *(__int16 *)(dword_AE400 + 8)
                     + dword_AE400
                     + 13323
                     + 28
                     + 68 * *(__int16 *)(*(_DWORD *)(v14 + 160) + 48));
        do
        {
          v21 = *v19;
          *v20 = *v19;
          if ( !v21 )
            break;
          v22 = v19[1];
          v19 += 2;
          v20[1] = v22;
          v20 += 2;
        }
        while ( v22 );
        v23 = dword_AE400;
        *(_WORD *)(68 * *(__int16 *)(*(_DWORD *)(v14 + 160) + 48)
                 + dword_AE400
                 + 2049 * *(__int16 *)(dword_AE400 + 8)
                 + 13415) = 100;
        *(_WORD *)(v23 + 2049 * *(__int16 *)(v23 + 8) + 68 * *(__int16 *)(*(_DWORD *)(v14 + 160) + 48) + 13417) = 0;
        *(_WORD *)(v106 + 2) = 8;
        sub_43760(v108);
        *(_BYTE *)(v106 + 6) = 0;
        goto LABEL_150;
      case 0x1E:
        sub_3DD10();
        if ( *(_BYTE *)(v14 + 70) || *(int *)(v14 + 12) <= 0 )
          goto LABEL_150;
        break;
      default:
        goto LABEL_150;
    }
    switch ( v13[1] )
    {
      case 1:
        v103 = 0;
        v104 = 0;
        do
        {
          if ( !*(_WORD *)(v103 + *(_DWORD *)(v14 + 160) + 676) )
          {
            v51 = v104;
            v52 = 0;
            v101 = 0;
            while ( 1 )
            {
              if ( !*(_DWORD *)(*(_DWORD *)(v14 + 160) + v52 + 532) )
              {
                v53 = (*(int (**)(int))((char *)&off_987DE + v51))(v14 + 72);
                v54 = v53;
                if ( v53 )
                  break;
              }
              v52 += 4;
              ++v101;
              if ( v52 >= 96 )
                goto LABEL_110;
            }
            *(_DWORD *)(v53 + 16) |= (unsigned int)&loc_3FFFE + 3;
            v55 = dword_AE400 + 29795;
            v107 = 164;
            v56 = (v14 - (dword_AE400 + 29795)) / 164;
            *(_DWORD *)(v54 + 132) = 0;
            *(_WORD *)(v54 + 42) = v56;
            *(_DWORD *)(*(_DWORD *)(v14 + 160) + v52 + 532) = (v54 - v55) / 164;
            v57 = 0;
            while ( 1 )
            {
              v58 = *(_DWORD *)(v14 + 160) + v57;
              if ( *(char *)(v58 + 772) == -1 )
                break;
              if ( ++v57 >= 10 )
                goto LABEL_110;
            }
            *(_BYTE *)(v58 + 772) = v101;
          }
LABEL_110:
          v103 += 2;
          v104 += 14;
        }
        while ( v103 != 48 );
        for ( m = dword_AE400 + 29959; ; m += 164 )
        {
          v60 = dword_AE400;
          if ( m >= dword_AE400 + 193795 )
            break;
          if ( *(_BYTE *)(m + 64) == 11 )
            *(_BYTE *)(m + 16) &= ~1u;
        }
        v61 = (unsigned __int16)v108;
        if ( *(__int16 *)(dword_AE400 + 8) == (unsigned __int16)v108 )
        {
          v62 = 68 * (unsigned __int16)v108;
          *(_WORD *)(dword_AE400 + 2049 * (unsigned __int16)v108 + v62 + 13415) = 100;
          *(_WORD *)(v62 + v60 + 2049 * *(__int16 *)(v60 + 8) + 13417) = 0;
          strcpy((char *)(68 * v61 + 2049 * *(__int16 *)(v60 + 8) + v60 + 13351), ".. CHEAT: access all spells");
        }
        break;
      case 2:
        v63 = sub_373F0(v14 + 72, 10, 39);
        if ( v63 )
        {
          *(_DWORD *)(v63 + 140) = 100000;
          *(_WORD *)(v63 + 144) = (v14 - (dword_AE400 + 29795)) / 164;
        }
        HIWORD(v65) = 0;
        *(_DWORD *)(v14 + 140) = *(_DWORD *)(v14 + 136);
        v64 = dword_AE400;
        LOWORD(v65) = v108;
        if ( *(__int16 *)(dword_AE400 + 8) == (unsigned __int16)v108 )
        {
          v66 = 68 * v65;
          *(_WORD *)(dword_AE400 + 2049 * v65 + v66 + 13415) = 100;
          *(_WORD *)(v66 + v64 + 2049 * *(__int16 *)(v64 + 8) + 13417) = 0;
          strcpy((char *)(68 * v65 + 2049 * *(__int16 *)(v64 + 8) + v64 + 13351), ".. CHEAT: more mana");
        }
        break;
      case 3:
        for ( n = *(_DWORD *)(dword_AE408 + 36462); ; n = *(_DWORD *)n )
        {
          v68 = dword_AE400;
          if ( n <= dword_AE400 + 29795 )
            break;
          if ( *(_WORD *)(n + 24) != *(_WORD *)(v14 + 24) && *(_BYTE *)(n + 65) <= 1u )
            *(_DWORD *)(n + 12) = -1;
        }
        v69 = (unsigned __int16)v108;
        if ( *(__int16 *)(dword_AE400 + 8) == (unsigned __int16)v108 )
        {
          v70 = 68 * (unsigned __int16)v108;
          *(_WORD *)(dword_AE400 + 2049 * (unsigned __int16)v108 + v70 + 13415) = 100;
          *(_WORD *)(v68 + 2049 * *(__int16 *)(v68 + 8) + v70 + 13417) = 0;
          strcpy((char *)(2049 * *(__int16 *)(v68 + 8) + v68 + 68 * v69 + 13351), ".. CHEAT: destroy all players");
        }
        break;
      case 4:
        for ( ii = *(_DWORD *)(dword_AE408 + 36462); ; ii = *(_DWORD *)ii )
        {
          v72 = dword_AE400;
          if ( ii <= dword_AE400 + 29795 )
            break;
          if ( *(_WORD *)(ii + 24) != *(_WORD *)(v14 + 24) && *(_BYTE *)(ii + 65) == 2 )
            *(_DWORD *)(ii + 12) = -1;
        }
        v73 = (unsigned __int16)v108;
        if ( *(__int16 *)(dword_AE400 + 8) == (unsigned __int16)v108 )
        {
          v74 = 68 * (unsigned __int16)v108;
          *(_WORD *)(dword_AE400 + 2049 * (unsigned __int16)v108 + v74 + 13415) = 100;
          *(_WORD *)(v72 + 2049 * *(__int16 *)(v72 + 8) + v74 + 13417) = 0;
          strcpy((char *)(2049 * *(__int16 *)(v72 + 8) + v72 + 68 * v73 + 13351), ".. CHEAT: destroy all castles");
        }
        break;
      case 5:
        for ( jj = *(_DWORD *)(dword_AE408 + 36462); ; jj = *(_DWORD *)jj )
        {
          v76 = dword_AE400;
          if ( jj <= dword_AE400 + 29795 )
            break;
          if ( *(_WORD *)(jj + 24) != *(_WORD *)(v14 + 24) && *(_BYTE *)(jj + 65) == 3 )
            *(_DWORD *)(jj + 12) = -1;
        }
        v77 = (unsigned __int16)v108;
        if ( *(__int16 *)(dword_AE400 + 8) == (unsigned __int16)v108 )
        {
          v78 = 68 * (unsigned __int16)v108;
          *(_WORD *)(dword_AE400 + 2049 * (unsigned __int16)v108 + v78 + 13415) = 100;
          *(_WORD *)(v76 + 2049 * *(__int16 *)(v76 + 8) + v78 + 13417) = 0;
          strcpy((char *)(2049 * *(__int16 *)(v76 + 8) + v76 + 68 * v77 + 13351), ".. CHEAT: destroy all balloons");
        }
        break;
      case 6:
        HIWORD(v80) = 0;
        *(_DWORD *)(v14 + 12) = *(_DWORD *)(v14 + 8);
        v79 = dword_AE400;
        LOWORD(v80) = v108;
        if ( *(__int16 *)(dword_AE400 + 8) == (unsigned __int16)v108 )
        {
          v81 = 2049 * v80;
          v82 = 68 * v80;
          *(_WORD *)(v82 + dword_AE400 + v81 + 13415) = 100;
          *(_WORD *)(v82 + v79 + 2049 * *(__int16 *)(v79 + 8) + 13417) = 0;
          strcpy((char *)(v82 + 2049 * *(__int16 *)(v79 + 8) + v79 + 13351), ".. CHEAT: heal");
        }
        break;
      case 7:
        sub_194F0();
        v83 = dword_AE400;
        v84 = (unsigned __int16)v108;
        if ( *(__int16 *)(dword_AE400 + 8) == (unsigned __int16)v108 )
        {
          v85 = 68 * (unsigned __int16)v108;
          *(_WORD *)(dword_AE400 + 2049 * (unsigned __int16)v108 + v85 + 13415) = 100;
          *(_WORD *)(v85 + v83 + 2049 * *(__int16 *)(v83 + 8) + 13417) = 0;
          strcpy((char *)(68 * v84 + 2049 * *(__int16 *)(v83 + 8) + v83 + 13351), ".. CHEAT: Kill all creatures");
        }
        break;
      default:
        break;
    }
LABEL_150:
    v86 = dword_AE400;
    v87 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(v106 + 10);
    v88 = *(_DWORD *)(v87 + 160);
    v89 = 2 * (char)v102[3] - *(__int16 *)(v88 + 327);
    *(_WORD *)(v88 + 4) = (int)(v89 - (__CFSHL__(HIDWORD(v89), 2) + 4 * HIDWORD(v89))) >> 2;
    v90 = *(_DWORD *)(v87 + 160);
    v91 = 2 * (char)v102[4] - *(__int16 *)(v90 + 329);
    *(_WORD *)(v90 + 6) = (int)(v91 - (__CFSHL__(HIDWORD(v91), 2) + 4 * HIDWORD(v91))) >> 2;
    **(_DWORD **)(v87 + 160) = (unsigned __int8)v102[5];
    if ( *(_BYTE *)(v86 + 2049 * *(__int16 *)(v86 + 8) + 13327) || v112 )
    {
      v92 = v112;
      sub_3EC50();
      if ( v92 )
      {
        v93 = dword_AE408;
        v94 = *(_WORD *)(dword_AE408 + 13) + 1;
        *(_BYTE *)dword_AE408 &= ~2u;
        *(_WORD *)(v93 + 13) = v94;
      }
    }
    sub_41B20(v106, 164 * *(unsigned __int16 *)(v106 + 10) + dword_AE400 + 29795);
    v95 = v102;
    memset(v102, 0, 10);
    v102 = v95 + 10;
    v105 += 2049;
    v106 += 2049;
    ++v108;
  }
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 987DE: using guessed type int (*off_987DE)(int);
// 99B68: using guessed type char *off_99B68[8];
// AC5D4: using guessed type int dword_AC5D4;
// AE330: using guessed type int dword_AE330;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (0003DC90) --------------------------------------------------------
char sub_3DC90(int a1, char a2)
{
  *(_BYTE *)(a1 + 1098) = a2;
  if ( *(_WORD *)(a1 + 7) == *(_WORD *)(dword_AE400 + 8) )
  {
    if ( *(_BYTE *)(a1 + 1098) == 2 )
    {
      sub_5C05C(dword_AE450 + 6);
      sub_31A00();
    }
    else
    {
      sub_5C05C(dword_AE450);
      sub_59720();
      sub_31A60();
    }
    sub_55370(0, *(_WORD *)(a1 + 7), 14);
  }
  return sub_3DD10();
}
// AE400: using guessed type int dword_AE400;
// AE450: using guessed type int dword_AE450;

//----- (0003DD10) --------------------------------------------------------
char sub_3DD10()
{
  int v0; // eax

  LOBYTE(v0) = dword_AE408;
  if ( (*(_BYTE *)(dword_AE408 + 4) & 7) == 0 )
  {
    LOBYTE(v0) = *(_BYTE *)(dword_AE408 + 24) & 3;
    if ( (_BYTE)v0 == 1 )
    {
      LOWORD(v0) = sub_11050();
      if ( !v0 )
      {
        v0 = 2049 * *(__int16 *)(dword_AE400 + 8);
        *(_BYTE *)(dword_AE400 + v0 + 13327) = 2;
      }
    }
  }
  return v0;
}
// 3DD2C: variable 'v0' is possibly undefined
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (0003DD50) --------------------------------------------------------
int sub_3DD50()
{
  int v0; // ebx
  int v1; // edi
  int v2; // eax
  char *v3; // edi
  char *v4; // esi
  char v5; // al
  char v6; // al
  __int16 v7; // ax
  int v8; // esi
  int v9; // esi
  _BYTE *v10; // eax
  int v11; // esi
  __int16 v12; // dx
  char v13; // cl
  int v14; // eax
  int v15; // edi
  int result; // eax
  char *v17; // [esp+0h] [ebp-44h]
  int v18; // [esp+4h] [ebp-40h]
  int v19; // [esp+Ch] [ebp-38h]
  int v20; // [esp+10h] [ebp-34h]
  int v21; // [esp+14h] [ebp-30h]
  int v22; // [esp+1Ch] [ebp-28h]
  _BYTE *v23; // [esp+20h] [ebp-24h]
  int v24; // [esp+24h] [ebp-20h]
  int v25; // [esp+28h] [ebp-1Ch]
  unsigned __int16 v26; // [esp+2Ch] [ebp-18h]
  unsigned __int16 v27; // [esp+30h] [ebp-14h]

  v23 = (_BYTE *)(dword_AE400 + 29715);
  v0 = dword_AE400 + 13323;
  v17 = (char *)(dword_AE400 + 15318);
  v18 = dword_AE400 + 14357;
  v27 = 0;
  v22 = dword_AE400 + 13419;
  do
  {
    memset(v23, 0, 10);
    v1 = dword_AE400 + 11274;
    qmemcpy((void *)(dword_AE400 + 11274), (const void *)v0, 0x800u);
    *(_BYTE *)(v1 + 2048) = *(_BYTE *)(v0 + 2048);
    memset((void*)v0, 0, 2049);
    qmemcpy(v17, (const void *)(dword_AE400 + 13269), 0x18u);
    v2 = dword_AE400;
    *(_DWORD *)(v0 + 24) = *(_DWORD *)(dword_AE400 + 11298);
    *v23 = 1;
    *(_WORD *)(v0 + 7) = v27;
    if ( (*(_BYTE *)dword_AE408 & 0x10) == 0 && v27 != *(__int16 *)(v2 + 8) )
      *(_BYTE *)(v0 + 9) = 1;
    *(_WORD *)(v0 + 16) = 32;
    *(_WORD *)(v0 + 14) = *(_WORD *)(v0 + 16) - 1;
    *(_WORD *)(v0 + 584) = 128;
    v3 = (char *)v18;
    v4 = off_99B68[v27];
    do
    {
      v5 = *v4;
      *v3 = *v4;
      if ( !v5 )
        break;
      v6 = v4[1];
      v4 += 2;
      v3[1] = v6;
      v3 += 2;
    }
    while ( v6 );
    v7 = 0;
    while ( 1 )
    {
      v8 = v7;
      if ( v7 >= (int)*(unsigned __int16 *)(v0 + 16) )
        break;
      ++v7;
      *(_DWORD *)(14 * v8 + v0 + 586) = *(_DWORD *)(v0 + 572);
      *(_DWORD *)(14 * v8 + v0 + 590) = *(_DWORD *)(v0 + 576);
      *(_DWORD *)(14 * v8 + v0 + 594) = *(_DWORD *)(v0 + 580);
      *(_WORD *)(14 * v8 + v0 + 598) = *(_WORD *)(v0 + 584);
    }
    v9 = v0;
    do
    {
      v9 += 4;
      *(_DWORD *)(v9 + 1631) = -1;
    }
    while ( v9 != v22 );
    *(_WORD *)(v0 + 2043) = 255;
    v10 = (_BYTE *)dword_AE408;
    *(_WORD *)(v0 + 2047) = 255;
    if ( (*v10 & 0x10) != 0 )
      v26 = 0;
    else
      v26 = v27;
    v19 = v0;
    v24 = v0;
    v20 = v0;
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = 0;
      v14 = (unsigned __int8)byte_99B88[v11];
      *(_BYTE *)(v19 + 1875) = -1;
      v21 = v0 + v14;
      if ( *(_BYTE *)(v0 + 9) == 1 )
      {
        v15 = dword_AE400;
        *(_BYTE *)(v21 + 1899) = byte_38647[216 * v26 + v14 + dword_AE400];
        if ( byte_385E3[216 * v27 + v15 + v14] && *(_BYTE *)(v21 + 1899) )
          goto LABEL_27;
      }
      else
      {
        v25 = v14 + 216 * v26 + dword_AE400;
        if ( byte_38647[v25] != 1 )
          goto LABEL_28;
        if ( (*(_BYTE *)dword_AE408 & 0x10) == 0 )
        {
          if ( !*(_BYTE *)(v21 + 1995) )
            goto LABEL_28;
LABEL_27:
          v13 = 1;
          goto LABEL_28;
        }
        if ( byte_385E3[v25] && byte_38647[v25] )
          goto LABEL_27;
      }
LABEL_28:
      if ( v13 )
      {
        *(_DWORD *)(v24 + 1635) = v14;
        if ( *(_WORD *)(v0 + 2043) == 255 )
        {
          *(_WORD *)(v0 + 2043) = v12;
        }
        else if ( *(_WORD *)(v0 + 2047) == 255 )
        {
          *(_WORD *)(v0 + 2047) = v12;
        }
        *(_BYTE *)(v20 + 1875) = v12;
        ++v20;
        ++v12;
        v24 += 4;
      }
      result = v19 + 1;
      ++v11;
      ++v19;
    }
    while ( v11 < 24 );
    v0 += 2049;
    v23 += 10;
    v17 += 2049;
    v18 += 2049;
    v22 += 2049;
    ++v27;
  }
  while ( v27 < 8u );
  return result;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 99B68: using guessed type char *off_99B68[8];
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (0003E100) --------------------------------------------------------
char sub_3E100(__int16 a1, void *a2)
{
  int v2; // edi
  int v3; // ebx
  int v5; // esi
  int v6; // ebp
  int v7; // edi
  int v8; // edi
  char v9[80]; // [esp+0h] [ebp-50h] BYREF

  v2 = dword_AE3FC;
  if ( a1 < 1000 )
  {
    sprintf(v9, "%s%s/%s/levels.dat", &aLc_0[1], aCarpetCd_0, aLevels_0);
    v3 = sub_5CDE0((int)v9, 512);
    if ( v3 == -1 )
    {
      v3 = sub_5CDE0((int)aLevelsLevelsDa, 512);
      if ( v3 == -1 )
        return 0;
    }
    sprintf(v9, "%s%s/%s/levels.tab", &aLc_0[1], aCarpetCd_0, aLevels_0);
    v5 = sub_5CDE0((int)v9, 512);
    if ( v5 == -1 )
    {
      v5 = sub_5CDE0((int)aLevelsLevelsTa, 512);
      if ( v5 == -1 )
      {
        sub_5CE50(v3);
        return 0;
      }
    }
    sub_5CBD0(v5, v2, 4000);
    v6 = *(_DWORD *)(v2 + 4 * a1);
    v7 = *(_DWORD *)(v2 + 4 * a1 + 4);
    sub_5CE50(v5);
    v8 = v7 - v6;
    if ( filelength )
    {
      sub_62B30(v3, v6, 0);
      sub_5CBD0(v3, dword_AE3FC, v8);
      if ( sub_62B60(dword_AE3FC, (char *)dword_AE3FC) < 0 )
      {
        printf("ERROR decompressing levels.dat\n");
        return 0;
      }
      qmemcpy(a2, (const void *)dword_AE3FC, 0x979Cu);
      memset((void*)dword_AE3FC, 0, 38812);
    }
    sub_5CE50(v3);
  }
  return 1;
}
// 5CC03: using guessed type _DWORD printf(const char *, ...);
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 62AE2: using guessed type _DWORD filelength(_DWORD);
// AE3FC: using guessed type int dword_AE3FC;

//----- (0003E350) --------------------------------------------------------
char sub_3E350(__int16 a1)
{
  char result; // al
  int v2; // ebx
  _DWORD *v3; // eax
  _DWORD *v4; // edi
  char v5[64]; // [esp+0h] [ebp-70h] BYREF
  int v6; // [esp+40h] [ebp-30h]
  int v7; // [esp+44h] [ebp-2Ch]
  int v8; // [esp+48h] [ebp-28h]
  int v9; // [esp+4Ch] [ebp-24h]
  int v10; // [esp+50h] [ebp-20h]
  int v11; // [esp+54h] [ebp-1Ch]
  int v12; // [esp+58h] [ebp-18h]
  int v13; // [esp+5Ch] [ebp-14h]
  int v14; // [esp+60h] [ebp-10h]

  result = sub_3E460(a1);
  if ( result )
  {
    sprintf(v5, "%s/gam%05d.dat", aMovie_0, a1);
    v2 = *(_DWORD *)dword_AE400;
    v12 = *(_DWORD *)(dword_AE400 + 8597);
    v13 = *(_DWORD *)(dword_AE400 + 8601);
    v14 = *(_DWORD *)(dword_AE400 + 8605);
    v9 = *(_DWORD *)(dword_AE400 + 8609);
    v10 = *(_DWORD *)(dword_AE400 + 8613);
    v11 = *(_DWORD *)(dword_AE400 + 8617);
    v6 = *(_DWORD *)(dword_AE400 + 8621);
    v7 = *(_DWORD *)(dword_AE400 + 8625);
    v8 = *(_DWORD *)(dword_AE400 + 8629);
    sub_3EEA0(v5, (char *)dword_AE400);
    v3 = (_DWORD *)dword_AE400;
    v4 = (_DWORD *)(dword_AE400 + 8597);
    *(_DWORD *)(dword_AE400 + 8597) = v12;
    *++v4 = v13;
    v4[1] = v14;
    *(_DWORD *)((char *)v3 + 8609) = v9;
    *(_DWORD *)((char *)v3 + 8613) = v10;
    *(_DWORD *)((char *)v3 + 8617) = v11;
    *(_DWORD *)((char *)v3 + 8621) = v6;
    *(_DWORD *)((char *)v3 + 8625) = v7;
    *(_DWORD *)((char *)v3 + 8629) = v8;
    *v3 = v2;
    sub_416B0();
    sub_37220();
    *(_DWORD *)(dword_AE400 + 4593) = -1;
    return 1;
  }
  return result;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// AE400: using guessed type int dword_AE400;

//----- (0003E410) --------------------------------------------------------
_BOOL1 sub_3E410(__int16 a1)
{
  char v2[64]; // [esp+0h] [ebp-40h] BYREF

  sprintf(v2, "%s/gam%05d.dat", aMovie_0, a1);
  return sub_62E60((int)v2, dword_AE400, (int)sub_38D09) == (_DWORD)sub_38D09;
}
// 38D09: using guessed type int sub_38D09();
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// AE400: using guessed type int dword_AE400;

//----- (0003E460) --------------------------------------------------------
char sub_3E460(__int16 a1)
{
  int v1; // eax
  char v3[64]; // [esp+0h] [ebp-40h] BYREF

  sprintf(v3, "%s/gam%05d.dat", aMovie_0, a1);
  v1 = sub_5CDE0((int)v3, 512);
  if ( v1 == -1 )
    return 0;
  sub_5CE50(v1);
  return 1;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);

//----- (0003E4B0) --------------------------------------------------------
char sub_3E4B0(__int16 a1)
{
  char result; // al
  int v2; // ebx
  char v3[68]; // [esp+0h] [ebp-44h] BYREF

  result = sub_3E640(a1);
  if ( result )
  {
    sprintf(v3, "%s/map%05d.dat", aMovie_0, a1);
    v2 = sub_5CDE0((int)v3, 512);
    sub_5CBD0(v2, (int)byte_CC1E0, (int)sub_10000);
    sub_5CBD0(v2, (int)byte_DC1E0, (int)sub_10000);
    sub_5CBD0(v2, (int)byte_EC1E0, (int)sub_10000);
    sub_5CBD0(v2, (int)byte_FC1E0, (int)sub_10000);
    sub_5CBD0(v2, (int)word_10C1E0, (int)&loc_1FFFE + 2);
    sub_5CBD0(v2, (int)byte_B5D40, 4802);
    sub_5CE50(v2);
    return 1;
  }
  return result;
}
// 10000: using guessed type void sub_10000();
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (0003E580) --------------------------------------------------------
char sub_3E580(__int16 a1)
{
  int v1; // ebx
  char v3[68]; // [esp+0h] [ebp-44h] BYREF

  sprintf(v3, "%s/map%05d.dat", aMovie_0, a1);
  v1 = sub_5CDE0((int)v3, 546);
  sub_62ED0(v1, (int)byte_CC1E0, (int)sub_10000);
  sub_62ED0(v1, (int)byte_DC1E0, (int)sub_10000);
  sub_62ED0(v1, (int)byte_EC1E0, (int)sub_10000);
  sub_62ED0(v1, (int)byte_FC1E0, (int)sub_10000);
  sub_62ED0(v1, (int)word_10C1E0, (int)&loc_1FFFE + 2);
  sub_62ED0(v1, (int)byte_B5D40, 4802);
  sub_5CE50(v1);
  return 0;
}
// 10000: using guessed type void sub_10000();
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (0003E640) --------------------------------------------------------
char sub_3E640(__int16 a1)
{
  int v1; // eax
  char v3[64]; // [esp+0h] [ebp-40h] BYREF

  sprintf(v3, "%s/map%05d.dat", aMovie_0, a1);
  v1 = sub_5CDE0((int)v3, 512);
  if ( v1 == -1 )
    return 0;
  sub_5CE50(v1);
  return 1;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);

//----- (0003E690) --------------------------------------------------------
char sub_3E690(__int16 a1)
{
  char result; // al
  int v2; // ebx
  _DWORD *v3; // eax
  _DWORD *v4; // edi
  char v5[64]; // [esp+0h] [ebp-70h] BYREF
  int v6; // [esp+40h] [ebp-30h]
  int v7; // [esp+44h] [ebp-2Ch]
  int v8; // [esp+48h] [ebp-28h]
  int v9; // [esp+4Ch] [ebp-24h]
  int v10; // [esp+50h] [ebp-20h]
  int v11; // [esp+54h] [ebp-1Ch]
  int v12; // [esp+58h] [ebp-18h]
  int v13; // [esp+5Ch] [ebp-14h]
  int v14; // [esp+60h] [ebp-10h]

  result = sub_3E7A0(a1);
  if ( result )
  {
    sprintf(v5, "c:/CARPET.CD/%s/gam%05d.dat", aSave_0, a1);
    v2 = *(_DWORD *)dword_AE400;
    v12 = *(_DWORD *)(dword_AE400 + 8597);
    v13 = *(_DWORD *)(dword_AE400 + 8601);
    v14 = *(_DWORD *)(dword_AE400 + 8605);
    v9 = *(_DWORD *)(dword_AE400 + 8609);
    v10 = *(_DWORD *)(dword_AE400 + 8613);
    v11 = *(_DWORD *)(dword_AE400 + 8617);
    v6 = *(_DWORD *)(dword_AE400 + 8621);
    v7 = *(_DWORD *)(dword_AE400 + 8625);
    v8 = *(_DWORD *)(dword_AE400 + 8629);
    sub_3EEA0(v5, (char *)dword_AE400);
    v3 = (_DWORD *)dword_AE400;
    v4 = (_DWORD *)(dword_AE400 + 8597);
    *(_DWORD *)(dword_AE400 + 8597) = v12;
    *++v4 = v13;
    v4[1] = v14;
    *(_DWORD *)((char *)v3 + 8609) = v9;
    *(_DWORD *)((char *)v3 + 8613) = v10;
    *(_DWORD *)((char *)v3 + 8617) = v11;
    *(_DWORD *)((char *)v3 + 8621) = v6;
    *(_DWORD *)((char *)v3 + 8625) = v7;
    *(_DWORD *)((char *)v3 + 8629) = v8;
    *v3 = v2;
    sub_416B0();
    sub_37220();
    *(_DWORD *)(dword_AE400 + 4593) = -1;
    return 1;
  }
  return result;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// AE400: using guessed type int dword_AE400;

//----- (0003E750) --------------------------------------------------------
_BOOL1 sub_3E750(__int16 a1)
{
  char v2[64]; // [esp+0h] [ebp-40h] BYREF

  sprintf(v2, "c:/CARPET.CD/%s/gam%05d.dat", aSave_0, a1);
  return sub_62E60((int)v2, dword_AE400, (int)sub_38D09) == (_DWORD)sub_38D09;
}
// 38D09: using guessed type int sub_38D09();
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// AE400: using guessed type int dword_AE400;

//----- (0003E7A0) --------------------------------------------------------
char sub_3E7A0(__int16 a1)
{
  int v1; // eax
  char v3[64]; // [esp+0h] [ebp-40h] BYREF

  sprintf(v3, "c:/CARPET.CD/%s/gam%05d.dat", aSave_0, a1);
  v1 = sub_5CDE0((int)v3, 512);
  if ( v1 == -1 )
    return 0;
  sub_5CE50(v1);
  return 1;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);

//----- (0003E7F0) --------------------------------------------------------
char sub_3E7F0(__int16 a1)
{
  char result; // al
  int v2; // ebx
  char v3[68]; // [esp+0h] [ebp-44h] BYREF

  result = sub_3E980(a1);
  if ( result )
  {
    sprintf(v3, "c:/CARPET.CD/%s/map%05d.dat", aSave_0, a1);
    v2 = sub_5CDE0((int)v3, 512);
    sub_5CBD0(v2, (int)byte_CC1E0, (int)sub_10000);
    sub_5CBD0(v2, (int)byte_DC1E0, (int)sub_10000);
    sub_5CBD0(v2, (int)byte_EC1E0, (int)sub_10000);
    sub_5CBD0(v2, (int)byte_FC1E0, (int)sub_10000);
    sub_5CBD0(v2, (int)word_10C1E0, (int)&loc_1FFFE + 2);
    sub_5CBD0(v2, (int)byte_B5D40, 4802);
    sub_5CE50(v2);
    return 1;
  }
  return result;
}
// 10000: using guessed type void sub_10000();
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (0003E8C0) --------------------------------------------------------
char sub_3E8C0(__int16 a1)
{
  int v1; // ebx
  char v3[68]; // [esp+0h] [ebp-44h] BYREF

  sprintf(v3, "c:/CARPET.CD/%s/map%05d.dat", aSave_0, a1);
  v1 = sub_5CDE0((int)v3, 546);
  sub_62ED0(v1, (int)byte_CC1E0, (int)sub_10000);
  sub_62ED0(v1, (int)byte_DC1E0, (int)sub_10000);
  sub_62ED0(v1, (int)byte_EC1E0, (int)sub_10000);
  sub_62ED0(v1, (int)byte_FC1E0, (int)sub_10000);
  sub_62ED0(v1, (int)word_10C1E0, (int)&loc_1FFFE + 2);
  sub_62ED0(v1, (int)byte_B5D40, 4802);
  sub_5CE50(v1);
  return 0;
}
// 10000: using guessed type void sub_10000();
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (0003E980) --------------------------------------------------------
char sub_3E980(__int16 a1)
{
  int v1; // eax
  char v3[64]; // [esp+0h] [ebp-40h] BYREF

  sprintf(v3, "c:/CARPET.CD/%s/map%05d.dat", aSave_0, a1);
  v1 = sub_5CDE0((int)v3, 512);
  if ( v1 == -1 )
    return 0;
  sub_5CE50(v1);
  return 1;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);

//----- (0003E9D0) --------------------------------------------------------
void sub_3E9D0(_BYTE *a1)
{
  int v1; // edx
  int v2; // eax
  char v3; // dl
  int v4; // ebp
  int v5; // edx
  int v6; // eax
  char v7; // bl
  int v8; // eax
  int v9; // ecx
  char v10[80]; // [esp+0h] [ebp-50h] BYREF

  if ( (*(_BYTE *)dword_AE408 & 4) != 0 )
  {
    if ( !*(_DWORD *)(dword_AE408 + 9) && !((int)&a1[-dword_AE400 - 29715] / 10) )
    {
      sprintf(v10, "%s/mvi%05d.dat", aMovie_0, *(__int16 *)(dword_AE408 + 13));
      v1 = sub_5CDE0((int)v10, 512);
      v2 = dword_AE408;
      *(_DWORD *)(dword_AE408 + 9) = v1;
      if ( v1 == -1 )
      {
        v3 = *(_BYTE *)v2;
        *(_DWORD *)(v2 + 9) = 0;
        *(_BYTE *)v2 = v3 & 0xFB;
        return;
      }
      sub_3E350(*(_WORD *)(v2 + 13));
      sub_3E4B0(*(_WORD *)(dword_AE408 + 13));
      sub_59420();
      sub_356E0();
    }
    v4 = *(_DWORD *)(dword_AE408 + 9);
    if ( v4 )
    {
      if ( *a1 == 2 )
      {
        sub_3EC50();
        *(_WORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13325) = 8;
        *a1 = 0;
        return;
      }
      if ( sub_5CBD0(v4, (int)a1, 10) != 10 )
      {
        sub_3EC50();
        *(_WORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13325) = 8;
        *a1 = 0;
      }
      if ( *a1 == 2 || sub_35710() )
      {
        sub_3EC50();
        *(_WORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13325) = 8;
LABEL_25:
        *a1 = 0;
      }
    }
  }
  else
  {
    if ( (*(_BYTE *)dword_AE408 & 2) == 0 )
      return;
    if ( !*(_DWORD *)(dword_AE408 + 9) && !((int)&a1[-dword_AE400 - 29715] / 10) )
    {
      sprintf(v10, "%s/mvi%05d.dat", aMovie_0, *(__int16 *)(dword_AE408 + 13));
      v5 = sub_5CDE0((int)v10, 546);
      v6 = dword_AE408;
      *(_DWORD *)(dword_AE408 + 9) = v5;
      if ( v5 == -1 )
      {
        v7 = *(_BYTE *)v6;
        *(_DWORD *)(v6 + 9) = 0;
        *(_BYTE *)v6 = v7 & 0xFD;
        return;
      }
      sub_593B0();
      sub_3E410(*(_WORD *)(dword_AE408 + 13));
      sub_3E580(*(_WORD *)(dword_AE408 + 13));
      sub_37220();
      *(_DWORD *)(dword_AE400 + 4593) = -1;
      v8 = dword_AE408;
      *(_BYTE *)(dword_AE408 + 161) = 3;
      *(_DWORD *)(v8 + 162) = 200;
    }
    v9 = *(_DWORD *)(dword_AE408 + 9);
    if ( v9 )
    {
      if ( sub_62ED0(v9, (int)a1, 10) != 10 )
        sub_3EC50();
      if ( *a1 == 12 )
        goto LABEL_25;
    }
  }
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (0003EC50) --------------------------------------------------------
_BYTE *sub_3EC50()
{
  _BYTE *result; // eax
  char v1; // dl

  result = (_BYTE *)dword_AE408;
  if ( *(_DWORD *)(dword_AE408 + 9) )
  {
    sub_5CE50(*(_DWORD *)(dword_AE408 + 9));
    result = (_BYTE *)dword_AE408;
    v1 = *(_BYTE *)dword_AE408;
    *(_DWORD *)(dword_AE408 + 9) = 0;
    *result = v1 & 0xF9;
  }
  return result;
}
// AE408: using guessed type int dword_AE408;

//----- (0003EC80) --------------------------------------------------------
int sub_3EC80(int a1)
{
  return access(a1, 0);
}
// 62F18: using guessed type _DWORD access(_DWORD, _DWORD);

//----- (0003EC90) --------------------------------------------------------
char sub_3EC90(unsigned __int8 a1, const char *a2, char *a3)
{
  char *v4; // esi
  char *v5; // edi
  char v6; // al
  char v7; // al
  char *v8; // esi
  char *v9; // edi
  char v10; // al
  char v11; // al
  char *v12; // esi
  char *v13; // edi
  char v14; // al
  char v15; // al
  char *v16; // esi
  char *v17; // edi
  char v18; // al
  char v19; // al
  char *v20; // esi
  char *v21; // edi
  char v22; // al
  char v23; // al
  char *v24; // esi
  char *v25; // edi
  char v26; // al
  char v27; // al
  char v28[144]; // [esp+0h] [ebp-134h] BYREF
  char v29[144]; // [esp+90h] [ebp-A4h] BYREF
  char v30[20]; // [esp+120h] [ebp-14h] BYREF

  if ( dos_getdiskfree(a1 - 64, (uint32)v30) )
    return 1;
  sprintf(v28, "%c:%s", a1, a2);
  if ( (__int16)sub_3EC80((int)v28) <= -1 )
  {
    if ( mkdir((uint32)v28) )
      return 2;
    v16 = v28;
    v17 = v29;
    do
    {
      v18 = *v16;
      *v17 = *v16;
      if ( !v18 )
        break;
      v19 = v16[1];
      v16 += 2;
      v17[1] = v19;
      v17 += 2;
    }
    while ( v19 );
    v20 = &aEs_0[2];
    v21 = &v29[strlen(v29)];
    do
    {
      v22 = *v20;
      *v21 = *v20;
      if ( !v22 )
        break;
      v23 = v20[1];
      v20 += 2;
      v21[1] = v23;
      v21 += 2;
    }
    while ( v23 );
    v24 = a3;
    v25 = &v29[strlen(v29)];
    do
    {
      v26 = *v24;
      *v25 = *v24;
      if ( !v26 )
        break;
      v27 = v24[1];
      v24 += 2;
      v25[1] = v27;
      v25 += 2;
    }
    while ( v27 );
    if ( (sub_3EC80((int)v29) & 0x8000u) != 0 && mkdir((uint32)v29) )
      return 2;
  }
  else
  {
    v4 = v28;
    v5 = v29;
    do
    {
      v6 = *v4;
      *v5 = *v4;
      if ( !v6 )
        break;
      v7 = v4[1];
      v4 += 2;
      v5[1] = v7;
      v5 += 2;
    }
    while ( v7 );
    v8 = &aEs_0[2];
    v9 = &v29[strlen(v29)];
    do
    {
      v10 = *v8;
      *v9 = *v8;
      if ( !v10 )
        break;
      v11 = v8[1];
      v8 += 2;
      v9[1] = v11;
      v9 += 2;
    }
    while ( v11 );
    v12 = a3;
    v13 = &v29[strlen(v29)];
    do
    {
      v14 = *v12;
      *v13 = *v12;
      if ( !v14 )
        break;
      v15 = v12[1];
      v12 += 2;
      v13[1] = v15;
      v13 += 2;
    }
    while ( v15 );
    if ( (sub_3EC80((int)v29) & 0x8000u) != 0 && mkdir((uint32)v29) )
      return 2;
  }
  return 3;
}
// 5CEAC: using guessed type _DWORD dos_getdiskfree(_DWORD, _DWORD);
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 62F56: using guessed type _DWORD mkdir(_DWORD);
// 3EC90: using guessed type char var_14[20];
// 3EC90: using guessed type char var_A4[144];

//----- (0003EEA0) --------------------------------------------------------
int sub_3EEA0(const char *a1, char *a2)
{
  int result; // eax
  int v3; // ebx
  int v4; // esi

  result = sub_5CDE0((int)a1, 512);
  v3 = result;
  if ( result != -1 )
  {
    v4 = filelength(result);
    sub_5CBD0(v3, (int)a2, v4);
    sub_5CE50(v3);
    result = sub_62B60((int)a2, a2);
    if ( result >= 0 )
    {
      if ( !result )
        return v4;
    }
    else
    {
      printf("ERROR decompressing %s\n", a1);
      return -2;
    }
  }
  return result;
}
// 5CC03: using guessed type _DWORD printf(const char *, ...);
// 62AE2: using guessed type _DWORD filelength(_DWORD);

//----- (0003EF20) --------------------------------------------------------
int sub_3EF20()
{
  return 1;
}

//----- (0003EF30) --------------------------------------------------------
bool sub_3EF30(int a1)
{
  return (unsigned __int16)access(a1, 0) == 0;
}
// 62F18: using guessed type _DWORD access(_DWORD, _DWORD);

//----- (0003EF50) --------------------------------------------------------
char sub_3EF50(const char *a1, const char *a2, const char *a3)
{
  int v3; // ebx
  int v4; // esi
  int v6; // eax
  int v7; // eax
  int v8; // ebx
  int v9; // ebp
  int v10; // edi
  int v11; // ebx
  int v12; // eax
  int v13; // esi
  int v14; // edx
  char v15[144]; // [esp+0h] [ebp-19Ch] BYREF
  char v16[144]; // [esp+90h] [ebp-10Ch] BYREF
  char v17[100]; // [esp+120h] [ebp-7Ch] BYREF
  int v18; // [esp+184h] [ebp-18h]
  int v19; // [esp+188h] [ebp-14h]

  if ( !sub_3EF30((int)a1) )
    return 2;
  if ( !sub_3EF30((int)a2) )
    return 1;
  sprintf(v15, "%s/%s.tab", a1, a3);
  sprintf(v16, "%s/%s.tab", a2, a3);
  v3 = sub_5CDE0((int)v15, 512);
  if ( v3 == -1 )
    return 3;
  v4 = sub_5CDE0((int)v16, 546);
  if ( v4 == -1 )
    return 3;
  v6 = filelength(v3);
  v7 = sub_5CBD0(v3, dword_12EFF4, v6);
  sub_62ED0(v4, dword_12EFF4, v7);
  sub_5CE50(v3);
  sub_5CE50(v4);
  sprintf(v15, "%s/%s.dat", a1, a3);
  sprintf(v16, "%s/%s.dat", a2, a3);
  v8 = sub_5CDE0((int)v15, 512);
  v9 = v8;
  if ( v8 != -1 )
  {
    v18 = sub_5CDE0((int)v16, 546);
    if ( v18 != -1 )
    {
      v10 = 0;
      v11 = filelength(v8);
      v19 = v11;
      while ( v11 )
      {
        if ( v11 <= 64000 )
          v12 = v11;
        else
          v12 = 64000;
        v13 = sub_5CBD0(v9, dword_12EFF4, v12);
        v11 -= v13;
        sub_62ED0(v18, dword_12EFF4, v13);
        v10 += v13;
        settextposition((__int16)dword_B76F0, SHIWORD(dword_B76F0));
        v14 = 100 * v10 / v19;
        if ( (__int16)v14 > 100 )
          LOWORD(v14) = 100;
        sprintf(v17, "%d%c", (__int16)v14, 37);
        outtext((uint32)v17);
      }
      sub_5CE50(v9);
      sub_5CE50(v18);
    }
  }
  memset((void*)dword_12EFF4, 0, 64000);
  return 0;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 62AE2: using guessed type _DWORD filelength(_DWORD);
// 79CA6: using guessed type _DWORD settextposition(_DWORD, _DWORD);
// 79F0E: using guessed type _DWORD outtext(_DWORD);
// B76F0: using guessed type int dword_B76F0;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (0003F1D0) --------------------------------------------------------
char sub_3F1D0()
{
  int v0; // eax
  __int16 v1; // ax
  int v2; // eax
  char v4[64]; // [esp+0h] [ebp-80h] BYREF
  char v5[64]; // [esp+40h] [ebp-40h] BYREF

  sprintf(v5, "%s%s/%s/%s.dat", &aLc_0[1], aCarpetCd_0, aData_0, aTmaps00);
  sprintf(v4, "data/%s.dat", aTmaps00);
  if ( (unsigned __int16)sub_3EF20() )
  {
    sprintf(v5, "%s%s/%s", &aLc_0[1], aCarpetCd_0, aData_0);
    v0 = outtext((uint32)aCreatingSetupD);
    dword_B76F0 = gettextposition(v0);
    if ( !sub_3EF50(aData_0, v5, aTmaps00) )
      sprintf(v5, "%s%s/%s/%s.dat", &aLc_0[1], aCarpetCd_0, aData_0, aTmaps00);
  }
  outtext((uint32)&aAp[3]);
  sprintf(v5, "%s%s/%s/levels.dat", &aLc_0[1], aCarpetCd_0, aLevels_0);
  v1 = sub_3EF20();
  if ( v1 )
  {
    sprintf(v5, "%s%s/%s", &aLc_0[1], aCarpetCd_0, aLevels_0);
    v2 = outtext((uint32)aSetupLevels);
    dword_B76F0 = gettextposition(v2);
    LOBYTE(v1) = sub_3EF50(aLevels_0, v5, aLevels_0);
    if ( !(_BYTE)v1 )
      LOBYTE(v1) = sprintf(v5, "%s%s/%s/levels.dat", &aLc_0[1], aCarpetCd_0, aLevels_0);
  }
  return v1;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 79C74: using guessed type int gettextposition(_DWORD);
// 79F0E: using guessed type _DWORD outtext(_DWORD);
// B76F0: using guessed type int dword_B76F0;
// 3F1D0: using guessed type char var_80[64];

//----- (0003F370) --------------------------------------------------------
int sub_3F370()
{
  int result; // eax
  int v1; // [esp+0h] [ebp-38h] BYREF
  __int16 v2[14]; // [esp+1Ch] [ebp-1Ch] BYREF

  v2[0] = 0;
  result = int386(51, (uint32)v2, (uint32)&v1);
  dword_9AD98 = 0;
  return result;
}
// 62F78: using guessed type _DWORD int386(_DWORD, _DWORD, _DWORD);
// 9AD98: using guessed type int dword_9AD98;
// 3F370: using guessed type __int16 var_1C[14];

//----- (0003F398) --------------------------------------------------------
__int16 sub_3F398(__int16 a1)
{
  unsigned __int16 v1; // bx
  unsigned __int16 v2; // si
  int v3; // ecx
  unsigned __int8 v4; // al

  v1 = 0;
  v2 = 0;
  __outbyte(0x201u, a1);
  v3 = 10000;
  _disable();
  while ( 1 )
  {
    v4 = __inbyte(0x201u);
    if ( (v4 & 3) == 0 )
      break;
    if ( (v4 & 1) != 0 )
      ++v1;
    if ( (v4 & 2) != 0 )
      ++v2;
    if ( !--v3 )
    {
      _enable();
      byte_B7700 = 0;
      return a1;
    }
  }
  _enable();
  byte_B7700 = 2;
  word_B770A = v1 >> 1;
  word_B7706 = v1 + (v1 >> 1);
  word_B770C = v2 >> 1;
  word_B7708 = v2 + (v2 >> 1);
  return a1;
}
// B7700: using guessed type char byte_B7700;
// B7706: using guessed type __int16 word_B7706;
// B7708: using guessed type __int16 word_B7708;
// B770A: using guessed type __int16 word_B770A;
// B770C: using guessed type __int16 word_B770C;

//----- (0003F413) --------------------------------------------------------
void sub_3F413(unsigned __int8 a1)
{
  __int16 v1; // bx
  __int16 v2; // si
  int v3; // ecx
  unsigned __int8 v4; // al
  __int16 v5; // ax
  __int16 v6; // ax

  if ( byte_B7700 )
  {
    v1 = 0;
    v2 = 0;
    __outbyte(0x201u, a1);
    v3 = 10000;
    _disable();
    while ( 1 )
    {
      v4 = __inbyte(0x201u);
      if ( (v4 & 3) == 0 )
        break;
      if ( (v4 & 1) != 0 )
        ++v1;
      if ( (v4 & 2) != 0 )
        ++v2;
      if ( !--v3 )
      {
        _enable();
        byte_B7700 = 0;
        goto LABEL_19;
      }
    }
    _enable();
    byte_B772A = v4;
    v5 = 0;
    if ( v1 >= word_B770A )
    {
      if ( v1 > word_B7706 )
        v5 = 1;
    }
    else
    {
      v5 = -1;
    }
    word_B7702 = v5;
    v6 = 0;
    if ( v2 >= word_B770C )
    {
      if ( v2 > word_B7708 )
        v6 = 1;
    }
    else
    {
      v6 = -1;
    }
    word_B7704 = v6;
  }
  else
  {
LABEL_19:
    word_B7702 = 0;
    word_B7704 = 0;
    byte_B772A = -1;
  }
}
// B7700: using guessed type char byte_B7700;
// B7702: using guessed type __int16 word_B7702;
// B7704: using guessed type __int16 word_B7704;
// B7706: using guessed type __int16 word_B7706;
// B7708: using guessed type __int16 word_B7708;
// B770A: using guessed type __int16 word_B770A;
// B770C: using guessed type __int16 word_B770C;
// B772A: using guessed type char byte_B772A;

//----- (0003F4CE) --------------------------------------------------------
__int16 sub_3F4CE(__int16 a1)
{
  __int16 v1; // bx
  __int16 v2; // cx
  __int16 v3; // si
  __int16 v4; // di
  unsigned __int8 v5; // al
  int v8; // [esp+0h] [ebp-4h]

  v8 = 10000;
  v1 = 0;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  __outbyte(0x201u, 0x10u);
  _disable();
  do
  {
    v5 = __inbyte(0x201u);
    if ( (v5 & 0xF) == 0 )
      break;
    if ( (v5 & 1) != 0 )
      ++v1;
    if ( (v5 & 2) != 0 )
      ++v3;
    if ( (v5 & 4) != 0 )
      ++v2;
    if ( (v5 & 8) != 0 )
      ++v4;
    --v8;
  }
  while ( v8 >= 0 );
  _enable();
  byte_B7700 = (v5 & 3) == 0;
  byte_B7701 = (v5 & 0xC) == 0;
  return a1;
}
// B7700: using guessed type char byte_B7700;
// B7701: using guessed type char byte_B7701;

//----- (0003F54D) --------------------------------------------------------
void sub_3F54D(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  byte_B772A = sub_3F76D((int)&savedregs);
  word_B7702 = a2;
  word_B7704 = a4;
  word_B7716 = a1;
  word_B7718 = a3;
}
// B7702: using guessed type __int16 word_B7702;
// B7704: using guessed type __int16 word_B7704;
// B7716: using guessed type __int16 word_B7716;
// B7718: using guessed type __int16 word_B7718;
// B772A: using guessed type char byte_B772A;

//----- (0003F587) --------------------------------------------------------
void sub_3F587(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  if ( byte_B7700 )
  {
    byte_B772A = sub_3F76D((int)&savedregs) & 0xF0;
    if ( byte_B7700 )
    {
      v4 = 0;
      if ( a2 >= word_B770A )
      {
        if ( a2 > word_B7706 )
        {
          LOWORD(v4) = a2 - word_B7706;
          v4 = ((unsigned __int16)word_B770E * v4) >> 11;
          if ( (unsigned int)v4 > 0x80 )
            LOWORD(v4) = 128;
        }
      }
      else
      {
        v4 = (word_B7712 * (__int16)(a2 - word_B770A)) >> 11;
        if ( v4 < -128 )
          LOWORD(v4) = -128;
      }
      word_B7702 = v4;
      v5 = 0;
      if ( a4 >= word_B770C )
      {
        if ( a4 > word_B7708 )
        {
          LOWORD(v5) = a4 - word_B7708;
          v5 = ((unsigned __int16)word_B7710 * v5) >> 11;
          if ( (unsigned int)v5 > 0x80 )
            LOWORD(v5) = 128;
        }
      }
      else
      {
        v5 = (word_B7714 * (__int16)(a4 - word_B770C)) >> 11;
        if ( v5 < -128 )
          LOWORD(v5) = -128;
      }
      word_B7704 = v5;
    }
    if ( byte_B7701 )
    {
      v6 = 0;
      if ( a1 >= word_B771E )
      {
        if ( a1 > word_B771A )
        {
          LOWORD(v6) = a1 - word_B771A;
          v6 = ((unsigned __int16)word_B7722 * v6) >> 11;
          if ( (unsigned int)v6 > 0x80 )
            LOWORD(v6) = 128;
        }
      }
      else
      {
        v6 = (word_B7726 * (__int16)(a1 - word_B771E)) >> 11;
        if ( v6 < -128 )
          LOWORD(v6) = -128;
      }
      word_B7716 = v6;
      v7 = 0;
      if ( a3 >= word_B7720 )
      {
        if ( a3 > word_B771C )
        {
          LOWORD(v7) = a3 - word_B771C;
          v7 = ((unsigned __int16)word_B7724 * v7) >> 11;
          if ( (unsigned int)v7 > 0x80 )
            LOWORD(v7) = 128;
        }
      }
      else
      {
        v7 = (word_B7728 * (__int16)(a3 - word_B7720)) >> 11;
        if ( v7 < -128 )
          LOWORD(v7) = -128;
      }
      word_B7718 = v7;
    }
  }
  else
  {
    word_B7702 = 0;
    word_B7704 = 0;
    byte_B772A = -1;
  }
}
// B7700: using guessed type char byte_B7700;
// B7701: using guessed type char byte_B7701;
// B7702: using guessed type __int16 word_B7702;
// B7704: using guessed type __int16 word_B7704;
// B7706: using guessed type __int16 word_B7706;
// B7708: using guessed type __int16 word_B7708;
// B770A: using guessed type __int16 word_B770A;
// B770C: using guessed type __int16 word_B770C;
// B770E: using guessed type __int16 word_B770E;
// B7710: using guessed type __int16 word_B7710;
// B7712: using guessed type __int16 word_B7712;
// B7714: using guessed type __int16 word_B7714;
// B7716: using guessed type __int16 word_B7716;
// B7718: using guessed type __int16 word_B7718;
// B771A: using guessed type __int16 word_B771A;
// B771C: using guessed type __int16 word_B771C;
// B771E: using guessed type __int16 word_B771E;
// B7720: using guessed type __int16 word_B7720;
// B7722: using guessed type __int16 word_B7722;
// B7724: using guessed type __int16 word_B7724;
// B7726: using guessed type __int16 word_B7726;
// B7728: using guessed type __int16 word_B7728;
// B772A: using guessed type char byte_B772A;

//----- (0003F76D) --------------------------------------------------------
unsigned __int8 sub_3F76Dfix(int a1)
{
  __int16 v1; // bx
  __int16 v2; // cx
  __int16 v3; // si
  __int16 v4; // di
  unsigned __int8 result; // al

  if ( byte_B7701 )
    *(_BYTE *)(a1 - 5) = 15;
  else
    *(_BYTE *)(a1 - 5) = 3;
  *(_DWORD *)(a1 - 4) = 10000;
  v1 = 0;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  _disable();
  __outbyte(0x201u, 0x10u);
  while ( 1 )
  {
    result = __inbyte(0x201u);
    if ( (result & *(_BYTE *)(a1 - 5)) == 0 )
      break;
    if ( (result & 1) != 0 )
      ++v1;
    if ( (result & 2) != 0 )
      ++v3;
    if ( (result & 4) != 0 )
      ++v2;
    if ( (result & 8) != 0 )
      ++v4;
    if ( --*(_DWORD *)(a1 - 4) < 0 )
    {
      byte_B7700 = 0;
      break;
    }
  }
  _enable();
  return result;
}
// B7700: using guessed type char byte_B7700;
// B7701: using guessed type char byte_B7701;

//----- (0003F7D0) --------------------------------------------------------
char sub_3F7D0(int a1)
{
  __int16 v1; // ax
  __int16 v2; // ax
  __int16 v3; // ax

  v1 = (short)memset(&byte_B7700, 0, 43);
  v2 = sub_3F4CE(v1);
  v3 = sub_3F398(v2);
  if ( byte_B7700 )
  {
    sub_3F398(v3);
    LOBYTE(v3) = sub_3FB30(word_90B34, word_90B36, a1);
    byte_90B23 = 2;
  }
  return v3;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 90B23: using guessed type char byte_90B23;
// 90B34: using guessed type __int16 word_90B34;
// 90B36: using guessed type __int16 word_90B36;
// B7700: using guessed type char byte_B7700;

//----- (0003F820) --------------------------------------------------------
char sub_3F820fix(__int16 a1, __int16 a2, int a3, int a4, int a5, char a6)
{
  __int16 v6; // ax
  char result; // al
  __int16 v8; // bx
  __int16 v9; // si
  __int16 v10; // di
  __int16 v11; // di
  __int16 v12; // bx
  __int16 v13; // si
  __int16 v14; // bx
  __int16 v15; // di
  __int16 v16; // si
  int v17; // edi
  int v18; // ebx
  __int64 v19; // rtt
  __int64 v20; // rtt
  __int64 v21; // rtt
  __int64 v22; // rtt
  int v23; // [esp+0h] [ebp-1Ch]
  int v24; // [esp+4h] [ebp-18h]
  int v25; // [esp+8h] [ebp-14h]
  int v26; // [esp+Ch] [ebp-10h]

  v6 = sub_3F4CE(a1);
  result = sub_3F398(v6);
  if ( byte_B7700 )
  {
    byte_B7700 = 1;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    sub_3FB30(word_90B24, word_90B26, a3);
    do
    {
      sub_3F54D(a2, v8, v10, v9);
      v8 += word_B7702;
      a2 = word_B7704;
      ++v10;
      v9 += word_B7704;
    }
    while ( (unsigned __int16)v10 < 0x10u );
    v24 = (int)(v8 - (__CFSHL__((unsigned __int64)v8 >> 32, 4) + 16 * ((unsigned __int64)v8 >> 32))) >> 4;
    v25 = (int)(v9 - (__CFSHL__((unsigned __int64)v9 >> 32, 4) + 16 * ((unsigned __int64)v9 >> 32))) >> 4;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    sub_3FB30(word_90B2C, word_90B2E, a4);
    do
    {
      sub_3F54D(a4, v12, v11, v13);
      v12 += word_B7702;
      ++v11;
      v13 += word_B7704;
    }
    while ( (unsigned __int16)v11 < 0x10u );
    v26 = (int)(v12 - (__CFSHL__((unsigned __int64)v12 >> 32, 4) + 16 * ((unsigned __int64)v12 >> 32))) >> 4;
    v23 = (int)(v13 - (__CFSHL__((unsigned __int64)v13 >> 32, 4) + 16 * ((unsigned __int64)v13 >> 32))) >> 4;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    sub_3FB30(word_90B34, word_90B36, a5);
    do
    {
      sub_3F54D(a4, v14, v15, v16);
      v14 += word_B7702;
      ++v15;
      v16 += word_B7704;
    }
    while ( (unsigned __int16)v15 < 0x10u );
    v17 = (int)(v14 - (__CFSHL__((unsigned __int64)v14 >> 32, 4) + 16 * ((unsigned __int64)v14 >> 32))) >> 4;
    v18 = (int)(v16 - (__CFSHL__((unsigned __int64)v16 >> 32, 4) + 16 * ((unsigned __int64)v16 >> 32))) >> 4;
    if ( (unsigned __int16)(v26 - v17) <= 0x1Eu )
    {
      word_B7706 = 10000;
    }
    else
    {
      word_B7706 = v17 + 3 * (unsigned __int16)(v26 - v17) / 10;
      LODWORD(v19) = (uint32)((char *)&loc_3FFFE + 2);
      HIDWORD(v19) = (uint32)(((int)&loc_3FFFE + 2) >> 31);
      word_B770E = v19 / ((unsigned __int16)v26 - word_B7706);
    }
    if ( (unsigned __int16)(v23 - v18) <= 0x1Eu )
    {
      word_B7708 = 10000;
    }
    else
    {
      word_B7708 = v18 + 3 * (unsigned __int16)(v23 - v18) / 10;
      LODWORD(v20) = (uint32)((char *)&loc_3FFFE + 2);
      HIDWORD(v20) = (uint32)(((int)&loc_3FFFE + 2) >> 31);
      word_B7710 = v20 / ((unsigned __int16)v23 - word_B7708);
    }
    if ( (unsigned __int16)(v18 - v25) <= 0x1Eu )
    {
      word_B770C = 0;
    }
    else
    {
      word_B770C = v18 - 3 * (unsigned __int16)(v18 - v25) / 10;
      LODWORD(v21) = (uint32)((char *)&loc_3FFFE + 2);
      HIDWORD(v21) = (uint32)(((int)&loc_3FFFE + 2) >> 31);
      word_B7714 = v21 / (word_B770C - (unsigned __int16)v25);
    }
    if ( (unsigned __int16)(v17 - v24) <= 0x1Eu )
    {
      word_B770A = 0;
    }
    else
    {
      word_B770A = v17 - 3 * (unsigned __int16)(v17 - v24) / 10;
      LODWORD(v22) = (uint32)((char *)&loc_3FFFE + 2);
      HIDWORD(v22) = (uint32)(((int)&loc_3FFFE + 2) >> 31);
      word_B7712 = v22 / (word_B770A - (unsigned __int16)v24);
    }
    result = a6;
    byte_90B23 = a6;
  }
  return result;
}
// 90B23: using guessed type char byte_90B23;
// 90B24: using guessed type __int16 word_90B24;
// 90B26: using guessed type __int16 word_90B26;
// 90B2C: using guessed type __int16 word_90B2C;
// 90B2E: using guessed type __int16 word_90B2E;
// 90B34: using guessed type __int16 word_90B34;
// 90B36: using guessed type __int16 word_90B36;
// B7700: using guessed type char byte_B7700;
// B7702: using guessed type __int16 word_B7702;
// B7704: using guessed type __int16 word_B7704;
// B7706: using guessed type __int16 word_B7706;
// B7708: using guessed type __int16 word_B7708;
// B770A: using guessed type __int16 word_B770A;
// B770C: using guessed type __int16 word_B770C;
// B770E: using guessed type __int16 word_B770E;
// B7710: using guessed type __int16 word_B7710;
// B7712: using guessed type __int16 word_B7712;
// B7714: using guessed type __int16 word_B7714;

//----- (0003FB30) --------------------------------------------------------
unsigned __int8 sub_3FB30(__int16 a1, __int16 a2, int a3)
{
  unsigned __int8 v3; // al
  unsigned __int8 v4; // al

  do
  {
    if ( (word_12F02E & 1) != 0 )
      sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
    else
      sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
    sub_4B560();
    v3 = a2;
    if ( a3 + 6 * (a1 + a2) )
    {
      if ( (word_12F02E & 1) != 0 )
        v3 = sub_60CE0(a1, a2, a3);
      else
        v3 = sub_60D18(a1, a2, a3);
    }
    sub_3F413(v3);
    if ( (word_12F02E & 1) != 0 )
      sub_5CDA0();
    else
      sub_599B0(480);
  }
  while ( (byte_B772A & 0x10) != 0 );
  sub_5CC54();
  do
  {
    if ( (word_12F02E & 1) != 0 )
      sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
    else
      sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
    sub_4B560();
    v4 = a2;
    if ( a3 + 6 * (a1 + a2) )
    {
      if ( (word_12F02E & 1) != 0 )
        v4 = sub_60CE0(a1, a2, a3);
      else
        v4 = sub_60D18(a1, a2, a3);
    }
    sub_3F413(v4);
    if ( (word_12F02E & 1) != 0 )
      sub_5CDA0();
    else
      sub_599B0(480);
  }
  while ( (byte_B772A & 0x10) == 0 );
  return sub_5CC54();
}
// AE3FC: using guessed type int dword_AE3FC;
// B772A: using guessed type char byte_B772A;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0003FCA0) --------------------------------------------------------
char sub_3FCA0fix(
        int a1,
        __int16 a2,
        __int16 a3,
        __int16 a4,
        char a5,
        __int16 a6,
        __int16 a7,
        __int16 a8,
        __int16 a9,
        __int16 a10,
        __int16 a11)
{
  __int16 v11; // bx
  int v12; // eax
  int v13; // edx
  __int16 *v14; // eax
  __int16 v15; // dx
  __int16 v16; // ax
  int v17; // edx
  __int16 *v18; // eax
  __int16 v19; // dx
  __int64 v20; // rax
  __int16 v21; // ax

  v11 = 0;
  if ( a5 )
  {
    if ( (byte_90B23 & 2) != 0 || (byte_90B23 & 1) != 0 )
    {
      if ( byte_B772A >= 0 )
      {
        LOBYTE(a2) = dword_AE400;
        a1 = 2049 * *(__int16 *)(dword_AE400 + 8);
        if ( (*(_BYTE *)(dword_AE400 + a1 + 13341) & 3) == 0 )
          byte_12EF70 = 28;
      }
      if ( dword_9AD98 )
        LOBYTE(a1) = sub_3F370();
      HIBYTE(a2) = byte_90B20;
      word_12EFDC = 0;
      word_12EFE2 = 0;
      word_12EFDE = 0;
      word_12EFE4 = 0;
      if ( !byte_90B20 )
      {
        LOBYTE(a1) = 1;
        dword_9AD90 = 0;
        byte_90B20 = 1;
      }
      if ( (byte_90B23 & 2) != 0 )
        sub_3F413(a1);
      else
        sub_3F587(a2, 0, a3, a4);
      if ( word_B7704 >= 0 )
      {
        if ( word_B7704 <= 0 )
        {
          if ( word_B7702 <= 0 )
          {
            if ( word_B7702 < 0 )
              LOWORD(dword_9AD90) = dword_9AD90 - a10;
          }
          else
          {
            LOWORD(dword_9AD90) = a10 + dword_9AD90;
          }
        }
        else
        {
          HIWORD(dword_9AD90) += a11;
        }
      }
      else
      {
        HIWORD(dword_9AD90) -= a11;
      }
      if ( (__int16)dword_9AD90 >= a6 )
      {
        if ( (__int16)dword_9AD90 > a8 )
          LOWORD(dword_9AD90) = a8;
      }
      else
      {
        LOWORD(dword_9AD90) = a6;
      }
      LOBYTE(a1) = BYTE2(dword_9AD90);
      if ( SHIWORD(dword_9AD90) >= a7 )
      {
        if ( SHIWORD(dword_9AD90) > a9 )
          HIWORD(dword_9AD90) = a9;
      }
      else
      {
        HIWORD(dword_9AD90) = a7;
      }
      if ( (byte_B772A & 0x10) == 0 )
      {
        word_12EFE4 = 1;
        word_12EFDE = 1;
      }
      if ( (byte_B772A & 0x20) == 0 )
      {
        word_12EFE2 = 1;
        word_12EFDC = 1;
      }
    }
  }
  else
  {
    LOBYTE(a2) = 0;
    byte_90B20 = 0;
    if ( byte_9AD08 )
    {
      if ( dword_9AD98 )
        sub_3F370();
      sub_5B210();
      v12 = dword_90B14;
      word_90B0C[dword_90B14] = word_12EE9E;
      v13 = (v12 + 1) % 2;
      v14 = word_90B0C;
      dword_90B14 = v13;
      v15 = 2;
      do
      {
        a4 = *v14++;
        v11 += a4;
        --v15;
      }
      while ( v15 );
      if ( (word_12F02E & 1) != 0 )
        v16 = 400 * (v11 / 2) / 12743 + 200;
      else
        v16 = 480 * (v11 / 2) / 12743 + 240;
      HIWORD(dword_9AD90) = v16;
      v17 = dword_90B18 + 1;
      word_90B02[v17] = word_12EEA0;
      v11 = 0;
      v18 = (__int16 *)&unk_90B04;
      dword_90B18 = v17 % 2;
      v19 = 2;
      do
      {
        a3 = *v18++;
        v11 += a3;
        --v19;
      }
      while ( v19 );
      a2 = 12743;
      a1 = 640 * (v11 / 2) / 12743 + 320;
      LOWORD(dword_9AD90) = 640 * (v11 / 2) / 12743 + 320;
    }
    if ( (byte_90B23 & 2) != 0 || (byte_90B23 & 1) != 0 || (byte_90B23 & 0x20) != 0 )
    {
      if ( dword_9AD98 )
        sub_3F370();
      LOBYTE(a1) = byte_B7700;
      if ( byte_B7700 )
      {
        if ( (unsigned __int8)byte_B7700 <= 1u )
        {
          sub_3F587(a2, v11, a3, a4);
          if ( (byte_90B23 & 0x20) != 0 || byte_9AD08 )
          {
            byte_12EF38 = 0;
            byte_12EF40 = 0;
            byte_12EF3B = 0;
            byte_12EF3D = 0;
          }
          if ( byte_B772A >= 0 )
          {
            a1 = 2049 * *(__int16 *)(dword_AE400 + 8);
            if ( (*(_BYTE *)(dword_AE400 + a1 + 13341) & 3) == 0 )
              byte_12EF70 = 28;
          }
          if ( (byte_B772A & 0x40) == 0 || byte_9AD08 )
          {
            if ( ((byte_B772A & 0x40) != 0 || byte_9AD08) && (!byte_9AD08 || (byte_B772A & 0x40) == 0) )
            {
              if ( byte_9AD08 && (byte_B772A & 0x40) == 0 )
                LOBYTE(a1) = sub_5B2B0();
            }
            else
            {
              if ( word_B7704 >= 0 )
              {
                if ( word_B7704 > 0 )
                  byte_12EF40 = 1;
              }
              else
              {
                byte_12EF38 = 1;
              }
              if ( word_B7702 <= 0 )
              {
                if ( word_B7702 < 0 )
                  byte_12EF3B = 1;
              }
              else
              {
                byte_12EF3D = 1;
              }
            }
          }
          else
          {
            word_90B1C = 2 * word_B7702;
            word_90B1E = 2 * word_B7704;
            LOWORD(dword_9AD90) = 2 * word_B7702 + 320;
            if ( (word_12F02E & 1) != 0 )
              LOWORD(a1) = word_90B1E + 200;
            else
              LOWORD(a1) = word_90B1E + 240;
            HIWORD(dword_9AD90) = a1;
          }
          if ( (byte_B772A & 0x10) != 0 || byte_90B21 )
          {
            if ( byte_90B21 && (byte_B772A & 0x10) != 0 )
            {
              byte_90B21 = 0;
              LOBYTE(a1) = 0;
              word_12EFDE = 0;
              word_12EFE4 = 0;
            }
          }
          else
          {
            byte_90B21 = 1;
            word_12EFE4 = 1;
            word_12EFDE = 1;
          }
          if ( (byte_B772A & 0x20) != 0 || byte_90B22 )
          {
            if ( byte_90B22 && (byte_B772A & 0x20) != 0 )
            {
              byte_90B22 = 0;
              word_12EFE2 = 0;
              word_12EFDC = 0;
            }
          }
          else
          {
            byte_90B22 = 1;
            LOBYTE(a1) = 1;
            word_12EFE2 = 1;
            word_12EFDC = 1;
          }
        }
        else if ( byte_B7700 == 2 )
        {
          sub_3F413(2u);
          byte_12EF38 = 0;
          byte_12EF40 = 0;
          byte_12EF3B = 0;
          byte_12EF3D = 0;
          if ( byte_B772A >= 0 )
          {
            a1 = 2049 * *(__int16 *)(dword_AE400 + 8);
            if ( (*(_BYTE *)(dword_AE400 + a1 + 13341) & 3) == 0 )
              byte_12EF70 = 28;
          }
          if ( (byte_B772A & 0x40) == 0 || byte_9AD08 )
          {
            if ( ((byte_B772A & 0x40) != 0 || byte_9AD08) && (!byte_9AD08 || (byte_B772A & 0x40) == 0) )
            {
              if ( byte_9AD08 && (byte_B772A & 0x40) == 0 )
                LOBYTE(a1) = sub_5B2B0();
            }
            else
            {
              if ( word_B7704 >= 0 )
              {
                if ( word_B7704 > 0 )
                  byte_12EF40 = 1;
              }
              else
              {
                byte_12EF38 = 1;
              }
              if ( word_B7702 <= 0 )
              {
                if ( word_B7702 < 0 )
                  byte_12EF3B = 1;
              }
              else
              {
                byte_12EF3D = 1;
              }
            }
          }
          else
          {
            word_90B1C = (28 * (__int16)(32 * word_B7702 + word_90B1C)
                        - (__CFSHL__((28 * (__int16)(32 * word_B7702 + word_90B1C)) >> 31, 5)
                         + 32 * ((28 * (__int16)(32 * word_B7702 + word_90B1C)) >> 31))) >> 5;
            v20 = 31 * (__int16)(16 * word_B7704 + word_90B1E);
            word_90B1E = (int)(v20 - (__CFSHL__(HIDWORD(v20), 5) + 32 * HIDWORD(v20))) >> 5;
            LOWORD(dword_9AD90) = 2 * word_90B1C + 320;
            v21 = 2 * word_90B1E;
            if ( (word_12F02E & 1) != 0 )
              LOWORD(a1) = v21 + 200;
            else
              LOWORD(a1) = v21 + 240;
            HIWORD(dword_9AD90) = a1;
          }
          if ( (byte_B772A & 0x10) != 0 || byte_90B21 )
          {
            if ( byte_90B21 && (byte_B772A & 0x10) != 0 )
            {
              LOBYTE(a1) = 0;
              byte_90B21 = 0;
              word_12EFE4 = 0;
              word_12EFDE = 0;
            }
          }
          else
          {
            LOBYTE(a1) = 1;
            byte_90B21 = 1;
            word_12EFE4 = 1;
            word_12EFDE = 1;
          }
          if ( (byte_B772A & 0x20) != 0 || byte_90B22 )
          {
            if ( byte_90B22 && (byte_B772A & 0x20) != 0 )
            {
              byte_90B22 = 0;
              word_12EFE2 = 0;
              word_12EFDC = 0;
            }
          }
          else
          {
            LOBYTE(a1) = 1;
            byte_90B22 = 1;
            word_12EFE2 = 1;
            word_12EFDC = 1;
          }
        }
      }
    }
  }
  return a1;
}
// 90B02: using guessed type __int16 word_90B02[];
// 90B0C: using guessed type __int16 word_90B0C[4];
// 90B14: using guessed type int dword_90B14;
// 90B18: using guessed type int dword_90B18;
// 90B1C: using guessed type __int16 word_90B1C;
// 90B1E: using guessed type __int16 word_90B1E;
// 90B20: using guessed type char byte_90B20;
// 90B21: using guessed type char byte_90B21;
// 90B22: using guessed type char byte_90B22;
// 90B23: using guessed type char byte_90B23;
// 9AD08: using guessed type char byte_9AD08;
// 9AD90: using guessed type int dword_9AD90;
// 9AD98: using guessed type int dword_9AD98;
// AE400: using guessed type int dword_AE400;
// B7700: using guessed type char byte_B7700;
// B7702: using guessed type __int16 word_B7702;
// B7704: using guessed type __int16 word_B7704;
// B772A: using guessed type char byte_B772A;
// 12EE9E: using guessed type __int16 word_12EE9E;
// 12EEA0: using guessed type __int16 word_12EEA0;
// 12EF38: using guessed type char byte_12EF38;
// 12EF3B: using guessed type char byte_12EF3B;
// 12EF3D: using guessed type char byte_12EF3D;
// 12EF40: using guessed type char byte_12EF40;
// 12EF70: using guessed type char byte_12EF70;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;
// 12EFE2: using guessed type __int16 word_12EFE2;
// 12EFE4: using guessed type __int16 word_12EFE4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00040440) --------------------------------------------------------
__int16 sub_40440(int a1)
{
  int v1; // ebx
  __int16 v2; // si
  int v3; // ecx
  int v4; // ebx
  __int16 v5; // ax
  int v6; // eax
  int v8; // [esp+0h] [ebp-74h] BYREF

  sub_63010();
  v1 = a1;
  v2 = 0;
  if ( *(_DWORD *)(a1 + 28) )
  {
    do
    {
      sub_634A0(v1);
      v3 = *(_DWORD *)(v1 + 72);
      v1 += 44;
    }
    while ( v3 );
  }
  v4 = a1;
  if ( *(_DWORD *)(a1 + 28) )
  {
    while ( 1 )
    {
      v5 = sub_634E0(v4);
      if ( v5 < 0 )
        break;
      if ( !v5 )
      {
        sub_319A0((unsigned __int8 *)dword_AE428);
        printf("ERROR: File %s.\n", v4);
        goto LABEL_8;
      }
LABEL_9:
      v6 = *(_DWORD *)(v4 + 72);
      v4 += 44;
      if ( !v6 )
        return v2;
    }
    sub_319A0((unsigned __int8 *)dword_AE428);
    printf("ERROR: Allocation %s.\n", v4);
LABEL_8:
    printf("Press return to continue\n");
    ++v2;
    gets((uint32)&v8);
    goto LABEL_9;
  }
  return v2;
}
// 5CC03: using guessed type _DWORD printf(const char *, ...);
// 6360F: using guessed type _DWORD gets(_DWORD);
// AE428: using guessed type int dword_AE428;

//----- (000404F0) --------------------------------------------------------
int sub_main(int argc, const char **argv, const char **envp)
{
  int v3; // ecx
  __int16 v4; // si
  __int16 v5; // fps

  //fix
  v3 = 0;
  v4 = 0;
  v5 = 0;
  //fix

  sub_3EC90(0x43u, aCarpetCd, aSave);
  sub_3EC90(0x43u, aCarpetCd, aData);
  sub_3EC90(0x43u, aCarpetCd, aLevels);
  sub_340B0(v3, v4, v5, argc, (int)argv);
  return 0;
}
// 40539: variable 'v3' is possibly undefined
// 40539: variable 'v4' is possibly undefined

//----- (00040550) --------------------------------------------------------
int sub_40550()
{
  int result; // eax

  memset((void*)(dword_AE400 + 12), 0, 20);
  memset((void*)(dword_AE400 + 32), 0, 4);
  memset((void*)(dword_AE400 + 36), 0, 2);
  memset((void*)(dword_AE400 + 38), 0, 2);
  memset((void*)(dword_AE400 + 40), 0, 4);
  memset((void*)(dword_AE400 + 580), 0, 1);
  memset((char *)(&dword_38C9F + dword_AE400), 0, 106);
  memset((void*)(dword_AE400 + 9177), 0, 48);
  memset((void*)(dword_AE400 + 29795), 0, size_t((char *)&loc_2809F + 1));
  memset((void*)(dword_AE408 + 23), 0, 1);
  memset((void*)(dword_AE408 + 93), 0, 16);
  memset((void*)(dword_AE408 + 150), 0, 1);
  memset((void*)(dword_AE408 + 152), 0, 1);
  memset((void*)(dword_AE408 + 184), 0, 14);
  memset((void*)(dword_AE408 + 36378), 0, 4);
  memset((void*)(dword_AE408 + 36382), 0, 80);
  memset((void*)(dword_AE408 + 36462), 0, 4);
  memset((void*)(dword_AE408 + 36466), 0, 4);
  memset((void*)(dword_AE408 + 36470), 0, 4);
  memset((void*)(dword_AE408 + 36474), 0, 4);
  memset((void*)(word_10C1E0), 0, (size_t)((char *)&loc_1FFFE + 2));
  memset(byte_CC1E0, 0, (size_t)sub_10000);
  memset(byte_DC1E0, 0, (size_t)sub_10000);
  memset(byte_EC1E0, 0, (size_t)sub_10000);
  memset(byte_FC1E0, 0, (size_t)sub_10000);
  memset((void*)dword_AE3FC, 0, 64000);
  result = dword_AE408;
  *(_DWORD *)dword_AE408 &= 0xFFFE3FFF;
  return result;
}
// 10000: using guessed type void sub_10000();
// 38C9F: using guessed type int dword_38C9F;
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// AE3FC: using guessed type int dword_AE3FC;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (000407A0) --------------------------------------------------------
int sub_407A0()
{
  char v0; // bl

  v0 = byte_939E5;
  byte_939E5 = 0;
  sub_40550();
  sub_5AD10((int)aLoadLevel);
  sub_3E100(*(_WORD *)(dword_AE408 + 17), (void *)(dword_AE400 + 193795));
  if ( (*(_BYTE *)dword_AE408 & 0x10) == 0 )
    *(_WORD *)(dword_AE400 + 10) = *(_WORD *)&byte_38C95[dword_AE400];
  sub_5AD10((int)aGenerateMap);
  sub_31AA0(dword_AE400 + 193795);
  sub_371C0();
  sub_5AD10((int)aGenerateFeatur);
  sub_36430(dword_AE400 + 193795);
  sub_5AD10((int)aInitialiseMode);
  memset(&word_AE454, 0, 6);
  sub_37220();
  *(_DWORD *)(dword_AE400 + 4593) = -1;
  sub_37440(0, 1);
  byte_939E5 = v0;
  sub_3DD50();
  return sub_48230(dword_AE400 + 29795 + 164
                                       * *(unsigned __int16 *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13333));
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 939E5: using guessed type char byte_939E5;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE454: using guessed type __int16 word_AE454;

//----- (000408D0) --------------------------------------------------------
int sub_408D0()
{
  char v0; // bl
  int v2; // [esp-4h] [ebp-8h]

  v0 = byte_939E5;
  byte_939E5 = 0;
  sub_40550();
  sub_3E100(*(_WORD *)(dword_AE408 + 17), (void *)(dword_AE400 + 193795));
  v2 = dword_AE400 + 193795;
  *(_WORD *)(dword_AE400 + 10) = *(_WORD *)(dword_AE400 + 232597);
  sub_31AA0(v2);
  sub_371C0();
  sub_36430(dword_AE400 + 193795);
  memset(&word_AE454, 0, 6);
  sub_37220();
  *(_DWORD *)(dword_AE400 + 4593) = -1;
  sub_37440(0, 1);
  byte_939E5 = v0;
  sub_3DD50();
  return sub_48230(dword_AE400 + 29795 + 164
                                       * *(unsigned __int16 *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13333));
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 939E5: using guessed type char byte_939E5;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE454: using guessed type __int16 word_AE454;

//----- (000409E0) --------------------------------------------------------
_BOOL1 sub_409E0(unsigned __int16 a1)
{
  char v1; // al

  v1 = byte_FC1E0[a1] & 7;
  return v1 != 5 && v1 != 2 && v1 != 3;
}

//----- (00040A10) --------------------------------------------------------
char sub_40A10(__int16 a1, __int16 a2, __int16 a3, char a4)
{
  __int16 v4; // bx
  char v5; // al
  unsigned __int16 v6; // bx
  char v8; // [esp+0h] [ebp-10h]
  unsigned __int16 v9; // [esp+4h] [ebp-Ch]

  LOBYTE(v9) = a1;
  HIBYTE(v9) = a2;
  v8 = 0;
  v4 = a3 + (unsigned __int8)byte_DC1E0[v9];
  if ( v4 > 200 )
  {
    v4 = 200;
    if ( !a1 && !a2 )
      v8 = 1;
  }
  if ( v4 < 0 )
  {
    v4 = 0;
    if ( !a1 && !a2 )
      v8 = 1;
  }
  if ( a4 && byte_FC1E0[v9] < 0 )
    return 1;
  byte_DC1E0[v9] = v4;
  if ( v4 )
  {
    v5 = byte_FC1E0[v9] & 0xF8 | 1;
  }
  else
  {
    LOBYTE(v6) = a1 - 1;
    HIBYTE(v6) = a2 - 1;
    if ( !sub_409E0(v6) )
      goto LABEL_24;
    LOBYTE(v6) = v6 + 1;
    if ( !sub_409E0(v6) )
      goto LABEL_24;
    LOBYTE(v6) = v6 + 1;
    if ( !sub_409E0(v6) )
      goto LABEL_24;
    HIBYTE(v6) = a2;
    if ( !sub_409E0(v6) )
      goto LABEL_24;
    LOBYTE(v6) = v6 - 2;
    if ( !sub_409E0(v6) )
      goto LABEL_24;
    HIBYTE(v6) = a2 + 1;
    if ( !sub_409E0(v6) )
      goto LABEL_24;
    LOBYTE(v6) = v6 + 1;
    if ( !sub_409E0(v6) )
      goto LABEL_24;
    LOBYTE(v6) = v6 + 1;
    if ( !sub_409E0(v6) )
      goto LABEL_24;
    v5 = byte_FC1E0[v9] & 0xF0;
  }
  byte_FC1E0[v9] = v5;
LABEL_24:
  if ( a4 )
    sub_33B90(v9, v9);
  else
    sub_33E10(v9, v9);
  return v8;
}

//----- (00040D30) --------------------------------------------------------
int sub_40D30(__int16 *a1, __int16 a2, __int16 a3, __int16 a4, char a5)
{
  int v5; // ebx
  int v6; // esi
  int v7; // edi
  int v8; // eax
  int v9; // ebx
  int v10; // eax
  int v12; // [esp+0h] [ebp-14h] BYREF
  int v13[4]; // [esp+4h] [ebp-10h] BYREF

  LOWORD(v5) = a3;
  v6 = (a1[36] + 128) >> 8;
  v7 = (a1[37] + 128) >> 8;
  if ( a3 > (int)(a1[40] - (__CFSHL__((unsigned __int64)a1[40] >> 32, 8) + ((unsigned __int64)a1[40] >> 32 << 8))) >> 8 )
    v5 = (int)(a1[40] - (__CFSHL__((unsigned __int64)a1[40] >> 32, 8) + ((unsigned __int64)a1[40] >> 32 << 8))) >> 8;
  v8 = sub_11410(a2, (__int16)v5);
  v9 = v8;
  if ( v8 )
  {
    while ( sub_114B0(v9, (uint32*)v13, (uint32*)&v12) == 1 )
    {
      if ( sub_40A10(v6 + LOWORD(v13[0]), v7 + v12, a4, a5) )
      {
        v10 = sub_11490(v9);
        LOBYTE(v10) = 1;
        return nullsub_3(v10);
      }
    }
    v8 = sub_11490(v9);
  }
  LOBYTE(v8) = 0;
  return nullsub_3(v8);
}
// 40DF0: using guessed type int nullsub_3(_DWORD);
// 40D30: using guessed type int var_10[4];

//----- (00040E20) --------------------------------------------------------
int sub_40E20(unsigned __int16 a1, unsigned __int16 a2)
{
  int v2; // eax
  int i; // ebx
  char v4; // ah
  int v5; // ebx
  int result; // eax

  v2 = dword_AE400 + 29795;
  for ( i = 164 * word_10C1E0[a1]; ; i = dword_AE400 + 29795 )
  {
    v5 = v2 + i;
    result = dword_AE400 + 29795;
    if ( v5 == dword_AE400 + 29795 )
      break;
    if ( *(__int16 *)(v5 + 24) != a2 )
    {
      switch ( *(_BYTE *)(v5 + 64) )
      {
        case 2:
          sub_41E80(v5);
          break;
        case 5:
          v4 = *(_BYTE *)(v5 + 65);
          if ( v4 != 16 && v4 != 6 && v4 != 8 )
          {
            *(_DWORD *)(v5 + 12) = -1;
            *(_WORD *)(v5 + 38) = a2;
            *(_WORD *)(v5 + 40) = a2;
          }
          break;
        default:
          break;
      }
    }
    v2 = 164 * *(unsigned __int16 *)(v5 + 20);
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (00040EDC) --------------------------------------------------------
char sub_40EDC(_BYTE *a1, _BYTE *a2, char a3, char a4, char a5, __int16 a6, __int16 a7, __int16 a8)
{
  _BYTE *v8; // esi
  char v10; // bl
  char v11; // bh
  char v12; // cl
  _BYTE *v13; // esi
  char v14; // ch
  __int16 v15; // ax
  char result; // al
  _BYTE *v17; // [esp-14h] [ebp-20h]
  char v18; // [esp+7h] [ebp-5h]
  __int16 v19; // [esp+8h] [ebp-4h]
  __int16 v20; // [esp+Ah] [ebp-2h]

  v8 = a1;
  v20 = 256;
  do
  {
    v10 = ((unsigned __int16)(a6 * (char)(a3 - *v8)) >> 8) + *v8;
    v11 = ((unsigned __int16)(a7 * (char)(a4 - v8[1])) >> 8) + v8[1];
    v12 = ((unsigned __int16)(a8 * (char)(a5 - v8[2])) >> 8) + v8[2];
    v17 = v8;
    v13 = a1;
    v19 = 0x7FFF;
    v14 = 0;
    do
    {
      v15 = (char)(v13[2] - v12) * (char)(v13[2] - v12);
      if ( (__int16)(v15 + 2 * (char)(v13[1] - v11) * (char)(v13[1] - v11) + 2 * (char)(*v13 - v10) * (char)(*v13 - v10)) < v19 )
      {
        v18 = v14;
        v19 = v15 + 2 * (char)(v13[1] - v11) * (char)(v13[1] - v11) + 2 * (char)(*v13 - v10) * (char)(*v13 - v10);
      }
      v13 += 3;
      ++v14;
    }
    while ( v14 );
    result = v18;
    *a2++ = v18;
    v8 = v17 + 3;
    --v20;
  }
  while ( v20 );
  return result;
}
// 40F6E: variable 'v18' is possibly undefined

//----- (00040F87) --------------------------------------------------------
__int16 sub_40F87(__int16 a1, __int16 a2)
{
  int v2; // ebx
  int v4; // ebx
  int v5; // eax
  int v6; // ebx

  if ( a1 )
  {
    v2 = a2;
  }
  else
  {
    v2 = a2;
    if ( !a2 )
      return 0;
  }
  if ( a1 < 0 )
  {
    v5 = -a1;
    if ( v2 < 0 )
    {
      v6 = -v2;
      if ( v5 < v6 )
        return 2048 - word_9374C[-256 * a1 / (unsigned int)v6];
      else
        return word_9374C[(v6 << 8) / (unsigned int)v5] + 1536;
    }
    else if ( v5 < v2 )
    {
      return word_9374C[-256 * a1 / (unsigned int)v2] + 1024;
    }
    else
    {
      return 1536 - word_9374C[(v2 << 8) / (unsigned int)v5];
    }
  }
  else if ( v2 < 0 )
  {
    v4 = -v2;
    if ( a1 < v4 )
      return word_9374C[(a1 << 8) / (unsigned int)v4];
    else
      return 512 - word_9374C[(v4 << 8) / (unsigned int)a1];
  }
  else if ( a1 < v2 )
  {
    return 1024 - word_9374C[(a1 << 8) / (unsigned int)v2];
  }
  else
  {
    return word_9374C[(v2 << 8) / (unsigned int)a1] + 512;
  }
}
// 9374C: using guessed type __int16 word_9374C[258];

//----- (000410CE) --------------------------------------------------------
unsigned int sub_410CE(unsigned int a1)
{
  unsigned int v1; // eax
  unsigned int i; // ebx

  if ( !a1 )
    return 0;
  _BitScanReverse((unsigned long*)&v1, a1);
  for ( i = (unsigned __int16)word_41104[v1]; (int)(a1 / i) < (int)i; i = (a1 / i + i) >> 1 )
    ;
  return i;
}
// 41104: using guessed type __int16 word_41104[];

//----- (00041144) --------------------------------------------------------
void sub_41144(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  __outbyte(0x3C8u, a1);
  __outbyte(0x3C9u, a2);
  __outbyte(0x3C9u, a3);
  __outbyte(0x3C9u, a4);
}

//----- (000411D7) --------------------------------------------------------
int sub_411D7(int a1, void *a2, unsigned __int16 a3, char a4)
{
  int v4; // eax
  int v6; // [esp-8h] [ebp-Ch]

  v6 = a1;
  LOBYTE(a1) = a4;
  BYTE1(a1) = a4;
  v4 = a1 << 16;
  LOBYTE(v4) = a4;
  BYTE1(v4) = a4;
  memset32((char*)a2, v4, 80 * a3);
  return v6;
}

//----- (000411FD) --------------------------------------------------------
int sub_411FD(int a1, void *a2, unsigned __int16 a3, char a4)
{
  int v4; // eax
  int v6; // [esp-8h] [ebp-Ch]

  v6 = a1;
  LOBYTE(a1) = a4;
  BYTE1(a1) = a4;
  v4 = a1 << 16;
  LOBYTE(v4) = a4;
  BYTE1(v4) = a4;
  memset32((char*)a2, v4, 160 * a3);
  return v6;
}

//----- (00041230) --------------------------------------------------------
int *sub_41230()
{
  int *result; // eax
  int v1; // eax
  unsigned int v2; // ebx
  int v3; // edx
  int v4; // edx
  int v5; // eax
  unsigned int v6; // ebp
  unsigned __int8 v7; // al
  int v8; // [esp+0h] [ebp-34h]

  result = (int *)dword_AE408;
  if ( !*(_DWORD *)(dword_AE408 + 168) )
  {
    v8 = sub_42540(60000);
    v1 = dword_AE400;
    v2 = dword_1314AC;
    byte_968F0 = 1;
    *(_BYTE *)(dword_AE400 + 8608) = 32;
    if ( v2 <= 0x800000 )
    {
      if ( v2 <= 0x700000 )
      {
        v3 = v2 - 2398576;
        if ( v2 <= 0x600000 )
        {
          if ( v2 <= 0x500000 )
          {
            if ( v2 <= 0x400000 )
            {
              v4 = v2 - 1398576;
              if ( v2 <= 0x300000 )
              {
                if ( v2 <= 0x200000 )
                {
                  if ( v2 <= (unsigned int)&unk_100000 )
                  {
                    printf("ERROR : NOT ENOUGH MEMORY.\n");
                    exit(1);
                  }
                  *(_DWORD *)(dword_AE408 + 172) = v2 - 430000;
                  *(_BYTE *)(v1 + 8608) = 16;
                  *(_BYTE *)(v1 + 8631) = 0;
                  byte_939EC = 3;
                }
                else
                {
                  *(_DWORD *)(dword_AE408 + 172) = v4;
                  byte_939EC = 0;
                  *(_BYTE *)(v1 + 8631) = 0;
                }
              }
              else
              {
                *(_DWORD *)(dword_AE408 + 172) = v4;
                byte_939EC = 0;
                *(_BYTE *)(v1 + 8631) = 0;
              }
            }
            else
            {
              *(_DWORD *)(dword_AE408 + 172) = v3;
              *(_BYTE *)(v1 + 8631) = 0;
              byte_939EC = 1;
            }
          }
          else
          {
            *(_DWORD *)(dword_AE408 + 172) = v3;
            *(_BYTE *)(v1 + 8631) = 0;
            byte_939EC = 1;
          }
        }
        else
        {
          *(_DWORD *)(dword_AE408 + 172) = v3;
          *(_BYTE *)(v1 + 8631) = 0;
          byte_939EC = 1;
        }
      }
      else
      {
        *(_DWORD *)(dword_AE408 + 172) = v2 - 3398576;
        byte_939EC = 1;
      }
    }
    else
    {
      byte_939EC = 1;
      *(_DWORD *)(dword_AE408 + 172) = 0x400000;
    }
    v5 = sub_42540(*(_DWORD *)(dword_AE408 + 172));
    v6 = *(_DWORD *)(dword_AE408 + 172);
    *(_DWORD *)(dword_AE408 + 168) = v5;
    if ( v6 <= (unsigned int)&unk_96000 )
    {
      printf("ERROR : NOT ENOUGH MEMORY.\n");
      exit(1);
    }
    v7 = *(_BYTE *)(dword_AE400 + 8608);
    if ( v7 >= 0x10u )
    {
      if ( v7 <= 0x10u )
      {
        sub_40440((int)aDataBlk00Dat);
      }
      else if ( v7 == 32 )
      {
        sub_40440((int)aDataBlk01Dat);
      }
    }
    sub_44470();
    return sub_426E0(v8);
  }
  return result;
}
// 5CC03: using guessed type _DWORD printf(const char *, ...);
// 939EC: using guessed type char byte_939EC;
// 968F0: using guessed type char byte_968F0;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// 1314AC: using guessed type int dword_1314AC;

//----- (00041490) --------------------------------------------------------
void sub_41490()
{
  void *v0; // eax
  int v1; // ebx
  int i; // esi

  //fix
  v1 = 0;
  //fix

  if ( dword_1314AC <= (unsigned int)&unk_96000 )
  {
    byte_93950 = 0;
    v0 = &unk_96000;
    if ( dword_AE3EC )
    {
        //fix v1 = ios::failure::cause(dword_AE3EC);
      if ( v1 <= (int)&unk_96000 )
      {
        for ( i = 0; i < 10; ++i )
        {
          if ( v1 >= (int)&unk_96000 )
            break;
          v1 += sub_58C30((unsigned int)&unk_96000 - v1 + 1024);
        }
      }
      //fix v0 = (void *)ios::failure::cause(dword_AE3EC);
    }
    sub_42730(*(_DWORD *)(dword_AE408 + 168), *(_DWORD *)(dword_AE408 + 172) - ((_DWORD)v0 + 256));
  }
  else
  {
    byte_93950 = 1;
  }
}
// 369D0: using guessed type _DWORD ios::failure::cause(_DWORD);
// 93950: using guessed type char byte_93950;
// AE3EC: using guessed type int dword_AE3EC;
// AE408: using guessed type int dword_AE408;
// 1314AC: using guessed type int dword_1314AC;

//----- (00041540) --------------------------------------------------------
void sub_41540()
{
  if ( !byte_93950 && !sub_427A0(*(_DWORD *)(dword_AE408 + 168), *(_DWORD *)(dword_AE408 + 172)) )
  {
    sub_44840();
    printf("ERROR : UNABLE TO GROW MEMORY.\n");
    exit(1);
  }
}
// 5CC03: using guessed type _DWORD printf(const char *, ...);
// 93950: using guessed type char byte_93950;
// AE408: using guessed type int dword_AE408;

//----- (000415C0) --------------------------------------------------------
unsigned __int16 sub_415C0()
{
  unsigned __int16 result; // ax
  int v1; // edi
  int i; // esi
  int v3; // ebx
  int v4; // eax
  __int16 v5; // cx

  result = dword_AE408;
  if ( (*(_WORD *)dword_AE408 & 0x110) == 0 )
  {
    v1 = 0;
    for ( i = 0; ; i += 2049 )
    {
      result = *(_WORD *)(dword_AE400 + 10);
      if ( v1 >= result )
        break;
      v3 = dword_AE400 + i;
      if ( *(_BYTE *)(dword_AE400 + i + 13329) )
      {
        v4 = *(_DWORD *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(v3 + 13333) + 160);
        if ( *(_WORD *)(v4 + 50) )
        {
          if ( *(_DWORD *)(dword_AE408 + 188) )
          {
            if ( 100
               * (*(_DWORD *)(v4 + 308) + *(_DWORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(v4 + 50) + 29935))
               / *(_DWORD *)(dword_AE408 + 188) <= *(unsigned __int16 *)&byte_38C93[dword_AE400] )
            {
              *(_WORD *)(v3 + 13323) = 0;
            }
            else
            {
              v5 = *(_WORD *)(v3 + 13323);
              if ( v5 < 16 )
                *(_WORD *)(v3 + 13323) = v5 + 1;
              else
                *(_BYTE *)(v3 + 13325) |= 2u;
            }
          }
        }
      }
      ++v1;
    }
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (000416B0) --------------------------------------------------------
unsigned int sub_416B0()
{
  int v0; // edi
  int v1; // ecx
  int v2; // ebx
  int v3; // edx
  int v4; // esi
  int v5; // eax
  unsigned int result; // eax
  char *v7; // esi

  v0 = dword_AE400;
  v1 = dword_AE400 + 29795;
  v2 = 0;
  v3 = 0;
  while ( v2 < *(unsigned __int16 *)(v0 + 10) )
  {
    v4 = 164 * *(unsigned __int16 *)(v3 + v0 + 13333);
    ++v2;
    v5 = v3 + v0 + 13323 + 1103;
    v3 += 2049;
    *(_DWORD *)(v1 + v4 + 160) = v5;
  }
  result = v0 + 29959;
  v7 = (char *)&unk_99018 - *(_DWORD *)(v1 + 164 * *(unsigned __int16 *)(v0 + 13333) + 156);
  while ( result < v0 + 193795 )
  {
    if ( *(_BYTE *)(result + 64) )
      *(_DWORD *)(result + 156) += (int)v7;
    result += 164;
  }
  dword_AE400 = v0;
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00041780) --------------------------------------------------------
char sub_41780()
{
  int v0; // esi
  int v1; // eax
  unsigned int i; // ebx
  char v3; // dh
  _DWORD *v4; // edi
  int v5; // eax
  int v6; // esi
  _DWORD *v7; // ecx
  _DWORD *v8; // edx
  int *v9; // eax
  char v10; // bl
  int **v11; // ebp
  unsigned __int8 v12; // bl
  int v13; // ebx
  int v14; // eax
  char v15; // ch
  _BYTE *j; // ebx
  char v17; // cl
  int v18; // edx
  int v19; // eax
  int v20; // ecx
  int v21; // edi
  int v22; // eax
  char v24[256]; // [esp+0h] [ebp-168h] BYREF
  int v25[20]; // [esp+100h] [ebp-68h] BYREF
  _DWORD *v26; // [esp+150h] [ebp-18h]
  int v27; // [esp+154h] [ebp-14h]

  v0 = dword_AE400;
  *(_DWORD *)(dword_AE400 + 4) = 9377 * *(_DWORD *)(dword_AE400 + 4) + 9439;
  v1 = dword_AE408;
  if ( (*(_BYTE *)(dword_AE408 + 2) & 1) != 0 )
    goto LABEL_52;
  for ( i = v0 + 29959; i < v0 + 193795; i += 164 )
  {
    v3 = *(_BYTE *)(i + 64);
    dword_AE400 = v0;
    if ( v3 && (*(_BYTE *)(i + 17) & 4) != 0 )
      sub_41E90(v0 - 2813, i);
    v0 = dword_AE400;
  }
  dword_AE400 = v0;
  memset(v25, 0, sizeof(v25));
  v4 = 0;
  memset((void*)(dword_AE408 + 36382), 0, 80);
  v5 = dword_AE408;
  v6 = dword_AE400;
  *(_DWORD *)(dword_AE408 + 36466) = 0;
  v7 = 0;
  *(_DWORD *)(v5 + 36470) = 0;
  v8 = 0;
  *(_DWORD *)(v5 + 36462) = 0;
  v26 = 0;
  *(_DWORD *)(v5 + 36474) = 0;
  v9 = (int *)(v6 + 29959);
  while ( (unsigned int)v9 < v6 + 193795 )
  {
    v10 = *((_BYTE *)v9 + 64);
    if ( !v10 )
      goto LABEL_40;
    switch ( v10 )
    {
      case 3:
        if ( v9[3] >= 0 && (v9[4] & 0x10) == 0 )
        {
          if ( v7 )
            *v7 = (uint32)v9;
          else
            *(_DWORD *)(dword_AE408 + 36462) = (uint32)v9;
          v13 = v6 + 29795;
          v7 = (uint32*)v9;
          goto LABEL_39;
        }
        goto LABEL_40;
      case 5:
        if ( v9[3] >= 0 && *((_BYTE *)v9 + 70) != 120 )
        {
          v11 = (int **)v25[*((char *)v9 + 65)];
          if ( v11 )
            *v11 = v9;
          else
            *(_DWORD *)(dword_AE408 + 4 * *((char *)v9 + 65) + 36382) = (uint32)v9;
          *v9 = v6 + 29795;
          v25[*((char *)v9 + 65)] = (int)v9;
        }
        goto LABEL_40;
      case 9:
        if ( v8 )
          *v8 = (uint32)v9;
        else
          *(_DWORD *)(dword_AE408 + 36474) = (uint32)v9;
        *v9 = v6 + 29795;
        v8 = (uint32*)v9;
        goto LABEL_40;
      case 10:
        v12 = *((_BYTE *)v9 + 65);
        if ( v12 < 0x27u )
          goto LABEL_40;
        if ( v12 <= 0x28u )
        {
          if ( v4 )
            *v4 = (uint32)v9;
          else
            *(_DWORD *)(dword_AE408 + 36466) = (uint32)v9;
          v13 = v6 + 29795;
          v4 = (uint32*)v9;
          goto LABEL_39;
        }
        if ( v12 == 45 )
        {
          if ( v26 )
            *v26 = (uint32)v9;
          else
            *(_DWORD *)(dword_AE408 + 36470) = (uint32)v9;
          v13 = v6 + 29795;
          v26 = (uint32*)v9;
LABEL_39:
          *v9 = v13;
        }
LABEL_40:
        v9 += 41;
        break;
      default:
        goto LABEL_40;
    }
  }
  v14 = dword_AE408;
  v15 = *(_BYTE *)dword_AE408;
  dword_AE400 = v6;
  if ( (v15 & 0x10) == 0 )
    v14 = sub_54F00();
  sub_16540(v14);
  sub_48230(164 * *(unsigned __int16 *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13333) + dword_AE400 + 29795);
  v0 = dword_AE400;
  for ( j = (_BYTE *)(dword_AE400 + 29959); ; j += 164 )
  {
    v1 = v0 + 193795;
    if ( (unsigned int)j >= v0 + 193795 )
      break;
    v17 = j[64];
    dword_AE400 = v0;
    if ( v17 )
    {
      v18 = v17;
      v19 = 18 * v17;
      v20 = (char)j[70];
      v21 = 14 * v20;
      v22 = 14 * v20 + *(int *)((char *)&dword_96902 + v19);
      LOWORD(v21) = (char)j[70];
      v27 = v21;
      if ( *(_WORD *)(v22 + 4) == (_WORD)v21 )
      {
        if ( *(_DWORD *)(v22 + 10) )
        {
          (*(void (**)(_BYTE *))(v22 + 6))(j);
          ++j[63];
        }
      }
      else
      {
        sprintf(v24, "STATE-ID does not match. CLASS %d, MODEL %d, STATE %d", v18, (char)j[65], v20);
        sub_41E80((int)j);
      }
    }
    v0 = dword_AE400;
  }
LABEL_52:
  LOBYTE(v1) = byte_12EF04;
  dword_AE400 = v0;
  if ( byte_12EF04 && byte_12EF16 )
    LOBYTE(v1) = nullsub_3(v1);
  return v1;
}
// 40DF0: using guessed type int nullsub_3(_DWORD);
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 96902: using guessed type int dword_96902;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// 12EF04: using guessed type char byte_12EF04;
// 12EF16: using guessed type char byte_12EF16;
// 41780: using guessed type int var_68[20];
// 41780: using guessed type char var_168[256];

//----- (00041B20) --------------------------------------------------------
char sub_41B20(int a1, int a2)
{
  int v2; // esi

  if ( (*(_BYTE *)(dword_AE408 + 2) & 1) == 0 )
  {
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 586) = *(_WORD *)(a2 + 72);
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 588) = *(_WORD *)(a2 + 74);
    sub_11F50((__int16 *)(a2 + 72));
    *(_WORD *)(14 * (*(unsigned __int16 *)(a1 + 16) - 1) + a1 + 590) = *(_WORD *)(a2 + 76);
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 592) = *(_WORD *)(a2 + 30);
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 598) = *(_WORD *)(a1 + 584);
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 596) = *(_WORD *)(*(_DWORD *)(a2 + 160) + 327);
    v2 = *(_DWORD *)(a2 + 160);
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 594) = *(__int16 *)(v2 + 329) / 2
                                                                     + ((int)(*(__int16 *)(v2 + 22)
                                                                            - (__CFSHL__(
                                                                                 (unsigned __int64)*(__int16 *)(v2 + 22) >> 32,
                                                                                 4)
                                                                             + 16
                                                                             * ((unsigned __int64)*(__int16 *)(v2 + 22) >> 32))) >> 4)
                                                                     * *(unsigned __int8 *)(dword_AE408 + 94)
                                                                     - ((int)(*(__int16 *)(v2 + 22)
                                                                            - (__CFSHL__(
                                                                                 (unsigned __int64)*(__int16 *)(v2 + 22) >> 32,
                                                                                 3)
                                                                             + 8
                                                                             * ((unsigned __int64)*(__int16 *)(v2 + 22) >> 32))) >> 3);
  }
  return 1;
}
// AE408: using guessed type int dword_AE408;

//----- (00041C70) --------------------------------------------------------
int sub_41C70(__int16 a1, int a2, int a3)
{
  int result; // eax

  LOBYTE(a1) = *(_BYTE *)(a2 + 73);
  if ( (_BYTE)a1 == *(_BYTE *)(a3 + 1) && (LOBYTE(a1) = *(_BYTE *)(a2 + 75), (_BYTE)a1 == *(_BYTE *)(a3 + 3)) )
  {
    result = 0;
    *(_DWORD *)(a2 + 72) = *(_DWORD *)a3;
    *(_WORD *)(a2 + 76) = *(_WORD *)(a3 + 4);
  }
  else
  {
    sub_41DD0(a1, a2);
    sub_41CF0(a2, a3);
    return 1;
  }
  return result;
}

//----- (00041CC0) --------------------------------------------------------
int sub_41CC0(__int16 a1, int a2, int a3)
{
  sub_41DD0(a1, a2);
  sub_41CF0(a2, a3);
  return 1;
}

//----- (00041CF0) --------------------------------------------------------
int sub_41CF0(int a1, int a2)
{
  unsigned __int16 v2; // di
  int result; // eax

  if ( (*(_BYTE *)(a1 + 16) & 4) == 0 )
  {
    *(_WORD *)(a1 + 22) = 0;
    v2 = word_10C1E0[256 * *(unsigned __int8 *)(a2 + 3) + *(unsigned __int8 *)(a2 + 1)];
    *(_WORD *)(a1 + 20) = v2;
    if ( v2 )
      *(_WORD *)(dword_AE400 + 164 * v2 + 29817) = (a1 - (dword_AE400 + 29795)) / 164;
    result = (*(unsigned __int8 *)(a2 + 3) << 8) + *(unsigned __int8 *)(a2 + 1);
    word_10C1E0[result] = (a1 - (dword_AE400 + 29795)) / 164;
    *(_DWORD *)(a1 + 72) = *(_DWORD *)a2;
    *(_WORD *)(a1 + 76) = *(_WORD *)(a2 + 4);
    *(_BYTE *)(a1 + 16) |= 4u;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (00041DD0) --------------------------------------------------------
__int16 sub_41DD0fix(__int16 result, int a2)
{
  unsigned __int16 v2; // cx

  if ( (*(_BYTE *)(a2 + 16) & 4) != 0 )
  {
    result = *(_WORD *)(a2 + 20);
    if ( *(_WORD *)(a2 + 22) )
      *(_WORD *)(164 * *(unsigned __int16 *)(a2 + 22) + dword_AE400 + 29815) = result;
    else
      word_10C1E0[256 * *(unsigned __int8 *)(a2 + 75) + *(unsigned __int8 *)(a2 + 73)] = result;
    v2 = *(_WORD *)(a2 + 20);
    if ( v2 )
    {
      result = *(_WORD *)(a2 + 22);
      *(_WORD *)(dword_AE400 + 164 * v2 + 29817) = result;
    }
    *(_BYTE *)(a2 + 16) &= ~4u;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (00041E80) --------------------------------------------------------
int sub_41E80(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 17) |= 4u;
  return result;
}

//----- (00041E90) --------------------------------------------------------
int sub_41E90(__int16 a1, int a2)
{
  int result; // eax
  int v3; // edx

  sub_41DD0(a1, a2);
  result = dword_AE400;
  *(_BYTE *)(a2 + 64) = 0;
  v3 = *(_DWORD *)(result + 40) + 1;
  *(_DWORD *)(result + 40) = v3;
  *(_DWORD *)(result + 4 * v3 + 593) = a2;
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00041EC0) --------------------------------------------------------
_WORD *sub_41EC0(_WORD *a1, unsigned __int16 a2, __int16 a3, __int16 a4)
{
  _WORD *result; // eax
  unsigned __int16 v5; // bx
  int v6; // edx

  result = a1;
  LOBYTE(v5) = a3;
  LOWORD(v6) = a4;
  if ( a4 )
  {
    HIBYTE(v5) = HIBYTE(a3) & 7;
    HIBYTE(a2) &= 7u;
    if ( v5 )
    {
      a1[2] -= (unsigned int)(a4 * dword_90B4C[v5]) >> 16;
      v6 = (a4 * (int)off_9134C[v5]) >> 16;
    }
    *a1 += (unsigned int)((__int16)v6 * dword_90B4C[a2]) >> 16;
    a1[1] -= (unsigned int)((_DWORD)off_9134C[a2] * (__int16)v6) >> 16;
  }
  return result;
}
// 90B4C: using guessed type int dword_90B4C[256];
// 9134C: using guessed type void (*off_9134C[2])();

//----- (00041F50) --------------------------------------------------------
_WORD *sub_41F50(int a1, _WORD *a2)
{
  _WORD *result; // eax
  unsigned __int16 v3; // dx
  unsigned __int8 v4; // cl
  unsigned __int8 v5; // bl
  unsigned __int8 v6; // bl

  result = a2;
  LOBYTE(v3) = *(_BYTE *)(a1 + 1);
  HIBYTE(v3) = *(_BYTE *)(a1 + 3);
  v4 = byte_DC1E0[v3];
  *a2 = v4;
  LOBYTE(v3) = v3 + 1;
  a2[1] = v4;
  *a2 -= (unsigned __int8)byte_DC1E0[v3];
  v5 = byte_DC1E0[v3];
  ++HIBYTE(v3);
  a2[1] += v5;
  *a2 -= (unsigned __int8)byte_DC1E0[v3];
  v6 = byte_DC1E0[v3];
  LOBYTE(v3) = v3 - 1;
  a2[1] -= v6;
  *a2 += (unsigned __int8)byte_DC1E0[v3];
  a2[1] -= (unsigned __int8)byte_DC1E0[v3];
  return result;
}

//----- (00042000) --------------------------------------------------------
int sub_42000(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ecx
  int result; // eax

  v5 = *(__int16 *)(a1 + 4);
  result = 0;
  if ( v5 <= a2 + a4 )
  {
    if ( v5 > a2 + a3 )
    {
      *(_WORD *)(a1 + 4) = v5 + 25 * a5 / 100;
      result = 1;
    }
  }
  else
  {
    result = 1;
    *(_WORD *)(a1 + 4) += a5;
  }
  if ( *(__int16 *)(a1 + 4) < a2 + a3 )
  {
    result = 1;
    *(_WORD *)(a1 + 4) = a3 + a2;
  }
  return result;
}

//----- (00042090) --------------------------------------------------------
int sub_42090(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi
  int v6; // ecx

  v5 = 0;
  if ( (sub_11760(a1) & 1) != 0 && !a2 )
    a3 = -768;
  v6 = *(__int16 *)(a1 + 4);
  if ( v6 <= a2 + a4 )
  {
    if ( v6 > a2 + a3 )
    {
      v5 = 1;
      *(_WORD *)(a1 + 4) = v6 + 25 * a5 / 100;
    }
  }
  else
  {
    v5 = 1;
    *(_WORD *)(a1 + 4) += a5;
  }
  if ( *(__int16 *)(a1 + 4) < a2 + a3 )
  {
    v5 = 1;
    *(_WORD *)(a1 + 4) = a2 + a3;
  }
  if ( *(__int16 *)(a1 + 4) == -768 )
    return -1;
  return v5;
}

//----- (00042150) --------------------------------------------------------
__int16 sub_42150(_WORD *a1, _WORD *a2)
{
  return sub_40F87(*a2 - *a1, a2[1] - a1[1]);
}

//----- (00042180) --------------------------------------------------------
__int16 sub_42180(_WORD *a1, _WORD *a2)
{
  __int16 v3; // [esp-4h] [ebp-8h]

  v3 = -(__int16)sub_423D0(a1, a2);
  return sub_40F87(a1[2] - a2[2], v3);
}

//----- (00042210) --------------------------------------------------------
int sub_42210(__int16 a1, __int16 a2)
{
  __int64 v2; // rax
  int result; // eax

  v2 = (a1 & 0x7FF) - (a2 & 0x7FF);
  result = (HIDWORD(v2) ^ v2) - HIDWORD(v2);
  if ( (unsigned __int16)result > 0x400u )
    return 2048 - result;
  return result;
}

//----- (00042240) --------------------------------------------------------
int sub_42240(int a1, __int16 a2)
{
  int v2; // ecx
  int v3; // ebx

  v2 = a1;
  BYTE1(v2) = BYTE1(a1) & 7;
  v3 = (a2 & 0x7FF) - (unsigned __int16)v2;
  if ( !v3 )
    return v2 ^ (unsigned __int16)v2;
  if ( (int)abs32(v3) > 1024 )
  {
    if ( v3 >= 0 )
      v3 -= 2048;
    else
      v3 += 2048;
  }
  if ( v3 )
    return v3 / (int)abs32(v3);
  else
    return 0;
}

//----- (000422A0) --------------------------------------------------------
int sub_422A0(unsigned __int16 a1, __int16 a2, int a3, unsigned __int16 a4)
{
  int v4; // ebx
  int v5; // esi
  int v6; // eax

  if ( a1 == a2 )
    return 0;
  v4 = sub_42210(a1, a2);
  v5 = sub_42240(a1, a2);
  v6 = v4;
  if ( (__int16)v4 > (int)a4 )
    v6 = a4;
  return v5 * v6;
}

//----- (00042300) --------------------------------------------------------
int sub_42300(_WORD *a1, _WORD *a2)
{
  int v2; // ebx
  __int64 v3; // rax
  int v4; // eax

  v2 = abs16(*a2 - *a1);
  v3 = (__int16)(a2[1] - a1[1]);
  v4 = (HIDWORD(v3) ^ v3) - HIDWORD(v3);
  if ( v2 < v4 )
    return v4;
  return v2;
}

//----- (00042340) --------------------------------------------------------
unsigned int sub_42340(_WORD *a1, _WORD *a2)
{
  int v2; // edx

  v2 = (__int16)(a2[1] - a1[1]);
  return sub_410CE((__int16)(*a2 - *a1) * (__int16)(*a2 - *a1) + v2 * v2 + (__int16)(a2[2] - a1[2])
                                                                         * (__int16)(a2[2] - a1[2]));
}

//----- (00042390) --------------------------------------------------------
int sub_42390(_WORD *a1, _WORD *a2)
{
  int v2; // edx

  v2 = (__int16)(a2[1] - a1[1]);
  return (__int16)(*a2 - *a1) * (__int16)(*a2 - *a1) + v2 * v2 + (__int16)(a2[2] - a1[2]) * (__int16)(a2[2] - a1[2]);
}

//----- (000423D0) --------------------------------------------------------
unsigned int sub_423D0(_WORD *a1, _WORD *a2)
{
  int v2; // edx

  v2 = (__int16)(a2[1] - a1[1]);
  return sub_410CE((__int16)(*a2 - *a1) * (__int16)(*a2 - *a1) + v2 * v2);
}

//----- (00042410) --------------------------------------------------------
int sub_42410(_WORD *a1, _WORD *a2)
{
  int v2; // edx

  v2 = (__int16)(a2[1] - a1[1]);
  return v2 * v2 + (__int16)(*a2 - *a1) * (__int16)(*a2 - *a1);
}

//----- (000424F0) --------------------------------------------------------
int sub_424F0(int a1, unsigned __int8 a2)
{
  *(_BYTE *)(a1 + 70) = a2;
  return a2;
}

//----- (00042510) --------------------------------------------------------
int sub_42510(int a1)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 88) >= *(_BYTE *)(a1 + 89) )
    return 1;
  result = 0;
  ++*(_BYTE *)(a1 + 88);
  return result;
}

//----- (00042530) --------------------------------------------------------
char sub_42530(char a1)
{
  char result; // al

  result = a1;
  byte_93954 = a1;
  return result;
}
// 93954: using guessed type char byte_93954;

//----- (00042540) --------------------------------------------------------
int sub_42540(int a1)
{
  unsigned int v1; // edi
  int result; // eax
  int *v3; // edx
  unsigned int v4; // ebx
  int *i; // esi
  unsigned int v6; // ecx

  v1 = a1 + 3;
  LOWORD(v1) = (a1 + 3) & 0xFFFC;
  sub_63010();
  result = sub_425C0(v1);
  if ( !result )
  {
    v3 = &dword_1302A0;
    v4 = -1;
    for ( i = 0; v3; v3 = (int *)v3[2] )
    {
      v6 = v3[1];
      if ( v1 <= v6 && v4 > v6 && !*((_BYTE *)v3 + 16) )
      {
        v4 = v3[1];
        i = v3;
      }
    }
    if ( i && sub_42650((int)i, v1) )
    {
      sub_63338();
      memset((void*)*i, 0, v1);
      return *i;
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 1302A0: using guessed type int dword_1302A0;

//----- (000425C0) --------------------------------------------------------
int sub_425C0(int a1)
{
  int *v1; // edx
  unsigned int v2; // ebx
  int *v3; // esi
  unsigned int v4; // edi
  unsigned int v5; // ecx

  sub_63010();
  v1 = &dword_1302A0;
  v2 = -1;
  v4 = a1 + 15;
  v3 = 0;
  for ( LOWORD(v4) = (a1 + 15) & 0xFFF0; v1; v1 = (int *)v1[2] )
  {
    v5 = v1[1];
    if ( v4 <= v5 && v2 > v5 && !*((_BYTE *)v1 + 16) && dword_12F6A4[3 * *((unsigned __int8 *)v1 + 17)] )
    {
      v3 = v1;
      v2 = v1[1];
    }
  }
  if ( !v3 || !sub_42650((int)v3, v4) )
    return 0;
  sub_63338();
  memset((void*)*v3, 0, v4);
  return *v3;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 12F6A4: using guessed type int dword_12F6A4[];
// 1302A0: using guessed type int dword_1302A0;

//----- (00042650) --------------------------------------------------------
char sub_42650(int a1, int a2)
{
  char result; // al
  int *i; // edx
  char v4; // al
  int v5; // edi

  if ( a2 == *(_DWORD *)(a1 + 4) )
  {
    *(_BYTE *)(a1 + 16) = byte_93954;
    return 1;
  }
  else
  {
    for ( i = &dword_1302A0; i < &dword_1314A0; i = (int *)((char *)i + 18) )
    {
      if ( !i[1] )
        break;
    }
    if ( i == &dword_1314A0 )
    {
      return 0;
    }
    else
    {
      i[1] = *(_DWORD *)(a1 + 4) - a2;
      *i = a2 + *(_DWORD *)a1;
      v4 = byte_93954;
      *(_DWORD *)(a1 + 4) = a2;
      *(_BYTE *)(a1 + 16) = v4;
      *((_BYTE *)i + 17) = *(_BYTE *)(a1 + 17);
      i[2] = *(_DWORD *)(a1 + 8);
      i[3] = a1;
      v5 = *(_DWORD *)(a1 + 8);
      if ( v5 )
        *(_DWORD *)(v5 + 12) = (uint32)i;
      result = 1;
      *(_DWORD *)(a1 + 8) = (uint32)i;
    }
  }
  return result;
}
// 93954: using guessed type char byte_93954;
// 1302A0: using guessed type int dword_1302A0;
// 1314A0: using guessed type int dword_1314A0;

//----- (000426E0) --------------------------------------------------------
int *sub_426E0(int a1)
{
  int *v1; // ebx
  char v2; // cl
  int *i; // ebx

  v1 = &dword_1302A0;
  v2 = 0;
  if ( &dword_1302A0 )
  {
    while ( a1 != *v1 )
    {
      v1 = (int *)v1[2];
      if ( !v1 )
        goto LABEL_5;
    }
    v2 = 1;
    *((_BYTE *)v1 + 16) = 0;
  }
LABEL_5:
  if ( v2 == 1 )
  {
    for ( i = &dword_1302A0; i; i = (int *)i[2] )
    {
      if ( !*((_BYTE *)i + 16) )
        sub_42860((int)i);
    }
  }
  return sub_63338();
}
// 1302A0: using guessed type int dword_1302A0;

//----- (00042730) --------------------------------------------------------
int sub_42730(int a1, int a2)
{
  int v2; // eax
  int *v3; // ebx
  char v4; // cl
  int *i; // ebx

  v2 = a2 + 3;
  v3 = &dword_1302A0;
  v4 = 0;
  if ( &dword_1302A0 )
  {
    while ( a1 != *v3 )
    {
      v3 = (int *)v3[2];
      if ( !v3 )
        goto LABEL_5;
    }
    *((_BYTE *)v3 + 16) = 0;
    LOBYTE(v2) = (a2 + 3) & 0xFC;
    sub_42650((int)v3, v2);
    v4 = 1;
  }
LABEL_5:
  if ( v4 == 1 )
  {
    for ( i = &dword_1302A0; i; i = (int *)i[2] )
    {
      if ( !*((_BYTE *)i + 16) )
        sub_42860((int)i);
    }
  }
  sub_63338();
  return 1;
}
// 1302A0: using guessed type int dword_1302A0;

//----- (000427A0) --------------------------------------------------------
int sub_427A0(int a1, int a2)
{
  int *v2; // ebx
  unsigned int v3; // ecx
  int v4; // edi
  unsigned int v5; // edx
  int v6; // edx
  char v7; // al
  int *i; // ebx
  char v10; // [esp+0h] [ebp-Ch]

  v2 = &dword_1302A0;
  v3 = a2 + 3;
  LOBYTE(v3) = (a2 + 3) & 0xFC;
  v10 = 0;
  if ( &dword_1302A0 )
  {
    while ( a1 != *v2 )
    {
      v2 = (int *)v2[2];
      if ( !v2 )
        goto LABEL_13;
    }
    v4 = v2[2];
    *((_BYTE *)v2 + 16) = 0;
    if ( !v4 || *(_BYTE *)(v4 + 16) )
      return 0;
    v5 = v2[1] + *(_DWORD *)(v4 + 4);
    if ( v5 <= v3 )
    {
      if ( v5 < v3 )
        return 0;
      sub_42860(v4);
    }
    else
    {
      *(_DWORD *)(v4 + 4) = v5 - v3;
      v6 = v2[2];
      v7 = byte_93954;
      v2[1] = v3;
      *(_BYTE *)(v6 + 16) = v7;
    }
    v10 = 1;
    *((_BYTE *)v2 + 16) = byte_93954;
  }
LABEL_13:
  if ( v10 == 1 )
  {
    for ( i = &dword_1302A0; i; i = (int *)i[2] )
    {
      if ( !*((_BYTE *)i + 16) )
        sub_42860((int)i);
    }
  }
  sub_63338();
  return 1;
}
// 93954: using guessed type char byte_93954;
// 1302A0: using guessed type int dword_1302A0;

//----- (00042860) --------------------------------------------------------
int sub_42860(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // ebx

  result = a1;
  if ( *(_DWORD *)(a1 + 12) )
  {
    *(_BYTE *)(a1 + 16) = 0;
    v2 = *(_DWORD *)(a1 + 12);
    if ( *(_BYTE *)(a1 + 17) == *(_BYTE *)(v2 + 17) && !*(_BYTE *)(v2 + 16) )
    {
      v3 = *(_DWORD *)(a1 + 8);
      if ( v3 )
        *(_DWORD *)(v3 + 12) = v2;
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 8) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) += *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a1 + 4) = 0;
    }
  }
  return result;
}

//----- (000428B0) --------------------------------------------------------
__int16 sub_428B0()
{
  __int16 result; // ax

  if ( byte_12EF70 == 1
    || word_12EFDE && word_9AD8C >= 568 && word_9AD8C <= 606 && word_9AD8E >= 96 && word_9AD8E <= 134 )
  {
    word_93988 = 1;
    byte_12EF70 = 0;
    word_12EFDE = 0;
    return sub_61CC0(0, 0x10u, 0);
  }
  else
  {
    result = 0;
    word_12EFDE = 0;
  }
  return result;
}
// 93988: using guessed type __int16 word_93988;
// 9AD8C: using guessed type __int16 word_9AD8C;
// 9AD8E: using guessed type __int16 word_9AD8E;
// 12EF70: using guessed type char byte_12EF70;
// 12EFDE: using guessed type __int16 word_12EFDE;

//----- (00042930) --------------------------------------------------------
int sub_42930(_BYTE *a1, char *a2, unsigned __int8 a3)
{
  const char *v3; // edx
  char *v5; // edi
  char v6; // al
  char v7; // al
  char *v8; // esi
  char *v9; // edi
  char v10; // al
  char v11; // al
  char v13; // ah

  v3 = (char*)(a1 + 26);
  v5 = (char*)(a1 + 26);
  do
  {
    v6 = *a2;
    *v5 = *a2;
    if ( !v6 )
      break;
    v7 = a2[1];
    a2 += 2;
    v5[1] = v7;
    v5 += 2;
  }
  while ( v7 );
  while ( strlen(v3) < 0xF )
  {
    v8 = asc_A95F4;
    v9 = (char *)&v3[strlen(v3)];
    do
    {
      v10 = *v8;
      *v9 = *v8;
      if ( !v10 )
        break;
      v11 = v8[1];
      v8 += 2;
      v9[1] = v11;
      v9 += 2;
    }
    while ( v11 );
  }
  *a1 = -80;
  if ( sub_431A0((unsigned int)a1) == -1 )
    return -99;
  while ( 1 )
  {
    v13 = a1[49];
    if ( v13 != -1 )
      break;
    sub_428B0();
    sub_4E3D0(a3);
  }
  if ( v13 )
    sub_4E510(a3);
  else
    sub_4E470(a3);
  return -(unsigned __int8)a1[49];
}

//----- (00042A00) --------------------------------------------------------
int sub_42A00(__int16 a1)
{
  char *v1; // esi
  char *v2; // edi
  char v3; // al
  char v4; // al
  char *v5; // esi
  const char *v6; // edi
  char *v7; // edi
  char v8; // al
  char v9; // al
  __int16 v11; // ax
  char *v12; // esi
  char *v13; // edi
  char v14; // al
  char v15; // al
  char v16[32]; // [esp+0h] [ebp-20h] BYREF

  *(_BYTE *)dword_93990[word_9395A] = -112;
  sprintf(v16, "%s%d", aTester, a1);
  v1 = v16;
  v2 = (char *)(dword_93990[word_9395A] + 10);
  do
  {
    v3 = *v1;
    *v2 = *v1;
    if ( !v3 )
      break;
    v4 = v1[1];
    v1 += 2;
    v2[1] = v4;
    v2 += 2;
  }
  while ( v4 );
  while ( strlen((const char *)(dword_93990[word_9395A] + 10)) < 0xF )
  {
    v5 = asc_A95F4;
    v6 = (const char *)(dword_93990[word_9395A] + 10);
    v7 = (char *)&v6[strlen(v6)];
    do
    {
      v8 = *v5;
      *v7 = *v5;
      if ( !v8 )
        break;
      v9 = v5[1];
      v5 += 2;
      v7[1] = v9;
      v7 += 2;
    }
    while ( v9 );
  }
  *(_BYTE *)(dword_93990[word_9395A] + 42) = 0;
  *(_BYTE *)(dword_93990[word_9395A] + 43) = 0;
  if ( sub_431A0(dword_93990[word_9395A]) == -1 )
    return -99;
  while ( *(_BYTE *)(dword_93990[word_9395A] + 49) == 0xFF && *(_BYTE *)(dword_93990[a1] + 49) == 0xFF )
  {
    sub_4E3D0(a1);
    sub_428B0();
    if ( word_93988 == 1 )
    {
      sub_42C70(word_9395A);
      return -1;
    }
  }
  v11 = 0;
  if ( !*(_BYTE *)(dword_93990[a1] + 49) )
  {
    sub_42C70(word_9395A);
    v11 = 1;
  }
  if ( !*(_BYTE *)(dword_93990[word_9395A] + 49) )
  {
    sub_42C70(a1);
    v11 = 1;
  }
  if ( v11 == 1 )
    sub_4E470(a1);
  if ( !*(_BYTE *)(dword_93990[word_9395A] + 49) )
  {
    sub_42C70(a1);
    v12 = (char *)(dword_93990[word_9395A] + 10);
    v13 = (char *)(dword_93990[a1] + 10);
    do
    {
      v14 = *v12;
      *v13 = *v12;
      if ( !v14 )
        break;
      v15 = v12[1];
      v12 += 2;
      v13[1] = v15;
      v13 += 2;
    }
    while ( v15 );
    *(_BYTE *)(dword_93990[a1] + 2) = *(_BYTE *)(dword_93990[word_9395A] + 2);
    *(_BYTE *)(dword_93990[a1] + 49) = *(_BYTE *)(dword_93990[word_9395A] + 49);
  }
  return -*(unsigned __int8 *)(dword_93990[a1] + 49);
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 9395A: using guessed type __int16 word_9395A;
// 93988: using guessed type __int16 word_93988;
// 93990: using guessed type int dword_93990[7];

//----- (00042C70) --------------------------------------------------------
int sub_42C70(__int16 a1)
{
  unsigned int v2; // [esp-4h] [ebp-8h]

  if ( *(_BYTE *)(dword_93990[a1] + 49) == 0xFF )
  {
    *(_BYTE *)dword_9398C = 53;
    v2 = dword_9398C;
    *(_WORD *)(dword_9398C + 6) = (unsigned int)dword_93990[a1] >> 4;
    if ( sub_431A0(v2) == -1 )
      return -99;
    do
    {
      while ( *(_BYTE *)(dword_9398C + 49) == 0xFF )
        ;
    }
    while ( *(_BYTE *)(dword_93990[a1] + 49) == 0xFF );
  }
  return -*(unsigned __int8 *)(dword_9398C + 49);
}
// 9398C: using guessed type int dword_9398C;
// 93990: using guessed type int dword_93990[7];

//----- (00042CF0) --------------------------------------------------------
int sub_42CF0(int a1, __int16 a2)
{
  int result; // eax
  unsigned int v3; // [esp-4h] [ebp-4h]

  if ( !dos_getvect(92) && !a2 )
    return -1;
  v3 = dword_9398C;
  *(_BYTE *)dword_9398C = 127;
  result = sub_431A0(v3);
  if ( result != -1 )
  {
    if ( *(_BYTE *)(dword_9398C + 1) == 3 )
      return 0;
    else
      return -1;
  }
  return result;
}
// 62481: using guessed type _DWORD dos_getvect(_DWORD);
// 9398C: using guessed type int dword_9398C;

//----- (00042D40) --------------------------------------------------------
int sub_42D40(_BYTE *a1, char *a2)
{
  const char *v2; // edx
  char *v4; // edi
  char v5; // al
  char v6; // al
  char *v7; // esi
  char *v8; // edi
  char v9; // al
  char v10; // al

  v2 = (char*)(a1 + 26);
  v4 = (char*)(a1 + 26);
  do
  {
    v5 = *a2;
    *v4 = *a2;
    if ( !v5 )
      break;
    v6 = a2[1];
    a2 += 2;
    v4[1] = v6;
    v4 += 2;
  }
  while ( v6 );
  while ( strlen(v2) < 0xF )
  {
    v7 = asc_A95F4;
    v8 = (char *)&v2[strlen(v2)];
    do
    {
      v9 = *v7;
      *v8 = *v7;
      if ( !v9 )
        break;
      v10 = v7[1];
      v7 += 2;
      v8[1] = v10;
      v8 += 2;
    }
    while ( v10 );
  }
  *a1 = -79;
  if ( sub_431A0((unsigned int)a1) == -1 )
    return -99;
  while ( a1[49] == 0xFF )
    ;
  return -(unsigned __int8)a1[49];
}

//----- (00042DE0) --------------------------------------------------------
int sub_42DE0(_BYTE *a1)
{
  int v2; // eax

  *a1 = -110;
  if ( sub_431A0((unsigned int)a1) == -1 )
    return -99;
  while ( a1[49] == 0xFF )
    ;
  v2 = (unsigned __int8)a1[49];
  a1[2] = 0;
  return -v2;
}

//----- (00042E10) --------------------------------------------------------
int sub_42E10(__int16 a1)
{
  char *v1; // esi
  char *v2; // edi
  char v3; // al
  char v4; // al
  char *v5; // esi
  const char *v6; // edi
  char *v7; // edi
  char v8; // al
  char v9; // al
  char v12[32]; // [esp+0h] [ebp-20h] BYREF

  if ( *(_BYTE *)(dword_93990[a1] + 49) == 0xFF )
    return -*(unsigned __int8 *)(dword_93990[a1] + 49);
  sprintf(v12, "%s%d", aTester, a1);
  *(_BYTE *)dword_93990[a1] = -111;
  v1 = v12;
  v2 = (char *)(dword_93990[a1] + 10);
  do
  {
    v3 = *v1;
    *v2 = *v1;
    if ( !v3 )
      break;
    v4 = v1[1];
    v1 += 2;
    v2[1] = v4;
    v2 += 2;
  }
  while ( v4 );
  while ( strlen((const char *)(dword_93990[a1] + 10)) < 0xF )
  {
    v5 = asc_A95F4;
    v6 = (const char *)(dword_93990[a1] + 10);
    v7 = (char *)&v6[strlen(v6)];
    do
    {
      v8 = *v5;
      *v7 = *v5;
      if ( !v8 )
        break;
      v9 = v5[1];
      v5 += 2;
      v7[1] = v9;
      v7 += 2;
    }
    while ( v9 );
  }
  *(_BYTE *)(dword_93990[a1] + 42) = 0;
  *(_BYTE *)(dword_93990[a1] + 43) = 0;
  if ( sub_431A0(dword_93990[a1]) != -1 )
  {
    *(_WORD *)(dword_93990[a1] + 4) = 0;
    return -*(unsigned __int8 *)(dword_93990[a1] + 49);
  }
  return -99;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 93990: using guessed type int dword_93990[7];

//----- (00042F30) --------------------------------------------------------
int sub_42F30(unsigned int a1, void *a2)
{
  unsigned int v2; // eax
  char v4; // ah

  *(_BYTE *)a1 = -107;
  v2 = dword_93964;
  *(_WORD *)(a1 + 8) = 2048;
  *(_WORD *)(a1 + 6) = v2 >> 4;
  if ( sub_431A0(a1) == -1 )
    return -99;
  do
    v4 = *(_BYTE *)(a1 + 49);
  while ( v4 == -1 );
  if ( v4 )
    return -*(unsigned __int8 *)(a1 + 49);
  qmemcpy(a2, (const void *)dword_93964, *(unsigned __int16 *)(a1 + 8));
  return *(unsigned __int16 *)(a1 + 8);
}
// 93964: using guessed type int dword_93964;

//----- (00042FB0) --------------------------------------------------------
int sub_42FB0(unsigned int a1, char *a2, unsigned int a3)
{
  unsigned int v4; // esi
  int result; // eax

  v4 = 0;
  if ( a3 >> 11 )
  {
    while ( 1 )
    {
      result = sub_42F30(a1, a2);
      if ( result != 2048 )
        break;
      ++v4;
      a2 += 2048;
      if ( v4 >= a3 >> 11 )
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    result = sub_42F30(a1, a2);
    if ( result == (a3 & 0x7FF) )
      return a3;
  }
  return result;
}

//----- (00043010) --------------------------------------------------------
int sub_43010(unsigned int a1, int a2, unsigned __int16 a3)
{
  unsigned int v3; // edx

  *(_BYTE *)a1 = -107;
  v3 = (unsigned int)dword_93968[a3] >> 4;
  *(_WORD *)(a1 + 8) = 2048;
  *(_WORD *)(a1 + 6) = v3;
  if ( sub_431A0(a1) == -1 )
    return -99;
  else
    return 1;
}
// 93968: using guessed type int dword_93968[8];

//----- (00043080) --------------------------------------------------------
int sub_43080(unsigned int a1, const void *a2, unsigned int a3)
{
  unsigned int v3; // eax

  qmemcpy((void *)dword_93960, a2, a3);
  *(_BYTE *)a1 = -108;
  v3 = dword_93960;
  *(_WORD *)(a1 + 8) = a3;
  *(_WORD *)(a1 + 6) = v3 >> 4;
  if ( sub_431A0(a1) == -1 )
    return -99;
  while ( *(_BYTE *)(a1 + 49) == 0xFF )
    ;
  return -*(unsigned __int8 *)(a1 + 49);
}
// 93960: using guessed type int dword_93960;

//----- (000430F0) --------------------------------------------------------
int sub_430F0(unsigned int a1, char *a2, unsigned int a3)
{
  unsigned int v4; // esi
  int result; // eax

  v4 = 0;
  if ( !(a3 >> 11) )
    return sub_43080(a1, a2, a3 & 0x7FF);
  while ( 1 )
  {
    LOWORD(result) = sub_43080(a1, a2, 0x800u);
    if ( (_WORD)result )
      break;
    ++v4;
    a2 += 2048;
    if ( v4 >= a3 >> 11 )
      return sub_43080(a1, a2, a3 & 0x7FF);
  }
  return (__int16)result;
}

//----- (00043150) --------------------------------------------------------
int sub_43150()
{
  __int16 i; // bx
  int v1; // esi
  int result; // eax

  for ( i = 0; i < 8; ++i )
  {
    v1 = i;
    result = sub_43170(i);
    byte_939B0[v1] = result;
  }
  return result;
}

//----- (00043170) --------------------------------------------------------
int sub_43170(__int16 a1)
{
  int v2; // eax

  if ( a1 == word_9395A )
    return 2;
  v2 = dword_93990[a1];
  return *(_BYTE *)(v2 + 2) && !*(_BYTE *)(v2 + 49);
}
// 9395A: using guessed type __int16 word_9395A;
// 93990: using guessed type int dword_93990[7];

//----- (000431A0) --------------------------------------------------------
int sub_431A0(unsigned int a1)
{
  int v2[13]; // [esp+0h] [ebp-80h] BYREF
  int v3[7]; // [esp+34h] [ebp-4Ch] BYREF
  int v4[7]; // [esp+50h] [ebp-30h] BYREF
  char v5[20]; // [esp+6Ch] [ebp-14h] BYREF

  *(_BYTE *)(a1 + 49) = 0;
  memset(v2, 0, 50);
  LOWORD(v2[9]) = a1 >> 4;
  HIWORD(v2[8]) = v2[9];
  v2[4] = 0;
  v2[7] = 256;
  memset(v4, 0, sizeof(v4));
  memset(v3, 0, sizeof(v3));
  memset(v5, 0, 12);
  segread((uint32)v5);
  v4[5] = (int)v2;
  v4[0] = 768;
  v4[1] = 92;
  int386x(49, (uint32)v4, (uint32)v3, (uint32)v5);
  return (v3[6] == 0) - 1;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 636BC: using guessed type _DWORD segread(_DWORD);
// 636E6: using guessed type _DWORD int386x(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00043270) --------------------------------------------------------
int sub_43270(int a1, __int16 a2)
{
  int v2; // esi
  int v3; // eax
  int result; // eax
  int i; // ebx
  int v6; // eax
  int v7; // eax
  int j; // ebx

  v2 = 1;
  if ( !byte_93958 && !dword_9398C )
  {
    system(aNetbios);
    v3 = sub_425C0(66);
    dword_9398C = v3;
    if ( !v3 )
      goto LABEL_14;
    result = sub_42CF0(v3, a2);
    if ( result == -1 )
      return result;
    dword_93960 = sub_425C0(2048);
    if ( dword_93960 && (dword_93964 = sub_425C0(2048)) != 0 )
    {
      for ( i = 0; i != 8; ++i )
      {
        v6 = sub_425C0(2048);
        dword_93968[i] = v6;
        if ( !v6 )
          v2 = -1;
        v7 = sub_425C0(66);
        dword_93990[i] = v7;
        if ( !v7 )
          v2 = -1;
      }
      byte_93958 = 1;
    }
    else
    {
LABEL_14:
      v2 = -1;
    }
  }
  if ( v2 == -1 )
  {
    if ( dword_9398C )
      sub_426E0(dword_9398C);
    if ( dword_93960 )
      sub_426E0(dword_93960);
    if ( dword_93964 )
      sub_426E0(dword_93964);
    for ( j = 0; j != 8; ++j )
    {
      if ( dword_93990[j] )
        sub_426E0(dword_93990[j]);
      if ( dword_93968[j] )
        sub_426E0(dword_93968[j]);
    }
  }
  return v2;
}
// 63709: using guessed type _DWORD system(_DWORD);
// 93958: using guessed type char byte_93958;
// 93960: using guessed type int dword_93960;
// 93964: using guessed type int dword_93964;
// 93968: using guessed type int dword_93968[];
// 9398C: using guessed type int dword_9398C;
// 93990: using guessed type int dword_93990[7];

//----- (000433C0) --------------------------------------------------------
int *sub_433C0()
{
  int v0; // ebx
  int *result; // eax
  int v2; // [esp-4h] [ebp-14h]

  //fix
  result = 0;
  //fix

  if ( byte_93958 )
  {
    v0 = 0;
    sub_426E0(dword_9398C);
    do
    {
      sub_426E0(dword_93990[v0]);
      v2 = dword_93968[v0++];
      sub_426E0(v2);
    }
    while ( v0 != 8 );
    sub_426E0(dword_93960);
    result = sub_426E0(dword_93964);
    byte_93958 = 0;
  }
  return result;
}
// 93958: using guessed type char byte_93958;
// 93960: using guessed type int dword_93960;
// 93964: using guessed type int dword_93964;
// 93968: using guessed type int dword_93968[];
// 9398C: using guessed type int dword_9398C;
// 93990: using guessed type int dword_93990[7];

//----- (00043430) --------------------------------------------------------
int sub_43430(char *a1, __int16 a2)
{
  char *v3; // edi
  int v4; // ebx
  char v5; // al
  char v6; // al
  unsigned int v7; // eax
  int v8; // ebx
  int v10; // ebx
  int v11; // edx
  char *v12; // esi
  char *v13; // edi
  char v14; // al
  char v15; // al
  int i; // ebx
  int v17; // ebx
  int j; // esi
  int v19; // ebx
  int v20; // edi
  int v21; // esi
  __int16 v22; // bx
  _BYTE *v23; // [esp-8h] [ebp-2Ch]
  char v24[36]; // [esp+0h] [ebp-24h] BYREF

  if ( byte_93958 )
  {
    if ( byte_93959 )
      return word_9395A;
    v3 = aTester;
    v4 = 0;
    word_93988 = (unsigned __int8)byte_93959;
    word_9395C = a2;
    do
    {
      v5 = *a1;
      *v3 = *a1;
      if ( !v5 )
        break;
      v6 = a1[1];
      a1 += 2;
      v3[1] = v6;
      v3 += 2;
    }
    while ( v6 );
    do
      byte_939AF[++v4] = 0;
    while ( v4 < 8 );
    v8 = 0;
    word_9395A = -1;
    do
    {
      if ( word_9395A != -1 || word_93988 )
        break;
      sprintf(v24, "%s%d", aTester, v8);
      v7 = sub_42930((_BYTE *)dword_93990[v8], v24, v8);
      if ( v7 < 0xFFFE7961 )
      {
        if ( !v7 )
          word_9395A = v8;
      }
      else if ( v7 > 0xFFFE7961 && v7 == -13 )
      {
        v23 = (_BYTE *)dword_93990[v8--];
        sub_42D40(v23, v24);
      }
      ++v8;
    }
    while ( v8 < 8 );
    if ( word_9395A == -1 )
      return -1;
    if ( word_93988 )
    {
      sprintf(v24, "%s%d", aTester, word_9395A);
      sub_42D40((_BYTE *)dword_93990[v8], v24);
      return -1;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      if ( v10 != word_9395A )
      {
        v12 = (char *)(dword_93990[word_9395A] + 26);
        v13 = (char *)(dword_93990[v11] + 26);
        do
        {
          v14 = *v12;
          *v13 = *v12;
          if ( !v14 )
            break;
          v15 = v12[1];
          v12 += 2;
          v13[1] = v15;
          v13 += 2;
        }
        while ( v15 );
        *(_BYTE *)(dword_93990[v11] + 3) = *(_BYTE *)(dword_93990[word_9395A] + 3);
      }
      ++v10;
      ++v11;
    }
    while ( v10 < 8 );
    for ( i = 0; i < word_9395C; ++i )
    {
      if ( i != word_9395A )
        sub_42E10(i);
    }
    v17 = 0;
    for ( j = 0; v17 < word_9395C; ++j )
    {
      if ( v17 != word_9395A && *(_BYTE *)(dword_93990[j] + 49) == 0xFF )
      {
        sub_42A00(v17);
        if ( word_93988 )
          break;
      }
      ++v17;
    }
    do
    {
      sub_428B0();
      v19 = 0;
      v20 = 0;
      v21 = 0;
      while ( v19 < word_9395C )
      {
        if ( v19 != word_9395A && *(_BYTE *)(dword_93990[v21] + 49) )
        {
          if ( word_93988 )
            sub_42C70(v19);
        }
        else
        {
          sub_4E470(v19);
          if ( word_93988 )
          {
            if ( v19 == word_9395A )
            {
              sprintf(v24, "%s%d", aTester, word_9395A);
              sub_42D40((_BYTE *)dword_93990[v21], v24);
            }
            else
            {
              sub_42DE0((_BYTE *)dword_93990[v21]);
            }
          }
          ++v20;
        }
        ++v21;
        ++v19;
      }
    }
    while ( v20 != word_9395C && !word_93988 );
    v22 = word_93988;
    if ( !word_93988 )
    {
      sub_43150();
      word_9398A = v22;
      byte_93959 = 1;
      return word_9395A;
    }
  }
  return -1;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 93958: using guessed type char byte_93958;
// 93959: using guessed type char byte_93959;
// 9395A: using guessed type __int16 word_9395A;
// 9395C: using guessed type __int16 word_9395C;
// 93988: using guessed type __int16 word_93988;
// 9398A: using guessed type __int16 word_9398A;
// 93990: using guessed type int dword_93990[7];

//----- (00043760) --------------------------------------------------------
int sub_43760(__int16 a1)
{
  __int16 i; // bx
  int result; // eax
  __int16 v3; // bx
  char v4[32]; // [esp+0h] [ebp-20h] BYREF

  if ( byte_93958 && byte_93959 )
  {
    if ( a1 == word_9395A )
    {
      for ( i = 0; i < word_9395C; ++i )
      {
        if ( i != word_9395A )
        {
          sub_42C70(i);
          sub_42DE0((_BYTE *)dword_93990[i]);
        }
      }
      sprintf(v4, "%s%d", aTester, word_9395A);
      sub_42D40((_BYTE *)dword_93990[a1], v4);
      byte_93959 = 0;
    }
    else
    {
      sub_42C70(a1);
      sub_42DE0((_BYTE *)dword_93990[a1]);
    }
    result = sub_43150();
    v3 = 0;
    if ( word_9395C > 0 )
    {
      while ( !byte_939B0[v3] )
      {
        if ( ++v3 >= word_9395C )
          return result;
      }
      word_9398A = v3;
    }
  }
  return result;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 93958: using guessed type char byte_93958;
// 93959: using guessed type char byte_93959;
// 9395A: using guessed type __int16 word_9395A;
// 9395C: using guessed type __int16 word_9395C;
// 9398A: using guessed type __int16 word_9398A;
// 93990: using guessed type int dword_93990[7];

//----- (00043870) --------------------------------------------------------
void sub_43870(unsigned __int16 a1, char *a2, unsigned int a3)
{
  if ( byte_93958 && byte_939B0[a1] == 1 )
  {
    sub_430F0(dword_93990[a1], a2, a3);
    if ( *(_BYTE *)(dword_93990[a1] + 49) )
      sub_42E10(a1);
  }
}
// 93958: using guessed type char byte_93958;
// 93990: using guessed type int dword_93990[7];

//----- (000438D0) --------------------------------------------------------
void sub_438D0(unsigned __int16 a1, char *a2, unsigned int a3)
{
  if ( byte_93958 && byte_939B0[a1] == 1 )
  {
    sub_42FB0(dword_93990[a1], a2, a3);
    if ( *(_BYTE *)(dword_93990[a1] + 49) )
      sub_42E10(a1);
  }
}
// 93958: using guessed type char byte_93958;
// 93990: using guessed type int dword_93990[7];

//----- (00043930) --------------------------------------------------------
void sub_43930(char *a1, unsigned int a2)
{
  signed __int16 i; // bx
  signed __int16 j; // bx

  if ( byte_93958 )
  {
    if ( word_9395A == (unsigned __int16)word_9398A )
    {
      for ( i = 0; i < word_9395C; ++i )
      {
        if ( i != word_9395A )
          sub_438D0(i, &a1[a2 * i], a2);
      }
      for ( j = 0; j < word_9395C; ++j )
      {
        if ( j != word_9395A )
          sub_43870(j, a1, a2 * word_9395C);
      }
    }
    else
    {
      sub_43870(word_9398A, &a1[a2 * word_9395A], a2);
      sub_438D0(word_9398A, a1, word_9395C * a2);
    }
  }
}
// 93958: using guessed type char byte_93958;
// 9395A: using guessed type __int16 word_9395A;
// 9395C: using guessed type __int16 word_9395C;
// 9398A: using guessed type __int16 word_9398A;

//----- (00043B20) --------------------------------------------------------
char sub_43B20fix(int a1, unsigned int a2)
{
  int v2; // eax
  char *v3; // eax
  int v4; // eax
  char *v5; // eax
  unsigned __int16 v6; // dx
  int v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax

  //fix
  v2 = 0;
  //fix

  byte_9EBDD = 0;
  byte_9EBE7 = 0;
  byte_9EBE8 = 0;
  byte_9EBE9 = 0;
  byte_9EBEA = 0;
  byte_9EBEB = 0;
  byte_9EBEC = 0;
  byte_9EC0D = 0;
  byte_9EC17 = 0;
  byte_9EC18 = 0;
  byte_9EC19 = 0;
  byte_9EC1A = 0;
  byte_9EC1B = 0;
  byte_9EC1C = 0;
  byte_9EBED = 0;
  byte_9EBF7 = 0;
  byte_9EBF8 = 0;
  byte_9EBF9 = 0;
  byte_9EBFA = 0;
  byte_9EBFB = 0;
  byte_9EBFC = 0;
  sub_5D883(a1, 0xFF00u, 0);
  byte_939D4 = 1;
  //fix sub_60199((int)&unk_A9608, __DS__);
  word_CBF48 = 0;
  dword_CBF6C = dword_CBF70;
  dword_CBF44 = 0;
  //fix
  /*v2 = sub_6035F(
         a2,
         (unsigned int)&dword_CBF6C,
         (unsigned __int16)__DS__,
         (int)&unk_CBF40,
         (unsigned __int16)__DS__,
         (unsigned int)&dword_CBFDC);*/
  if ( v2 )
  {
    v3 = sub_6378C(v2);
    printf("\nError : %s\n", v3);
    sub_60335();
    LOBYTE(v4) = sub_5D948();
    byte_939CC = 0;
    byte_939CD = 0;
  }
  else
  {
    LOBYTE(v4) = a2 - 1;
    switch ( a2 )
    {
      case 0xA001u:
        byte_CBFEF = 0;
        byte_CBFEE = 2;
        break;
      case 0xA002u:
        v5 = sub_43E50(aDataInstBnk);
        word_CBFEC = 0;
        dword_CBFE8 = (int)v5;
        if ( v5 )
        {
          v6 = 0;
          v7 = sub_637D1(dword_CBFDC, (int)v5, 0, 1);
          if ( v7 )
          {
            v8 = sub_6378C(v7);
            printf("\nError : %s\n", v8);
            sub_6080C(dword_CBFDC, 1);
            sub_60335();
            sub_5D948();
            HIBYTE(v6) = 0;
            byte_939CC = 0;
            byte_939CD = 0;
          }
          v9 = sub_43E50(aDataDrumBnk);
          word_CBFE6 = v6;
          dword_CBFE2 = (int)v9;
          if ( v9 )
          {
            v4 = sub_637D1(dword_CBFDC, (int)v9, v6, 1);
            if ( v4 )
            {
              v10 = sub_6378C(v4);
              printf("\nError : %s\n", v10);
              sub_6080C(dword_CBFDC, 1);
              sub_60335();
              LOBYTE(v4) = sub_5D948();
              byte_939CC = 0;
              byte_939CD = 0;
            }
            if ( byte_939CC )
            {
              byte_CBFEF = 1;
              byte_CBFEE = 0;
            }
          }
          else
          {
            LOBYTE(v4) = printf("\nError : Unable to load drum.bnk.\n");
            byte_939CC = 0;
            byte_939CD = 0;
          }
        }
        else
        {
          LOBYTE(v4) = printf("\nError : Unable to load inst.bnk.\n");
          byte_939CC = 0;
          byte_939CD = 0;
        }
        break;
      case 0xA004u:
        byte_CBFEF = 0;
        byte_CBFEE = 1;
        break;
      case 0xA008u:
        LOBYTE(v4) = 2;
        byte_CBFEF = 0;
        byte_CBFEE = 2;
        break;
      default:
        break;
    }
    if ( byte_939CC )
    {
      v4 = sub_5CEF0(0);
      if ( v4 )
      {
        printf("\nError opening music files\n");
        sub_6080C(dword_CBFDC, 1);
        sub_60335();
        LOBYTE(v4) = sub_5D948();
        byte_939CC = 0;
        byte_939CD = 0;
      }
    }
  }
  return v4;
}
// 43D1D: conditional instruction was optimized away because dx.2==0
// 5CC03: using guessed type _DWORD printf(const char *, ...);
// 939CC: using guessed type char byte_939CC;
// 939CD: using guessed type char byte_939CD;
// 939D4: using guessed type char byte_939D4;
// 9EBDD: using guessed type char byte_9EBDD;
// 9EBE7: using guessed type char byte_9EBE7;
// 9EBE8: using guessed type char byte_9EBE8;
// 9EBE9: using guessed type char byte_9EBE9;
// 9EBEA: using guessed type char byte_9EBEA;
// 9EBEB: using guessed type char byte_9EBEB;
// 9EBEC: using guessed type char byte_9EBEC;
// 9EBED: using guessed type char byte_9EBED;
// 9EBF7: using guessed type char byte_9EBF7;
// 9EBF8: using guessed type char byte_9EBF8;
// 9EBF9: using guessed type char byte_9EBF9;
// 9EBFA: using guessed type char byte_9EBFA;
// 9EBFB: using guessed type char byte_9EBFB;
// 9EBFC: using guessed type char byte_9EBFC;
// 9EC0D: using guessed type char byte_9EC0D;
// 9EC17: using guessed type char byte_9EC17;
// 9EC18: using guessed type char byte_9EC18;
// 9EC19: using guessed type char byte_9EC19;
// 9EC1A: using guessed type char byte_9EC1A;
// 9EC1B: using guessed type char byte_9EC1B;
// 9EC1C: using guessed type char byte_9EC1C;
// CBF44: using guessed type int dword_CBF44;
// CBF48: using guessed type __int16 word_CBF48;
// CBF6C: using guessed type int dword_CBF6C;
// CBF70: using guessed type int dword_CBF70;
// CBFDC: using guessed type int dword_CBFDC;
// CBFE2: using guessed type int dword_CBFE2;
// CBFE6: using guessed type __int16 word_CBFE6;
// CBFE8: using guessed type int dword_CBFE8;
// CBFEC: using guessed type __int16 word_CBFEC;
// CBFEE: using guessed type char byte_CBFEE;
// CBFEF: using guessed type char byte_CBFEF;

//----- (00043E50) --------------------------------------------------------
char *sub_43E50(const char *a1)
{
  char *v1; // esi
  int v2; // ebp
  int v3; // eax
  int v4; // edi
  char *v5; // eax
  int v6; // ebx

  v1 = 0;
  v2 = 0;
  v3 = sub_63910((int)a1);
  v4 = v3;
  if ( v3 > 0 )
  {
    v5 = (char *)sub_42540(v3);
    v6 = (int)v5;
    v1 = v5;
    if ( v5 )
    {
      if ( sub_3EEA0(a1, v5) != v4 )
      {
        sub_426E0(v6);
        v1 = (char *)(v6 ^ (unsigned int)v1);
      }
    }
  }
  if ( v1 )
    return v1;
  return (char *)v2;
}

//----- (00043EC0) --------------------------------------------------------
int sub_43EC0(
        __int16 a1,
        int a2,
        int a3,
        unsigned __int16 a4,
        unsigned __int16 a5)
{
  unsigned __int16 v5; // ax
  char *v6; // eax
  unsigned __int16 v7; // ax
  char *v8; // eax
  int result; // eax
  unsigned __int16 v10; // ax
  char *v11; // eax
  char *v12; // eax
  _BYTE v13[16]; // [esp+0h] [ebp-10h] BYREF

  //fix
  v5 = 0;
  v10 = 0;
  //fix

  if ( !stricmp(&unk_CC158, aSblast_0) )
  {
    a5 = -8192;
    a2 = 60;
    a4 = 22050;
    word_CC1C4 = 60;
  }
  else if ( !strcmp(&unk_CC158, aSbpro_0) )
  {
    a5 = -8191;
    a3 = 120;
    a4 = 22050;
    word_CC1C4 = 120;
  }
  else if ( !strcmp(&unk_CC158, aSb16) )
  {
    a5 = -8169;
    a4 = -21436;
    a1 = 240;
    BYTE1(a3) = 1;
    word_CC1C4 = 240;
    byte_939ED = 1;
  }
  else if ( !strcmp(&unk_CC158, aAdlibg_0) )
  {
    a5 = -8183;
    a4 = 22050;
    word_CC1C4 = 60;
  }
  else if ( !strcmp(&unk_CC158, aMicrosoft8) )
  {
    a5 = -8181;
    a2 = 60;
    a4 = 22050;
    word_CC1C4 = 60;
  }
  else if ( !strcmp(&unk_CC158, aMicrosoft16) )
  {
    a3 = 1;
    a5 = -8179;
    word_CC1C4 = 240;
    a4 = -21436;
    byte_939ED = 1;
  }
  else if ( !strcmp(&unk_CC158, aPas8) )
  {
    a5 = -8189;
    a1 = 60;
    a4 = 22050;
    word_CC1C4 = 60;
  }
  else if ( !strcmp(&unk_CC158, aPas16) )
  {
    a5 = -8188;
    a4 = -21436;
    HIBYTE(a1) = 1;
    word_CC1C4 = 240;
    byte_939ED = 1;
  }
  else if ( !strcmp(&unk_CC158, aGravis_0) )
  {
    a5 = -8192;
    a2 = 60;
    a4 = 22050;
    word_CC1C4 = 60;
  }
  else if ( !strcmp(&unk_CC158, aSoundmasterii) )
  {
    a5 = -8190;
    a3 = 60;
    a4 = 22050;
    word_CC1C4 = 60;
  }
  else if ( !strcmp(&unk_CC158, aCompatible_0) )
  {
    a5 = -8192;
    a1 = 60;
    a4 = 22050;
    word_CC1C4 = 60;
  }
  else
  {
    byte_939E4 = 0;
    byte_939E5 = 0;
  }
  if ( !byte_939EC )
  {
LABEL_35:
    a2 = 60;
    a4 = 11025;
    word_CC1C4 = 60;
    switch ( a5 )
    {
      case 0xE004:
        HIBYTE(a1) = 0;
        a5 = -8189;
        byte_939ED = 0;
        break;
      case 0xE017:
        LOBYTE(a1) = 0;
        a5 = -8170;
        byte_939ED = 0;
        break;
      case 0xE00D:
        a5 = -8181;
        byte_939ED = 0;
        break;
    }
    goto LABEL_41;
  }
  if ( (unsigned __int8)byte_939EC > 1u )
  {
    if ( byte_939EC != 3 )
      goto LABEL_41;
    goto LABEL_35;
  }
  a4 = 22050;
  switch ( a5 )
  {
    case 0xE004:
      a5 = -8189;
      a3 = 60;
      word_CC1C4 = 60;
      byte_939ED = 0;
      break;
    case 0xE017:
      a5 = -8170;
      a1 = 120;
      BYTE1(a2) = 0;
      word_CC1C4 = 120;
      byte_939ED = 0;
      break;
    case 0xE00D:
      a5 = -8181;
      LOBYTE(a2) = 0;
      word_CC1C4 = 60;
      byte_939ED = 0;
      break;
  }
LABEL_41:
  if ( byte_939E6 )
  {
    //fix v5 = sub_63A9D(a1, a2, (int)&asc_A970B[1], __DS__);
    if ( v5 )
    {
      v6 = sub_6378C(v5);
      printf("\nError : %s\n", v6);
LABEL_63:
      byte_939E4 = 0;
      byte_939E5 = 0;
      return sub_61610((int)aDataSnds00Dat);
    }
    v7 = 1;
    a3 = 0;
    do
    {
      if ( !v7 )
        break;
      ++a3;
      //fix v7 = sub_63C5A(v13, a5, byte_CC0C2, __DS__, (unsigned int)v13);
    }
    while ( (__int16)a3 < 5 );
    //fix if ( v7 || (v7 = sub_64248((unsigned int)&dword_CC134, __DS__)) != 0 )
    {
      v8 = sub_6378C(v7);
      printf("\nError : %s\n", v8);
      sub_63C06();
      byte_939E4 = 0;
      byte_939E5 = 0;
      return sub_61610((int)aDataSnds00Dat);
    }
    sub_63C06();
  }
  else
  {
    dword_CC134 = dword_CC14C;
    dword_CC138 = dword_CC150;
    dword_CC13C = dword_CC1BC;
    dword_CC126 = a5;
  }
  //fix sub_647C0((int)&asc_A970B[1], __DS__);
  if ( !byte_939D4 )
    sub_5D883(a3, 0xFF00u, 0);
  dword_93A54 = a4;
  //fix 
  /*v10 = sub_64846(
          a2,
          a5,
          dword_CC126,
          (unsigned int)&dword_CC134,
          (unsigned __int16)__DS__,
          (unsigned int)&unk_93A44,
          (unsigned __int16)__DS__,
          (unsigned int)&dword_CC140);*/
  if ( !v10 )
  {
    result = sub_5D97B((unsigned __int16)word_CC1C4, dword_93A60, word_93A64, (unsigned int)&dword_CC148);
    if ( !(_WORD)result )
      return result;
    v12 = sub_6378C((unsigned __int16)result);
    printf("\nError : %s\n", v12);
    if ( !byte_939D4 )
      sub_5D948();
    sub_64F78(dword_CC140, 1, 1);
    sub_6481C();
    goto LABEL_63;
  }
  v11 = sub_6378C(v10);
  printf("\nError : %s\n", v11);
  if ( !byte_939D4 )
    sub_5D948();
  sub_6481C();
  byte_939E4 = 0;
  byte_939E5 = 0;
  return sub_61610((int)aDataSnds00Dat);
}
// 5CC03: using guessed type _DWORD printf(const char *, ...);
// 61EF5: using guessed type _DWORD stricmp(_DWORD, _DWORD);
// 639E0: using guessed type _DWORD strcmp(_DWORD, _DWORD);
// 939D4: using guessed type char byte_939D4;
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// 939E6: using guessed type char byte_939E6;
// 939EC: using guessed type char byte_939EC;
// 939ED: using guessed type char byte_939ED;
// 93A54: using guessed type int dword_93A54;
// 93A60: using guessed type int dword_93A60;
// 93A64: using guessed type __int16 word_93A64;
// CC126: using guessed type int dword_CC126;
// CC134: using guessed type int dword_CC134;
// CC138: using guessed type int dword_CC138;
// CC13C: using guessed type int dword_CC13C;
// CC140: using guessed type int dword_CC140;
// CC148: using guessed type int dword_CC148;
// CC14C: using guessed type int dword_CC14C;
// CC150: using guessed type int dword_CC150;
// CC1BC: using guessed type int dword_CC1BC;
// CC1C4: using guessed type __int16 word_CC1C4;

//----- (00044470) --------------------------------------------------------
int sub_44470()
{
  unsigned int v0; // esi
  int result; // eax
  int *v2; // ebx
  unsigned int v3; // eax
  int v4; // edx
  int v5; // ebp
  int v6; // esi
  unsigned __int16 v7; // bx
  char v8; // di
  unsigned __int16 v9; // bx
  int v10; // esi
  char v11; // di
  unsigned __int16 i; // bx
  unsigned __int16 j; // bx
  unsigned __int16 v14; // si
  char *v15; // [esp-1Ch] [ebp-54h]
  char *v16; // [esp-1Ch] [ebp-54h]
  char *v17; // [esp-1Ch] [ebp-54h]
  char v18; // [esp-18h] [ebp-50h]
  char v19; // [esp-14h] [ebp-4Ch]
  char v20; // [esp-10h] [ebp-48h]
  __int16 v21; // [esp-Ch] [ebp-44h]
  __int16 v22; // [esp-Ch] [ebp-44h]
  __int16 v23; // [esp-8h] [ebp-40h]
  __int16 v24; // [esp-8h] [ebp-40h]
  __int16 v25; // [esp-4h] [ebp-3Ch]
  __int16 v26; // [esp-4h] [ebp-3Ch]
  int v27; // [esp+4h] [ebp-34h]
  int v28; // [esp+8h] [ebp-30h]
  int v29; // [esp+Ch] [ebp-2Ch]
  int v30; // [esp+10h] [ebp-28h]
  char v31; // [esp+18h] [ebp-20h]
  char v32; // [esp+1Ch] [ebp-1Ch]
  char v33; // [esp+20h] [ebp-18h]
  char v34; // [esp+24h] [ebp-14h]

  v29 = *(char *)(dword_AE400 + 8608);
  sub_29BA0(v29);
  v0 = 256 / v29;
  result = 0x100u / (256 / v29);
  v27 = 0;
  v2 = dword_9334C;
  v28 = result;
  if ( result > 0 )
  {
    v30 = 0;
    do
    {
      v3 = 0;
      if ( v0 )
      {
        v4 = 0;
        do
        {
          ++v2;
          ++v3;
          v5 = v4 + dword_AE3F0 + v30;
          v4 += v29;
          *(v2 - 1) = v5;
        }
        while ( v3 < v0 );
      }
      result = v27 + 1;
      v30 += v29 << 8;
      v27 = result;
    }
    while ( result < v28 );
  }
  if ( !byte_90B48 )
  {
    result = sub_3EEA0(aDataTablesDat, byte_B7934);
    if ( result <= 0 )
      byte_90B48 = 1;
  }
  if ( byte_90B48 )
  {
    v6 = 256;
    v7 = 0;
    v32 = *(_BYTE *)(dword_AE428 + 766);
    v8 = *(_BYTE *)(dword_AE428 + 765);
    v31 = *(_BYTE *)(dword_AE428 + 767);
    sub_72807((unsigned __int8 *)dword_AE428, (uint8*)byte_CB934);
    do
    {
      v25 = v6;
      v23 = v6;
      v21 = v6;
      v15 = &byte_B7934[256 * v7];
      v6 -= 8;
      ++v7;
      sub_40EDC((_BYTE *)dword_AE428, (uint8*)v15, v8, v32, v31, v21, v23, v25);
    }
    while ( v7 < 0x20u );
    v9 = 32;
    v34 = *(_BYTE *)dword_AE428;
    v10 = 0;
    v11 = *(_BYTE *)(dword_AE428 + 2);
    v33 = *(_BYTE *)(dword_AE428 + 1);
    do
    {
      v26 = v10;
      v24 = v10;
      v22 = v10;
      v16 = &byte_B7934[256 * v9];
      v10 += 8;
      ++v9;
      sub_40EDC((_BYTE *)dword_AE428, (uint8*)v16, v34, v33, v11, v22, v24, v26);
    }
    while ( v9 < 0x40u );
    for ( i = 0; i < 0x100u; ++i )
    {
      v20 = *(_BYTE *)(dword_AE428 + 3 * i + 2);
      v19 = *(_BYTE *)(dword_AE428 + 3 * i + 1);
      v18 = *(_BYTE *)(dword_AE428 + 3 * i);
      v17 = &byte_BB934[256 * i];
      sub_40EDC((_BYTE *)dword_AE428, (uint8*)v17, v18, v19, v20, 85, 85, 85);
    }
    for ( j = 0; j < 0x100u; ++j )
    {
      v14 = j;
      byte_CBC34[v14] = sub_410CE((unsigned int)sub_10000 - v14 * v14);
    }
    byte_CBC34[0] = -1;
    return sub_62E60((int)aDataTablesDat, (int)byte_B7934, &unk_CBF34 - (_UNKNOWN *)byte_B7934);
  }
  return result;
}
// 10000: using guessed type void sub_10000();
// 90B48: using guessed type char byte_90B48;
// 9334C: using guessed type int dword_9334C[148];
// AE3F0: using guessed type int dword_AE3F0;
// AE400: using guessed type int dword_AE400;
// AE428: using guessed type int dword_AE428;

//----- (00044700) --------------------------------------------------------
void sub_44700(const char *a1, int a2, int a3)
{
  int i; // ebx
  int v6; // edx

  for ( i = 0; (_WORD)--a3 != 0xFFFF; i += 4 )
  {
    v6 = i;
    *(_DWORD *)(v6 + a2) = (uint32)a1;
    a1 += strlen(a1) + 1;
  }
  JUMPOUT(0x446F1);
}
// 44718: control flows out of bounds to 446F1

//----- (00044730) --------------------------------------------------------
void sub_44730(int a1)
{
  __int16 v1; // dx

  if ( !byte_93A84 )
  {
    byte_93A84 = 1;
    if ( (word_12F02E & 1) != 0 )
      sub_411D7(a1, (void *)dword_12EFF4, 0xC8u, 0);
    else
      sub_411FD(a1, (void *)dword_12EFF4, 0x1E0u, 0);
    if ( (*(_WORD *)dword_AE408 & 0x110) != 0 )
    {
      if ( (word_12F02E & 1) != 0 )
        sub_61B90((unsigned __int8 *)dword_AE428);
      else
        sub_61C30((unsigned __int8 *)dword_AE428);
    }
    else
    {
      sub_61CC0(0, 0x10u, 0);
      if ( (word_12F02E & 1) != 0 )
        sub_61B90((unsigned __int8 *)dword_12EFF4);
      else
        sub_61C30((unsigned __int8 *)dword_12EFF4);
    }
    sub_5C214();
    if ( !dword_9AD98 )
    {
      sub_44840();
      printf("ERROR : MOUSE DRIVER NOT FOUND.\n");
      exit(1);
    }
    v1 = dword_AE450;
    sub_5C05C(dword_AE450);
    if ( (*(_BYTE *)dword_AE408 & 8) != 0 )
      sub_5B5E0();
    else
      sub_36D83(dword_AE408, v1);
  }
}
// 5CC03: using guessed type _DWORD printf(const char *, ...);
// 93A84: using guessed type char byte_93A84;
// 9AD98: using guessed type int dword_9AD98;
// AE408: using guessed type int dword_AE408;
// AE428: using guessed type int dword_AE428;
// AE450: using guessed type int dword_AE450;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00044840) --------------------------------------------------------
int sub_44840()
{
  if ( byte_93A84 != 1 )
    JUMPOUT(0x44836);
  sub_3F370();
  if ( (*(_BYTE *)dword_AE408 & 8) != 0 )
    sub_5B5F4();
  else
    sub_36DC2();
  sub_5CD70();
  sub_433C0();
  return sub_5A4EA();
}
// 44847: control flows out of bounds to 44836
// 93A84: using guessed type char byte_93A84;
// AE408: using guessed type int dword_AE408;

//----- (000448E0) --------------------------------------------------------
int sub_448E0()
{
  int v0; // edx
  int v1; // esi
  int v2; // eax
  int v3; // ebx
  int v4; // ecx
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  int v8; // ebx
  int v9; // ecx
  int v10; // eax
  int v11; // ebx
  int v12; // eax
  int v13; // eax
  int v14; // ebx
  int v15; // eax
  int v16; // ebx
  int v17; // edx
  int result; // eax
  int v19; // [esp+0h] [ebp-18h]
  int v20; // [esp+4h] [ebp-14h]

  v0 = 0;
  v1 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13333);
  v2 = 0;
  v3 = 0;
  v19 = 0;
  v20 = 0;
  do
  {
    if ( *(int *)((char *)&dword_38CA3 + dword_AE400 + v3) )
    {
      v4 = *(_DWORD *)(v1 + 160);
      ++v20;
      if ( *(_WORD *)(v4 + v0 + 676) )
      {
        *(_BYTE *)(v4 + v2 + 892) = 1;
        ++v19;
      }
    }
    v5 = *(_DWORD *)(v1 + 160);
    if ( *(_WORD *)(v5 + v0 + 676) )
      *(_BYTE *)(v5 + v2 + 892) = 1;
    v3 += 4;
    ++v2;
    v0 += 2;
  }
  while ( v2 < 24 );
  if ( v20 )
  {
    *(_DWORD *)(*(_DWORD *)(v1 + 160) + 363) = 100 * v19 / v20;
    v6 = *(_DWORD *)(v1 + 160);
    if ( *(int *)(v6 + 363) <= 100 )
      goto LABEL_13;
  }
  else
  {
    v6 = *(_DWORD *)(v1 + 160);
  }
  *(_DWORD *)(v6 + 363) = 100;
LABEL_13:
  if ( *(int *)((char *)&dword_38C9F + dword_AE400) )
  {
    *(_DWORD *)(*(_DWORD *)(v1 + 160) + 359) = 100
                                             * *(_DWORD *)(*(_DWORD *)(v1 + 160) + 359)
                                             / *(int *)((char *)&dword_38C9F + dword_AE400);
    v7 = *(_DWORD *)(v1 + 160);
    if ( *(int *)(v7 + 359) <= 100 )
      goto LABEL_18;
  }
  else
  {
    v7 = *(_DWORD *)(v1 + 160);
  }
  *(_DWORD *)(v7 + 359) = 100;
LABEL_18:
  v8 = *(_DWORD *)(v1 + 160);
  v9 = *(_DWORD *)(v8 + 343);
  if ( v9 )
  {
    *(_DWORD *)(v8 + 367) = 100 * *(_DWORD *)(v8 + 347) / v9;
    v10 = *(_DWORD *)(v1 + 160);
    if ( *(int *)(v10 + 367) > 100 )
      *(_DWORD *)(v10 + 367) = 100;
  }
  else
  {
    *(_DWORD *)(v8 + 367) = 100;
  }
  v11 = *(_DWORD *)(v1 + 160);
  v12 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(v11 + 50);
  if ( v12 )
  {
    *(_DWORD *)(v11 + 371) = 100 * (*(_DWORD *)(v11 + 308) + *(_DWORD *)(v12 + 140)) / *(_DWORD *)(dword_AE408 + 188);
    v13 = *(_DWORD *)(v1 + 160);
    if ( *(int *)(v13 + 371) > 100 )
      *(_DWORD *)(v13 + 371) = 100;
  }
  else
  {
    *(_DWORD *)(v11 + 371) = 0;
  }
  *(_DWORD *)(*(_DWORD *)(v1 + 160) + 375) = 0;
  v14 = 0;
  if ( v20 )
  {
    *(_DWORD *)(*(_DWORD *)(v1 + 160) + 375) += *(_DWORD *)(*(_DWORD *)(v1 + 160) + 363);
    v14 = 1;
  }
  if ( *(int *)((char *)&dword_38C9F + dword_AE400) )
  {
    ++v14;
    *(_DWORD *)(*(_DWORD *)(v1 + 160) + 375) += *(_DWORD *)(*(_DWORD *)(v1 + 160) + 359);
  }
  v15 = *(_DWORD *)(v1 + 160);
  if ( *(_DWORD *)(v15 + 343) )
  {
    ++v14;
    *(_DWORD *)(v15 + 375) += *(_DWORD *)(v15 + 367);
  }
  *(_DWORD *)(*(_DWORD *)(v1 + 160) + 375) += *(_DWORD *)(*(_DWORD *)(v1 + 160) + 371);
  v16 = v14 + 1;
  if ( !v16 )
    v16 = 1;
  *(int *)(*(_DWORD *)(v1 + 160) + 375) /= v16;
  v17 = *(_DWORD *)(v1 + 160);
  result = dword_AC5D4 - *(_DWORD *)(v17 + 379);
  *(_DWORD *)(v17 + 379) = result;
  return result;
}
// 38C9F: using guessed type int dword_38C9F;
// 38CA3: using guessed type int dword_38CA3;
// AC5D4: using guessed type int dword_AC5D4;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00044BE0) --------------------------------------------------------
__int16 sub_44BE0(int a1, char a2)
{
  __int16 result; // ax

  result = *(_WORD *)(dword_AE400 + 8);
  if ( result == *(_WORD *)(*(_DWORD *)(a1 + 160) + 48) )
  {
    result = dword_AE408;
    *(_BYTE *)(dword_AE408 + 152) = a2;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00044C10) --------------------------------------------------------
signed int sub_44C10(int a1)
{
  int v1; // ebx
  int v2; // esi
  signed int result; // eax

  v1 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13333);
  v2 = *(_DWORD *)(v1 + 160);
  result = sub_42340((_WORD *)(a1 + 72), (_WORD *)(v1 + 72));
  if ( result <= *(_DWORD *)(v2 + 396) )
    *(_DWORD *)(*(_DWORD *)(v1 + 160) + 396) = result;
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00044C90) --------------------------------------------------------
signed int sub_44C90(int a1)
{
  int v1; // ebx
  int v2; // esi
  signed int result; // eax

  v1 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13333);
  v2 = *(_DWORD *)(v1 + 160);
  result = sub_42340((_WORD *)(a1 + 72), (_WORD *)(v1 + 72));
  if ( result <= *(_DWORD *)(v2 + 400) )
    *(_DWORD *)(*(_DWORD *)(v1 + 160) + 400) = result;
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00044D30) --------------------------------------------------------
int sub_44D30(int a1, int a2)
{
  int v2; // ebx
  int v3; // edx
  __int16 v4; // ax
  int v5; // ecx
  char v6; // dh
  int v7; // eax
  unsigned __int16 v8; // dx
  int v9; // esi
  int v10; // eax
  int v11; // eax
  int v12; // ecx
  int v13; // edi
  char v14; // ah
  int v15; // edx
  int v16; // eax
  int v17; // eax
  int v18; // ebp
  int v19; // ecx
  int v20; // eax
  __int16 v21; // dx
  int v22; // eax
  int v23; // ecx
  int v24; // eax
  int v25; // ecx
  int v26; // eax
  int v27; // edx
  unsigned __int16 v28; // di
  unsigned int j; // eax
  int k; // eax
  int result; // eax
  int v32; // [esp+0h] [ebp-24h] BYREF
  __int16 v33; // [esp+4h] [ebp-20h]
  int v34; // [esp+8h] [ebp-1Ch]
  int i; // [esp+Ch] [ebp-18h]
  int v36; // [esp+10h] [ebp-14h]

  v2 = a2;
  v34 = 0;
  sub_37220();
  v3 = (a1 - (dword_AE400 + 13323)) / 2049;
  v32 = *(_DWORD *)(dword_AE400 + 6 * v3 + 9177);
  v33 = *(_WORD *)(dword_AE400 + 6 * v3 + 9181);
  v4 = sub_11F50((__int16 *)&v32);
  ++HIBYTE(v4);
  v5 = dword_AE400;
  v33 = v4;
  if ( a2 == dword_AE400 + 29795 )
  {
    v2 = sub_373F0((int)&v32, 3, *(_BYTE *)(a1 + 9) == 1);
    v34 = 1;
  }
  else
  {
    v6 = *(_BYTE *)(a2 + 16);
    *(_BYTE *)(a2 + 70) = *(_BYTE *)(a1 + 9) == 1;
    v7 = *(_DWORD *)(a2 + 160);
    *(_BYTE *)(a2 + 16) = v6 & 0xDF;
    if ( *(_WORD *)(v7 + 50) )
    {
      v8 = *(_WORD *)(v7 + 50);
      v32 = *(_DWORD *)(v5 + 164 * v8 + 29867);
      v33 = *(_WORD *)(v5 + 164 * v8 + 29871);
    }
    sub_41C70((__int16)&v32, a2, (int)&v32);
  }
  *(_DWORD *)(v2 + 160) = a1 + 1103;
  *(_WORD *)(*(_DWORD *)(v2 + 160) + 48) = (a1 - (dword_AE400 + 13323)) / 2049;
  *(_WORD *)(*(_DWORD *)(v2 + 160) + 331) = 100;
  *(_DWORD *)(*(_DWORD *)(v2 + 160) + 351) = 2000;
  *(_WORD *)(*(_DWORD *)(v2 + 160) + 12) = 0;
  *(_WORD *)(*(_DWORD *)(v2 + 160) + 24) = 0;
  *(_WORD *)(*(_DWORD *)(v2 + 160) + 26) = 0;
  *(_WORD *)(*(_DWORD *)(v2 + 160) + 22) = 0;
  v9 = 0;
  *(_WORD *)(*(_DWORD *)(v2 + 160) + 16) = 0;
  do
  {
    v10 = v9 + *(_DWORD *)(v2 + 160);
    if ( *(int *)(v10 + 532) < 0 )
    {
      *(_DWORD *)(v10 + 532) = 0;
    }
    else
    {
      v11 = sub_373F0(v2 + 72, 12, *(_DWORD *)(v10 + 532));
      v12 = v11;
      if ( v11 )
      {
        v13 = dword_AE400 + 29795;
        v36 = 164;
        *(_DWORD *)(*(_DWORD *)(v2 + 160) + v9 + 532) = (v11 - (dword_AE400 + 29795)) / 164;
        *(_WORD *)(v11 + 42) = (v2 - v13) / 164;
        *(_BYTE *)(v11 + 16) |= 1u;
        if ( *(_BYTE *)(*(char *)(v11 + 65) + *(_DWORD *)(v2 + 160) + 916) )
        {
          *(_WORD *)(v11 + 86) = 280;
          v14 = *(_BYTE *)(v11 + 18);
          *(_DWORD *)(v12 + 132) = 0;
          *(_BYTE *)(v12 + 18) = v14 | 4;
        }
      }
      else
      {
        *(_DWORD *)(v9 + *(_DWORD *)(v2 + 160) + 532) = 0;
      }
    }
    v9 += 4;
  }
  while ( v9 != 96 );
  if ( v34 )
  {
    *(_DWORD *)(*(_DWORD *)(v2 + 160) + 379) = dword_AC5D4;
    switch ( *(_WORD *)(*(_DWORD *)(v2 + 160) + 48) )
    {
      case 0:
        sub_36FA0(v2, 44);
        break;
      case 1:
        sub_36FA0(v2, 273);
        break;
      case 2:
        sub_36FA0(v2, 274);
        break;
      case 3:
        sub_36FA0(v2, 275);
        break;
      case 4:
        sub_36FA0(v2, 276);
        break;
      case 5:
        sub_36FA0(v2, 277);
        break;
      case 6:
        sub_36FA0(v2, 278);
        break;
      case 7:
        sub_36FA0(v2, 279);
        break;
      default:
        break;
    }
    sub_45C10(v2);
    if ( *(_BYTE *)(a1 + 9) == 1 )
    {
      v15 = dword_AE400;
      *(_WORD *)(*(_DWORD *)(v2 + 160) + 522) = *(_WORD *)&byte_385D7[216 * *(__int16 *)(*(_DWORD *)(v2 + 160) + 48)
                                                                    + dword_AE400];
      *(_WORD *)(*(_DWORD *)(v2 + 160) + 524) = *(_WORD *)&algn_385D8[216 * *(__int16 *)(*(_DWORD *)(v2 + 160) + 48)
                                                                    + 7
                                                                    + v15];
      *(_WORD *)(*(_DWORD *)(v2 + 160) + 526) = *(_WORD *)&algn_385D8[216 * *(__int16 *)(*(_DWORD *)(v2 + 160) + 48)
                                                                    + 3
                                                                    + v15];
      v16 = *(_DWORD *)(v2 + 160);
      if ( *(_WORD *)(v16 + 708) )
      {
        if ( byte_38C97[v15 + *(__int16 *)(v16 + 48)] )
        {
          v17 = sub_373F0(v2 + 72, 3, 2);
          v18 = v17;
          if ( v17 )
          {
            v19 = dword_AE400 + 29795;
            *(_WORD *)(v17 + 24) = *(_WORD *)(v2 + 24);
            *(_WORD *)(*(_DWORD *)(v2 + 160) + 50) = (v17 - v19) / 164;
            sub_55370((v2 - v19) / 164, -1, 30);
            for ( i = 0; ; ++i )
            {
              v22 = dword_AE400;
              v23 = (unsigned __int8)byte_38C97[dword_AE400 + *(__int16 *)(*(_DWORD *)(v2 + 160) + 48)];
              if ( v23 <= i )
                break;
              *(_DWORD *)(dword_AE400 + 29867) = *(_DWORD *)(v18 + 150);
              *(_WORD *)(v22 + 29871) = *(_WORD *)(v18 + 154);
              v20 = v22 + 29795;
              v21 = *(_WORD *)(v18 + 24);
              *(_BYTE *)(v20 + 65) = 0;
              *(_WORD *)(v20 + 26) = 0;
              *(_WORD *)(v20 + 24) = v21;
              *(_BYTE *)(v20 + 71) = i;
              sub_279D0(v20);
            }
            *(_WORD *)(v18 + 26) = (unsigned __int8)v23 - 1;
            sub_37150((_WORD *)v18, (unsigned __int8)v23 - 1);
            sub_47C60(v18);
            v24 = *(_DWORD *)(v18 + 136);
            *(_DWORD *)(v18 + 140) = v24;
            if ( v24 < 0 )
              *(_DWORD *)(v18 + 140) = 0;
            if ( *(_DWORD *)(v18 + 140) > (int)&loc_4E200 )
              *(_DWORD *)(v18 + 140) = (uint32)&loc_4E200;
          }
        }
      }
    }
    *(_DWORD *)(*(_DWORD *)(v2 + 160) + 359) = 0;
  }
  v25 = dword_AE400;
  *(_WORD *)(a1 + 10) = (v2 - (dword_AE400 + 29795)) / 164;
  if ( *(_WORD *)(v25 + 8) == *(_WORD *)(*(_DWORD *)(v2 + 160) + 48) )
    *(_BYTE *)(v2 + 16) |= 1u;
  if ( *(_UNKNOWN **)(a1 + 24) == &unk_AE89E )
  {
    *(_DWORD *)(v2 + 136) = (uint32)&unk_F4240;
    *(_DWORD *)(v2 + 8) = (uint32)&unk_F4240;
  }
  else
  {
    *(_DWORD *)(v2 + 136) = 1000;
    *(_DWORD *)(v2 + 8) = 10000;
  }
  *(_DWORD *)(v2 + 12) = *(_DWORD *)(v2 + 8);
  v26 = *(_DWORD *)(v2 + 136);
  v27 = *(_DWORD *)(v2 + 160);
  *(_DWORD *)(v2 + 140) = v26;
  *(_DWORD *)(v27 + 322) = v26;
  sub_45C10(v2);
  v28 = *(_WORD *)(*(_DWORD *)(v2 + 160) + 50);
  if ( v28 )
    sub_47DD0(164 * v28 + dword_AE400 + 29795);
  for ( j = *(_DWORD *)(dword_AE408 + 36462); j > dword_AE400 + 29795; j = *(_DWORD *)j )
  {
    if ( *(_WORD *)(j + 24) != *(_WORD *)(v2 + 24) && *(_BYTE *)(j + 65) <= 1u )
      *(_WORD *)(8 * *(__int16 *)(*(_DWORD *)(v2 + 160) + 48) + *(_DWORD *)(j + 160) + 460) = -24609;
  }
  *(_WORD *)(*(_DWORD *)(v2 + 160) + 314) = 0;
  *(_WORD *)(*(_DWORD *)(v2 + 160) + 316) = 0;
  if ( *(_BYTE *)(v2 + 65) == 1 )
  {
    memset((void*)(*(_DWORD *)(v2 + 160) + 415), 0, 1);
    for ( k = 0; k != 64; *(_WORD *)(*(_DWORD *)(v2 + 160) + k + 452) = 24607 )
      k += 8;
    *(_WORD *)(*(_DWORD *)(v2 + 160) + 756) = 4 * *(_WORD *)(*(_DWORD *)(v2 + 160) + 48);
  }
  *(_DWORD *)(*(_DWORD *)(v2 + 160) + 396) = 2048;
  *(_DWORD *)(*(_DWORD *)(v2 + 160) + 400) = 2048;
  *(_WORD *)(*(_DWORD *)(v2 + 160) + 46) = 0;
  memset((void*)(*(_DWORD *)(v2 + 160) + 333), 16, 8);
  result = dword_AE400;
  *(_DWORD *)(dword_AE400 + 4593) = -1;
  if ( *(_WORD *)(*(_DWORD *)(v2 + 160) + 48) == *(_WORD *)(result + 8) )
  {
    result = dword_AE408;
    *(_BYTE *)(dword_AE408 + 150) = 0;
  }
  return result;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// AC5D4: using guessed type int dword_AC5D4;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00045410) --------------------------------------------------------
int sub_45410(int a1)
{
  unsigned __int16 v1; // si
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // ax
  int v4; // ebx
  __int16 v5; // ax
  unsigned __int16 v7; // [esp+0h] [ebp-28h]
  __int16 v8; // [esp+Ch] [ebp-1Ch]
  __int16 v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]

  v10 = 1;
  if ( sub_11810(&word_AE454) == 256 )
  {
    v1 = sub_42150((_WORD *)(a1 + 72), (uint16*)&word_AE454);
    v8 = sub_42180((_WORD *)(a1 + 72), (uint16*)&word_AE454);
    v7 = sub_42340((_WORD *)(a1 + 72), (uint16*)&word_AE454);
    *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
    *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
    v9 = ((((int)v1 >> 9) + 1) << 9) & 0x7FF;
    v2 = sub_42210(v1, (int)v1 >> 9 << 9);
    sub_41EC0(
        (uint16*)&word_AE454,
      (int)v1 >> 9 << 9,
      v8,
      (v7 * (512 - v2) - (__CFSHL__((v7 * (512 - v2)) >> 31, 9) + ((v7 * (512 - v2)) >> 31 << 9))) >> 9);
    if ( sub_11810(&word_AE454) == 256 )
    {
      *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
      *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
      v3 = sub_42210(v1, v9);
      sub_41EC0(
          (uint16*)&word_AE454,
        v9,
        v8,
        (v7 * (512 - v3) - (__CFSHL__((v7 * (512 - v3)) >> 31, 9) + ((v7 * (512 - v3)) >> 31 << 9))) >> 9);
      if ( sub_11810(&word_AE454) == 256 )
        v10 = 0;
    }
  }
  v4 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 12);
  v5 = sub_11F50(&word_AE454);
  if ( word_AE458 < v5 + v4 )
    word_AE458 = *(_WORD *)(*(_DWORD *)(a1 + 156) + 12) + v5;
  return v10;
}
// AE454: using guessed type __int16 word_AE454;
// AE458: using guessed type __int16 word_AE458;

//----- (000455D0) --------------------------------------------------------
void sub_455D0(int a1)
{
  int v1; // eax
  int v2; // eax
  __int16 v3; // si
  int v4; // ecx
  int v5; // edx
  __int16 v6; // ax
  int v7; // eax
  __int16 v8; // dx
  __int16 v9; // di
  unsigned __int16 v10; // ax
  int v11; // eax
  __int16 v12; // dx
  int v13; // ecx
  __int16 v14; // di
  int v15; // eax
  __int64 v16; // rax
  _WORD *v17; // eax
  __int16 v18; // si
  __int16 v19; // dx
  unsigned int v20; // edi
  signed int v21; // ebp
  int v22; // ecx
  int v23; // esi
  __int16 v24; // di
  __int16 v25; // ax
  __int16 v26; // ax
  int v27; // eax
  __int16 v28; // di
  unsigned int v29; // eax

  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  *(_WORD *)(*(_DWORD *)(a1 + 160) + 327) += *(_WORD *)(*(_DWORD *)(a1 + 160) + 4);
  *(_WORD *)(*(_DWORD *)(a1 + 160) + 329) += *(_WORD *)(*(_DWORD *)(a1 + 160) + 6);
  v1 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 327);
  *(_WORD *)(a1 + 30) = (*(_WORD *)(a1 + 30) + ((v1 - (__CFSHL__(v1 >> 31, 3) + 8 * (v1 >> 31))) >> 3)) & 0x7FF;
  v2 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 12) - *(__int16 *)(a1 + 126);
  if ( v2 )
    v2 /= (int)abs32(v2);
  *(_WORD *)(a1 + 126) += v2 * dword_93A88;
  v3 = sub_11F50(&word_AE454);
  v4 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 10);
  v5 = ((word_AE458 - v3 - v4) << 10) / v4;
  if ( v5 < -256 )
    v5 = -256;
  if ( v5 > 256 )
    v5 = 256;
  v6 = *(_WORD *)(*(_DWORD *)(a1 + 160) + 329);
  HIBYTE(v6) &= 7u;
  *(_WORD *)(a1 + 32) = v6;
  if ( v6 > 1024 )
    v6 -= 2048;
  if ( *(__int16 *)(a1 + 126) >= 0 || v6 <= 0 )
  {
    if ( *(__int16 *)(a1 + 126) >= 0 || v6 >= 0 )
    {
      if ( *(__int16 *)(a1 + 126) <= 0 || v6 >= 0 )
      {
        if ( *(__int16 *)(a1 + 126) <= 0 || v6 <= 0 )
        {
          if ( !*(_WORD *)(a1 + 126) && word_AE458 > *(__int16 *)(*(_DWORD *)(a1 + 156) + 10) + v3 )
            word_AE458 -= 8;
        }
        else
        {
          *(_WORD *)(*(_DWORD *)(a1 + 160) + 28) = *(_WORD *)(*(_DWORD *)(a1 + 160) + 329);
        }
      }
      else
      {
        *(_WORD *)(*(_DWORD *)(a1 + 160) + 28) = (v6 * -v5 - (__CFSHL__((v6 * -v5) >> 31, 8) + ((v6 * -v5) >> 31 << 8))) >> 8;
      }
    }
    else
    {
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 28) = *(_WORD *)(*(_DWORD *)(a1 + 160) + 329);
    }
  }
  else
  {
    *(_WORD *)(*(_DWORD *)(a1 + 160) + 28) = (v6 * -v5 - (__CFSHL__((v6 * -v5) >> 31, 8) + ((v6 * -v5) >> 31 << 8))) >> 8;
  }
  v7 = *(_DWORD *)(a1 + 160);
  v8 = *(_WORD *)(v7 + 28);
  HIBYTE(v8) &= 7u;
  *(_WORD *)(v7 + 28) = v8;
  sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), *(_WORD *)(*(_DWORD *)(a1 + 160) + 28), *(_WORD *)(a1 + 126));
  v9 = *(_WORD *)(*(_DWORD *)(a1 + 160) + 16);
  if ( v9 )
  {
    v10 = *(_WORD *)(a1 + 30);
    HIBYTE(v10) += 2;
    sub_41EC0((uint16*)&word_AE454, v10, 0, v9);
  }
  v11 = *(_DWORD *)(a1 + 160);
  v12 = *(_WORD *)(v11 + 22);
  if ( v12 )
  {
    if ( v12 > 128 )
      *(_WORD *)(v11 + 22) = 128;
    sub_41EC0((uint16*)&word_AE454, *(_WORD *)(*(_DWORD *)(a1 + 160) + 24), 0, *(_WORD *)(*(_DWORD *)(a1 + 160) + 22));
    v13 = *(_DWORD *)(a1 + 160);
    v14 = *(_WORD *)(v13 + 22);
    if ( v14 )
      v15 = v14 / (int)abs16(v14);
    else
      LOWORD(v15) = 0;
    *(_WORD *)(v13 + 22) += v15 * dword_93A94;
    v16 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 22);
    if ( (int)((HIDWORD(v16) ^ v16) - HIDWORD(v16)) < 4 )
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 22) = 0;
  }
  v17 = *(_WORD **)(a1 + 160);
  v18 = v17[205] + word_AE456;
  v19 = v17[206];
  word_AE454 += v17[204];
  word_AE456 = v18;
  word_AE458 += v19;
  v17[204] = 0;
  *(_WORD *)(*(_DWORD *)(a1 + 160) + 410) = 0;
  *(_WORD *)(*(_DWORD *)(a1 + 160) + 412) = 0;
  v20 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 314);
  if ( v20 > dword_AE400 + 29795 )
  {
    v21 = sub_42340((_WORD *)(a1 + 72), (_WORD *)(v20 + 72));
    if ( v21 >= 5120 || *(int *)(v20 + 12) < 0 || *(_WORD *)(*(_DWORD *)(a1 + 160) + 316) == 1000 )
    {
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 314) = 0;
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 316) = 0;
    }
    v22 = 3 * *(__int16 *)(a1 + 128) / 2;
    v23 = (v21 - *(_DWORD *)(*(_DWORD *)(a1 + 160) + 318)) / (1024 / (__int16)v22);
    if ( (__int16)v23 < -(__int16)v22 )
      v23 = 3 * *(__int16 *)(a1 + 128) / -2;
    if ( (__int16)v23 > (__int16)v22 )
      LOWORD(v23) = 3 * *(__int16 *)(a1 + 128) / 2;
    v24 = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v20 + 72));
    v25 = *(_WORD *)(a1 + 30) + sub_422A0(*(_WORD *)(a1 + 30), v24, 5, 0x82u);
    HIBYTE(v25) &= 7u;
    *(_WORD *)(a1 + 30) = v25;
    sub_41EC0((uint16*)&word_AE454, v24, *(_WORD *)(a1 + 32), v23);
    ++*(_WORD *)(*(_DWORD *)(a1 + 160) + 316);
  }
  v26 = sub_45410(a1);
  if ( v26 )
    sub_41C70(v26, a1, (int)&word_AE454);
  if ( sub_11810((__int16 *)(a1 + 72)) == 1 )
  {
    sub_55370(0, *(_WORD *)(dword_AE400 + 8), 1);
    sub_55890(0, *(_WORD *)(dword_AE400 + 8), 2);
  }
  else
  {
    sub_55370(0, *(_WORD *)(dword_AE400 + 8), 2);
    sub_55890(0, *(_WORD *)(dword_AE400 + 8), 1);
  }
  if ( *(int *)(*(_DWORD *)(a1 + 160) + 396) >= 1536 )
  {
    sub_55890(0, *(_WORD *)(dword_AE400 + 8), 5);
  }
  else
  {
    sub_55370(0, *(_WORD *)(dword_AE400 + 8), 5);
    *(_DWORD *)(*(_DWORD *)(a1 + 160) + 396) = 2048;
  }
  if ( *(int *)(*(_DWORD *)(a1 + 160) + 400) >= 1536 )
  {
    sub_55890(0, *(_WORD *)(dword_AE400 + 8), 31);
  }
  else
  {
    sub_55370(0, *(_WORD *)(dword_AE400 + 8), 31);
    *(_DWORD *)(*(_DWORD *)(a1 + 160) + 400) = 2048;
  }
  v27 = *(_DWORD *)(a1 + 160);
  if ( *(_WORD *)(v27 + 48) == *(_WORD *)(dword_AE400 + 8) )
  {
    v28 = *(_WORD *)(v27 + 46);
    if ( v28 <= 0 )
    {
      sub_20D00(1);
    }
    else
    {
      *(_WORD *)(v27 + 46) = v28 - 1;
      sub_20D00(2);
    }
  }
  if ( (*(_BYTE *)(a1 + 63) & 0x3F) == 0 )
  {
    v29 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
    *(_DWORD *)(a1 + 4) = v29;
    if ( !(v29 % 0xB) )
      sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 46);
  }
}
// 93A88: using guessed type int dword_93A88;
// 93A94: using guessed type int dword_93A94;
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;
// AE458: using guessed type __int16 word_AE458;

//----- (00045C10) --------------------------------------------------------
int sub_45C10(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // ecx

  memset((void*)(*(_DWORD *)(a1 + 160) + 676), 0, 48);
  for ( result = 0; result != 96; result += 4 )
  {
    v2 = *(_DWORD *)(a1 + 160);
    v3 = *(_DWORD *)(v2 + result + 532);
    if ( v3 )
      *(_WORD *)(v2 + 2 * *(char *)(164 * v3 + dword_AE400 + 29860) + 676) = *(_WORD *)(v2 + result + 532);
  }
  return result;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// AE400: using guessed type int dword_AE400;

//----- (00045C90) --------------------------------------------------------
void sub_45C90(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  unsigned __int8 v4; // dh
  int v5; // edx
  int v6; // eax
  int v7; // ebp
  int v8; // edi
  int v9; // edx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  __int16 v13; // cx
  char v14; // [esp+0h] [ebp-14h]

  v14 = 0;
  if ( (*(_BYTE *)(dword_AE408 + 2) & 1) == 0 )
    sub_45C10(a1);
  *(_WORD *)(a1 + 128) = dword_93A90;
  if ( (*(_BYTE *)(dword_AE408 + 2) & 1) == 0 )
  {
    v1 = *(_DWORD *)(a1 + 160);
    if ( *(_WORD *)(v1 + 50) )
    {
      if ( sub_11950(a1, 164 * *(unsigned __int16 *)(v1 + 50) + dword_AE400 + 29795) )
        v14 = 1;
    }
  }
  sub_46840(a1);
  if ( (*(_BYTE *)(dword_AE408 + 2) & 1) == 0 && v14 )
  {
    if ( *(_WORD *)(a1 + 94) )
    {
      v2 = 164 * *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 50) + dword_AE400 + 29795;
      if ( *(_WORD *)(v2 + 94) )
        *(_DWORD *)(v2 + 90) += *(_DWORD *)(a1 + 90);
      else
        *(_DWORD *)(v2 + 90) = *(_DWORD *)(a1 + 90);
      *(_WORD *)(v2 + 94) = *(_WORD *)(a1 + 94);
    }
    *(_WORD *)(*(_DWORD *)(a1 + 160) + 331) = 2;
  }
  if ( (*(_BYTE *)(dword_AE408 + 2) & 1) == 0 )
  {
    if ( *(_WORD *)(*(_DWORD *)(a1 + 160) + 331) )
    {
      memset((void*)(a1 + 90), 0, 36);
      --*(_WORD *)(*(_DWORD *)(a1 + 160) + 331);
    }
    else
    {
      sub_46540(a1);
    }
    v3 = *(_DWORD *)(a1 + 160);
    v4 = *(_BYTE *)(v3 + 326);
    if ( v4 < 0xC8u )
      *(_BYTE *)(v3 + 326) = v4 + 1;
  }
  sub_455D0(a1);
  if ( *(int *)(a1 + 12) >= 0 )
  {
    if ( (*(_BYTE *)(dword_AE408 + 2) & 1) == 0 )
    {
      v6 = *(_DWORD *)(a1 + 160);
      *(_DWORD *)(a1 + 140) += *(_DWORD *)(a1 + 132);
      v7 = *(_DWORD *)(v6 + 383);
      if ( v7 )
        *(_DWORD *)(v6 + 383) = v7 - 1;
      else
        *(_DWORD *)(a1 + 12) += *(__int16 *)(v6 + 341);
      if ( *(int *)(a1 + 140) < 0 )
        *(_DWORD *)(a1 + 140) = 0;
      v8 = *(_DWORD *)(a1 + 136);
      if ( *(_DWORD *)(a1 + 140) > v8 )
        *(_DWORD *)(a1 + 140) = v8;
      if ( *(int *)(a1 + 12) < -1 )
        *(_DWORD *)(a1 + 12) = -1;
      v9 = *(_DWORD *)(a1 + 8);
      if ( *(_DWORD *)(a1 + 12) > v9 )
        *(_DWORD *)(a1 + 12) = v9;
      v10 = *(_DWORD *)(a1 + 160);
      v11 = *(_DWORD *)(v10 + 351);
      if ( v11 )
        *(_DWORD *)(v10 + 351) = v11 - 1;
      v12 = *(_DWORD *)(a1 + 160);
      v13 = *(_WORD *)(v12 + 528);
      if ( v13 )
        *(_WORD *)(v12 + 528) = v13 - 1;
      if ( v14 || (*(_BYTE *)(a1 + 17) & 0x10) != 0 )
      {
        *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 136) / 200;
        *(_WORD *)(*(_DWORD *)(a1 + 160) + 341) = *(_DWORD *)(a1 + 8) / 250;
        if ( *(int *)(a1 + 132) < 1000 )
          *(_DWORD *)(a1 + 132) = 1000;
        *(_BYTE *)(a1 + 17) &= ~0x10u;
      }
      else
      {
        *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 136) / 2000;
        *(_WORD *)(*(_DWORD *)(a1 + 160) + 341) = *(_DWORD *)(a1 + 8) / 2000;
        if ( *(int *)(a1 + 132) < 100 )
          *(_DWORD *)(a1 + 132) = 100;
      }
    }
  }
  else
  {
    v5 = dword_AE400;
    *(_BYTE *)(a1 + 70) = 2;
    *(_WORD *)(a1 + 46) = 0;
    sub_55370((a1 - (v5 + 29795)) / 164, -1, 16);
  }
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 93A90: using guessed type int dword_93A90;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00045FC0) --------------------------------------------------------
int sub_45FC0(int a1)
{
  __int16 v1; // cx
  int v2; // edi
  __int16 v3; // ax
  __int16 v4; // si
  int v5; // eax
  int result; // eax
  unsigned __int16 v7; // di
  int v8; // eax
  int v9; // edx
  int v10; // eax
  char *v11; // esi
  char *v12; // edi
  char v13; // al
  char v14; // al
  int v15; // eax
  unsigned int v16; // ebp
  __int16 v17; // dx
  int v18; // esi
  unsigned int v19; // eax
  int v20; // esi
  int v21; // edx
  __int64 v22; // rax
  int v23; // ebp
  unsigned int j; // ebp
  int v25; // ecx
  int i; // [esp+0h] [ebp-14h]

  sub_455D0(a1);
  if ( *(_BYTE *)(dword_AE408 + 99) )
    sub_44BE0(a1, 7);
  v1 = *(_WORD *)(a1 + 46) - 2;
  *(_WORD *)(a1 + 76) += *(_WORD *)(a1 + 46);
  *(_WORD *)(a1 + 46) = v1;
  if ( v1 < -256 )
    *(_WORD *)(a1 + 46) = -256;
  if ( *(__int16 *)(a1 + 46) > 0 )
    *(_WORD *)(a1 + 46) = 0;
  v2 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 12);
  v3 = sub_11F50((__int16 *)(a1 + 72));
  v4 = v3;
  if ( *(__int16 *)(a1 + 76) < v3 + v2 )
    *(_WORD *)(a1 + 76) = *(_WORD *)(*(_DWORD *)(a1 + 156) + 12) + v3;
  v5 = sub_373F0((int)&word_AE454, 10, 1);
  if ( v5 )
  {
    *(_BYTE *)(v5 + 16) |= 0x80u;
    *(_WORD *)(v5 + 24) = *(_WORD *)(a1 + 24);
  }
  result = v4 + *(__int16 *)(*(_DWORD *)(a1 + 156) + 12);
  if ( *(__int16 *)(a1 + 76) == result )
  {
    sub_37220();
    v7 = *(_WORD *)(a1 + 38);
    if ( v7 )
    {
      v8 = dword_AE400 + 164 * v7;
      if ( *(_BYTE *)(v8 + 29859) == 3 && *(_BYTE *)(v8 + 29860) <= 1u )
      {
        v9 = *(_DWORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 38) + 29955);
        v10 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 48);
        ++*(_WORD *)(v9 + 2 * v10 + 30);
      }
    }
    v11 = (char *)dword_AE310;
    v12 = (char *)(dword_AE400
                 + 13323
                 + 2049 * *(__int16 *)(dword_AE400 + 8)
                 + 28
                 + 68 * *(__int16 *)(*(_DWORD *)(a1 + 160) + 48));
    do
    {
      v13 = *v11;
      *v12 = *v11;
      if ( !v13 )
        break;
      v14 = v11[1];
      v11 += 2;
      v12[1] = v14;
      v12 += 2;
    }
    while ( v14 );
    *(_WORD *)(2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 68 * *(__int16 *)(*(_DWORD *)(a1 + 160) + 48) + 13415) = 100;
    memset((void*)(a1 + 90), 0, 36);
    for ( i = 0; i != 96; i += 4 )
    {
      v15 = i + *(_DWORD *)(a1 + 160);
      v16 = dword_AE400 + 29795 + 164 * *(_DWORD *)(v15 + 532);
      if ( v16 <= dword_AE400 + 29795 )
      {
        *(_DWORD *)(v15 + 532) = -1;
      }
      else
      {
        *(_DWORD *)(v15 + 532) = *(char *)(v16 + 65);
        if ( (*(_BYTE *)(v16 + 18) & 4) != 0 )
          *(_BYTE *)(*(_DWORD *)(a1 + 160) + *(char *)(v16 + 65) + 916) = 1;
        else
          *(_BYTE *)(*(char *)(v16 + 65) + *(_DWORD *)(a1 + 160) + 916) = 0;
        *(_BYTE *)(v16 + 16) &= ~1u;
        ++*(_BYTE *)(v16 + 70);
        *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
        *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
        v17 = 9377 * *(_WORD *)(a1 + 4) + 9439;
        *(_DWORD *)(a1 + 4) = 9377 * *(_DWORD *)(a1 + 4) + 9439;
        v18 = *(_DWORD *)(a1 + 4);
        word_AE454 += (v17 & 0x1FF) - 256;
        *(_DWORD *)(a1 + 4) = 9377 * v18 + 9439;
        word_AE456 += ((9377 * v18 + 9439) & 0x1FF) - 256;
        sub_41C70(word_AE456, v16, (int)&word_AE454);
        v19 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
        *(_DWORD *)(a1 + 4) = v19;
        *(_DWORD *)(v16 + 12) = v19 % 0x5A + 200;
      }
    }
    v20 = sub_373F0(a1 + 72, 10, 40);
    if ( v20 )
    {
      v21 = *(_DWORD *)(a1 + 160);
      *(_BYTE *)(a1 + 70) = 3;
      v22 = 255 - *(__int16 *)(v21 + 526);
      v23 = dword_AE408;
      *(_WORD *)(a1 + 26) = 32 * ((int)(v22 - (__CFSHL__(HIDWORD(v22), 3) + 8 * HIDWORD(v22))) >> 3) + 32;
      for ( j = *(_DWORD *)(v23 + 36466); ; j = *(_DWORD *)j )
      {
        v25 = dword_AE400 + 29795;
        if ( j <= dword_AE400 + 29795 )
          break;
        if ( *(_BYTE *)(j + 65) == 39 && *(unsigned __int16 *)(j + 144) == (a1 - v25) / 164 )
          *(_WORD *)(j + 144) = (v20 - v25) / 164;
      }
    }
    result = dword_AE400;
    *(_BYTE *)(a1 + 16) |= 0x20u;
    --*(_DWORD *)(result + 4593);
  }
  return result;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// AE310: using guessed type int dword_AE310;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;

//----- (000463B0) --------------------------------------------------------
int sub_463B0(int a1)
{
  _WORD *v1; // edi
  int result; // eax

  v1 = (_WORD *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 38) + 72);
  *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), v1);
  *(_WORD *)(a1 + 36) = sub_42180((_WORD *)(a1 + 72), v1);
  *(_WORD *)(a1 + 30) += sub_422A0(*(_WORD *)(a1 + 30), *(_WORD *)(a1 + 34), 5, 0x16u);
  *(_BYTE *)(a1 + 31) &= 7u;
  *(_WORD *)(a1 + 32) += sub_422A0(*(_WORD *)(a1 + 32), *(_WORD *)(a1 + 36), 5, 0x16u);
  *(_BYTE *)(a1 + 33) &= 7u;
  *(_WORD *)(a1 + 32) = 0;
  *(_WORD *)(*(_DWORD *)(a1 + 160) + 329) = *(_WORD *)(a1 + 32);
  result = *(_DWORD *)(a1 + 160);
  *(_WORD *)(result + 327) = 0;
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00046480) --------------------------------------------------------
int sub_46480(int a1)
{
  int v1; // ecx
  int v2; // edx
  int result; // eax
  __int16 v4; // cx

  *(_WORD *)(*(_DWORD *)(a1 + 160) + 22) = 0;
  v1 = *(_DWORD *)(a1 + 160);
  v2 = 2049 * *(__int16 *)(v1 + 48);
  result = dword_AE400;
  if ( *(_BYTE *)(dword_AE400 + v2 + 13332) == 1 )
  {
    if ( (*(_BYTE *)(dword_AE408 + 1) & 2) == 0 )
    {
      if ( *(_WORD *)(v1 + 50) )
      {
        v4 = *(_WORD *)(a1 + 26);
        if ( v4 )
          *(_WORD *)(a1 + 26) = v4 - 1;
        else
          return sub_44D30(dword_AE400 + 13323 + v2, a1);
      }
      else
      {
        *(_BYTE *)(dword_AE400 + v2 + 13329) = 0;
      }
    }
  }
  else
  {
    sub_44BE0(a1, 7);
    return sub_463B0(a1);
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00046520) --------------------------------------------------------
int sub_46520(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  v2 = *(_DWORD *)(a1 + 160);
  if ( v2 )
    *(_WORD *)(v2 + 46) = 100;
  return result;
}

//----- (00046540) --------------------------------------------------------
int sub_46540(int a1)
{
  int v1; // edi
  int v3; // esi
  int v4; // eax
  int v5; // eax
  int v6; // eax
  unsigned __int16 v7; // cx
  unsigned int v8; // eax
  int v9; // eax
  int v10; // eax
  char v11; // cl
  unsigned int v12; // eax
  unsigned int v13; // edi
  _WORD *v14; // edi
  int v15; // eax
  int v16; // eax
  int v17; // edx

  v1 = 0;
  if ( *(int *)(a1 + 12) < 0 )
    return 2;
  if ( *(_WORD *)(a1 + 118) )
  {
    v3 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 118);
    if ( v3 )
    {
      *(_WORD *)(*(_DWORD *)(v3 + 160) + 314) = (a1 - (dword_AE400 + 29795)) / 164;
      *(_WORD *)(*(_DWORD *)(v3 + 160) + 316) = 200;
      *(_DWORD *)(*(_DWORD *)(v3 + 160) + 318) = sub_42340((_WORD *)(a1 + 72), (_WORD *)(v3 + 72));
      v4 = *(_DWORD *)(v3 + 160);
      if ( *(int *)(v4 + 318) < 1024 )
        *(_DWORD *)(v4 + 318) = 1024;
      v5 = *(_DWORD *)(v3 + 160);
      if ( *(int *)(v5 + 318) > 3072 )
        *(_DWORD *)(v5 + 318) = 3072;
    }
    v6 = *(_DWORD *)(a1 + 160);
    *(_WORD *)(a1 + 118) = 0;
    *(_BYTE *)(v6 + 392) = 4;
    *(_DWORD *)(*(_DWORD *)(a1 + 160) + 383) = 16;
    sub_46520(a1);
  }
  v7 = *(_WORD *)(a1 + 112);
  if ( v7 )
  {
    v8 = dword_AE400 + 29795 + 164 * v7;
    if ( v8 >= dword_AE400 + 29795 )
    {
      if ( *(_BYTE *)(v8 + 64) == 3 )
        *(_DWORD *)(v8 + 140) += *(_DWORD *)(a1 + 108);
      v9 = *(_DWORD *)(a1 + 160);
      *(_DWORD *)(a1 + 140) -= *(_DWORD *)(a1 + 108);
      *(_BYTE *)(v9 + 392) = 4;
      *(_DWORD *)(*(_DWORD *)(a1 + 160) + 383) = 16;
    }
    sub_46520(a1);
    *(_WORD *)(a1 + 112) = 0;
  }
  if ( *(_WORD *)(a1 + 94) )
  {
    if ( (*(_BYTE *)(a1 + 17) & 0x40) != 0 )
    {
      v10 = (*(_DWORD *)(a1 + 90) - (__CFSHL__(*(int *)(a1 + 90) >> 31, 2) + 4 * (*(int *)(a1 + 90) >> 31))) >> 2;
      *(_DWORD *)(a1 + 140) -= v10;
      v11 = *(_BYTE *)(a1 + 17);
      *(_DWORD *)(a1 + 90) = v10;
      *(_BYTE *)(a1 + 17) = v11 & 0xBF;
    }
    v12 = dword_AE400 + 29795;
    v13 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 94);
    *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
    if ( v13 > v12 )
    {
      v14 = (_WORD *)(v13 + 72);
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 24) = sub_42150(v14, (_WORD *)(a1 + 72));
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 26) = sub_42180(v14, (_WORD *)(a1 + 72));
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 22) = *(_DWORD *)(a1 + 90) / 10;
      v15 = *(_DWORD *)(a1 + 160);
      if ( *(__int16 *)(v15 + 22) < 0 )
        *(_WORD *)(v15 + 22) = 0;
      v16 = *(_DWORD *)(a1 + 160);
      if ( *(__int16 *)(v16 + 22) > 80 )
        *(_WORD *)(v16 + 22) = 80;
    }
    sub_44BE0(a1, 2);
    *(_BYTE *)(*(_DWORD *)(a1 + 160) + 392) = 4;
    v17 = dword_AE400 + 29795;
    *(_DWORD *)(*(_DWORD *)(a1 + 160) + 383) = 16;
    sub_55370((a1 - v17) / 164, -1, 17);
    if ( *(int *)(a1 + 12) < 0 )
    {
      *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 94);
      return 2;
    }
    v1 = 1;
    sub_46520(a1);
    *(_WORD *)(a1 + 94) = 0;
  }
  return v1;
}
// AE400: using guessed type int dword_AE400;

//----- (00046840) --------------------------------------------------------
void sub_46840(int a1)
{
  int v1; // eax
  unsigned __int16 v2; // di
  __int16 v3; // cx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  __int16 v8; // ax
  __int16 v9; // si
  int v10; // eax
  __int16 v11; // di
  __int16 v12; // si
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax

  v1 = *(_DWORD *)(a1 + 160);
  if ( *(_DWORD *)v1 != 48 )
  {
    v3 = 0;
    *(_WORD *)(v1 + 14) = 0;
    v4 = *(_DWORD *)(a1 + 160);
    if ( (*(_BYTE *)v4 & 1) != 0 && *(__int16 *)(v4 + 12) < dword_93A90 )
      v3 = 1;
    v5 = *(_DWORD *)(a1 + 160);
    if ( (*(_BYTE *)v5 & 2) != 0 && *(__int16 *)(v5 + 12) > dword_93A8C )
      v3 = -1;
    if ( v3 )
    {
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 12) += dword_93A88 * v3;
      v6 = *(_DWORD *)(a1 + 160);
      if ( *(__int16 *)(v6 + 12) < dword_93A8C )
        *(_WORD *)(v6 + 12) = dword_93A8C;
      v7 = *(_DWORD *)(a1 + 160);
      if ( *(__int16 *)(v7 + 12) > dword_93A90 )
        *(_WORD *)(v7 + 12) = dword_93A90;
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 14) = 1;
    }
    v8 = 0;
    if ( (**(_BYTE **)(a1 + 160) & 4) != 0 )
      v8 = -1;
    if ( (**(_BYTE **)(a1 + 160) & 8) != 0 )
      v8 = 1;
    if ( v8 )
    {
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 16) += word_93AA8 * v8;
      v16 = *(_DWORD *)(a1 + 160);
      if ( *(__int16 *)(v16 + 16) < dword_93AAC )
        *(_WORD *)(v16 + 16) = dword_93AAC;
      v15 = *(_DWORD *)(a1 + 160);
      if ( *(__int16 *)(v15 + 16) <= dword_93AB0 )
        goto LABEL_37;
    }
    else
    {
      v9 = *(_WORD *)(*(_DWORD *)(a1 + 160) + 16);
      if ( v9 )
        v10 = v9 / (int)abs16(v9);
      else
        LOWORD(v10) = 0;
      v11 = v10;
      *(_WORD *)(*(_DWORD *)(a1 + 160) + 16) += v10 * word_93AB4;
      v12 = *(_WORD *)(*(_DWORD *)(a1 + 160) + 16);
      if ( v12 )
        v13 = v12 / (int)abs16(v12);
      else
        v13 = 0;
      if ( v11 != v13 )
        *(_WORD *)(*(_DWORD *)(a1 + 160) + 16) = 0;
      v14 = *(_DWORD *)(a1 + 160);
      if ( *(__int16 *)(v14 + 16) < dword_93AAC )
        *(_WORD *)(v14 + 16) = dword_93AAC;
      v15 = *(_DWORD *)(a1 + 160);
      if ( *(__int16 *)(v15 + 16) <= dword_93AB0 )
        goto LABEL_37;
    }
    *(_WORD *)(v15 + 16) = dword_93AB0;
LABEL_37:
    sub_46B00(
      a1,
      dword_AE400
    + 29795
    + 164 * *(_DWORD *)(*(_DWORD *)(a1 + 160) + 4 * *(__int16 *)(*(_DWORD *)(a1 + 160) + 940) + 532),
      256,
      16);
    sub_46B00(
      a1,
      164 * *(_DWORD *)(*(_DWORD *)(a1 + 160) + 4 * *(__int16 *)(*(_DWORD *)(a1 + 160) + 944) + 532)
    + dword_AE400
    + 29795,
      512,
      32);
    return;
  }
  v2 = *(_WORD *)(v1 + 50);
  if ( v2 )
    *(_DWORD *)(dword_AE400 + 164 * v2 + 29807) = -1;
}
// 93A88: using guessed type int dword_93A88;
// 93A8C: using guessed type int dword_93A8C;
// 93A90: using guessed type int dword_93A90;
// 93AA8: using guessed type __int16 word_93AA8;
// 93AAC: using guessed type int dword_93AAC;
// 93AB0: using guessed type int dword_93AB0;
// 93AB4: using guessed type __int16 word_93AB4;
// AE400: using guessed type int dword_AE400;

//----- (00046B00) --------------------------------------------------------
void sub_46B00(int a1, unsigned int a2, int a3, int a4)
{
  int v4; // edx
  unsigned __int8 v5; // al
  int v6; // edi
  int v7; // edi
  int v8; // eax

  if ( a2 <= dword_AE400 + 29795 )
    return;
  v4 = *(_DWORD *)(a1 + 160);
  if ( (a4 & *(_DWORD *)v4) == 0 )
  {
    if ( !*(_BYTE *)(a2 + 61) || (a3 & *(_DWORD *)(a1 + 16)) == 0 )
      return;
    goto LABEL_32;
  }
  v5 = *(_BYTE *)(a2 + 65);
  if ( v5 < 0x10u )
  {
    if ( v5 != 2 )
      goto LABEL_20;
    v6 = 164 * *(__int16 *)(v4 + 718) + dword_AE400;
    if ( *(_WORD *)(v6 + 29843) )
      *(_WORD *)(v6 + 29843) = 0;
    if ( *(_DWORD *)(a1 + 140) >= *(_DWORD *)(a2 + 136) )
    {
LABEL_20:
      if ( *(_BYTE *)(a2 + 62) )
      {
        ++*(_BYTE *)(a2 + 61);
        v8 = *(_DWORD *)(a1 + 140) / *(_DWORD *)(a2 + 136);
        if ( (__int16)v8 > *(char *)(a2 + 62) )
          LOWORD(v8) = *(char *)(a2 + 62);
        if ( *(char *)(a2 + 61) < 0 )
          *(_BYTE *)(a2 + 61) = 0;
        if ( *(char *)(a2 + 61) > (__int16)v8 )
          *(_BYTE *)(a2 + 61) = v8;
        *(_BYTE *)(a1 + 17) &= 0xFCu;
        *(_DWORD *)(a1 + 16) |= a3;
        return;
      }
      if ( *(_DWORD *)(a1 + 140) < *(_DWORD *)(a2 + 136) )
        return;
LABEL_32:
      *(_WORD *)(a2 + 48) = *(_WORD *)(a2 + 50);
      *(_BYTE *)(a1 + 17) &= 0xFCu;
      *(_DWORD *)(a1 + 16) |= a3;
      *(_BYTE *)(a1 + 16) &= ~0x20u;
    }
  }
  else
  {
    if ( v5 <= 0x10u )
    {
      if ( *(_WORD *)(a2 + 48) )
      {
        sub_55370(0, *(_WORD *)(v4 + 48), 29);
        return;
      }
      if ( *(_DWORD *)(a1 + 140) < *(_DWORD *)(a2 + 136) )
        return;
      goto LABEL_32;
    }
    if ( v5 != 21 )
      goto LABEL_20;
    v7 = 164 * *(__int16 *)(v4 + 680) + dword_AE400;
    if ( *(_WORD *)(v7 + 29843) )
      *(_WORD *)(v7 + 29843) = 0;
    if ( *(_DWORD *)(a1 + 140) >= *(_DWORD *)(a2 + 136) )
      goto LABEL_20;
  }
}
// AE400: using guessed type int dword_AE400;

//----- (00046CA0) --------------------------------------------------------
unsigned int sub_46CA0(int a1, int a2, int a3)
{
  unsigned int v3; // esi
  unsigned int v4; // edi
  unsigned int i; // ebx
  unsigned int v6; // eax

  v3 = -1;
  v4 = 0;
  for ( i = *(_DWORD *)(dword_AE408 + 36466); i > dword_AE400 + 29795; i = *(_DWORD *)i )
  {
    if ( *(_BYTE *)(i + 65) == 39 && *(unsigned __int16 *)(i + 144) == *(__int16 *)(a1 + 24) && i != a2 && i != a3 )
    {
      v6 = sub_42390((_WORD *)(a1 + 72), (_WORD *)(i + 72));
      if ( v6 < v3 )
      {
        v4 = i;
        v3 = v6;
      }
    }
  }
  return v4;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00046D20) --------------------------------------------------------
int sub_46D20(int a1, __int16 a2)
{
  int result; // eax
  __int16 v3; // bx
  int v4; // eax
  int v5; // edx

  result = *(_DWORD *)(dword_AE400 + 164 * *(__int16 *)(a1 + 24) + 29955);
  v3 = *(_WORD *)(result + 708);
  if ( v3 )
  {
    if ( a2 )
    {
      v4 = 164 * v3;
      v5 = v4 + dword_AE400;
      LOWORD(v4) = *(_WORD *)(v4 + dword_AE400 + 29845);
      result = v4 - 1;
      *(_WORD *)(v5 + 29843) = result;
    }
    else
    {
      result = 41 * v3;
      *(_WORD *)(dword_AE400 + 164 * v3 + 29843) = 0;
    }
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00046DB0) --------------------------------------------------------
__int16 sub_46DB0(int a1)
{
  int v1; // eax
  char v2; // dl
  unsigned int i; // ebx

  LOWORD(v1) = *(_WORD *)(a1 + 50);
  if ( (_WORD)v1 )
  {
    if ( (_WORD)v1 == 1 )
    {
      *(_BYTE *)(a1 + 70) = 5;
      *(_WORD *)(a1 + 48) = 3;
      *(_WORD *)(a1 + 50) = 0;
    }
    else
    {
      --*(_WORD *)(a1 + 50);
      sub_46D20(a1, 1);
      LOWORD(v1) = sub_11F50((__int16 *)(a1 + 72));
      *(_WORD *)(a1 + 76) = v1;
    }
  }
  else
  {
    if ( sub_47EC0(a1) == 2 )
    {
      *(_BYTE *)(a1 + 70) = 6;
    }
    else if ( (*(_BYTE *)(a1 + 16) & 0x40) != 0 )
    {
      *(_WORD *)(a1 + 48) = 0;
      *(_BYTE *)(a1 + 70) = 5;
    }
    *(_WORD *)(a1 + 76) = sub_11F50((__int16 *)(a1 + 72));
    LOWORD(v1) = *(_WORD *)(a1 + 24);
    v2 = *(_BYTE *)(a1 + 63);
    *(_WORD *)(a1 + 144) = v1;
    if ( (v2 & 1) == 0 )
    {
      sub_47130(a1);
      sub_37150((_WORD *)a1, *(_WORD *)(a1 + 26));
      sub_47400(a1);
      v1 = *(_DWORD *)(a1 + 140);
      if ( v1 < *(_DWORD *)(a1 + 136) )
      {
        for ( i = *(_DWORD *)(dword_AE408 + 36466); ; i = *(_DWORD *)i )
        {
          LOWORD(v1) = dword_AE400 + 29795;
          if ( i <= dword_AE400 + 29795 )
            break;
          if ( *(_BYTE *)(i + 65) == 39 && *(unsigned __int16 *)(i + 144) == *(__int16 *)(a1 + 24) && sub_11950(a1, i) )
          {
            *(_DWORD *)(a1 + 140) += *(_DWORD *)(i + 140);
            LOWORD(v1) = sub_41E80(i);
            return v1;
          }
        }
      }
    }
  }
  return v1;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00046F10) --------------------------------------------------------
char sub_46F10(int a1)
{
  __int16 v1; // ax
  char v2; // dh
  __int16 v3; // cx
  __int16 v4; // ax

  v1 = *(_WORD *)(a1 + 48);
  switch ( v1 )
  {
    case 0:
      sub_12C50((_WORD *)a1);
      if ( !*(_WORD *)(a1 + 26) || (LOBYTE(v1) = sub_12D10((_WORD *)a1), (_BYTE)v1) )
      {
        if ( (*(_BYTE *)(a1 + 16) & 2) == 0 )
        {
          v3 = *(_WORD *)(a1 + 86);
          v4 = *(_WORD *)(*(_DWORD *)(164 * *(__int16 *)(a1 + 24) + dword_AE400 + 29955) + 48);
          *(_BYTE *)(a1 + 16) |= 2u;
          *(_WORD *)(a1 + 86) = v4 + v3;
        }
        LOBYTE(v1) = sub_47960(a1);
      }
      else
      {
        v2 = *(_BYTE *)(a1 + 16);
        *(_WORD *)(a1 + 48) = 2;
        *(_BYTE *)(a1 + 16) = v2 & 0xBF;
      }
      break;
    case 1:
    case 4:
    case 6:
      v1 = sub_11F50((__int16 *)(a1 + 72));
      *(_WORD *)(a1 + 76) = v1;
      break;
    case 2:
      *(_BYTE *)(a1 + 70) = 4;
      LOBYTE(v1) = sub_46D20(a1, 0);
      *(_WORD *)(a1 + 48) = 0;
      break;
    case 3:
      sub_46D20(a1, 1);
      LOBYTE(v1) = sub_47020(a1);
      break;
    case 5:
      sub_46D20(a1, 1);
      *(_WORD *)(a1 + 76) = sub_11F50((__int16 *)(a1 + 72));
      LOBYTE(v1) = sub_47080(a1);
      break;
    default:
      return v1;
  }
  return v1;
}
// AE400: using guessed type int dword_AE400;

//----- (00047020) --------------------------------------------------------
int sub_47020(int a1)
{
  int result; // eax
  int v2; // ebx

  result = sub_373F0(a1 + 150, 10, 42);
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 71) = *(_BYTE *)(a1 + 26);
    *(_WORD *)(result + 24) = *(_WORD *)(a1 + 24);
    result = (a1 - (dword_AE400 + 29795)) / 164;
    *(_WORD *)(v2 + 42) = result;
    *(_WORD *)(a1 + 48) = 4;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00047080) --------------------------------------------------------
int sub_47080(int a1)
{
  int result; // eax
  int v2; // ebx

  result = sub_373F0(a1 + 150, 10, 41);
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 71) = *(_BYTE *)(a1 + 26);
    *(_WORD *)(result + 24) = *(_WORD *)(a1 + 24);
    result = (a1 - (dword_AE400 + 29795)) / 164;
    *(_WORD *)(v2 + 42) = result;
    *(_WORD *)(a1 + 48) = 6;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (000470E0) --------------------------------------------------------
int sub_470E0(int a1)
{
  int result; // eax

  result = sub_37710();
  if ( result )
  {
    sub_47A70(a1);
    *(_BYTE *)(a1 + 70) = 4;
    sub_47130(a1);
    result = sub_47400(a1);
    *(_WORD *)(a1 + 48) = 0;
    *(_WORD *)(a1 + 50) = 5;
  }
  else
  {
    *(_BYTE *)(a1 + 70) = 4;
  }
  return result;
}

//----- (00047130) --------------------------------------------------------
int sub_47130(int a1)
{
  int v1; // esi
  int result; // eax
  int v3; // ebp
  int v4; // esi
  int v5; // eax
  int v6; // esi
  int v7; // ecx
  int v8; // edi
  __int16 v9; // ax
  unsigned int v10; // eax
  int v11; // eax
  __int16 v12; // ax
  int v13; // edi
  int j; // ebp
  int v15; // esi
  int v16; // eax
  __int16 v17; // ax
  __int16 v18; // [esp-4h] [ebp-24h]
  int v19; // [esp+0h] [ebp-20h]
  int i; // [esp+8h] [ebp-18h]
  __int16 v21; // [esp+Ch] [ebp-14h]

  v1 = *(_DWORD *)(a1 + 136);
  result = *(_DWORD *)(*(_DWORD *)(dword_AE400 + 164 * *(__int16 *)(a1 + 24) + 29955) + 308) + *(_DWORD *)(a1 + 140);
  v3 = 0;
  if ( result > v1 )
    v3 = *(_DWORD *)(a1 + 140) - v1;
  if ( !*(_WORD *)(a1 + 26) )
    v3 = *(_DWORD *)(a1 + 140);
  if ( v3 > 0 )
  {
    v4 = v3 / 1000;
    v21 = sub_37710();
    if ( v21
      || (sub_37220(), result = sub_37710(), v4 = 8, v21 = result, *(_DWORD *)(dword_AE400 + 4593) = -1, (_WORD)result) )
    {
      if ( v4 < 1 )
        v4 = 1;
      if ( v4 > 32 )
        v4 = 32;
      if ( v21 < 0 )
        v21 = 0;
      if ( v21 > v4 )
        v21 = v4;
      v19 = v3 / v21;
      for ( i = 0; v21 > i; ++i )
      {
        *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
        *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
        v5 = sub_373F0((int)&word_AE454, 10, 39);
        v6 = v5;
        if ( v5 )
        {
          *(_DWORD *)(v5 + 140) = v19;
          v7 = *(_DWORD *)(v5 + 4);
          *(_WORD *)(v5 + 144) = *(_WORD *)(a1 + 24);
          *(_DWORD *)(v5 + 4) = 9377 * v7 + 9439;
          *(_WORD *)(v5 + 150) = 0;
          *(_WORD *)(v5 + 152) = 0;
          *(_WORD *)(v5 + 126) = (9377 * v7 + 9439) % 0x30u + 16;
          v8 = *(__int16 *)(a1 + 76);
          v9 = sub_11F50((__int16 *)(a1 + 72));
          *(_WORD *)(v6 + 46) = (1024
                               - (v8
                                - v9)
                               - (__CFSHL__((1024 - (v8 - v9)) >> 31, 3)
                                + 8 * ((1024 - (v8 - v9)) >> 31))) >> 3;
          v10 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
          *(_DWORD *)(a1 + 4) = v10;
          v18 = v10 % 0x1400 + 3840;
          v11 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
          *(_DWORD *)(a1 + 4) = v11;
          v12 = (unsigned __int16)sub_41EC0((uint16*)&word_AE454, v11 & 0x7FF, 0, v18);
          sub_41C70(v12, v6, (int)&word_AE454);
          v13 = *(_DWORD *)(v6 + 140);
          v3 -= v13;
          *(_DWORD *)(a1 + 140) -= v13;
          if ( v3 < v19 )
            v19 = v3;
        }
      }
      for ( j = 0; j < 4; ++j )
      {
        *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
        *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
        result = sub_373F0((int)&word_AE454, 10, 54);
        v15 = result;
        if ( result )
        {
          *(_WORD *)(result + 24) = *(_WORD *)(a1 + 24);
          v16 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
          *(_DWORD *)(a1 + 4) = v16;
          v17 = (unsigned __int16)sub_41EC0((uint16*)&word_AE454, v16 & 0x7FF, 0, 6400);
          result = sub_41C70(v17, v15, (int)&word_AE454);
        }
      }
    }
  }
  return result;
}
// 47195: conditional instruction was optimized away because ebp.4>=1
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;

//----- (00047400) --------------------------------------------------------
int sub_47400(int a1)
{
  int v1; // ebp
  __int16 v2; // dx
  __int16 v3; // bx
  int i; // esi
  int v5; // edx
  int v6; // eax
  int v7; // edi
  int v8; // ecx
  unsigned int v9; // ebx
  unsigned int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // edi
  unsigned int v14; // ebx
  int result; // eax
  __int16 v16; // bx
  int v17; // edi
  _BYTE *v18; // eax
  int v19; // ebx
  int v20; // edx
  int v21; // [esp+Ch] [ebp-2Ch]
  int v22; // [esp+1Ch] [ebp-1Ch]
  __int16 v23; // [esp+20h] [ebp-18h]
  __int16 v24; // [esp+24h] [ebp-14h]

  v1 = dword_AE400 + 29795 + 164 * *(__int16 *)(a1 + 24);
  switch ( *(_WORD *)(a1 + 26) )
  {
    case 1:
      v2 = 1;
      v3 = 0;
      goto LABEL_10;
    case 2:
      v24 = 1;
      v23 = 0;
      break;
    case 3:
      v24 = 1;
      v23 = 4;
      break;
    case 4:
      v2 = 2;
      v3 = 6;
      goto LABEL_10;
    case 5:
      v24 = 2;
      v23 = 14;
      break;
    case 6:
      v24 = 3;
      v23 = 18;
      break;
    case 7:
      v2 = 3;
      v3 = 34;
LABEL_10:
      v24 = v2;
      v23 = v3;
      break;
    default:
      v24 = 0;
      v23 = 0;
      break;
  }
  for ( i = 0; (__int16)i < v24; ++i )
  {
    while ( 1 )
    {
      *(_DWORD *)(*(_DWORD *)(v1 + 160) + 294) = 0;
      v5 = *(_DWORD *)(v1 + 160);
      v21 = 2 * (__int16)i;
      v6 = 164 * *(unsigned __int16 *)(v5 + v21 + 52);
      v7 = dword_AE400;
      v8 = dword_AE400 + 29795;
      v9 = dword_AE400 + 29795 + v6;
      if ( v9 <= dword_AE400 + 29795 )
      {
        v12 = sub_373F0(a1 + 72, 3, 3);
        if ( v12 )
        {
          *(_WORD *)(v12 + 24) = *(_WORD *)(a1 + 24);
          *(_WORD *)(v12 + 86) += *(_WORD *)(*(_DWORD *)(v1 + 160) + 48);
          *(_WORD *)(v12 + 144) = *(_WORD *)(a1 + 24);
          *(_WORD *)(v21 + *(_DWORD *)(v1 + 160) + 52) = (v12 - (dword_AE400 + 29795)) / 164;
          *(_BYTE *)(v12 + 70) = 9;
        }
        goto LABEL_27;
      }
      if ( *(int *)(v9 + 12) >= 0 )
        break;
      sub_27690((_WORD *)v6, dword_AE400 + 29795 + v6);
      sub_41E80(v9);
      *(_WORD *)(v21 + *(_DWORD *)(v1 + 160) + 52) = 0;
LABEL_27:
      if ( (__int16)++i >= v24 )
        goto LABEL_32;
    }
    if ( *(_DWORD *)(v5 + 308) + *(_DWORD *)(a1 + 140) >= *(_DWORD *)(a1 + 136) )
    {
      LOWORD(v11) = (a1 - v8) / 164;
    }
    else
    {
      if ( *(unsigned __int8 *)(a1 + 63) % v24 )
        goto LABEL_23;
      if ( *(_BYTE *)(v9 + 70) != 9 )
        goto LABEL_23;
      *(_WORD *)(v9 + 146) = (a1 - v8) / 164;
      if ( *(_DWORD *)(v9 + 136) <= *(_DWORD *)(v9 + 140) )
        goto LABEL_23;
      *(_WORD *)(v7 + 29941) = 0;
      v10 = sub_46CA0(
              v9,
              v8
            + 164
            * *(unsigned __int16 *)(164 * *(unsigned __int16 *)(*(_DWORD *)(v1 + 160) + 2 * (((__int16)i + 1) % 3) + 52)
                                  + v7
                                  + 29941),
              v8
            + 164
            * *(unsigned __int16 *)(v7
                                  + 164 * *(unsigned __int16 *)(*(_DWORD *)(v1 + 160) + 2 * (((__int16)i + 2) % 3) + 52)
                                  + 29941));
      if ( !v10 )
        goto LABEL_23;
      v11 = (int)(v10 - (dword_AE400 + 29795)) / 164;
    }
    *(_WORD *)(v9 + 146) = v11;
LABEL_23:
    *(_DWORD *)(*(_DWORD *)(v1 + 160) + 294) += *(_DWORD *)(v9 + 140);
    *(_DWORD *)(*(_DWORD *)(v1 + 160) + 290) += *(_DWORD *)(v9 + 136);
  }
LABEL_32:
  while ( (__int16)i < 3 )
  {
    v13 = 2 * (__int16)i;
    v14 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(v13 + *(_DWORD *)(v1 + 160) + 52);
    if ( v14 > dword_AE400 + 29795 )
    {
      sub_27690(
        (_WORD *)(dword_AE400 + 29795),
        dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(v13 + *(_DWORD *)(v1 + 160) + 52));
      sub_41E80(v14);
      *(_WORD *)(v13 + *(_DWORD *)(v1 + 160) + 52) = 0;
    }
    LOWORD(i) = i + 1;
  }
  result = a1;
  v16 = *(_WORD *)(a1 + 46);
  if ( v16 > 0 )
    *(_WORD *)(a1 + 46) = v16 - 1;
  v22 = 0;
  if ( v23 > 0 )
  {
    do
    {
      v17 = 2 * (__int16)v22;
      v18 = (_BYTE *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(v17 + *(_DWORD *)(v1 + 160) + 84));
      if ( (unsigned int)v18 <= dword_AE400 + 29795 )
      {
        if ( !*(_WORD *)(a1 + 46) )
        {
          v19 = sub_373F0(a1 + 72, 5, 15);
          if ( v19 )
          {
            *(_WORD *)(a1 + 46) = 16;
            *(_WORD *)(v19 + 24) = *(_WORD *)(a1 + 24);
            v20 = dword_AE400 + 29795;
            *(_WORD *)(v19 + 144) = *(_WORD *)(a1 + 24);
            *(_WORD *)(v17 + *(_DWORD *)(v1 + 160) + 84) = (v19 - v20) / 164;
            *(_WORD *)(v19 + 30) = 512;
            *(_WORD *)(v19 + 34) = *(_WORD *)(v19 + 30);
            *(_DWORD *)&word_AE454 = *(_DWORD *)(v19 + 72);
            *(&word_AE454 + 2) = *(_WORD *)(v19 + 76);
            word_AE454 += 128;
            word_AE456 += 640;
            word_AE458 = sub_11F50(&word_AE454);
            sub_41C70(word_AE458, v19, (int)&word_AE454);
          }
        }
      }
      else if ( v18[64] != 5 || v18[65] != 15 || v18[70] == 95 )
      {
        *(_WORD *)(*(_DWORD *)(v1 + 160) + 2 * (__int16)v22 + 84) = 0;
        *(_WORD *)(a1 + 46) = 16;
      }
      result = v22 + 1;
      v22 = result;
    }
    while ( (__int16)result < v23 );
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;
// AE458: using guessed type __int16 word_AE458;

//----- (00047960) --------------------------------------------------------
char sub_47960(int a1)
{
  int v1; // eax
  int v2; // esi
  __int16 v3; // dx
  int v4; // ecx
  __int16 v6; // [esp-4h] [ebp-10h]

  v1 = sub_3B7B0(a1 + 150);
  v2 = v1;
  if ( v1 )
  {
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 10);
    v3 = *(_WORD *)(a1 + 26);
    *(_BYTE *)(a1 + 16) &= ~0x40u;
    *(_WORD *)(a1 + 26) = v3 + 1;
    v6 = *(_WORD *)(a1 + 26);
    *(_BYTE *)(a1 + 70) = 5;
    *(_WORD *)(a1 + 48) = 4;
    sub_37150((_WORD *)a1, v6);
    sub_47C60(a1);
    v4 = dword_AE400 + 29795 + 164 * *(__int16 *)(a1 + 24);
    v1 = (a1 - (dword_AE400 + 29795)) / 164;
    *(_WORD *)(*(_DWORD *)(v4 + 160) + 50) = v1;
    *(_WORD *)(*(_DWORD *)(v4 + 160) + 416) = *(_WORD *)(a1 + 26);
    *(_WORD *)(v2 + 42) = v1;
    *(_WORD *)(v2 + 24) = *(_WORD *)(a1 + 24);
    LOBYTE(v3) = *(_BYTE *)(v2 + 18);
    LOBYTE(v1) = *(_BYTE *)(a1 + 26);
    *(_BYTE *)(v2 + 60) = 0;
    *(_BYTE *)(v2 + 71) = v1;
    *(_BYTE *)(v2 + 18) = v3 | 1;
  }
  return v1;
}
// AE400: using guessed type int dword_AE400;

//----- (00047A70) --------------------------------------------------------
int sub_47A70(int a1)
{
  int v1; // esi
  int v2; // edx
  int v3; // ecx
  int v4; // edi
  int result; // eax
  __int16 v6; // [esp-4h] [ebp-10h]

  if ( *(__int16 *)(a1 + 26) > 0 )
  {
    v1 = 10 * *(_DWORD *)(a1 + 136) / 100;
    *(_DWORD *)(a1 + 136) -= v1;
    sub_47130(a1);
    v2 = a1 - (dword_AE400 + 29795);
    *(_DWORD *)(a1 + 136) += v1;
    sub_55370(v2 / 164, -1, 30);
    v3 = dword_AE400;
    v4 = dword_AE400 + 29867;
    *(_DWORD *)(dword_AE400 + 29867) = *(_DWORD *)(a1 + 150);
    *(_WORD *)(v4 + 4) = *(_WORD *)(a1 + 154);
    *(_BYTE *)(v3 + 29866) = *(_BYTE *)(a1 + 26);
    *(_WORD *)(v3 + 29819) = *(_WORD *)(a1 + 24);
    *(_BYTE *)(v3 + 29860) = 0;
    *(_WORD *)(v3 + 29821) = 0;
    *(_WORD *)(v3 + 29837) = (a1 - (v3 + 29795)) / 164;
    sub_28FE0(v3 + 29795);
    v6 = *(_WORD *)(a1 + 26) - 1;
    *(_WORD *)(a1 + 26) = v6;
    sub_37150((_WORD *)a1, v6);
    sub_47C60(a1);
    result = sub_46D20(a1, 1);
  }
  if ( !*(_WORD *)(a1 + 26) )
  {
    sub_46D20(a1, 0);
    *(_WORD *)(*(_DWORD *)(164 * *(__int16 *)(a1 + 24) + dword_AE400 + 29955) + 50) = 0;
    return sub_41E80(a1);
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00047BD0) --------------------------------------------------------
int sub_47BD0(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // edx
  int v6; // ecx

  result = a3;
  if ( a3 )
  {
    v5 = a1[3];
    v6 = 0;
    a1[2] = a3;
    if ( v5 < 0 )
    {
      v6 = -v5;
      if ( -v5 > a3 / 2 )
        v6 = a3 / 2;
    }
    result = a1[2] - v6;
    a1[3] = result;
  }
  if ( a2 )
  {
    result = a4 / *(__int16 *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = a4;
    *(_DWORD *)(a2 + 140) = result;
  }
  a1[34] = a4;
  return result;
}

//----- (00047C60) --------------------------------------------------------
int sub_47C60(int a1)
{
  int v1; // eax
  __int16 v2; // bx
  int result; // eax

  v1 = 164 * *(__int16 *)(a1 + 24) + dword_AE400 + 29795;
  if ( *(_BYTE *)(v1 + 70) <= 1u && (v2 = *(_WORD *)(*(_DWORD *)(v1 + 160) + 708)) != 0 )
    result = 164 * v2 + dword_AE400 + 29795;
  else
    result = 0;
  switch ( *(_WORD *)(a1 + 26) )
  {
    case 0:
      result = sub_47BD0((_DWORD *)a1, result, 0, 5000);
      break;
    case 1:
      result = sub_47BD0((_DWORD *)a1, result, 20000, 10000);
      break;
    case 2:
      result = sub_47BD0((_DWORD *)a1, result, 40000, 20000);
      break;
    case 3:
      result = sub_47BD0((_DWORD *)a1, result, 40000, 40000);
      break;
    case 4:
      result = sub_47BD0((_DWORD *)a1, result, 60000, (int)&loc_13880);
      break;
    case 5:
      result = sub_47BD0((_DWORD *)a1, result, 60000, (int)&loc_270FA + 6);
      break;
    case 6:
      result = sub_47BD0((_DWORD *)a1, result, (int)&loc_13880, (int)&loc_4E200);
      break;
    case 7:
      result = sub_47BD0((_DWORD *)a1, result, (int)&loc_13880, 30000000);
      break;
    default:
      return result;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00047DD0) --------------------------------------------------------
int sub_47DD0(int a1)
{
  int v1; // ebx
  int result; // eax
  __int16 v3; // dx
  int v4; // ebx
  _BOOL1 v5; // zf
  int v6; // ebx
  int v7; // edx
  int v8; // ecx

  v1 = dword_AE400 + 29795 + 164 * *(__int16 *)(a1 + 24);
  BYTE1(result) = *(_BYTE *)(v1 + 70);
  if ( BYTE1(result) <= 1u && (v3 = *(_WORD *)(*(_DWORD *)(v1 + 160) + 708)) != 0 )
  {
    v4 = 164 * v3;
    v5 = dword_AE400 + 29795 + v4 == 0;
    v6 = dword_AE400 + 29795 + v4;
  }
  else
  {
    v6 = 0;
    v5 = 1;
  }
  if ( !v5 )
  {
    switch ( *(_WORD *)(a1 + 26) )
    {
      case 0:
        v7 = 5000;
        break;
      case 1:
        v7 = 10000;
        break;
      case 2:
        v7 = 20000;
        break;
      case 3:
        v7 = 40000;
        break;
      case 4:
        v7 = (int)&loc_13880;
        break;
      case 5:
        v7 = (int)&loc_270FA + 6;
        break;
      case 6:
        v7 = (int)&loc_4E200;
        break;
      case 7:
        v7 = 30000000;
        break;
      default:
        v7 = 0;
        break;
    }
    v8 = *(__int16 *)(v6 + 50);
    *(_DWORD *)(v6 + 136) = v7;
    result = v7 / v8;
    *(_DWORD *)(v6 + 140) = v7 / v8;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00047EC0) --------------------------------------------------------
int sub_47EC0(int a1)
{
  int v1; // esi
  int v3; // ecx
  __int16 v4; // ax
  int v5; // edx
  int v6; // eax

  v1 = 0;
  if ( *(int *)(a1 + 12) < 0 )
    return 2;
  if ( *(_WORD *)(a1 + 94) )
  {
    v3 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 90);
    *(_DWORD *)(a1 + 12) = v3;
    if ( v3 < 0 )
    {
      v4 = *(_WORD *)(a1 + 94);
      *(_WORD *)(a1 + 94) = 0;
      *(_WORD *)(a1 + 38) = v4;
      return 2;
    }
    v5 = *(__int16 *)(a1 + 24);
    *(_WORD *)(a1 + 94) = 0;
    v6 = dword_AE400;
    *(_DWORD *)(a1 + 90) = 0;
    v1 = 1;
    *(_BYTE *)(*(_DWORD *)(164 * v5 + v6 + 29955) + 391) = 4;
  }
  if ( *(unsigned __int16 *)(a1 + 124) == *(__int16 *)(a1 + 24) )
  {
    if ( *(__int16 *)(a1 + 26) < 7 )
      *(_BYTE *)(a1 + 16) |= 0x40u;
    *(_WORD *)(a1 + 124) = 0;
  }
  return v1;
}
// AE400: using guessed type int dword_AE400;

//----- (00047F90) --------------------------------------------------------
int sub_47F90(int a1)
{
  unsigned int v1; // ebp
  char v2; // ah
  signed int v3; // esi
  int v4; // eax
  __int16 v5; // ax
  signed int v6; // eax
  unsigned int v7; // edi
  int v8; // esi
  int v9; // edx
  __int16 *v10; // edx
  __int16 v11; // ax
  __int16 v12; // ax
  int v14; // [esp-Ch] [ebp-1Ch]
  int v15; // [esp-8h] [ebp-18h]
  int v16; // [esp-4h] [ebp-14h]

  v1 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 146);
  if ( v1 > dword_AE400 + 29795 )
  {
    *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
    *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
    *(_WORD *)(a1 + 30) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(v1 + 72));
    v2 = *(_BYTE *)(v1 + 64);
    if ( v2 == 10 )
    {
      if ( *(unsigned __int16 *)(v1 + 144) != *(__int16 *)(a1 + 24) )
      {
LABEL_17:
        v10 = *(__int16 **)(a1 + 156);
        v16 = v10[7];
        v15 = v10[5];
        v14 = v10[6];
        v11 = sub_11F50(&word_AE454);
        v12 = sub_42000((int)&word_AE454, v11, v14, v15, v16);
        sub_41C70(v12, a1, (int)&word_AE454);
        return sub_481D0(a1);
      }
      v3 = sub_423D0((uint16*)&word_AE454, (_WORD *)(v1 + 72));
      if ( v3 > 1024 )
      {
        *(_BYTE *)(v1 + 16) &= ~0x40u;
      }
      else
      {
        v4 = (a1 - (dword_AE400 + 29795)) / 164;
        *(_BYTE *)(v1 + 16) |= 0x40u;
        *(_WORD *)(v1 + 146) = v4;
        if ( sub_11950(v1, a1) )
        {
          *(_DWORD *)(a1 + 140) += *(_DWORD *)(v1 + 140);
          v5 = *(_WORD *)(v1 + 144);
          *(_WORD *)(a1 + 146) = 0;
          *(_WORD *)(a1 + 144) = v5;
          *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
          sub_41E80(v1);
        }
      }
      v6 = *(__int16 *)(a1 + 126);
      if ( v3 <= v6 )
      {
        word_AE454 = *(_WORD *)(v1 + 72);
        word_AE456 = *(_WORD *)(v1 + 74);
        goto LABEL_17;
      }
    }
    else
    {
      if ( v2 == 3 )
      {
        v7 = *(__int16 *)(v1 + 26) * *(__int16 *)(a1 + 126);
        if ( sub_423D0((uint16*)&word_AE454, (_WORD *)(v1 + 72)) <= v7 )
        {
          v8 = *(__int16 *)(*(_DWORD *)(a1 + 156) + 12);
          if ( word_AE458 <= v8 + (__int16)sub_11F50(&word_AE454) && *(__int16 *)(v1 + 26) > 0 )
          {
            word_AE454 = *(_WORD *)(v1 + 72);
            v9 = *(_DWORD *)(v1 + 140);
            word_AE456 = *(_WORD *)(v1 + 74);
            *(_DWORD *)(v1 + 140) = *(_DWORD *)(a1 + 140) + v9;
            *(_DWORD *)(a1 + 140) = 0;
            *(_WORD *)(a1 + 144) = *(_WORD *)(a1 + 24);
            *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
          }
          goto LABEL_17;
        }
      }
      LOWORD(v6) = *(_WORD *)(a1 + 126);
    }
    sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 32), v6);
    goto LABEL_17;
  }
  return sub_481D0(a1);
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;
// AE458: using guessed type __int16 word_AE458;

//----- (000481D0) --------------------------------------------------------
int sub_481D0(int a1)
{
  int v1; // edx
  int v3; // edx

  v1 = 0;
  if ( *(int *)(a1 + 12) < 0 )
    return 2;
  if ( *(_WORD *)(a1 + 94) )
  {
    v3 = *(_DWORD *)(a1 + 160);
    *(_DWORD *)(a1 + 12) -= *(_DWORD *)(a1 + 90);
    *(_BYTE *)(v3 + 393) = 4;
    if ( *(int *)(a1 + 12) < 0 )
    {
      *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 94);
      return 2;
    }
    v1 = 1;
    *(_WORD *)(a1 + 94) = 0;
  }
  return v1;
}

//----- (00048230) --------------------------------------------------------
int sub_48230(int a1)
{
  unsigned __int16 v1; // cx
  int i; // edx
  int v3; // eax
  int v4; // ebx
  int v5; // eax
  int v6; // edx
  unsigned int v7; // ebx
  int result; // eax
  unsigned __int8 v9; // al
  char v10; // ah
  unsigned __int8 v11; // al
  int v12; // eax

  v1 = 0;
  for ( i = dword_AE400 + 13323; ; i += 2049 )
  {
    v4 = dword_AE400;
    if ( v1 >= *(_WORD *)(dword_AE400 + 10) )
      break;
    v3 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(i + 10);
    *(_DWORD *)(v3 + 136) = *(_DWORD *)(*(_DWORD *)(v3 + 160) + 322);
    ++v1;
    *(_DWORD *)(*(_DWORD *)(v3 + 160) + 308) = 0;
  }
  v5 = dword_AE408;
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 160) + 322);
  *(_DWORD *)(dword_AE408 + 192) = 0;
  v7 = v4 + 29959;
  *(_DWORD *)(v5 + 188) = v6;
  for ( result = dword_AE400 + 193795; v7 < dword_AE400 + 193795; result = dword_AE400 + 193795 )
  {
    v9 = *(_BYTE *)(v7 + 64);
    if ( v9 < 5u )
    {
      if ( v9 != 3 )
        goto LABEL_20;
      v10 = *(_BYTE *)(v7 + 65);
      if ( v10 != 2 && v10 != 3 )
        goto LABEL_20;
    }
    else if ( v9 > 5u )
    {
      if ( v9 != 10 )
        goto LABEL_20;
      v11 = *(_BYTE *)(v7 + 65);
      if ( v11 < 0x27u )
        goto LABEL_20;
      if ( v11 > 0x27u )
      {
        if ( v11 == 45 )
        {
          v12 = sub_48340(v7);
          if ( v12 )
          {
            if ( *(_DWORD *)(v12 + 160) )
              *(_DWORD *)(*(_DWORD *)(v12 + 160) + 308) += *(_DWORD *)(v7 + 140);
          }
        }
        goto LABEL_20;
      }
    }
    sub_48340(v7);
LABEL_20:
    v7 += 164;
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00048340) --------------------------------------------------------
int sub_48340(int a1)
{
  int result; // eax

  result = 0;
  if ( *(_WORD *)(a1 + 144) )
  {
    result = 164 * *(unsigned __int16 *)(a1 + 144) + dword_AE400 + 29795;
    *(_DWORD *)(result + 136) += *(_DWORD *)(a1 + 140);
  }
  *(_DWORD *)(dword_AE408 + 188) += *(_DWORD *)(a1 + 140);
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (000483C0) --------------------------------------------------------
void sub_483C0(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  __int16 *v4; // esi
  __int16 v5; // bx

  if ( byte_939E4 && byte_939E5 && a2 <= (int)(unsigned __int16)word_CC1C6 )
  {
    v4 = word_CBFF0;
    v5 = 0;
    while ( a1 != *v4 || a2 != v4[1] || sub_651F8(dword_CC140, v5) )
    {
      ++v5;
      v4 += 2;
      if ( v5 >= 32 )
        goto LABEL_10;
    }
    sub_65965(dword_CC140, v5);
LABEL_10:
    sub_48570(a1, a2, a3, a4);
  }
}
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// CBFF0: using guessed type __int16 word_CBFF0[];
// CC140: using guessed type int dword_CC140;
// CC1C6: using guessed type __int16 word_CC1C6;

//----- (00048470) --------------------------------------------------------
void sub_48470(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  __int16 *v4; // esi
  __int16 v5; // bx
  char v6; // [esp+0h] [ebp-10h]

  if ( byte_939E4 && byte_939E5 && a2 <= (int)(unsigned __int16)word_CC1C6 )
  {
    v4 = word_CBFF0;
    v5 = 0;
    v6 = 0;
    while ( __PAIR32__(a2, a1) != *(_DWORD *)v4 || sub_651F8(dword_CC140, v5) )
    {
      ++v5;
      v4 += 2;
      if ( v5 >= 32 )
        goto LABEL_9;
    }
    v6 = 1;
LABEL_9:
    if ( !v6 )
      sub_48570(a1, a2, a3, a4);
  }
}
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// CBFF0: using guessed type __int16 word_CBFF0[];
// CC140: using guessed type int dword_CC140;
// CC1C6: using guessed type __int16 word_CC1C6;

//----- (00048520) --------------------------------------------------------
int sub_48520(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  int result; // eax

  if ( byte_939E4 && byte_939E5 )
  {
    result = a2;
    if ( a2 <= (int)(unsigned __int16)word_CC1C6 )
      return sub_48570(a1, a2, a3, a4);
  }
  return result;
}
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// CC1C6: using guessed type __int16 word_CC1C6;

//----- (00048570) --------------------------------------------------------
bool sub_48570(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  __int16 v4; // bx
  bool result; // eax
  int v6; // edx
  int v7; // eax
  int v8; // edx

  v4 = 0;
  while ( 1 )
  {
    result = sub_651F8(dword_CC140, v4);
    if ( result )
      break;
    if ( ++v4 >= 32 )
      return result;
  }
  word_CBFF0[2 * v4] = a1;
  word_93A00 = a3;
  word_CBFF2[2 * v4] = a2;
  word_93A0C = 768;
  word_93A22 = a4;
  word_93A02 = v4;
  word_CC070[v4] = (int)(a3 - (__CFSHL__((unsigned __int64)a3 >> 32, 8) + ((unsigned __int64)a3 >> 32 << 8))) >> 8;
  //fix word_939F4 = __DS__;
  v6 = 32 * a2 + dword_CC154;
  v7 = *(_DWORD *)(v6 + 26) - 16;
  v8 = *(_DWORD *)(v6 + 18);
  dword_939F8 = v7;
  dword_939F0 = v8;
  dword_CC144 = sub_6535C(dword_CC140, (unsigned int)&dword_939F0);
  return 1;
}
// 939F0: using guessed type int dword_939F0;
// 939F4: using guessed type __int16 word_939F4;
// 939F8: using guessed type int dword_939F8;
// 93A00: using guessed type __int16 word_93A00;
// 93A02: using guessed type __int16 word_93A02;
// 93A0C: using guessed type __int16 word_93A0C;
// 93A22: using guessed type __int16 word_93A22;
// CBFF0: using guessed type __int16 word_CBFF0[];
// CBFF2: using guessed type __int16 word_CBFF2[63];
// CC070: using guessed type __int16 word_CC070[];
// CC140: using guessed type int dword_CC140;
// CC144: using guessed type int dword_CC144;
// CC154: using guessed type int dword_CC154;

//----- (00048710) --------------------------------------------------------
char sub_48710(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8)
{
  int v8; // edx
  int v9; // eax
  int v10; // ebx
  __int64 v11; // rtt
  int v12; // ebx
  int v13; // ebp
  int v14; // ebx
  __int16 v15; // bx
  int v16; // ebp
  int v17; // ebx
  int v18; // edx
  int v19; // esi
  int v20; // edi
  int v21; // eax
  int v22; // edx
  int v23; // esi
  int v24; // eax
  int v25; // ebx
  int i; // eax
  int v27; // ebx
  unsigned int v28; // ebx
  unsigned __int8 v29; // al
  unsigned __int8 v30; // ah
  unsigned __int16 v31; // di
  int v32; // eax
  int v33; // eax
  unsigned __int8 v34; // ah
  int v35; // eax
  unsigned __int8 v36; // al
  char v37; // al
  unsigned __int8 v38; // ah
  int v39; // edi
  int v40; // edx
  int v41; // esi
  int v42; // edi
  char *v43; // edx
  __int16 v44; // cx
  __int16 v45; // di
  int v46; // edi
  char *v47; // edx
  int v48; // ebx
  int v49; // edi
  int v50; // edx
  int v51; // esi
  int v52; // edi
  int v53; // esi
  char *v54; // edx
  char *v55; // ebx
  char result; // al
  char *v57; // eax
  int v58; // [esp+4h] [ebp-54h]
  int v59; // [esp+8h] [ebp-50h]
  int v60; // [esp+Ch] [ebp-4Ch]
  int v61; // [esp+10h] [ebp-48h]
  int v62; // [esp+14h] [ebp-44h]
  int v63; // [esp+18h] [ebp-40h]
  int v64; // [esp+18h] [ebp-40h]
  int v65; // [esp+20h] [ebp-38h]
  int v66; // [esp+24h] [ebp-34h]
  int v67; // [esp+28h] [ebp-30h]
  signed int v68; // [esp+2Ch] [ebp-2Ch]
  int v69; // [esp+30h] [ebp-28h]
  int v70; // [esp+34h] [ebp-24h]
  char *v71; // [esp+38h] [ebp-20h]
  char *v72; // [esp+3Ch] [ebp-1Ch]
  unsigned __int16 j; // [esp+40h] [ebp-18h]
  char v74; // [esp+44h] [ebp-14h]

  v8 = a1;
  v9 = a2;
  v10 = a8;
  v59 = 0;
  if ( (word_12F02E & 1) != 0 )
  {
    v8 = a1 >> 1;
    v9 = a2 >> 1;
    v10 = 2 * a8;
    a5 >>= 1;
    a6 >>= 1;
  }
  v65 = dword_12EFF0 * v9 + dword_12EFF4 + v8;
  LODWORD(v11) = (uint32)sub_10000;
  HIDWORD(v11) = (int)sub_10000 >> 31;
  v12 = v11 / v10;
  v58 = a5 / 2;
  v13 = v12 * dword_90B4C[a7 & 0x7FF];
  v14 = ((int)off_9134C[a7 & 0x7FF] * v12) >> 16;
  v70 = a6 / 2;
  sub_5A3C0(1);
  v62 = v14;
  v69 = 164 * *(unsigned __int16 *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13333) + dword_AE400 + 29795;
  v15 = *(_WORD *)(*(_DWORD *)(v69 + 160) + 686);
  v16 = -v13 >> 16;
  if ( v15 )
    v59 = *(__int16 *)(dword_AE400 + 164 * v15 + 29843);
  v17 = *(_DWORD *)(v69 + 160);
  if ( *(_WORD *)(v17 + 50) )
  {
    v18 = (__int16)(*(_WORD *)(v69 + 72) - a3);
    v19 = v18 * v62;
    v20 = v70 + ((v16 * v18 + (__int16)(*(_WORD *)(v69 + 74) - a4) * v62) >> 16);
    v21 = dword_AE400 + 164 * *(unsigned __int16 *)(v17 + 50);
    v22 = (__int16)(*(_WORD *)(v21 + 29867) - a3);
    v23 = v58 + ((v19 - v16 * (__int16)(*(_WORD *)(v69 + 74) - a4)) >> 16);
    v24 = (__int16)(*(_WORD *)(v21 + 29869) - a4);
    v25 = v58 + ((v22 * v62 - v16 * v24) >> 16);
    v63 = ((v16 * v22 + v62 * v24) >> 16) + v70;
    v68 = sub_410CE((v25 - v23) * (v25 - v23) + (v63 - v20) * (v63 - v20));
    v66 = (unsigned __int16)sub_40F87(v25 - v23, v63 - v20);
    for ( i = (*(_DWORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13341) & 3) + 4;
          i <= v68;
          *(_BYTE *)(v65 + v27 + dword_12EFF0 * v64) = byte_BB934[256
                                                                * *(unsigned __int8 *)(v65 + v27 + dword_12EFF0 * v64)
                                                                + (unsigned __int8)byte_AE167] )
    {
      v27 = ((i * dword_90B4C[v66]) >> 16) + v23;
      v64 = v20 + ((-i * (int)off_9134C[v66]) >> 16);
      if ( v27 < 0 )
        break;
      if ( v27 >= a5 )
        break;
      if ( v64 < 0 )
        break;
      if ( v64 >= a6 )
        break;
      if ( v27 < word_12C1F2[2 * v64] )
        break;
      if ( v27 >= word_12C1F0[2 * v64] )
        break;
      i += 4;
    }
  }
  v28 = dword_AE400 + 29959;
  while ( v28 < dword_AE400 + 193795 )
  {
    v29 = 0;
    v60 = 1;
    switch ( *(_BYTE *)(v28 + 64) )
    {
      case 2:
        v34 = *(_BYTE *)(v28 + 65);
        if ( v34 )
        {
          if ( v34 <= 1u )
          {
            if ( *(_BYTE *)(dword_AE408 + 95) )
            {
              v74 = (char)byte_AD168;
              v29 = 1;
            }
          }
          else if ( v34 == 3 )
          {
            if ( *(_BYTE *)(dword_AE408 + 95) )
            {
              v74 = (char)byte_AD168;
              v29 = 1;
            }
          }
          else
          {
            v74 = 28;
            v29 = 1;
          }
        }
        else
        {
          if ( *(_BYTE *)(v28 + 70) != 2 )
            v29 = 1;
          v74 = 28;
        }
        goto LABEL_66;
      case 3:
        v38 = *(_BYTE *)(v28 + 65);
        if ( v38 >= 2u )
        {
          if ( v38 <= 2u )
          {
            v29 = *(_BYTE *)(*(_DWORD *)(dword_AE400 + 164 * *(__int16 *)(v28 + 24) + 29955) + 48) + 58;
          }
          else if ( v38 == 3 && (*(_WORD *)(v28 + 24) == *(_WORD *)(v69 + 24) || v59) )
          {
            v29 = *(_BYTE *)(*(_DWORD *)(164 * *(__int16 *)(v28 + 24) + dword_AE400 + 29955) + 48) + 66;
          }
        }
        goto LABEL_66;
      case 5:
        if ( *(_BYTE *)(v28 + 70) != 120 && (*(_BYTE *)(v28 + 16) & 1) == 0 )
        {
          v35 = *(__int16 *)(v28 + 24);
          if ( v35 == (int)(v28 - (dword_AE400 + 29795)) / 164 )
          {
            v36 = *(_BYTE *)(v28 + 65);
            if ( v36 < 0xCu || v36 > 0xEu )
              v37 = (char)byte_AD168;
            else
              v37 = byte_AD177;
          }
          else
          {
            v37 = byte_99B59[2 * *(__int16 *)(*(_DWORD *)(dword_AE400 + 164 * v35 + 29955) + 48)];
          }
          v74 = v37;
          v29 = 1;
        }
        goto LABEL_66;
      case 9:
        goto LABEL_32;
      case 0xA:
        v30 = *(_BYTE *)(v28 + 65);
        if ( v30 < 0x22u )
        {
          if ( v30 >= 3u && v30 == 18 )
            goto LABEL_66;
          goto LABEL_32;
        }
        if ( v30 <= 0x22u )
        {
          v60 = 2;
LABEL_32:
          v33 = 164 * *(__int16 *)(v28 + 24) + dword_AE400;
          if ( *(_BYTE *)(v33 + 29859) == 3 )
            v74 = byte_99B58[2 * *(__int16 *)(*(_DWORD *)(v33 + 29955) + 48)];
          else
            v74 = byte_AE077;
          v29 = 1;
          goto LABEL_66;
        }
        if ( v30 < 0x27u || v30 > 0x27u )
          goto LABEL_32;
        v31 = *(_WORD *)(v28 + 144);
        if ( v31 && (v32 = dword_AE400 + 164 * v31, *(_BYTE *)(v32 + 29859) == 3) )
        {
          v74 = byte_99B58[2 * *(__int16 *)(*(_DWORD *)(v32 + 29955) + 48) + *(unsigned __int8 *)(dword_AE408 + 96)];
          v29 = 1;
        }
        else
        {
          v29 = 1;
          v74 = -24;
        }
LABEL_66:
        if ( !v29 )
          goto LABEL_97;
        v39 = (__int16)(*(_WORD *)(v28 + 72) - a3);
        v40 = (__int16)(*(_WORD *)(v28 + 74) - a4);
        v41 = v58 + ((v39 * v62 - v16 * v40) >> 16);
        if ( v41 < 0 )
          goto LABEL_97;
        if ( v41 >= a5 )
          goto LABEL_97;
        v42 = ((v16 * v39 + v62 * v40) >> 16) + v70;
        if ( v42 < 0 || v42 >= a6 || v41 < word_12C1F2[2 * v42] || v41 >= word_12C1F0[2 * v42] )
          goto LABEL_97;
        v43 = (char *)(v42 * dword_12EFF0 + v41 + v65);
        if ( v29 <= 1u )
        {
          *v43 = v74;
          if ( v60 > 1 )
          {
            v46 = dword_12EFF0;
            v43[1] = v74;
            v47 = &v43[v46];
            *v47 = v74;
            v47[1] = v74;
          }
        }
        else
        {
          if ( word_12F02E != 1 )
          {
            if ( v29 < 0x3Cu )
            {
              if ( (word_12F02E & 1) != 0 )
              {
LABEL_83:
                sub_60CE0(v41, v42 - *(unsigned __int8 *)(dword_AE42C + 6 * v29 + 5), dword_AE42C + 6 * v29);
                goto LABEL_97;
              }
              goto LABEL_84;
            }
            if ( (word_12F02E & 1) != 0 )
            {
LABEL_78:
              sub_60CE0(
                v41 - ((int)*(unsigned __int8 *)(6 * v29 + dword_AE42C + 4) >> 1),
                v42 - *(unsigned __int8 *)(6 * v29 + dword_AE42C + 5),
                6 * v29 + dword_AE42C);
              goto LABEL_97;
            }
            goto LABEL_94;
          }
          if ( v29 >= 0x42u && v29 < 0x4Au )
          {
            LOWORD(v41) = 2 * v41;
            LOWORD(v42) = 2 * v42;
            if ( (word_12F02E & 1) != 0 )
              goto LABEL_78;
LABEL_94:
            sub_60D18(
              v41 - ((int)*(unsigned __int8 *)(dword_AE42C + 6 * v29 + 4) >> 1),
              v42 - *(unsigned __int8 *)(dword_AE42C + 6 * v29 + 5),
              dword_AE42C + 6 * v29);
            goto LABEL_97;
          }
          if ( v29 >= 0x3Au && v29 < 0x42u )
          {
            LOWORD(v41) = 2 * v41;
            LOWORD(v42) = 2 * v42;
            if ( (word_12F02E & 1) != 0 )
              goto LABEL_83;
LABEL_84:
            sub_60D18(v41, v42 - *(unsigned __int8 *)(dword_AE42C + 6 * v29 + 5), dword_AE42C + 6 * v29);
            goto LABEL_97;
          }
          if ( v29 == 83 || v29 == 84 )
          {
            v44 = 2 * v41;
            v45 = 2 * v42;
            if ( (word_12F02E & 1) != 0 )
              sub_60CE0(
                v44 - ((int)*(unsigned __int8 *)(6 * v29 + dword_AE42C + 4) >> 1),
                v45 - ((int)*(unsigned __int8 *)(6 * v29 + dword_AE42C + 5) >> 1),
                6 * v29 + dword_AE42C);
            else
              sub_60D18(
                v44 - ((int)*(unsigned __int8 *)(dword_AE42C + 6 * v29 + 4) >> 1),
                v45 - ((int)*(unsigned __int8 *)(dword_AE42C + 6 * v29 + 5) >> 1),
                dword_AE42C + 6 * v29);
          }
        }
LABEL_97:
        v28 += 164;
        break;
      case 0xB:
        switch ( *(_BYTE *)(v28 + 65) )
        {
          case 9:
          case 0xA:
          case 0xB:
          case 0xC:
            v29 = 83;
            break;
          case 0x1F:
            v29 = 84;
            break;
          default:
            goto LABEL_66;
        }
        goto LABEL_66;
      case 0xC:
        if ( (*(_BYTE *)(v28 + 16) & 1) == 0 )
        {
          v74 = byte_AE068;
          v29 = 1;
        }
        goto LABEL_66;
      default:
        goto LABEL_66;
    }
  }
  if ( v59 )
  {
    for ( j = 0; j < *(_WORD *)(dword_AE400 + 10); ++j )
    {
      if ( j != *(__int16 *)(dword_AE400 + 8) )
      {
        v67 = 2049 * j;
        v48 = 164 * *(unsigned __int16 *)(v67 + dword_AE400 + 13333) + dword_AE400 + 29795;
        if ( *(int *)(v48 + 12) >= 0 )
        {
          v49 = (__int16)(*(_WORD *)(v48 + 72) - a3);
          v50 = (__int16)(*(_WORD *)(v48 + 74) - a4);
          v51 = ((v49 * v62 - v16 * v50) >> 16) + v58;
          if ( v51 >= 0 && v51 < a5 )
          {
            v52 = ((v16 * v49 + v62 * v50) >> 16) + v70;
            if ( v52 >= 0 && v52 < a6 && v51 >= word_12C1F2[2 * v52] && v51 < word_12C1F0[2 * v52] )
            {
              if ( word_12F02E == 1 )
                sub_5A180(
                  (_BYTE *)(v67 + dword_AE400 + 13323 + 1034),
                  (__int16)(2 * v51 + 2),
                  2 * v52,
                  byte_99B59[2 * *(__int16 *)(*(_DWORD *)(v48 + 160) + 48)]);
              else
                sub_5A180(
                  (_BYTE *)(v67 + dword_AE400 + 13323 + 1034),
                  (__int16)(v51 + 2),
                  v52,
                  byte_99B59[2 * *(__int16 *)(*(_DWORD *)(v48 + 160) + 48)]);
            }
          }
        }
      }
    }
  }
  v61 = a5 / 12;
  v53 = 11264;
  v54 = (char *)(a5 / 2 + v65 + dword_12EFF0 * (a6 / 2) - 1);
  v71 = v54;
  v55 = v54;
  result = byte_B7934[(unsigned __int8)*v54 + 11264];
  v72 = v54;
  for ( *v54 = result; v61; --v61 )
  {
    v72 -= dword_12EFF0;
    v53 -= 2048 / (a5 / 12);
    v71 += dword_12EFF0;
    v57 = &byte_B7934[v53 & 0xFF00];
    *v72 = v57[(unsigned __int8)*v72];
    v55[1] = v57[(unsigned __int8)v55[1]];
    *v71 = v57[(unsigned __int8)*v71];
    ++v55;
    *(v54 - 1) = v57[(unsigned __int8)*(v54 - 1)];
    --v54;
    result = v61 - 1;
  }
  return result;
}
// 49053: variable 'v74' is possibly undefined
// 10000: using guessed type void sub_10000();
// 90B4C: using guessed type int dword_90B4C[256];
// 9134C: using guessed type void (*off_9134C[2])();
// AD168: using guessed type char byte_AD168;
// AD177: using guessed type char byte_AD177;
// AE068: using guessed type char byte_AE068;
// AE077: using guessed type char byte_AE077;
// AE167: using guessed type char byte_AE167;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// AE42C: using guessed type int dword_AE42C;
// 12C1F0: using guessed type __int16 word_12C1F0[];
// 12C1F2: using guessed type __int16 word_12C1F2[959];
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00049300) --------------------------------------------------------
int sub_49300(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10)
{
  int v10; // ebx
  int v11; // edx
  int v12; // edi
  __int16 *i; // ebx
  int v14; // edi
  __int16 *v15; // ecx
  int v16; // ebx
  __int16 *j; // esi
  int v18; // eax
  int v19; // ebx
  int result; // eax
  int v21; // ecx
  int v22; // ebx
  _BYTE *v23; // edi
  int v24; // esi
  int v25; // ecx
  int v26; // eax
  int v27; // edx
  int v28; // ecx
  int v29; // ebx
  _BYTE *v30; // edi
  int v31; // esi
  int v32; // ecx
  int v33; // eax
  int v34; // edx
  int m; // [esp+0h] [ebp-38h]
  int v36; // [esp+4h] [ebp-34h]
  int v37; // [esp+8h] [ebp-30h]
  int v38; // [esp+10h] [ebp-28h]
  int v39; // [esp+18h] [ebp-20h]
  int v40; // [esp+1Ch] [ebp-1Ch]
  int v41; // [esp+20h] [ebp-18h]
  int k; // [esp+24h] [ebp-14h]
  int v43; // [esp+28h] [ebp-10h]
  int v44; // [esp+2Ch] [ebp-Ch]
  int v45; // [esp+30h] [ebp-8h]
  __int16 *v46; // [esp+34h] [ebp-4h]

  v10 = a1;
  v11 = a2;
  if ( (word_12F02E & 1) != 0 )
  {
    v10 = a1 >> 1;
    v11 = a2 >> 1;
    a5 >>= 1;
    a6 >>= 1;
    a8 *= 2;
  }
  v38 = dword_12EFF0 * v11 + v10 + dword_12EFF4;
  if ( a10 )
  {
    v12 = a6;
    for ( i = word_12C1F0; v12; --v12 )
    {
      i += 2;
      *((_DWORD *)i - 1) = (unsigned __int16)a5;
    }
  }
  else
  {
    v14 = a6 / 2;
    v41 = 0;
    v15 = &word_12C1F0[2 * (a6 / 2)];
    v16 = a5 >> 1;
    for ( j = v15 - 2; v14; --v14 )
    {
      v18 = (v16 * (unsigned __int8)byte_CBC34[v41 >> 16]) >> 8;
      *v15 = v18 + v16;
      *j = v18 + v16;
      v15[1] = v16 - v18;
      j[1] = v16 - v18;
      j -= 2;
      v15 += 2;
      v41 += 0x1000000 / (a6 >> 1);
    }
  }
  v19 = a7 & 0x7FF;
  v40 = (a8 * dword_90B4C[v19]) >> 16;
  v39 = (a8 * (int)off_9134C[v19]) >> 16;
  v37 = a6 * v40 / a5;
  v36 = a6 * v39 / a5;
  v44 = a3 - (a5 * v36 - a6 * v40) / 2;
  v46 = word_12C1F0;
  v43 = a4 - (a6 * v39 + a5 * v37) / 2;
  v45 = v38;
  if ( a10 )
  {
    result = a6;
    for ( k = a6; k; --k )
    {
      v21 = v46[1];
      v22 = v44 + v21 * v36;
      v23 = (_BYTE *)(v21 + v45);
      v24 = *v46 - v21;
      v25 = v43 + v21 * v37;
      v26 = 0;
      HIWORD(v27) = 0;
      do
      {
        LOBYTE(v27) = BYTE1(v22);
        BYTE1(v27) = BYTE1(v25);
        LOBYTE(v26) = byte_CC1E0[v27];
        BYTE1(v27) = byte_EC1E0[v27];
        LOBYTE(v27) = byte_CB934[v26];
        *v23++ = byte_B7934[v27];
        v22 += v36;
        v25 += v37;
        --v24;
      }
      while ( v24 );
      v45 += dword_12EFF0;
      v46 += 2;
      v44 -= v40;
      v43 += v39;
      result = k - 1;
    }
  }
  else
  {
    result = a6;
    for ( m = a6; m; --m )
    {
      v28 = v46[1];
      v29 = v44 + v28 * v36;
      v30 = (_BYTE *)(v28 + v45);
      v31 = *v46 - v28;
      v32 = v43 + v28 * v37;
      v33 = 0;
      HIWORD(v34) = 0;
      do
      {
        LOBYTE(v34) = BYTE1(v29);
        BYTE1(v34) = BYTE1(v32);
        LOBYTE(v33) = byte_CC1E0[v34];
        BYTE1(v34) = byte_EC1E0[v34];
        LOBYTE(v34) = byte_CB934[v33];
        LOBYTE(v34) = byte_B7934[v34];
        BYTE1(v34) = *v30;
        *v30++ = byte_BB934[v34];
        v29 += v36;
        v32 += v37;
        --v31;
      }
      while ( v31 );
      v45 += dword_12EFF0;
      result = v39;
      v46 += 2;
      v44 -= v40;
      v43 += v39;
    }
  }
  return result;
}
// 90B4C: using guessed type int dword_90B4C[256];
// 9134C: using guessed type void (*off_9134C[2])();
// 12C1F0: using guessed type __int16 word_12C1F0[];
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00049890) --------------------------------------------------------
int sub_49890(int a1)
{
  __int16 v1; // dx
  int v2; // edx
  int v3; // eax
  int v4; // ecx
  __int64 v5; // rax
  int v6; // ebp
  int result; // eax
  int v8; // eax

  v1 = *(_WORD *)(a1 + 94);
  *(_BYTE *)(a1 + 18) |= 2u;
  if ( v1 )
  {
    v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 90);
    *(_DWORD *)(a1 + 12) = v2;
    if ( v2 < 0 )
    {
      v3 = sub_373F0(a1 + 72, 10, 6);
      v4 = v3;
      if ( v3 )
      {
        *(_WORD *)(v3 + 24) = *(_WORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(a1 + 94) + 29819);
        v5 = 3 * *(__int16 *)(a1 + 84);
        *(_WORD *)(v4 + 46) = (int)(v5 - (__CFSHL__(HIDWORD(v5), 2) + 4 * HIDWORD(v5))) >> 2;
        LODWORD(v5) = 9377 * *(_DWORD *)(a1 + 4) + 9439;
        *(_DWORD *)(a1 + 4) = v5;
        HIDWORD(v5) = (unsigned int)v5 % 0x3C + 130;
        *(_DWORD *)(v4 + 12) = HIDWORD(v5);
        v6 = *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 12) = HIDWORD(v5);
        *(_DWORD *)(a1 + 16) = v6 & 0xFFFDFFF7;
        BYTE4(v5) = *(_BYTE *)(a1 + 18);
        *(_BYTE *)(a1 + 70) = 1;
        *(_BYTE *)(a1 + 18) = BYTE4(v5) | 2;
        sub_41CC0((unsigned int)v5 / 0x3C, a1, a1 + 72);
      }
    }
    *(_WORD *)(a1 + 94) = 0;
  }
  *(_WORD *)(a1 + 76) = sub_11F50((__int16 *)(a1 + 72));
  result = sub_11810((__int16 *)(a1 + 72));
  if ( result == 1 )
  {
    v8 = sub_373F0(a1 + 72, 10, 5);
    if ( v8 )
      *(_WORD *)(v8 + 24) = *(_WORD *)(a1 + 24);
    return sub_41E80(a1);
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (000499C0) --------------------------------------------------------
int sub_499C0(int a1)
{
  int v1; // edx
  unsigned __int16 v2; // si
  int result; // eax
  int v4; // eax

  v1 = *(_DWORD *)(a1 + 12) - 1;
  *(_DWORD *)(a1 + 12) = v1;
  if ( v1 < 60 )
  {
    v2 = *(_WORD *)(a1 + 86);
    *(_BYTE *)(a1 + 70) = 2;
    if ( v2 >= 0x53u )
    {
      if ( v2 <= 0x53u )
      {
        sub_37030((_WORD *)a1, 226);
      }
      else if ( v2 == 84 )
      {
        sub_37030((_WORD *)a1, 227);
      }
    }
  }
  *(_WORD *)(a1 + 76) = sub_11F50((__int16 *)(a1 + 72));
  result = sub_11810((__int16 *)(a1 + 72));
  if ( result == 1 )
  {
    v4 = sub_373F0(a1 + 72, 10, 5);
    if ( v4 )
      *(_WORD *)(v4 + 24) = *(_WORD *)(a1 + 24);
    return sub_41E80(a1);
  }
  return result;
}

//----- (00049A50) --------------------------------------------------------
int sub_49A50(_WORD *a1)
{
  int result; // eax
  int v2; // eax

  a1[38] = sub_11F50((short*)(a1 + 36));
  result = sub_11810((short*)(a1 + 36));
  if ( result == 1 )
  {
    v2 = sub_373F0((int)(a1 + 36), 10, 5);
    if ( v2 )
      *(_WORD *)(v2 + 24) = a1[12];
    return sub_41E80((int)a1);
  }
  return result;
}

//----- (00049AA0) --------------------------------------------------------
int sub_49AA0(int a1)
{
  int result; // eax

  *(_BYTE *)(a1 + 18) |= 2u;
  result = sub_11F50((__int16 *)(a1 + 72));
  *(_WORD *)(a1 + 76) = result;
  return result;
}

//----- (00049AD0) --------------------------------------------------------
int sub_49AD0(int a1)
{
  unsigned __int16 v1; // di
  int v2; // esi
  int v3; // ebx
  int result; // eax

  v1 = 0;
  v2 = dword_AE400 + 13323;
  while ( v1 < *(_WORD *)(dword_AE400 + 10) )
  {
    v3 = 164 * *(unsigned __int16 *)(v2 + 10) + dword_AE400 + 29795;
    if ( *(int *)(v3 + 12) >= 0 && sub_11950(v3, a1) )
      *(_BYTE *)(v3 + 17) |= 0x10u;
    v2 += 2049;
    ++v1;
  }
  result = sub_11F50((__int16 *)(a1 + 72));
  *(_WORD *)(a1 + 76) = result;
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00049B50) --------------------------------------------------------
int sub_49B50(int a1)
{
  int result; // eax

  *(_BYTE *)(a1 + 18) |= 2u;
  result = sub_11F50((__int16 *)(a1 + 72));
  *(_WORD *)(a1 + 76) = result;
  return result;
}

//----- (0004A980) --------------------------------------------------------
int sub_4A980()
{
  int v0; // eax
  int v1; // eax
  int result; // eax
  char v3[40]; // [esp+0h] [ebp-34h] BYREF
  int v4[3]; // [esp+28h] [ebp-Ch] BYREF

  if ( sub_505A0() )
    byte_12CBC9 = 7;
  else
    byte_12CBC9 = 0;
  byte_12CBD4 = 0;
  word_12CBC0 = 0;
  word_12CBC2 = 0;
  word_12CBBC = 0;
  word_12CBBE = 0;
  byte_12CBCA = 0;
  byte_12CBC6 = 0;
  byte_12CBCD = 0;
  byte_12CBD0 = 0;
  byte_12CBCF = 2;
  byte_12CBD1 = 2;
  byte_12CBCC = 1;
  dword_12CBB0 = 0;
  byte_12CBD5 = byte_12CBD5 & 0x40 | 2;
  byte_12CBD2 = 6;
  byte_12CBD6 &= 0xF8u;
  byte_12CBCE = 6;
  byte_12CBD3 = 0;
  sprintf((char*)(dword_AE408 + 117), "CARPET%d", 0);
  sprintf(v3, "%s%s\\intro.pld", aC, aCarpetCd_1);
  v0 = sub_5CDE0((int)v3, 514);
  v4[0] = v0;
  if ( v0 == -1 )
  {
    byte_12CBD5 &= ~2u;
    v1 = sub_5CDE0((int)v3, 546);
    v4[0] = v1;
    if ( v1 != -1 )
    {
      sub_62ED0(v1, (int)v4, 4);
      sub_5CE50(v4[0]);
    }
  }
  else
  {
    sub_5CE50(v0);
  }
  result = dword_AE408;
  *(_BYTE *)(dword_AE408 + 151) = 0;
  return result;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// AE408: using guessed type int dword_AE408;
// 12CBB0: using guessed type int dword_12CBB0;
// 12CBBC: using guessed type __int16 word_12CBBC;
// 12CBBE: using guessed type __int16 word_12CBBE;
// 12CBC0: using guessed type __int16 word_12CBC0;
// 12CBC2: using guessed type __int16 word_12CBC2;
// 12CBC6: using guessed type char byte_12CBC6;
// 12CBC9: using guessed type char byte_12CBC9;
// 12CBCA: using guessed type char byte_12CBCA;
// 12CBCC: using guessed type char byte_12CBCC;
// 12CBCD: using guessed type char byte_12CBCD;
// 12CBCE: using guessed type char byte_12CBCE;
// 12CBCF: using guessed type char byte_12CBCF;
// 12CBD0: using guessed type char byte_12CBD0;
// 12CBD1: using guessed type char byte_12CBD1;
// 12CBD2: using guessed type char byte_12CBD2;
// 12CBD3: using guessed type char byte_12CBD3;
// 12CBD4: using guessed type char byte_12CBD4;
// 12CBD5: using guessed type char byte_12CBD5;
// 12CBD6: using guessed type char byte_12CBD6;
// 4A980: using guessed type int var_C[3];

//----- (0004AB20) --------------------------------------------------------
void sub_4AB20fix(
        __int16 a1,
        const char *a2,
        const char *a3,
        __int16 a4,
        __int16 a5)
{
  int v5; // eax

  if ( dword_12CA7C )
  {
    sub_40440((int)"data\\screens\\sptrs.dat");
    if ( (word_12F02E & 1) != 0 )
    {
      a3 = (const char *)dword_12CAF4;
      a1 = sub_65D70(dword_12CAEC, dword_12CAF0, dword_12CAF4);
    }
    else
    {
      a2 = (const char *)dword_12CAF0;
      a4 = dword_12CAEC;
      a1 = (unsigned __int16)sub_65DC0((unsigned int *)dword_12CAEC, dword_12CAF0, dword_12CAF4);
    }
    dword_12CA7C = 0;
  }
  sub_50770(a1, (__int16)a2, (__int16)a3, a4);
  switch ( byte_12CBCE )
  {
    case 0:
      sub_4D3B0();
      break;
    case 1:
      sub_4AC70(a2, a3);
      break;
    case 2:
      sub_4BD60();
      break;
    case 4:
      sub_4D680();
      break;
    case 5:
      sub_4E5B0();
      break;
    case 6:
      sub_4F3F0((__int16)a3);
      break;
    case 7:
      sub_4EFC0(a5);
      break;
    case 8:
      sub_4F1E0();
      break;
    case 9:
      sub_4EE70();
      break;
    case 10:
      sub_4D560();
    default:
      break;
  }
  ++dword_12CBB0;
  sub_65E00();
  if ( dword_96880 )
  {
    v5 = sub_61610((int)"data\\screens\\sptrs.dat");
    if ( (word_12F02E & 1) != 0 )
      sub_411D7(v5, (void *)dword_AE3FC, 0xC8u, 0);
    else
      sub_411FD(v5, (void *)dword_AE3FC, 0x1E0u, 0);
    dword_12CA7C = 1;
    sub_20E60();
  }
}
// 96880: using guessed type int dword_96880;
// AE3FC: using guessed type int dword_AE3FC;
// 12CA7C: using guessed type int dword_12CA7C;
// 12CAEC: using guessed type int dword_12CAEC;
// 12CAF0: using guessed type int dword_12CAF0;
// 12CAF4: using guessed type int dword_12CAF4;
// 12CBB0: using guessed type int dword_12CBB0;
// 12CBCE: using guessed type char byte_12CBCE;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004AC70) --------------------------------------------------------
void sub_4AC70fix(const char *a1, const char *a2)
{
  __int64 v2; // rax
  int v3; // esi
  int v4; // eax
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // ebx
  int v11; // eax
  int v12; // ebx
  char v13[40]; // [esp+0h] [ebp-3Ch] BYREF
  char v14; // [esp+28h] [ebp-14h]

  BYTE4(v2) = byte_12CBD5;
  v3 = 0;
  v14 = 0;
  if ( (byte_12CBD5 & 1) == 0 )
    sub_4BB20();
  if ( byte_12EEF1 )
  {
    byte_12EEF1 = 0;
    v3 = 1;
    v14 = 1;
  }
  LOBYTE(a1) = byte_12CAE4;
  if ( (byte_12CAE4 & 1) != 0 || (byte_12CAE4 & 0x40) != 0 )
  {
    v4 = word_12CADC >> 1;
    if ( v4 >= 280 && v4 <= 302 )
    {
      v5 = word_12CADE >> 1;
      if ( v5 >= 121 && v5 <= 147 && byte_12CBC9 == 7 )
      {
        BYTE4(v2) = 1;
        byte_12EEF1 = 0;
        v14 = 1;
      }
    }
  }
  BYTE5(v2) = -1;
  LODWORD(v2) = word_12CADC >> 1;
  byte_12CBCB = -1;
  if ( (int)v2 >= 56 && (int)v2 <= 146 )
  {
    HIDWORD(v2) = word_12CADE >> 1;
    if ( SHIDWORD(v2) >= 64 && SHIDWORD(v2) <= 143 )
    {
      if ( byte_12CBC9 == 7 )
      {
        if ( (byte_12CAE4 & 1) != 0 )
        {
          LOWORD(a1) = byte_12CAE4 & 0xFE;
          byte_12CAE4 &= ~1u;
          byte_12CBC9 = 0;
        }
      }
      else
      {
        v6 = *(unsigned __int8 *)(dword_96884 + 5) - 2;
        LODWORD(v2) = (HIDWORD(v2) - 64) / v6;
        HIDWORD(v2) = (HIDWORD(v2) - 64) % v6;
        byte_12CBCB = v2;
      }
    }
  }
  if ( (byte_12CAE4 & 1) != 0 )
  {
    WORD2(v2) = 0;
    LODWORD(v2) = word_12CADC >> 1;
    word_12EFDE = 0;
    if ( (int)v2 < 171 || (int)v2 > 264 || (v7 = word_12CADE >> 1, v7 < 42) || v7 > 147 )
    {
      v8 = word_12CADC >> 1;
      if ( v8 >= 56 && v8 <= 146 )
      {
        v9 = word_12CADE >> 1;
        if ( v9 >= 64 && v9 <= 143 )
        {
          switch ( byte_12CBC9 )
          {
            case 0:
              if ( sub_4B520() )
              {
                a1 = off_4A66C[2 * (unsigned __int8)byte_12CBCB];
                sprintf((char*)&word_12C9C0, "%s", a1);
                a2 = off_4A670[2 * (unsigned __int8)byte_12CBCB];
                sprintf(byte_12C9A0, "%s", a2);
                byte_12CBC9 = 1;
              }
              break;
            case 1:
              if ( sub_4B520() )
              {
                HIDWORD(v2) = (uint32)off_4A6CC[2 * (unsigned __int8)byte_12CBCB];
                sprintf((char*)&word_12C9E0, "%s", (const char *)HIDWORD(v2));
                sprintf(byte_12CA00, "%s", off_4A6D0[2 * (unsigned __int8)byte_12CBCB]);
                if ( !strcmp(byte_12C9A0, aNone) )
                {
                  if ( strcmp(byte_12CA00, aNone) )
                    goto LABEL_43;
                  byte_12CBC9 = 6;
                }
                else
                {
                  byte_12CBC9 = 2;
                }
              }
              break;
            case 2:
              if ( sub_4B520() )
              {
                a2 = off_4A734[2 * (unsigned __int8)byte_12CBCB];
                sprintf((char*)word_12CA80, "%s", a2);
                sprintf((char*)word_12CA9E, "%s", off_4A738[2 * (unsigned __int8)byte_12CBCB]);
                byte_12CBC9 = 3;
              }
              break;
            case 3:
              if ( sub_4B520() )
              {
                sprintf((char*)word_12CA8A, "%s", off_4A74C[2 * (unsigned __int8)byte_12CBCB]);
                a1 = (&off_4A750)[2 * (unsigned __int8)byte_12CBCB];
                sprintf((char*)word_12CAB2, "%s", a1);
                BYTE1(a1) = 4;
                byte_12CBC9 = 4;
              }
              break;
            case 4:
              if ( sub_4B520() )
              {
                sprintf((char*)word_12CAD0, "%s", (const char *)off_4A77C[2 * (unsigned __int8)byte_12CBCB]);
                HIDWORD(v2) = (uint32)((&off_4A780)[2 * (unsigned __int8)byte_12CBCB]);
                sprintf((char*)&word_12CAC6, "%s", (const char *)HIDWORD(v2));
                byte_12CBC9 = 5;
                if ( !strcmp(byte_12CA00, aWblast)
                  || !strcmp(byte_12CA00, aRoland)
                  || !strcmp(byte_12CA00, aGeneral)
                  || !strcmp(byte_12CA00, aSbawe32) )
                {
LABEL_43:
                  byte_12CBC9 = 5;
                }
                else
                {
                  LOBYTE(a1) = 6;
                  byte_12CBC9 = 6;
                  sprintf((char*)word_12CA94, "%s", &aE388[1]);
                  sprintf((char*)word_12CAA8, "%s", &aE388[1]);
                }
              }
              break;
            case 5:
              if ( sub_4B520() )
              {
                a1 = (const char *)*(&off_4A79C + 2 * (unsigned __int8)byte_12CBCB);
                sprintf((char*)word_12CA94, "%s", a1);
                a2 = (const char *)*(&off_4A7A0 + 2 * (unsigned __int8)byte_12CBCB);
                sprintf((char*)word_12CAA8, "%s", a2);
                BYTE5(v2) = 6;
                byte_12CBC9 = 6;
              }
              break;
            case 6:
              if ( sub_4B520() )
              {
                HIDWORD(v2) = (uint32)off_4A7B4[2 * (unsigned __int8)byte_12CBCB];
                sprintf((char*)&word_12CA20, "%s", (const char *)HIDWORD(v2));
                sprintf((char*)&dword_12CABC, "%s", (const char *)(&off_4A7B8)[2 * (unsigned __int8)byte_12CBCB]);
                if ( !strcmp((const char*)&dword_12CABC, (const char*)&dword_A99A0) )
                {
                  sprintf(v13, "%s%s\\sndsetup.inf", aC, aCarpetCd_1);
                  v2 = (long long)fopen(v13, &aNewt[2]);
                  v10 = v2;
                  if ( (_DWORD)v2 )
                  {
                    fprintf(
                      (FILE*)v2,
                      "SOUNDFX = %s %s %s %s\n",
                      byte_12C9A0,
                      (const char *)word_12CA9E,
                      (const char *)word_12CAB2,
                      (const char *)&word_12CAC6);
                    fprintf((FILE*)v10, "MUSIC = %s %s 0 0 \n", byte_12CA00, (const char *)word_12CAA8);
                    fclose((FILE*)v10);
                  }
                  sprintf(v13, "%s%s\\sndsetup.dat", aC, aCarpetCd_1);
                  v11 = sub_5CDE0((int)v13, 546);
                  v12 = v11;
                  if ( v11 != -1 )
                  {
                    sub_62ED0(v11, (int)byte_12C9A0, 32);
                    sub_62ED0(v12, (int)&word_12C9C0, 32);
                    sub_62ED0(v12, (int)byte_12CA00, 32);
                    sub_62ED0(v12, (int)&word_12C9E0, 32);
                    sub_62ED0(v12, (int)word_12CA9E, 10);
                    sub_62ED0(v12, (int)word_12CA80, 10);
                    sub_62ED0(v12, (int)word_12CAB2, 10);
                    sub_62ED0(v12, (int)word_12CA8A, 10);
                    sub_62ED0(v12, (int)&word_12CAC6, 10);
                    sub_62ED0(v12, (int)word_12CAD0, 10);
                    sub_62ED0(v12, (int)word_12CAA8, 10);
                    sub_62ED0(v12, (int)word_12CA94, 10);
                    sub_5CE50(v12);
                  }
                  byte_12CBC9 = 7;
                }
                else
                {
                  byte_12CBC9 = 0;
                }
              }
              break;
            default:
              break;
          }
        }
      }
    }
    else
    {
      if ( ++byte_12CBD3 == 7 )
      {
        BYTE1(a1) = 0;
        byte_12CBD3 = 0;
      }
      if ( byte_12CBD3 == 3 )
        byte_12CBD3 = 4;
      if ( byte_12CBD3 == 5 )
        byte_12CBD3 = 6;
    }
  }
  if ( (word_12F02E & 1) != 0 )
  {
    WORD2(v2) = dword_12EFF4;
    sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
  }
  else
  {
    sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
  }
  sub_4B560();
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  if ( v14 )
  {
    sub_51DF0(word_4A8C4[4 * (unsigned __int8)byte_12CBD3]);
    sub_4BC90();
    if ( byte_12CBD5 >= 0 )
    {
      sub_357C0(SWORD2(v2), (unsigned __int16)a1, (unsigned __int16)a2, v3);
      byte_12CBD5 |= 0x80u;
    }
    if ( (byte_12CBD5 & 2) != 0 && (byte_12CBD5 & 4) != 0 && (byte_12CAE4 & 0x40) == 0 || v3 )
      byte_12CBCE = 2;
    else
      byte_12CBCE = 7;
    byte_12CAE4 &= 0xBEu;
  }
}
// 4A66C: using guessed type char *off_4A66C[22];
// 4A670: using guessed type char *off_4A670[21];
// 4A6CC: using guessed type char *off_4A6CC[24];
// 4A6D0: using guessed type char *off_4A6D0[23];
// 4A734: using guessed type char *off_4A734[4];
// 4A738: using guessed type char *off_4A738[3];
// 4A74C: using guessed type char *off_4A74C[2];
// 4A750: using guessed type char *off_4A750;
// 4A77C: using guessed type __int16 *off_4A77C[2];
// 4A780: using guessed type __int16 *off_4A780;
// 4A79C: using guessed type void *off_4A79C;
// 4A7A0: using guessed type void *off_4A7A0;
// 4A7B4: using guessed type int *off_4A7B4[2];
// 4A7B8: using guessed type int *off_4A7B8;
// 4A8C4: using guessed type __int16 word_4A8C4[];
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 626D2: using guessed type __int64 fopen(_DWORD, _DWORD);
// 62781: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 627A6: using guessed type _DWORD fclose(_DWORD);
// 639E0: using guessed type _DWORD strcmp(_DWORD, _DWORD);
// 96884: using guessed type int dword_96884;
// A99A0: using guessed type int dword_A99A0;
// AE3FC: using guessed type int dword_AE3FC;
// 12C9C0: using guessed type __int16 word_12C9C0;
// 12C9E0: using guessed type __int16 word_12C9E0;
// 12CA20: using guessed type __int16 word_12CA20;
// 12CA80: using guessed type __int16 word_12CA80[5];
// 12CA8A: using guessed type __int16 word_12CA8A[5];
// 12CA94: using guessed type __int16 word_12CA94[5];
// 12CA9E: using guessed type __int16 word_12CA9E[5];
// 12CAA8: using guessed type __int16 word_12CAA8[5];
// 12CAB2: using guessed type __int16 word_12CAB2[5];
// 12CABC: using guessed type int dword_12CABC;
// 12CAC6: using guessed type __int16 word_12CAC6;
// 12CAD0: using guessed type __int16 word_12CAD0[6];
// 12CADC: using guessed type __int16 word_12CADC;
// 12CADE: using guessed type __int16 word_12CADE;
// 12CAE4: using guessed type char byte_12CAE4;
// 12CBC9: using guessed type char byte_12CBC9;
// 12CBCB: using guessed type char byte_12CBCB;
// 12CBCE: using guessed type char byte_12CBCE;
// 12CBD3: using guessed type char byte_12CBD3;
// 12CBD5: using guessed type char byte_12CBD5;
// 12EEF1: using guessed type char byte_12EEF1;
// 12EFDE: using guessed type __int16 word_12EFDE;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004B430) --------------------------------------------------------
int sub_4B430()
{
  int result; // eax

  result = 0;
  if ( (byte_12EF1A || byte_12EF26) && byte_12EF70 == 16 )
  {
    dword_96880 = 1;
    *(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13327) = 1;
    return 1;
  }
  return result;
}
// 96880: using guessed type int dword_96880;
// AE400: using guessed type int dword_AE400;
// 12EF1A: using guessed type char byte_12EF1A;
// 12EF26: using guessed type char byte_12EF26;
// 12EF70: using guessed type char byte_12EF70;

//----- (0004B480) --------------------------------------------------------
int sub_4B480(int (*a1)(void), int a2)
{
  int v2; // ebx
  unsigned int v3; // esi
  int result; // eax

  v2 = 0;
  v3 = dword_AC5D4 + 120 * a2;
  do
  {
    result = sub_4B430();
    if ( result )
      v2 = 1;
    if ( word_12EFDE || word_12EFDC || word_12EFDA || byte_12EF70 )
    {
      byte_12EF70 = 0;
      result = 0;
      word_12EFDA = 0;
      word_12EFDC = 0;
      word_12EFDE = 0;
      v2 = 1;
    }
    if ( v3 < dword_AC5D4 )
      v2 = 1;
    if ( !v2 )
    {
      if ( a1 )
        result = a1();
    }
  }
  while ( !v2 );
  return result;
}
// AC5D4: using guessed type int dword_AC5D4;
// 12EF70: using guessed type char byte_12EF70;
// 12EFDA: using guessed type __int16 word_12EFDA;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;

//----- (0004B520) --------------------------------------------------------
int sub_4B520()
{
  char **v0; // eax
  int v1; // esi
  char i; // dl

  v0 = sub_4B6A0();
  v1 = 1;
  for ( i = 0; **v0 != 33 && i != byte_12CBCB; ++i )
    v0 += 2;
  if ( **v0 == 33 )
    return 0;
  return v1;
}
// 12CBCB: using guessed type char byte_12CBCB;

//----- (0004B560) --------------------------------------------------------
int sub_4B560()
{
  unsigned __int8 **v0; // eax

  sub_513E0();
  sub_51360(56, 64, 90, 78);
  v0 = (unsigned __int8 **)sub_4B6A0();
  if ( v0 )
    sub_4B6F0(v0);
  else
    sub_4B8D0(0);
  if ( byte_12CBC9 == 7 )
  {
    if ( (word_12F02E & 1) != 0 )
      sub_60CE0(554, 224, dword_12CAF8 + 66);
    else
      sub_60D18(554, 224, dword_12CAF8 + 66);
  }
  sub_51400();
  if ( (word_12F02E & 1) != 0 )
    return sub_60CE0(
             2 * word_4A8BE[4 * (unsigned __int8)byte_12CBD3],
             2 * word_4A8C0[4 * (unsigned __int8)byte_12CBD3],
             dword_12CAF8 + 6 * word_4A8C2[4 * (unsigned __int8)byte_12CBD3]);
  else
    return sub_60D18(
             2 * word_4A8BE[4 * (unsigned __int8)byte_12CBD3],
             2 * word_4A8C0[4 * (unsigned __int8)byte_12CBD3],
             dword_12CAF8 + 6 * word_4A8C2[4 * (unsigned __int8)byte_12CBD3]);
}
// 4A8BE: using guessed type __int16 word_4A8BE[];
// 4A8C0: using guessed type __int16 word_4A8C0[];
// 4A8C2: using guessed type __int16 word_4A8C2[];
// 12CAF8: using guessed type int dword_12CAF8;
// 12CBC9: using guessed type char byte_12CBC9;
// 12CBD3: using guessed type char byte_12CBD3;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004B6A0) --------------------------------------------------------
char **sub_4B6A0()
{
  char **result; // eax

  //fix
  result = 0;
  //fix

  switch ( byte_12CBC9 )
  {
    case 0:
      result = off_4A66C;
      break;
    case 1:
      result = off_4A6CC;
      break;
    case 2:
      result = off_4A734;
      break;
    case 3:
      result = off_4A74C;
      break;
    case 4:
      result = (char **)off_4A77C;
      break;
    case 5:
      result = (char **)&off_4A79C;
      break;
    case 6:
      result = (char **)off_4A7B4;
      break;
    case 7:
      result = 0;
      break;
    default:
      return result;
  }
  return result;
}
// 4A66C: using guessed type char *off_4A66C[22];
// 4A6CC: using guessed type char *off_4A6CC[24];
// 4A734: using guessed type char *off_4A734[4];
// 4A74C: using guessed type char *off_4A74C[2];
// 4A77C: using guessed type __int16 *off_4A77C[2];
// 4A79C: using guessed type void *off_4A79C;
// 4A7B4: using guessed type int *off_4A7B4[2];
// 12CBC9: using guessed type char byte_12CBC9;

//----- (0004B6F0) --------------------------------------------------------
void sub_4B6F0(unsigned __int8 **a1)
{
  unsigned __int8 **v1; // esi
  int v2; // ebp
  char v3; // bl
  char v4; // bh
  int v5; // edi
  int v6; // ebp
  char v7; // al
  __int16 v8; // [esp-8h] [ebp-24h]
  unsigned __int8 *v9; // [esp-4h] [ebp-20h]
  char v10; // [esp+4h] [ebp-18h]
  char v11; // [esp+8h] [ebp-14h]

  v1 = a1;
  if ( a1 )
  {
    v2 = *(unsigned __int8 *)(dword_96884 + 5);
    byte_96888 &= ~2u;
    v10 = sub_5CC70((unsigned __int8 *)dword_12CB9C, 0x26u, 0x22u, 0x19u);
    v3 = 0;
    v4 = sub_5CC70((unsigned __int8 *)dword_12CB9C, 0x1Eu, 0x18u, 0x11u);
    v5 = 0;
    v6 = v2 - 2;
    v7 = sub_5CC70((unsigned __int8 *)dword_12CB9C, 0x20u, 0x1Eu, 0x17u);
    v11 = v7;
    if ( byte_12CBC9 == 6 )
    {
      byte_9688A = v10;
      if ( !byte_12CBCB )
        byte_9688A = v7;
      if ( !byte_12CBCA )
        byte_9688A = v4;
      sub_51560((uint8*)&dword_96884, 0, 0, (unsigned __int8 *)dword_AE35C);
      byte_9688A = v10;
      if ( byte_12CBCB == 1 )
        byte_9688A = v11;
      if ( byte_12CBCA == 1 )
        byte_9688A = v4;
      sub_51560((uint8*)&dword_96884, 0, v6, (unsigned __int8 *)dword_AE360);
    }
    else
    {
      while ( **v1 != 33 )
      {
        byte_9688A = v10;
        if ( v3 == byte_12CBCB )
          byte_9688A = v11;
        if ( v3 == byte_12CBCA )
          byte_9688A = v4;
        v9 = *v1;
        v8 = v5;
        v1 += 2;
        ++v3;
        v5 += v6;
        sub_51560((uint8*)&dword_96884, 0, v8, v9);
      }
    }
    if ( byte_12CBC9 == 6 )
      sub_4B8D0(16);
    if ( (unsigned __int8)byte_12CBC9 < 7u )
    {
      sub_513E0();
      sub_51360(66, 43, 84, 14);
      byte_9688A = v4;
      sub_51560(
          (uint8*)&dword_96884,
        1,
        1,
        (unsigned __int8 *)dword_AE238[(unsigned __int16)word_968B4[(unsigned __int8)byte_12CBC9]]);
      sub_51400();
    }
  }
}
// 96884: using guessed type int dword_96884;
// 96888: using guessed type char byte_96888;
// 9688A: using guessed type char byte_9688A;
// 968B4: using guessed type __int16 word_968B4[8];
// AE238: using guessed type int dword_AE238[17];
// AE35C: using guessed type int dword_AE35C;
// AE360: using guessed type int dword_AE360;
// 12CB9C: using guessed type int dword_12CB9C;
// 12CBC9: using guessed type char byte_12CBC9;
// 12CBCA: using guessed type char byte_12CBCA;
// 12CBCB: using guessed type char byte_12CBCB;

//----- (0004B8D0) --------------------------------------------------------
void sub_4B8D0(__int16 a1)
{
  __int16 v1; // si
  __int16 v2; // si
  __int16 v3; // di
  __int16 v4; // ax
  __int16 v5; // bx
  __int16 v6; // bx
  __int16 v7; // di
  __int16 v8; // ax
  __int16 v9; // bx
  __int16 v10; // bx
  __int16 v11; // [esp-8h] [ebp-58h]
  unsigned __int8 v12[40]; // [esp+0h] [ebp-50h] BYREF
  int v13; // [esp+28h] [ebp-28h] BYREF
  int v14; // [esp+2Ch] [ebp-24h]

  //fix
  v14 = 0;
  //fix

  v1 = *(unsigned __int8 *)(dword_96884 + 5);
  sub_513A0((uint32*)&v13);
  byte_9688A = sub_5CC70((unsigned __int8 *)dword_12CB9C, 0x1Eu, 0x18u, 0x11u);
  sprintf((char*)v12, "%s :", (const char *)dword_AE27C);
  sub_51560((uint8*)&dword_96884, 0, a1, v12);
  v2 = v1 - 2;
  sprintf((char*)v12, "%s", (const char *)&word_12C9C0);
  v3 = v14 - v13;
  v4 = sub_51420((uint32*)&dword_96884, (char *)v12);
  sub_51560((uint8*)&dword_96884, (__int16)(v3 - v4), v2 + a1, v12);
  sprintf((char*)v12, "%s :", (const char *)dword_AE280);
  v5 = v2 + v2 + a1;
  sub_51560((uint8*)&dword_96884, 0, v5, v12);
  v6 = v2 + v5;
  sprintf((char*)v12, "%s", (const char *)&word_12C9E0);
  v7 = v14 - v13;
  v8 = sub_51420((uint32*)&dword_96884, (char *)v12);
  sub_51560((uint8*)&dword_96884, (__int16)(v7 - v8), v6, v12);
  v9 = v2 + v6;
  if ( strncmp((char*)&unk_12C9A0, aNone, 4) )
  {
    sprintf((char*)v12, "%s : %s\n", (const char *)dword_AE294, (const char *)word_12CA80);
    sub_51560((uint8*)&dword_96884, 0, v9, v12);
    sprintf((char*)v12, "%s : %s\n", (const char *)dword_AE298, (const char *)word_12CA8A);
    v10 = v2 + v9;
    sub_51560((uint8*)&dword_96884, 0, v10, v12);
    sprintf((char*)v12, "%s : %s\n", (const char *)dword_AE29C, (const char *)word_12CAD0);
    v11 = v2 + v10;
    v9 = v2 + v2 + v10;
    sub_51560((uint8*)&dword_96884, 0, v11, v12);
  }
  if ( strncmp((char*)&unk_12CA00, aNone, 4) )
  {
    sprintf((char*)v12, "%s : %s\n", (const char *)dword_AE2A0, (const char *)word_12CA94);
    sub_51560((uint8*)&dword_96884, 0, v9, v12);
  }
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 65E6F: using guessed type _DWORD strncmp(_DWORD, _DWORD, _DWORD);
// 96884: using guessed type int dword_96884;
// 9688A: using guessed type char byte_9688A;
// AE27C: using guessed type int dword_AE27C;
// AE280: using guessed type int dword_AE280;
// AE294: using guessed type int dword_AE294;
// AE298: using guessed type int dword_AE298;
// AE29C: using guessed type int dword_AE29C;
// AE2A0: using guessed type int dword_AE2A0;
// 12C9C0: using guessed type __int16 word_12C9C0;
// 12C9E0: using guessed type __int16 word_12C9E0;
// 12CA80: using guessed type __int16 word_12CA80[5];
// 12CA8A: using guessed type __int16 word_12CA8A[5];
// 12CA94: using guessed type __int16 word_12CA94[5];
// 12CAD0: using guessed type __int16 word_12CAD0[6];
// 12CB9C: using guessed type int dword_12CB9C;

//----- (0004BB20) --------------------------------------------------------
__int16 sub_4BB20()
{
  __int16 result; // ax

  sub_61CC0(0, 0x10u, 0);
  sub_40440((int)"data\\screens\\sfont0.dat");
  sub_3EEA0(aDataScreensGco, (char *)dword_AE3FC);
  sub_3EEA0(aDataScreensGco_0, (char *)dword_12CB9C);
  if ( (word_12F02E & 1) != 0 )
    sub_65D70(dword_12CAF8, dword_12CAFC, dword_12CB00);
  else
    sub_65DC0((unsigned int *)dword_12CAF8, dword_12CAFC, dword_12CB00);
  sub_51480((int)&dword_96884, &dword_12CB28, (unsigned __int8 *)dword_12CB9C);
  byte_96888 &= ~2u;
  if ( !byte_90B23 )
    sub_5C05C(dword_12CAEC + 6 * (unsigned __int8)byte_12CBCE);
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
  else
    sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  result = sub_61CC0((unsigned __int8 *)dword_12CB9C, 0x20u, 0);
  byte_12CBD5 |= 1u;
  byte_12CAE4 &= 0xBEu;
  return result;
}
// 90B23: using guessed type char byte_90B23;
// 96884: using guessed type int dword_96884;
// 96888: using guessed type char byte_96888;
// AE3FC: using guessed type int dword_AE3FC;
// 12CAE4: using guessed type char byte_12CAE4;
// 12CAEC: using guessed type int dword_12CAEC;
// 12CAF8: using guessed type int dword_12CAF8;
// 12CAFC: using guessed type int dword_12CAFC;
// 12CB00: using guessed type int dword_12CB00;
// 12CB28: using guessed type _DWORD dword_12CB28;
// 12CB9C: using guessed type int dword_12CB9C;
// 12CBCE: using guessed type char byte_12CBCE;
// 12CBD5: using guessed type char byte_12CBD5;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004BC90) --------------------------------------------------------
int sub_4BC90()
{
  int v0; // eax
  int result; // eax

  LOBYTE(v0) = sub_61CC0(0, 0x10u, 0);
  BYTE1(v0) = byte_90B23;
  if ( !byte_90B23 )
    v0 = sub_5C05C(0);
  if ( (word_12F02E & 1) != 0 )
    sub_411D7(v0, (void *)dword_12EFF4, 0xC8u, 0);
  else
    sub_411FD(v0, (void *)dword_12EFF4, 0x1E0u, 0);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  result = sub_61610((int)"data\\screens\\sfont0.dat");
  byte_12CBD5 &= ~1u;
  return result;
}
// 4BCCA: variable 'v0' is possibly undefined
// 90B23: using guessed type char byte_90B23;
// 12CBD5: using guessed type char byte_12CBD5;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004BD60) --------------------------------------------------------
void sub_4BD60()
{
  int v0; // esi
  int v1; // edi
  int v2; // ebp
  int v3; // ebx
  int v4; // ebx
  int v5; // edx
  int v6; // eax
  __int16 v7; // cx
  int v8; // ebx
  int v9; // ebx
  int v10; // ebx
  __int16 v11; // cx
  int v12; // ebx
  int v13; // ebx
  int v14; // ebx
  int v15; // eax
  char v16; // dl

  v0 = 0;
  v1 = 0;
  v2 = 0;
  if ( (byte_12CBD5 & 1) == 0 )
    sub_4C7E0();
  sub_4C6F0();
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_12CBA8, (void *)dword_AE3FC, 0xC8u);
  else
    sub_62FC4((const void *)dword_12CBA8, (void *)dword_AE3FC, 0x1E0u);
  v3 = dword_AE3FC;
  dword_AE3FC = dword_12EFF4;
  dword_12EFF4 = v3;
  sub_4CB70();
  v4 = dword_AE3FC ^ dword_12EFF4;
  dword_AE3FC = dword_12EFF4;
  dword_12EFF4 ^= v4;
  if ( byte_12EEFF )
  {
    byte_12EEFF = 0;
    if ( byte_12EF1A || byte_12EF26 )
      sub_4C640();
    else
      sub_4C670();
  }
  if ( (__int16)dword_12CADC >> 1 != word_12CBDA || SHIWORD(dword_12CADC) >> 1 != word_12CBD8 )
  {
    v5 = (__int16)dword_12CADC >> 1;
    if ( v5 < 320 )
    {
      v6 = SHIWORD(dword_12CADC) >> 1;
      if ( v6 < 200 )
      {
        word_12CBDA = (__int16)dword_12CADC >> 1;
        word_12CBD8 = SHIWORD(dword_12CADC) >> 1;
        byte_12CBC6 = *(_BYTE *)((__int16)v5 + (__int16)v6 * dword_12EFF0 + dword_12CBA0);
        if ( !sub_4C6A0() )
          byte_12CBC6 = 0;
      }
    }
  }
  if ( byte_12EF0C )
  {
    byte_12EF0C = 0;
    byte_12CAE4 |= 1u;
  }
  if ( (byte_12CAE4 & 0x40) != 0 || byte_12EF70 == 1 )
  {
    byte_12EF70 = 0;
    byte_12CAE4 &= ~0x40u;
    if ( byte_12CBCD )
      byte_12CBCD = 0;
    byte_12CBC6 = *(_BYTE *)(dword_12CBA0 + word_12CBD8 * dword_12EFF0 + word_12CBDA);
    if ( !sub_4C6A0() )
      byte_12CBC6 = 0;
  }
  if ( (byte_12CAE4 & 1) != 0 )
  {
    byte_12CAE4 &= ~1u;
    if ( byte_12CBC6 != 11 || !byte_9687C )
    {
      if ( *(int *)((char *)&dword_4A12C + 6 * (unsigned __int8)byte_12CBC6) )
      {
        (*(void (**)(void))((char *)&dword_4A12C + 6 * (unsigned __int8)byte_12CBC6))();
        if ( (byte_12CBD5 & 8) != 0 )
        {
          v0 = 1;
          byte_12CBD5 &= ~8u;
        }
        goto LABEL_79;
      }
      v7 = word_4A130[3 * (unsigned __int8)byte_12CBC6];
      if ( !v7 )
        goto LABEL_79;
      v8 = dword_12EFF4;
      if ( !byte_12CBCD )
      {
        if ( word_4A130[3 * (unsigned __int8)byte_12CBC6] == 3 )
        {
          v0 = 1;
          byte_12CBCE = 1;
        }
        goto LABEL_70;
      }
      if ( (unsigned __int8)byte_12CBCD <= 1u )
      {
        switch ( v7 )
        {
          case 1:
            if ( sub_4F8D0(0, (void (*)(int))sub_4CC00) )
              sub_51AF0(1);
            break;
          case 2:
            if ( sub_4F8D0(0, (void (*)(int))sub_4CC00) )
              sub_51AF0(2);
            break;
          case 3:
            if ( sub_4F8D0(0, (void (*)(int))sub_4CC00) )
              sub_51AF0(3);
            break;
          case 4:
            if ( sub_4F8D0(0, (void (*)(int))sub_4CC00) )
              sub_51AF0(4);
            break;
          case 5:
            if ( sub_4F8D0(0, (void (*)(int))sub_4CC00) )
              sub_51AF0(5);
            break;
          case 6:
            if ( sub_4F8D0(0, (void (*)(int))sub_4CC00) )
              sub_51AF0(6);
            break;
          default:
            break;
        }
        v1 = 1;
        if ( (word_12F02E & 1) != 0 )
        {
LABEL_67:
          sub_62FA8((const void *)dword_12CBA8, (void *)dword_AE3FC, 0xC8u);
LABEL_69:
          v9 = dword_AE3FC;
          dword_AE3FC = dword_12EFF4;
          dword_12EFF4 = v9;
          sub_4CB70();
          v10 = dword_AE3FC ^ dword_12EFF4;
          dword_AE3FC = dword_12EFF4;
          v8 = dword_12EFF4 ^ v10;
          goto LABEL_70;
        }
      }
      else
      {
        if ( byte_12CBCD != 2 )
        {
LABEL_70:
          if ( v1 )
          {
            dword_12EFF4 = v8;
            byte_12CBCD = 0;
          }
          else
          {
            dword_12EFF4 = v8;
            if ( !byte_12CBCD )
            {
              v11 = word_4A130[3 * (unsigned __int8)byte_12CBC6];
              if ( v11 == 1 || v11 == 2 )
              {
                byte_12CBCD = word_4A130[3 * (unsigned __int8)byte_12CBC6];
                if ( (word_12F02E & 1) != 0 )
                  sub_62FA8((const void *)dword_12CBA8, (void *)dword_AE3FC, 0xC8u);
                else
                  sub_62FC4((const void *)dword_12CBA8, (void *)dword_AE3FC, 0x1E0u);
                v12 = dword_AE3FC;
                dword_AE3FC = dword_12EFF4;
                dword_12EFF4 = v12;
                sub_4CB70();
                v13 = dword_AE3FC;
                dword_AE3FC = dword_12EFF4;
                dword_12EFF4 = v13;
              }
            }
          }
          goto LABEL_79;
        }
        switch ( v7 )
        {
          case 1:
            if ( sub_4CCA0(0) )
              sub_51C90(1);
            break;
          case 2:
            if ( sub_4CCA0(0) )
              sub_51C90(2);
            break;
          case 3:
            if ( sub_4CCA0(0) )
              sub_51C90(3);
            break;
          case 4:
            if ( sub_4CCA0(0) )
              sub_51C90(4);
            break;
          case 5:
            if ( sub_4CCA0(0) )
              sub_51C90(5);
            break;
          case 6:
            if ( sub_4CCA0(0) )
              sub_51C90(6);
            break;
          default:
            break;
        }
        v1 = 1;
        if ( (word_12F02E & 1) != 0 )
          goto LABEL_67;
      }
      sub_62FC4((const void *)dword_12CBA8, (void *)dword_AE3FC, 0x1E0u);
      goto LABEL_69;
    }
  }
LABEL_79:
  if ( byte_12CBC6 == 11 && byte_9687C || !byte_12CBC6 )
    sub_51E84((_BYTE *)dword_AE3FC, (_BYTE *)dword_12EFF4, (_BYTE *)dword_12CBA0, dword_12CBAC, 255);
  else
    sub_51E84((_BYTE *)dword_AE3FC, (_BYTE *)dword_12EFF4, (_BYTE *)dword_12CBA0, dword_12CBAC, byte_12CBC6);
  if ( (byte_90B23 & 0x23) != 0 )
  {
    if ( (word_12F02E & 1) != 0 )
      sub_60CE0(dword_9AD90, SHIWORD(dword_9AD90), dword_12CAEC + 6 * (unsigned __int8)byte_12CBCE);
    else
      sub_60D18(dword_9AD90, SHIWORD(dword_9AD90), dword_12CAEC + 6 * (unsigned __int8)byte_12CBCE);
  }
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  if ( sub_4C580() )
  {
    v14 = dword_12EFF4;
    if ( dword_12CBB4 + 4800 <= (unsigned int)dword_AC5D4 )
    {
      dword_12CBB4 = dword_AC5D4;
      if ( byte_12CBD4 )
      {
        if ( (unsigned __int8)byte_12CBD4 <= 1u )
        {
          byte_12CBCE = 8;
          byte_12CBD6 |= 2u;
          sub_20E60();
        }
        else if ( byte_12CBD4 == 2 )
        {
          byte_12CBD6 |= 4u;
          v2 = 1;
          dword_12CBB8 = *(unsigned __int16 *)(dword_AE408 + 17);
          dword_96880 = 1;
          qmemcpy(&unk_12CA60, (const void *)(dword_AE400 + 15318), 0x18u);
          v15 = dword_AE408;
          *(_WORD *)(dword_AE408 + 13) = 0;
          *(_BYTE *)(v15 + 161) = 3;
          v16 = *(_BYTE *)v15;
          *(_DWORD *)(v15 + 162) = 200;
          *(_BYTE *)v15 = v16 | 0x24;
        }
      }
      else
      {
        byte_12CBCE = 0;
        byte_12CBD6 |= 1u;
        sub_20E60();
      }
      v14 = dword_12EFF4;
      if ( ++byte_12CBD4 == 3 )
        byte_12CBD4 = 0;
      v0 = 1;
    }
  }
  else
  {
    v14 = dword_12EFF4;
    dword_12CBB4 = dword_AC5D4;
  }
  dword_12EFF4 = v14;
  if ( v0 )
  {
    sub_4CAC0();
    if ( v2 )
      byte_12CBCE = 2;
  }
}
// 4A12C: using guessed type int dword_4A12C;
// 4A130: using guessed type __int16 word_4A130[];
// 4CC00: using guessed type int sub_4CC00();
// 90B23: using guessed type char byte_90B23;
// 9687C: using guessed type char byte_9687C;
// 96880: using guessed type int dword_96880;
// 9AD90: using guessed type int dword_9AD90;
// AC5D4: using guessed type int dword_AC5D4;
// AE3FC: using guessed type int dword_AE3FC;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// 12CADC: using guessed type int dword_12CADC;
// 12CAE4: using guessed type char byte_12CAE4;
// 12CAEC: using guessed type int dword_12CAEC;
// 12CBA0: using guessed type int dword_12CBA0;
// 12CBA8: using guessed type int dword_12CBA8;
// 12CBAC: using guessed type int dword_12CBAC;
// 12CBB4: using guessed type int dword_12CBB4;
// 12CBB8: using guessed type int dword_12CBB8;
// 12CBC6: using guessed type char byte_12CBC6;
// 12CBCD: using guessed type char byte_12CBCD;
// 12CBCE: using guessed type char byte_12CBCE;
// 12CBD4: using guessed type char byte_12CBD4;
// 12CBD5: using guessed type char byte_12CBD5;
// 12CBD6: using guessed type char byte_12CBD6;
// 12CBD8: using guessed type __int16 word_12CBD8;
// 12CBDA: using guessed type __int16 word_12CBDA;
// 12EEFF: using guessed type char byte_12EEFF;
// 12EF0C: using guessed type char byte_12EF0C;
// 12EF1A: using guessed type char byte_12EF1A;
// 12EF26: using guessed type char byte_12EF26;
// 12EF70: using guessed type char byte_12EF70;
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004C580) --------------------------------------------------------
int sub_4C580()
{
  int result; // eax

  result = 1;
  if ( word_9AD90 != dword_968C4
    || word_9AD92 != dword_968C8
    || byte_12EF70 != byte_12CBDC
    || word_12EFE4 != dword_968CC
    || word_12EFE2 != dword_968D0
    || word_12EFE0 != dword_968D4
    || byte_12EF70 != byte_12CBDC )
  {
    dword_968C4 = word_9AD90;
    dword_968C8 = word_9AD92;
    dword_968CC = word_12EFE4;
    dword_968D0 = word_12EFE2;
    dword_968D4 = word_12EFE0;
    byte_12CBDC = byte_12EF70;
    return 0;
  }
  return result;
}
// 968C4: using guessed type int dword_968C4;
// 968C8: using guessed type int dword_968C8;
// 968CC: using guessed type int dword_968CC;
// 968D0: using guessed type int dword_968D0;
// 968D4: using guessed type int dword_968D4;
// 9AD90: using guessed type __int16 word_9AD90;
// 9AD92: using guessed type __int16 word_9AD92;
// 12CBDC: using guessed type char byte_12CBDC;
// 12EF70: using guessed type char byte_12EF70;
// 12EFE0: using guessed type __int16 word_12EFE0;
// 12EFE2: using guessed type __int16 word_12EFE2;
// 12EFE4: using guessed type __int16 word_12EFE4;

//----- (0004C640) --------------------------------------------------------
bool sub_4C640()
{
  bool result; // eax

  do
  {
    if ( !--byte_12CBC6 )
      byte_12CBC6 = 11;
    result = sub_4C6A0();
  }
  while ( !result );
  return result;
}
// 12CBC6: using guessed type char byte_12CBC6;

//----- (0004C670) --------------------------------------------------------
bool sub_4C670()
{
  bool result; // eax

  do
  {
    if ( (unsigned __int8)++byte_12CBC6 > 0xBu )
      byte_12CBC6 = 1;
    result = sub_4C6A0();
  }
  while ( !result );
  return result;
}
// 12CBC6: using guessed type char byte_12CBC6;

//----- (0004C6A0) --------------------------------------------------------
bool sub_4C6A0()
{
  if ( (unsigned __int8)byte_12CBC6 <= 7u )
  {
    if ( byte_12CBC6 == 3 )
    {
      if ( byte_93958 != 1 )
        return 0;
    }
    else if ( byte_12CBC6 == 7 && !byte_12CBCD )
    {
      return 0;
    }
  }
  else
  {
    if ( byte_12CBC6 == 11 )
      return !byte_9687C;
    if ( !byte_12CBCD )
      return 0;
  }
  return 1;
}
// 93958: using guessed type char byte_93958;
// 9687C: using guessed type char byte_9687C;
// 12CBC6: using guessed type char byte_12CBC6;
// 12CBCD: using guessed type char byte_12CBCD;

//----- (0004C6F0) --------------------------------------------------------
int sub_4C6F0()
{
  int result; // eax
  __int16 v1; // dx
  __int16 v2; // di

  result = dword_12CBB0 & 1;
  if ( result == 1 && byte_12CBCE == 2 )
  {
    result = sub_1002D(dword_12CB7A, dword_12CBA8);
    v1 = word_12CB7E + 1;
    dword_12CB7A = result;
    word_12CB7E = v1;
    if ( v1 == 31 )
    {
      result = dword_12CB76;
      word_12CB7E = 1;
      dword_12CB7A = dword_12CB76;
    }
    else if ( v1 == 1 && !dword_12CB76 )
    {
      dword_12CB76 = result;
    }
    if ( !byte_9687C )
    {
      result = sub_1002D(dword_12CB88, dword_12CBA8);
      v2 = word_12CB8C + 1;
      dword_12CB88 = result;
      word_12CB8C = v2;
      if ( v2 == 4 )
      {
        result = dword_12CB84;
        word_12CB8C = 1;
        dword_12CB88 = dword_12CB84;
      }
      else if ( v2 == 1 && !dword_12CB84 )
      {
        dword_12CB84 = result;
      }
    }
  }
  return result;
}
// 9687C: using guessed type char byte_9687C;
// 12CB76: using guessed type int dword_12CB76;
// 12CB7A: using guessed type int dword_12CB7A;
// 12CB7E: using guessed type __int16 word_12CB7E;
// 12CB84: using guessed type int dword_12CB84;
// 12CB88: using guessed type int dword_12CB88;
// 12CB8C: using guessed type __int16 word_12CB8C;
// 12CBA8: using guessed type int dword_12CBA8;
// 12CBB0: using guessed type int dword_12CBB0;
// 12CBCE: using guessed type char byte_12CBCE;

//----- (0004C7E0) --------------------------------------------------------
void sub_4C7E0()
{
  int v0; // ecx
  const void *v1; // edi
  void *v2; // ebp
  void *v3; // edi

  sub_10010(320, 0);
  sub_61CC0(0, 0x10u, 0);
  sub_5D070(0xDu);
  sub_5CEF0(0);
  sub_40440((int)"data\\screens\\mmspr.dat");
  if ( (word_12F02E & 1) != 0 )
    sub_65D70(dword_12CB04, dword_12CB08, dword_12CB0C);
  else
    sub_65DC0((unsigned int *)dword_12CB04, dword_12CB08, dword_12CB0C);
  sub_51480((int)&dword_9688C, &dword_12CB34, (unsigned __int8 *)dword_12CB9C);
  byte_96890 &= ~2u;
  sub_3EEA0(aDataScreensMai, (char *)dword_AE3FC);
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_AE3FC, (void *)dword_12CBA8, 0xC8u);
  else
    sub_62FC4((const void *)dword_AE3FC, (void *)dword_12CBA8, 0x1E0u);
  sub_3EEA0(aDataScreensMai_0, (char *)dword_12CB9C);
  sub_504A0();
  sub_51A10();
  v0 = dword_AE3FC;
  dword_AE3FC = dword_12EFF4;
  dword_12EFF4 = v0;
  sub_4CB70();
  v1 = (const void *)dword_12EFF4;
  v2 = (void *)dword_AE3FC;
  dword_AE3FC = dword_12EFF4;
  dword_12EFF4 = (int)v2;
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8(v1, v2, 0xC8u);
  else
    sub_62FC4(v1, v2, 0x1E0u);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  if ( !byte_90B23 )
    sub_5C05C(dword_12CAEC + 6 * (unsigned __int8)byte_12CBCE);
  sub_61CC0((unsigned __int8 *)dword_12CB9C, 0x20u, 0);
  dword_12CB76 = 0;
  dword_12CB84 = 0;
  word_12CB8C = 0;
  byte_12CBD5 |= 1u;
  byte_12CBC6 = 0;
  dword_12CB7A = dword_12CB72;
  word_12CB7E = 0;
  dword_12CB88 = dword_12CB80;
  byte_967E4 = 1;
  byte_12CAE4 &= 0xBEu;
  dword_12CBB4 = dword_AC5D4;
  sub_356E0();
  sub_5D290(4);
  if ( (byte_12CBD6 & 4) != 0 )
  {
    v3 = (void *)(dword_AE400 + 15318);
    *(_WORD *)(dword_AE408 + 17) = dword_12CBB8;
    qmemcpy(v3, &unk_12CA60, 0x18u);
    byte_12CBD6 &= ~4u;
    *(_BYTE *)dword_AE408 &= 0xDBu;
  }
}
// 90B23: using guessed type char byte_90B23;
// 967E4: using guessed type char byte_967E4;
// 9688C: using guessed type int dword_9688C;
// 96890: using guessed type char byte_96890;
// AC5D4: using guessed type int dword_AC5D4;
// AE3FC: using guessed type int dword_AE3FC;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// 12CAE4: using guessed type char byte_12CAE4;
// 12CAEC: using guessed type int dword_12CAEC;
// 12CB04: using guessed type int dword_12CB04;
// 12CB08: using guessed type int dword_12CB08;
// 12CB0C: using guessed type int dword_12CB0C;
// 12CB34: using guessed type _DWORD dword_12CB34;
// 12CB72: using guessed type int dword_12CB72;
// 12CB76: using guessed type int dword_12CB76;
// 12CB7A: using guessed type int dword_12CB7A;
// 12CB7E: using guessed type __int16 word_12CB7E;
// 12CB80: using guessed type int dword_12CB80;
// 12CB84: using guessed type int dword_12CB84;
// 12CB88: using guessed type int dword_12CB88;
// 12CB8C: using guessed type __int16 word_12CB8C;
// 12CB9C: using guessed type int dword_12CB9C;
// 12CBA8: using guessed type int dword_12CBA8;
// 12CBB4: using guessed type int dword_12CBB4;
// 12CBB8: using guessed type int dword_12CBB8;
// 12CBC6: using guessed type char byte_12CBC6;
// 12CBCE: using guessed type char byte_12CBCE;
// 12CBD5: using guessed type char byte_12CBD5;
// 12CBD6: using guessed type char byte_12CBD6;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004CAC0) --------------------------------------------------------
int sub_4CAC0()
{
  int v0; // eax
  int result; // eax

  if ( byte_12CBCE != 5 )
  {
    LOWORD(v0) = sub_61CC0(0, 0x10u, 0);
    if ( !byte_90B23 )
      v0 = sub_5C05C(0);
    if ( (word_12F02E & 1) != 0 )
      sub_411D7(v0, (void *)dword_12EFF4, 0xC8u, 0);
    else
      sub_411FD(v0, (void *)dword_12EFF4, 0x1E0u, 0);
    if ( (word_12F02E & 1) != 0 )
      sub_5CDA0();
    else
      sub_599B0(480);
  }
  result = sub_61610((int)"data\\screens\\mmspr.dat");
  byte_967E4 = 0;
  byte_12CBD5 &= ~1u;
  return result;
}
// 4CB07: variable 'v0' is possibly undefined
// 90B23: using guessed type char byte_90B23;
// 967E4: using guessed type char byte_967E4;
// 12CBCE: using guessed type char byte_12CBCE;
// 12CBD5: using guessed type char byte_12CBD5;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004CB70) --------------------------------------------------------
void sub_4CB70()
{
  if ( byte_12CBCD )
  {
    if ( (unsigned __int8)byte_12CBCD <= 1u || byte_12CBCD == 2 )
      sub_4D300();
  }
  else
  {
    if ( (word_12F02E & 1) != 0 )
      sub_60CE0(358, 10, dword_12CB04 + 6);
    else
      sub_60D18(358, 10, dword_12CB04 + 6);
    if ( (word_12F02E & 1) != 0 )
      sub_60CE0(336, 86, dword_12CB04 + 12);
    else
      sub_60D18(336, 86, dword_12CB04 + 12);
  }
}
// 12CB04: using guessed type int dword_12CB04;
// 12CBCD: using guessed type char byte_12CBCD;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004CCA0) --------------------------------------------------------
int sub_4CCA0(int a1)
{
  int v1; // ebx
  __int16 v2; // di
  __int16 v3; // cx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax

  v1 = 0;
  v2 = 0;
  byte_12CBD5 &= ~0x40u;
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_AE3FC, (void *)dword_12CBA4, 0xC8u);
  else
    sub_62FC4((const void *)dword_AE3FC, (void *)dword_12CBA4, 0x1E0u);
  if ( !byte_90B23 )
    sub_5C05C(0);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  sprintf(&unk_9ADC8, aIntroScrollDat);
  dword_AC5C4 = (int (*)(_DWORD))sub_50470;
  word_90026 = 0;
  sub_107C0(0, 0, (int)dword_4A17C);
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_12EFF4, (void *)dword_AE3FC, 0xC8u);
  else
    sub_62FC4((const void *)dword_12EFF4, (void *)dword_AE3FC, 0x1E0u);
  HIBYTE(v3) = 0;
  dword_AC5C4 = 0;
  if ( !byte_90B23 )
    sub_5C05C(6 * (unsigned __int8)byte_12CBCE + dword_12CAEC);
  sub_513E0();
  sub_51360(80, 73, 159, 48);
  v4 = strcmp((char*)dword_96860[(unsigned __int16)word_4A130[3 * (unsigned __int8)byte_12CBC6]], asc_A9ACC);
  if ( !v4 )
    LOWORD(v4) = sub_4D0F0();
  while ( !v1 )
  {
    LOBYTE(v3) = byte_90B23;
    if ( !byte_90B23 || (byte_90B23 & 0x23) != 0 && (v2 & 3) == 0 )
      sub_50770(v4, v3, v2, a1);
    if ( byte_12EF0C )
    {
      v1 = 1;
      HIBYTE(v3) = 0;
      a1 = 1;
      word_12EFDE = 0;
      byte_12EF0C = 0;
      byte_12EEF1 = 0;
      byte_12CAE4 &= ~1u;
    }
    if ( byte_12EEF1 )
    {
      v1 = 1;
      a1 = 0;
      word_12EFDE = 0;
      HIBYTE(v3) = byte_12CAE4 & 0xFE;
      byte_12EF0C = 0;
      byte_12CAE4 &= ~1u;
      byte_12EEF1 = 0;
    }
    if ( (byte_12CAE4 & 1) != 0 )
    {
      v5 = word_12CAE0 >> 1;
      if ( v5 >= 68 && v5 <= 81 )
      {
        v6 = word_12CAE2 >> 1;
        if ( v6 >= 106 && v6 <= 116 )
        {
          v1 = 1;
          a1 = 1;
        }
      }
      v7 = word_12CAE0 >> 1;
      if ( v7 >= 240 && v7 <= 250 )
      {
        v8 = word_12CAE2 >> 1;
        if ( v8 >= 105 && v8 <= 115 )
        {
          v1 = 1;
          a1 = 0;
        }
      }
      v9 = word_12CAE0 >> 1;
      if ( v9 >= 110 && v9 <= 230 )
      {
        v10 = word_12CAE2 >> 1;
        if ( v10 >= 85 && v10 <= 95 )
        {
          sub_4D0F0();
          byte_12EF0C = 0;
          byte_12EEF1 = 0;
        }
      }
      word_12EFDE = 0;
      HIBYTE(v3) = byte_12CAE4 & 0xFE;
      byte_12EF0C = 0;
      byte_12EEF1 = 0;
      byte_12CAE4 &= ~1u;
    }
    sub_4D190();
    if ( (byte_90B23 & 0x23) != 0 )
    {
      if ( (word_12F02E & 1) != 0 )
        sub_60CE0(dword_9AD90, SHIWORD(dword_9AD90), dword_12CAEC + 6 * (unsigned __int8)byte_12CBCE);
      else
        sub_60D18(dword_9AD90, SHIWORD(dword_9AD90), 6 * (unsigned __int8)byte_12CBCE + dword_12CAEC);
    }
    if ( (word_12F02E & 1) != 0 )
      sub_5CDA0();
    else
      sub_599B0(480);
    ++v2;
  }
  sub_51400();
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_12CBA4, (void *)dword_AE3FC, 0xC8u);
  else
    sub_62FC4((const void *)dword_12CBA4, (void *)dword_AE3FC, 0x1E0u);
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
  else
    sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  word_12EFDC = 0;
  word_12EFDE = 0;
  byte_12EEF1 = 0;
  byte_12EF0C = 0;
  byte_12CAE4 &= 0xBEu;
  return a1;
}
// 4CE4A: variable 'v4' is possibly undefined
// 4A130: using guessed type __int16 word_4A130[];
// 4A17C: using guessed type int dword_4A17C[6];
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 639E0: using guessed type _DWORD strcmp(_DWORD, _DWORD);
// 90026: using guessed type __int16 word_90026;
// 90B23: using guessed type char byte_90B23;
// 96860: using guessed type int dword_96860[];
// 9AD90: using guessed type int dword_9AD90;
// AC5C4: using guessed type int (*dword_AC5C4)(_DWORD);
// AE3FC: using guessed type int dword_AE3FC;
// 12CAE0: using guessed type __int16 word_12CAE0;
// 12CAE2: using guessed type __int16 word_12CAE2;
// 12CAE4: using guessed type char byte_12CAE4;
// 12CAEC: using guessed type int dword_12CAEC;
// 12CBA4: using guessed type int dword_12CBA4;
// 12CBC6: using guessed type char byte_12CBC6;
// 12CBCE: using guessed type char byte_12CBCE;
// 12CBD5: using guessed type char byte_12CBD5;
// 12EEF1: using guessed type char byte_12EEF1;
// 12EF0C: using guessed type char byte_12EF0C;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004D0F0) --------------------------------------------------------
bool sub_4D0F0()
{
  bool result; // eax

  byte_12EF0C = 0;
  word_12EFDC = 0;
  byte_12EEF1 = 0;
  word_12EFDA = 0;
  byte_12CBD5 |= 0x40u;
  word_12EFDE = 0;
  result = sub_50D40(
             30,
             12,
             20,
             0,
             (char *)dword_96860[(unsigned __int16)word_4A130[3 * (unsigned __int8)byte_12CBC6]],
             255,
             0,
             (void (*)(void))sub_4D190,
             0,
             (int)&dword_9688C);
  byte_12CBD5 &= ~0x40u;
  return result;
}
// 4A130: using guessed type __int16 word_4A130[];
// 96860: using guessed type int dword_96860[];
// 9688C: using guessed type int dword_9688C;
// 12CBC6: using guessed type char byte_12CBC6;
// 12CBD5: using guessed type char byte_12CBD5;
// 12EEF1: using guessed type char byte_12EEF1;
// 12EF0C: using guessed type char byte_12EF0C;
// 12EFDA: using guessed type __int16 word_12EFDA;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;

//----- (0004D190) --------------------------------------------------------
int sub_4D190()
{
  int result; // eax

  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
  else
    sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
  sub_65EB0(65, 75, 189, 44);
  if ( (word_12F02E & 1) != 0 )
    sub_60CE0(24, 8, dword_12CB04 + 12);
  else
    sub_60D18(24, 8, dword_12CB04 + 12);
  result = sub_65EB0(0, 0, 320, 200);
  if ( (byte_12CBD5 & 0x40) == 0 )
  {
    sub_51560(
        (uint8*)&dword_9688C,
      30,
      12,
      (unsigned __int8 *)dword_96860[(unsigned __int16)word_4A130[3 * (unsigned __int8)byte_12CBC6]]);
    if ( (word_12F02E & 1) != 0 )
      sub_60CE0(136, 210, dword_12CB04 + 30);
    else
      sub_60D18(136, 210, dword_12CB04 + 30);
    if ( (word_12F02E & 1) != 0 )
      return sub_60CE0(480, 210, dword_12CB04 + 36);
    else
      return sub_60D18(480, 210, dword_12CB04 + 36);
  }
  return result;
}
// 4A130: using guessed type __int16 word_4A130[];
// 96860: using guessed type int dword_96860[];
// 9688C: using guessed type int dword_9688C;
// AE3FC: using guessed type int dword_AE3FC;
// 12CB04: using guessed type int dword_12CB04;
// 12CBC6: using guessed type char byte_12CBC6;
// 12CBD5: using guessed type char byte_12CBD5;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004D300) --------------------------------------------------------
void sub_4D300()
{
  int v0; // ebx
  __int64 v1; // rax
  unsigned __int8 i; // [esp+0h] [ebp-14h]

  byte_96892 = sub_5CC70((unsigned __int8 *)dword_12CB9C, 0x3Fu, 0x3Fu, 0);
  sub_513E0();
  for ( i = 0; i < 6u; ++i )
  {
    v0 = 4 * i;
    sub_51360(dword_4A7EC[v0], dword_4A7F0[v0], dword_4A7F4[v0], dword_4A7F8[v0]);
    v1 = dword_4A7F8[v0] - *(unsigned __int8 *)(dword_9688C + 5);
    sub_51560((uint8*)&dword_9688C, 4, ((int)v1 - HIDWORD(v1)) >> 1, (unsigned __int8 *)off_96864[i]);
  }
  sub_51400();
}
// 4A7EC: using guessed type int dword_4A7EC[];
// 4A7F0: using guessed type int dword_4A7F0[];
// 4A7F4: using guessed type int dword_4A7F4[];
// 4A7F8: using guessed type int dword_4A7F8[];
// 96864: using guessed type char *off_96864[5];
// 9688C: using guessed type int dword_9688C;
// 96892: using guessed type char byte_96892;
// 12CB9C: using guessed type int dword_12CB9C;

//----- (0004D3B0) --------------------------------------------------------
void sub_4D3B0()
{
  int v0; // eax
  int v1; // eax

  //fix
  v1 = 0;
  //fix

  if ( !byte_90B23 )
    sub_5C05C(0);
  LOWORD(v0) = sub_61CC0(0, 0x10u, 0);
  if ( (word_12F02E & 1) != 0 )
    sub_411D7(v0, (void *)dword_12EFF4, 0xC8u, 0);
  else
    sub_411FD(v0, (void *)dword_12EFF4, 0x1E0u, 0);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  sprintf(&unk_9ADC8, aIntroIntroDat);
  word_12EFDC = 0;
  word_12EFDE = 0;
  byte_12EEF1 = 0;
  byte_12EF70 = 0;
  if ( (byte_12CBD5 & 2) != 0 )
  {
    if ( (byte_12CBD6 & 1) != 0 )
      word_90026 = 1;
    sub_107C0(1, 1, (int)dword_4A1FC);
    word_90026 = 0;
  }
  else
  {
    sub_107C0(0, 1, (int)dword_4A1FC);
  }
  sub_61CC0(0, 0x10u, 0);
  sub_24BB0();
  sub_5D010();
  sub_20E60();
  if ( (word_12F02E & 1) != 0 )
    sub_411D7(v1, (void *)dword_12EFF4, 0xC8u, 0);
  else
    sub_411FD(v1, (void *)dword_12EFF4, 0x1E0u, 0);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  byte_12CBD5 |= 6u;
  if ( (byte_12CBD6 & 1) != 0 )
  {
    byte_12CBCE = 2;
    byte_12CBD6 &= ~1u;
  }
  else
  {
    byte_12CBCE = 8;
  }
  byte_12CBD5 &= ~1u;
}
// 4D3EC: variable 'v0' is possibly undefined
// 4D4DB: variable 'v1' is possibly undefined
// 4A1FC: using guessed type int dword_4A1FC[2];
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 90026: using guessed type __int16 word_90026;
// 90B23: using guessed type char byte_90B23;
// 12CBCE: using guessed type char byte_12CBCE;
// 12CBD5: using guessed type char byte_12CBD5;
// 12CBD6: using guessed type char byte_12CBD6;
// 12EEF1: using guessed type char byte_12EEF1;
// 12EF70: using guessed type char byte_12EF70;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004D560) --------------------------------------------------------
void sub_4D560()
{
  int v0; // eax
  int v1; // ebx

  if ( !byte_90B23 )
    sub_5C05C(0);
  LOWORD(v0) = sub_61CC0(0, 0x10u, 0);
  if ( (word_12F02E & 1) != 0 )
    sub_411D7(v0, (void *)dword_12EFF4, 0xC8u, 0);
  else
    sub_411FD(v0, (void *)dword_12EFF4, 0x1E0u, 0);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  sprintf(&unk_9ADC8, aIntroOutroDat);
  word_12EFDC = 0;
  word_12EFDE = 0;
  byte_12EEF1 = 0;
  byte_12EF70 = 0;
  word_90026 = 0;
  sub_107C0(0, 1, (int)dword_4A638);
  sub_61CC0(0, 0x10u, 0);
  sub_5D010();
  sub_20E60();
  v1 = *(__int16 *)(dword_AE400 + 8);
  dword_96880 = 1;
  *(_BYTE *)(dword_AE400 + 2049 * v1 + 13327) = 1;
  while ( 1 )
    ;
}
// 4D59B: variable 'v0' is possibly undefined
// 4A638: using guessed type int dword_4A638[2];
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 90026: using guessed type __int16 word_90026;
// 90B23: using guessed type char byte_90B23;
// 96880: using guessed type int dword_96880;
// AC5D4: using guessed type int dword_AC5D4;
// AE400: using guessed type int dword_AE400;
// 12EEF1: using guessed type char byte_12EEF1;
// 12EF70: using guessed type char byte_12EF70;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004D680) --------------------------------------------------------
void sub_4D680()
{
  int v0; // eax
  int v1; // edx
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  __int16 v11; // dx
  int v12; // eax
  int v13; // ebx
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  unsigned __int8 i; // ah
  int v19; // edx
  int v20; // esi
  int v21; // ecx
  int v22; // ebx
  int v23; // edx
  unsigned __int8 v24; // al
  int v25; // edx
  int v26; // eax
  int v27; // edx
  int v28; // edi
  int v29; // esi
  int v30; // eax
  char v31; // cl
  unsigned __int8 *v32; // [esp-4h] [ebp-18h]
  unsigned __int8 *v33; // [esp-4h] [ebp-18h]
  char v34; // [esp+0h] [ebp-14h]
  char v35; // [esp+4h] [ebp-10h]

  v34 = 0;
  v35 = 0;
  if ( (byte_12CBD5 & 1) == 0 )
  {
    sub_4E0E0();
    sub_4E320();
  }
  if ( byte_12EEF1 )
  {
    byte_12EEF1 = 0;
    v34 = 1;
  }
  v0 = (__int16)dword_12CADC >> 1;
  if ( v0 >= 173 && v0 <= 263 )
  {
    v1 = SHIWORD(dword_12CADC) >> 1;
    if ( v1 >= 72 && v1 <= 133 )
    {
      word_12CBC0 = (v1 - 72) / (*(unsigned __int8 *)(dword_9688C + 5) - 2);
      if ( (byte_12CAE4 & 1) != 0 )
        word_12CBC2 = word_12CBC0 + word_12CBBE;
    }
  }
  if ( (byte_12CAE4 & 1) != 0 )
  {
    v2 = (__int16)dword_12CADC >> 1;
    if ( v2 < 173 || v2 > 262 || (v3 = SHIWORD(dword_12CADC) >> 1, v3 < 57) || v3 > 71 )
    {
      v4 = (__int16)dword_12CADC >> 1;
      if ( v4 >= 173 && v4 <= 262 )
      {
        v5 = SHIWORD(dword_12CADC) >> 1;
        if ( v5 >= 134 && v5 <= 148 && (unsigned __int16)word_12CBBE + 5 < 20 )
          ++word_12CBBE;
      }
    }
    else if ( word_12CBBE )
    {
      --word_12CBBE;
    }
  }
  if ( (byte_12CAE4 & 1) != 0 || (byte_12CAE4 & 0x40) != 0 )
  {
    v6 = word_12CAE0 >> 1;
    if ( v6 < 284 || v6 > 303 || (v7 = word_12CAE2 >> 1, v7 < 48) || v7 > 67 )
    {
      v8 = word_12CAE0 >> 1;
      if ( v8 < 284 || v8 > 303 || (v9 = word_12CAE2 >> 1, v9 < 126) || v9 > 145 )
      {
        v14 = word_12CAE0 >> 1;
        if ( v14 < 236 || v14 > 256 || (v15 = word_12CAE2 >> 1, v15 < 156) || v15 > 176 )
        {
          v16 = word_12CAE0 >> 1;
          if ( v16 < 176 || v16 > 253 || (v17 = word_12CAE2 >> 1, v17 < 46) || v17 > 58 )
          {
            for ( i = 0; i < 8u; ++i )
            {
              v19 = word_12CAE0 >> 1;
              v20 = word_4A7CC[2 * i];
              if ( v19 >= v20 )
              {
                v21 = dword_12CB10 + 6 * (i + 1);
                if ( v19 <= ((int)*(unsigned __int8 *)(v21 + 4) >> 1) + v20 )
                {
                  v22 = word_4A7CE[2 * i];
                  v23 = word_12CAE2 >> 1;
                  if ( v23 >= v22 && v23 <= ((int)*(unsigned __int8 *)(v21 + 5) >> 1) + v22 && (byte_12CAE4 & 1) != 0 )
                  {
                    v24 = 0;
                    byte_12CBD1 = 0;
                    do
                    {
                      if ( v24 > i && v24 >= 2u )
                      {
                        byte_9689C[3 * v24] = 0;
                      }
                      else
                      {
                        ++byte_12CBD1;
                        byte_9689C[3 * v24] = 1;
                      }
                      v25 = 3 * v24++;
                      byte_9689D[v25] = 0;
                    }
                    while ( v24 < 8u );
                  }
                }
              }
            }
          }
          else
          {
            byte_12CAE4 &= ~1u;
            if ( ++byte_12CBD0 == 10 )
              byte_12CBD0 = 0;
            sprintf((char*)(dword_AE408 + 117), "CARPET%d", (unsigned __int8)byte_12CBD0);
          }
        }
        else
        {
          v34 = 1;
        }
      }
      else
      {
        word_12CBC4 = *(_WORD *)(dword_AE408 + 17);
        *(_WORD *)(dword_AE408 + 17) = word_12CBC2 + 50;
        byte_12CBD5 |= 0x10u;
        byte_12CBD2 = 6;
        sub_4DCC0();
        sub_513E0();
        sub_51360(173, 42, 90, 15);
        v32 = (unsigned __int8 *)(dword_AE408 + 117);
        v10 = sub_51420((uint32*)&dword_9688C, (char *)(dword_AE408 + 117));
        sub_51560((uint8*)&dword_9688C, (__int16)((90 - v10) / 2), 1, v32);
        sub_51400();
        if ( (word_12F02E & 1) != 0 )
          sub_5CDA0();
        else
          sub_599B0(480);
        *(_WORD *)(dword_AE400 + 10) = (unsigned __int8)byte_12CBD1;
        byte_12CBD5 &= ~0x10u;
        if ( !byte_90B23 )
          sub_5C05C(6 * (unsigned __int8)byte_12CBCE + dword_12CAEC);
        v11 = sub_43430((char *)(dword_AE408 + 117), (unsigned __int8)byte_12CBD1);
        v12 = dword_AE400;
        *(_WORD *)(dword_AE400 + 8) = v11;
        if ( v11 == -1 )
        {
          sub_4E320();
          sub_61CC0((unsigned __int8 *)dword_12CB9C, 0x20u, 0);
        }
        else
        {
          v13 = dword_AE408;
          *(_BYTE *)dword_AE408 |= 0x10u;
          *(_BYTE *)(v12 + 10 * *(__int16 *)(v12 + 8) + 29716) = *(_BYTE *)(v13 + 17);
          sub_43930((char *)(v12 + 29715), 0xAu);
          dword_96880 = 1;
          v35 = 1;
          v34 = 1;
          *(_WORD *)(dword_AE408 + 17) = *(char *)(dword_AE400 + 29716);
        }
      }
    }
    byte_12CAE4 &= 0xBEu;
  }
  sub_4DCC0();
  sub_513E0();
  sub_51360(173, 42, 90, 15);
  v33 = (unsigned __int8 *)(dword_AE408 + 117);
  v26 = 90 - sub_51420((uint32*)&dword_9688C, (char *)(dword_AE408 + 117));
  sub_51560((uint8*)&dword_9688C, (__int16)(v26 / 2), 1, v33);
  sub_51400();
  if ( (byte_90B23 & 0x23) != 0 )
  {
    if ( (word_12F02E & 1) != 0 )
      sub_60CE0(dword_9AD90, SHIWORD(dword_9AD90), 6 * (unsigned __int8)byte_12CBCE + dword_12CAEC);
    else
      sub_60D18(dword_9AD90, SHIWORD(dword_9AD90), 6 * (unsigned __int8)byte_12CBCE + dword_12CAEC);
  }
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  if ( v34 )
  {
    sub_4E270();
    if ( !v35 )
    {
      v27 = dword_AE400;
      v28 = dword_AE400 + 13323;
      v29 = dword_AE400 + 9225;
      v30 = dword_AE408;
      qmemcpy((void *)(dword_AE400 + 13323), (const void *)(dword_AE400 + 9225), 0x800u);
      *(_BYTE *)(v28 + 2048) = *(_BYTE *)(v29 + 2048);
      byte_12CBCE = 2;
      v31 = *(_BYTE *)v30 & 0xEF;
      *(_WORD *)(v30 + 17) = *(_WORD *)(v30 + 19);
      *(_BYTE *)v30 = v31;
      *(_WORD *)(v27 + 8) = 0;
    }
  }
}
// 4A7CC: using guessed type __int16 word_4A7CC[];
// 4A7CE: using guessed type __int16 word_4A7CE[];
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 90B23: using guessed type char byte_90B23;
// 96880: using guessed type int dword_96880;
// 9688C: using guessed type int dword_9688C;
// 9AD90: using guessed type int dword_9AD90;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// 12CADC: using guessed type int dword_12CADC;
// 12CAE0: using guessed type __int16 word_12CAE0;
// 12CAE2: using guessed type __int16 word_12CAE2;
// 12CAE4: using guessed type char byte_12CAE4;
// 12CAEC: using guessed type int dword_12CAEC;
// 12CB10: using guessed type int dword_12CB10;
// 12CB9C: using guessed type int dword_12CB9C;
// 12CBBE: using guessed type __int16 word_12CBBE;
// 12CBC0: using guessed type __int16 word_12CBC0;
// 12CBC2: using guessed type __int16 word_12CBC2;
// 12CBC4: using guessed type __int16 word_12CBC4;
// 12CBCE: using guessed type char byte_12CBCE;
// 12CBD0: using guessed type char byte_12CBD0;
// 12CBD1: using guessed type char byte_12CBD1;
// 12CBD2: using guessed type char byte_12CBD2;
// 12CBD5: using guessed type char byte_12CBD5;
// 12EEF1: using guessed type char byte_12EEF1;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004DCC0) --------------------------------------------------------
char sub_4DCC0()
{
  int v0; // edx
  int v1; // eax
  unsigned __int8 v2; // bl
  int v3; // eax
  int v4; // ecx
  int v5; // edx
  int v6; // esi
  char v7; // al
  unsigned __int8 v8; // bl
  char v9; // al
  int v10; // eax
  char result; // al
  char *v12; // [esp-4h] [ebp-1Ch]
  char v13; // [esp+0h] [ebp-18h]
  char v14; // [esp+4h] [ebp-14h]

  if ( (dword_12CBB0 & 7) == 7 && ++byte_12CBD2 == 21 )
    byte_12CBD2 = 6;
  if ( (byte_12CBD5 & 0x10) != 0 )
  {
    if ( !byte_90B23 )
    {
      v0 = 6 * (unsigned __int8)byte_12CBD2;
      v1 = dword_12CAEC;
LABEL_9:
      sub_5C05C(v0 + v1);
    }
  }
  else if ( !byte_90B23 )
  {
    v0 = dword_12CAEC;
    v1 = 6 * (unsigned __int8)byte_12CBCE;
    goto LABEL_9;
  }
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
  else
    sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
  sub_513E0();
  v2 = 0;
  sub_51360(0, 0, 320, 200);
  do
  {
    if ( byte_9689C[3 * v2] || byte_9689D[3 * v2] )
    {
      v3 = 2 * v2;
      if ( byte_9689D[3 * v2] )
      {
        if ( (word_12F02E & 1) != 0 )
          sub_60CE0(2 * (word_4A7CC[2 * v2] + 10), 2 * (word_4A7CE[2 * v2] - 10), dword_12CB10 + 102);
        else
          sub_60D18(2 * (word_4A7CC[2 * v2] + 10), 2 * (word_4A7CE[2 * v2] - 10), dword_12CB10 + 102);
      }
      else if ( byte_9689C[3 * v2] )
      {
        v4 = 6 * (v2 + 9);
        v5 = 6 * (v2 + 17);
        switch ( byte_9689E[3 * v2] )
        {
          case 0:
            if ( (word_12F02E & 1) == 0 )
              goto LABEL_23;
            goto LABEL_30;
          case 1:
            if ( (dword_12CBB0 & 0x10) == 0 )
              break;
            if ( (word_12F02E & 1) != 0 )
              goto LABEL_32;
            goto LABEL_33;
          case 2:
            if ( (word_12F02E & 1) != 0 )
              goto LABEL_32;
            goto LABEL_33;
          case 3:
            if ( (word_12F02E & 1) == 0 )
            {
LABEL_23:
              v5 = dword_12CB10;
              goto LABEL_34;
            }
LABEL_30:
            sub_60CE0(2 * word_4A7CC[2 * v2], 2 * word_4A7CE[2 * v2], v4 + dword_12CB10);
            break;
          default:
            break;
        }
      }
    }
    else
    {
      v5 = 6 * (v2 + 1);
      v3 = 2 * v2;
      if ( (word_12F02E & 1) != 0 )
      {
LABEL_32:
        sub_60CE0(2 * word_4A7CC[2 * v2], 2 * word_4A7CE[2 * v2], dword_12CB10 + v5);
      }
      else
      {
LABEL_33:
        v4 = dword_12CB10;
LABEL_34:
        sub_60D18(2 * word_4A7CC[v3], 2 * word_4A7CE[v3], v4 + v5);
      }
    }
    ++v2;
  }
  while ( v2 < 8u );
  sub_51360(173, 72, 90, 61);
  v6 = 0;
  v13 = sub_5CC70((unsigned __int8 *)dword_12CB9C, 0x3Fu, 0x3Fu, 0x3Fu);
  v7 = sub_5CC70((unsigned __int8 *)dword_12CB9C, 0x1Au, 0x12u, 0xDu);
  v8 = word_12CBBE;
  v14 = v7;
  while ( v8 < (unsigned __int16)word_12CBBE + 5 )
  {
    if ( v8 == word_12CBC2 )
      v9 = v13;
    else
      v9 = v14;
    byte_96892 = v9;
    v12 = off_99A84[v8];
    v10 = sub_51420((uint32*)&dword_9688C, v12);
    sub_51560((uint8*)&dword_9688C, (__int16)((90 - v10) / 2), v6, (unsigned __int8 *)v12);
    ++v8;
    v6 += *(unsigned __int8 *)(dword_9688C + 5) - 2;
  }
  sub_51400();
  result = v14;
  byte_96892 = v14;
  return result;
}
// 4A7CC: using guessed type __int16 word_4A7CC[];
// 4A7CE: using guessed type __int16 word_4A7CE[];
// 90B23: using guessed type char byte_90B23;
// 9688C: using guessed type int dword_9688C;
// 96892: using guessed type char byte_96892;
// 99A84: using guessed type char *off_99A84[20];
// AE3FC: using guessed type int dword_AE3FC;
// 12CAEC: using guessed type int dword_12CAEC;
// 12CB10: using guessed type int dword_12CB10;
// 12CB9C: using guessed type int dword_12CB9C;
// 12CBB0: using guessed type int dword_12CBB0;
// 12CBBE: using guessed type __int16 word_12CBBE;
// 12CBC2: using guessed type __int16 word_12CBC2;
// 12CBCE: using guessed type char byte_12CBCE;
// 12CBD2: using guessed type char byte_12CBD2;
// 12CBD5: using guessed type char byte_12CBD5;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004E0E0) --------------------------------------------------------
char sub_4E0E0()
{
  char result; // al

  sub_61CC0(0, 0x10u, 0);
  sub_20E60();
  sub_40440((int)"data\\screens\\pmultspr.dat");
  if ( (word_12F02E & 1) != 0 )
    sub_65D70(dword_12CB10, dword_12CB14, dword_12CB18);
  else
    sub_65DC0((unsigned int *)dword_12CB10, dword_12CB14, dword_12CB18);
  sub_51480((int)&dword_9688C, &dword_12CB34, (unsigned __int8 *)dword_12CB9C);
  byte_96890 &= ~2u;
  sub_3EEA0(aDataScreensPmu_0, (char *)dword_12CB9C);
  sub_3EEA0(aDataScreensPmu_1, (char *)dword_AE3FC);
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
  else
    sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  if ( !byte_90B23 )
    sub_5C05C(dword_12CAEC + 6 * (unsigned __int8)byte_12CBCE);
  sub_61CC0((unsigned __int8 *)dword_12CB9C, 0x20u, 0);
  byte_12CBD5 |= 1u;
  result = sub_5CC70((unsigned __int8 *)dword_12CB9C, 0x1Au, 0x12u, 0xDu);
  byte_96892 = result;
  return result;
}
// 90B23: using guessed type char byte_90B23;
// 9688C: using guessed type int dword_9688C;
// 96890: using guessed type char byte_96890;
// 96892: using guessed type char byte_96892;
// AE3FC: using guessed type int dword_AE3FC;
// 12CAEC: using guessed type int dword_12CAEC;
// 12CB10: using guessed type int dword_12CB10;
// 12CB14: using guessed type int dword_12CB14;
// 12CB18: using guessed type int dword_12CB18;
// 12CB34: using guessed type _DWORD dword_12CB34;
// 12CB9C: using guessed type int dword_12CB9C;
// 12CBCE: using guessed type char byte_12CBCE;
// 12CBD5: using guessed type char byte_12CBD5;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004E270) --------------------------------------------------------
void sub_4E270()
{
  int v0; // eax

  LOBYTE(v0) = sub_61CC0(0, 0x10u, 0);
  BYTE1(v0) = byte_90B23;
  if ( !byte_90B23 )
    v0 = sub_5C05C(0);
  if ( (word_12F02E & 1) != 0 )
    sub_411D7(v0, (void *)dword_12EFF4, 0xC8u, 0);
  else
    sub_411FD(v0, (void *)dword_12EFF4, 0x1E0u, 0);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  sub_61610((int)"data\\screens\\pmultspr.dat");
  byte_12CBD5 &= ~1u;
  if ( byte_12CBCE == 2 )
    sub_5D290(4);
}
// 4E2AA: variable 'v0' is possibly undefined
// 90B23: using guessed type char byte_90B23;
// 12CBCE: using guessed type char byte_12CBCE;
// 12CBD5: using guessed type char byte_12CBD5;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004E320) --------------------------------------------------------
void sub_4E320()
{
  unsigned __int8 v0; // al
  int v1; // eax
  unsigned __int8 *v2; // [esp-4h] [ebp-4h]

  v0 = 0;
  ++dword_12CBB0;
  do
  {
    if ( byte_9689C[3 * v0] )
      byte_9689E[3 * v0] = 0;
    ++v0;
  }
  while ( v0 < 8u );
  sub_4DCC0();
  sub_513E0();
  sub_51360(173, 42, 90, 15);
  v2 = (unsigned __int8 *)(dword_AE408 + 117);
  v1 = 90 - sub_51420((uint32*)&dword_9688C, (char *)(dword_AE408 + 117));
  sub_51560((uint8*)&dword_9688C, (__int16)(v1 / 2), 1, v2);
  sub_51400();
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
}
// 9688C: using guessed type int dword_9688C;
// AE408: using guessed type int dword_AE408;
// 12CBB0: using guessed type int dword_12CBB0;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004E3D0) --------------------------------------------------------
void sub_4E3D0(unsigned __int8 a1)
{
  int v1; // eax
  unsigned __int8 *v2; // [esp-4h] [ebp-4h]

  byte_9689E[3 * a1] = 1;
  ++dword_12CBB0;
  sub_4DCC0();
  sub_513E0();
  sub_51360(173, 42, 90, 15);
  v2 = (unsigned __int8 *)(dword_AE408 + 117);
  v1 = 90 - sub_51420((uint32*)&dword_9688C, (char *)(dword_AE408 + 117));
  sub_51560((uint8*)&dword_9688C, (__int16)(v1 / 2), 1, v2);
  sub_51400();
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
}
// 9688C: using guessed type int dword_9688C;
// AE408: using guessed type int dword_AE408;
// 12CBB0: using guessed type int dword_12CBB0;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004E470) --------------------------------------------------------
void sub_4E470(unsigned __int8 a1)
{
  int v1; // eax
  unsigned __int8 *v2; // [esp-4h] [ebp-4h]

  byte_9689E[3 * a1] = 2;
  ++dword_12CBB0;
  sub_4DCC0();
  sub_513E0();
  sub_51360(173, 42, 90, 15);
  v2 = (unsigned __int8 *)(dword_AE408 + 117);
  v1 = 90 - sub_51420((uint32*)&dword_9688C, (char *)(dword_AE408 + 117));
  sub_51560((uint8*)&dword_9688C, (__int16)(v1 / 2), 1, v2);
  sub_51400();
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
}
// 9688C: using guessed type int dword_9688C;
// AE408: using guessed type int dword_AE408;
// 12CBB0: using guessed type int dword_12CBB0;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004E510) --------------------------------------------------------
void sub_4E510(unsigned __int8 a1)
{
  int v1; // eax
  unsigned __int8 *v2; // [esp-4h] [ebp-4h]

  byte_9689E[3 * a1] = 0;
  ++dword_12CBB0;
  sub_4DCC0();
  sub_513E0();
  sub_51360(173, 42, 90, 15);
  v2 = (unsigned __int8 *)(dword_AE408 + 117);
  v1 = 90 - sub_51420((uint32*)&dword_9688C, (char *)(dword_AE408 + 117));
  sub_51560((uint8*)&dword_9688C, (__int16)(v1 / 2), 1, v2);
  sub_51400();
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
}
// 9688C: using guessed type int dword_9688C;
// AE408: using guessed type int dword_AE408;
// 12CBB0: using guessed type int dword_12CBB0;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004E5B0) --------------------------------------------------------
int sub_4E5B0()
{
  int v0; // edi
  int v1; // ebx
  int v2; // ebp
  int v3; // eax
  int v4; // eax
  char v5; // dl
  int v6; // eax
  int v7; // esi
  __int16 v8; // ax
  __int16 v9; // ax
  __int16 v10; // ax
  __int16 v11; // ax
  __int16 v12; // ax
  __int16 v13; // ax
  int result; // eax
  unsigned __int8 v15[64]; // [esp+0h] [ebp-80h] BYREF
  int v16; // [esp+40h] [ebp-40h]
  unsigned int v17; // [esp+44h] [ebp-3Ch]
  unsigned int v18; // [esp+48h] [ebp-38h]
  unsigned int v19; // [esp+4Ch] [ebp-34h]
  unsigned int v20; // [esp+50h] [ebp-30h]
  unsigned int v21; // [esp+54h] [ebp-2Ch]
  unsigned int v22; // [esp+58h] [ebp-28h]
  unsigned int v23; // [esp+5Ch] [ebp-24h]
  int v24; // [esp+60h] [ebp-20h]
  int v25; // [esp+64h] [ebp-1Ch]
  int v26; // [esp+68h] [ebp-18h]
  int v27; // [esp+6Ch] [ebp-14h]

  //fix
  v6 = 0;
  //fix

  v0 = 0;
  v1 = *(__int16 *)(dword_AE400 + 8);
  v2 = 0;
  v26 = 0;
  v25 = 0;
  v24 = 0;
  v27 = 0;
  LOBYTE(v1) = *(_BYTE *)(dword_AE400 + 2049 * v1 + 13325);
  v16 = 0;
  if ( (v1 & 8) == 0 )
  {
    if ( !byte_90B23 )
      sub_5C05C(0);
    LOWORD(v3) = sub_61CC0(0, 0x10u, 0);
    if ( (word_12F02E & 1) != 0 )
      sub_411D7(v3, (void *)dword_12EFF4, 0xC8u, 0);
    else
      sub_411FD(v3, (void *)dword_12EFF4, 0x1E0u, 0);
    if ( (word_12F02E & 1) != 0 )
      sub_5CDA0();
    else
      sub_599B0(480);
    v4 = dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8);
    if ( *(_WORD *)(v4 + 13325) & 2 | 4 )
    {
      v5 = *(_BYTE *)(v4 + 13325);
      if ( (v5 & 2) != 0 )
      {
        if ( (dword_AC5D4 & 1) != 0 )
          sprintf(&unk_9ADC8, aIntroLevelw2Da);
        else
          sprintf(&unk_9ADC8, aIntroLevelw1Da);
        word_12EFDA = 0;
        word_12EFDC = 0;
        word_12EFDE = 0;
        byte_12EF70 = 0;
        word_90026 = 0;
        sub_107C0(1, 1, (int)dword_4A5D8);
      }
      else if ( (v5 & 4) != 0 )
      {
        sprintf(&unk_9ADC8, aIntroLeveloseD);
        word_12EFDA = 0;
        word_12EFDC = 0;
        word_12EFDE = 0;
        byte_12EF70 = 0;
        word_90026 = 0;
        sub_107C0(1, 1, (int)dword_4A1C0);
      }
      sub_61CC0(0, 0x10u, 0);
      sub_5D010();
      sub_20E60();
      if ( (word_12F02E & 1) != 0 )
        sub_411D7(dword_12EFF4, (void *)dword_12EFF4, 0xC8u, 0);
      else
        sub_411FD(v6, (void *)dword_12EFF4, 0x1E0u, 0);
      if ( (word_12F02E & 1) != 0 )
        sub_5CDA0();
      else
        sub_599B0(480);
    }
    sub_5D070(0xDu);
    sub_5CEF0(0);
    sub_5D290(1);
    word_12EFDA = 0;
    word_12EFDC = 0;
    word_12EFDE = 0;
    byte_12EF70 = 0;
    byte_12CBCE = 2;
    sub_40440((int)"data\\screens\\sfont2.dat");
    if ( (word_12F02E & 1) != 0 )
      sub_65D70(dword_12CB40, dword_12CB44, dword_12CB48);
    else
      sub_65DC0((unsigned int *)dword_12CB40, dword_12CB44, dword_12CB48);
    word_96898 = 16;
    dword_96894 = dword_12CB40 + 6;
    sub_3EEA0(aDataScreensPpe, (char *)dword_12CB9C);
    sub_3EEA0(aDataScreensPpe_0, (char *)dword_AE3FC);
    if ( (word_12F02E & 1) != 0 )
      sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
    else
      sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
    if ( (word_12F02E & 1) != 0 )
      sub_5CDA0();
    else
      sub_599B0(480);
    sub_61CC0((unsigned __int8 *)dword_12CB9C, 0x20u, 0);
    byte_12EEF1 = 0;
    byte_12CAE4 &= ~1u;
    sub_51360(0, 0, 320, 200);
    v7 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13333);
    v19 = dword_AC5D4 + 360;
    v22 = dword_AC5D4 + 300;
    v17 = dword_AC5D4 + 240;
    v21 = dword_AC5D4 + 180;
    v23 = dword_AC5D4 + 120;
    v18 = dword_AC5D4 + 60;
    v20 = dword_AC5D4 + 1320;
    do
    {
      if ( byte_12EF70 || word_12EFDE || dword_AC5D4 > v20 )
      {
        byte_12CAE4 &= 0xB6u;
        byte_12EF70 = 0;
        v0 = 1;
        word_12EFDE = 0;
        byte_12EF29 = 0;
        byte_12EF0C = 0;
        byte_12EEF1 = 0;
        sub_61610((int)"data\\screens\\sfont2.dat");
      }
      if ( (word_12F02E & 1) != 0 )
        sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
      else
        sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
      if ( dword_AC5D4 > v18 )
      {
        sub_51560((uint8*)&dword_96894, 40, 8, (unsigned __int8 *)dword_999B8[*(unsigned __int16 *)(dword_AE408 + 17)]);
        if ( !v26 )
        {
          sub_65F10(0, 3);
          v26 = 1;
        }
        sub_51560((uint8*)&dword_96894, 40, 80, (unsigned __int8 *)dword_AE340);
        sprintf((char*)v15, "% 3d %%", *(_DWORD *)(*(_DWORD *)(v7 + 160) + 359));
        v8 = sub_51420((uint32*)&dword_96894, (char *)v15);
        sub_51560((uint8*)&dword_96894, (__int16)(600 - v8), 80, v15);
      }
      if ( dword_AC5D4 > v23 )
      {
        if ( !v25 )
        {
          sub_65F10(0, 3);
          v25 = 1;
        }
        sub_51560((uint8*)&dword_96894, 40, 120, (unsigned __int8 *)dword_AE344);
        sprintf((char*)v15, "% 3d %%", *(_DWORD *)(*(_DWORD *)(v7 + 160) + 367));
        v9 = sub_51420((uint32*)&dword_96894, (char *)v15);
        sub_51560((uint8*)&dword_96894, (__int16)(600 - v9), 120, v15);
      }
      if ( dword_AC5D4 > v21 )
      {
        if ( !v24 )
        {
          sub_65F10(0, 3);
          v24 = 1;
        }
        sub_51560((uint8*)&dword_96894, 40, 160, (unsigned __int8 *)dword_AE348);
        sprintf((char*)v15, "% 3d %%", *(_DWORD *)(*(_DWORD *)(v7 + 160) + 363));
        v10 = sub_51420((uint32*)&dword_96894, (char *)v15);
        sub_51560((uint8*)&dword_96894, (__int16)(600 - v10), 160, v15);
      }
      if ( dword_AC5D4 > v17 )
      {
        if ( !v27 )
        {
          sub_65F10(0, 3);
          v27 = 1;
        }
        sub_51560((uint8*)&dword_96894, 40, 200, (unsigned __int8 *)dword_AE324);
        sprintf((char*)v15, "% 3d %%", *(_DWORD *)(*(_DWORD *)(v7 + 160) + 371));
        v11 = sub_51420((uint32*)&dword_96894, (char *)v15);
        sub_51560((uint8*)&dword_96894, (__int16)(600 - v11), 200, v15);
      }
      if ( dword_AC5D4 > v22 )
      {
        if ( !v2 )
        {
          sub_65F10(0, 3);
          v2 = 1;
        }
        sub_51560((uint8*)&dword_96894, 40, 240, (unsigned __int8 *)dword_AE34C);
        sprintf((char*)v15, "% 3d %%", *(_DWORD *)(*(_DWORD *)(v7 + 160) + 375));
        v12 = sub_51420((uint32*)&dword_96894, (char *)v15);
        sub_51560((uint8*)&dword_96894, (__int16)(600 - v12), 240, v15);
      }
      if ( dword_AC5D4 > v19 )
      {
        if ( !v16 )
        {
          sub_65F10(0, 3);
          v16 = 1;
        }
        sub_51560((uint8*)&dword_96894, 40, 280, (unsigned __int8 *)dword_AE374);
        sprintf(
            (char*)v15,
          "%dh% 02dm %02ds",
          *(_DWORD *)(*(_DWORD *)(v7 + 160) + 379) / 120 / 3600,
          *(_DWORD *)(*(_DWORD *)(v7 + 160) + 379) / 120 / 60 % 60,
          *(_DWORD *)(*(_DWORD *)(v7 + 160) + 379) / 120 % 60);
        v13 = sub_51420((uint32*)&dword_96894, (char *)v15);
        sub_51560((uint8*)&dword_96894, (__int16)(600 - v13), 280, v15);
      }
      if ( (word_12F02E & 1) != 0 )
        sub_5CDA0();
      else
        sub_599B0(480);
    }
    while ( !v0 );
    sub_61CC0(0, 0x10u, 0);
    sub_20E60();
    sub_5D010();
  }
  result = dword_AE408;
  if ( *(_WORD *)(dword_AE408 + 17) == 50 )
    byte_12CBCE = 10;
  else
    byte_12CBCE = 2;
  return result;
}
// 4E629: variable 'v3' is possibly undefined
// 4E784: variable 'v6' is possibly undefined
// 4A1C0: using guessed type int dword_4A1C0[2];
// 4A5D8: using guessed type int dword_4A5D8[2];
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 90026: using guessed type __int16 word_90026;
// 90B23: using guessed type char byte_90B23;
// 96894: using guessed type int dword_96894;
// 96898: using guessed type __int16 word_96898;
// 999B8: using guessed type int dword_999B8[];
// AC5D4: using guessed type int dword_AC5D4;
// AE324: using guessed type int dword_AE324;
// AE340: using guessed type int dword_AE340;
// AE344: using guessed type int dword_AE344;
// AE348: using guessed type int dword_AE348;
// AE34C: using guessed type int dword_AE34C;
// AE374: using guessed type int dword_AE374;
// AE3FC: using guessed type int dword_AE3FC;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// 12CAE4: using guessed type char byte_12CAE4;
// 12CB40: using guessed type int dword_12CB40;
// 12CB44: using guessed type int dword_12CB44;
// 12CB48: using guessed type int dword_12CB48;
// 12CB9C: using guessed type int dword_12CB9C;
// 12CBCE: using guessed type char byte_12CBCE;
// 12EEF1: using guessed type char byte_12EEF1;
// 12EF0C: using guessed type char byte_12EF0C;
// 12EF29: using guessed type char byte_12EF29;
// 12EF70: using guessed type char byte_12EF70;
// 12EFDA: using guessed type __int16 word_12EFDA;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004EE70) --------------------------------------------------------
void sub_4EE70()
{
  int v0; // eax
  int v1; // eax

  //fix
  v1 = 0;
  //fix

  if ( !byte_90B23 )
    sub_5C05C(0);
  LOWORD(v0) = sub_61CC0(0, 0x10u, 0);
  if ( (word_12F02E & 1) != 0 )
    sub_411D7(v0, (void *)dword_12EFF4, 0xC8u, 0);
  else
    sub_411FD(v0, (void *)dword_12EFF4, 0x1E0u, 0);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  sprintf(&unk_9ADC8, aIntroLogoDat);
  word_12EFDA = 0;
  word_12EFDC = 0;
  word_12EFDE = 0;
  byte_12EF70 = 0;
  word_90026 = 0;
  sub_107C0(1, 1, (int)dword_4A620);
  sub_4B480(0, 8);
  sub_61CC0(0, 0x10u, 0);
  sub_5D010();
  sub_20E60();
  if ( (word_12F02E & 1) != 0 )
    sub_411D7(v1, (void *)dword_12EFF4, 0xC8u, 0);
  else
    sub_411FD(v1, (void *)dword_12EFF4, 0x1E0u, 0);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  byte_12CBCE = 0;
}
// 4EEAC: variable 'v0' is possibly undefined
// 4EF71: variable 'v1' is possibly undefined
// 4A620: using guessed type int dword_4A620[2];
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 90026: using guessed type __int16 word_90026;
// 90B23: using guessed type char byte_90B23;
// 12CBCE: using guessed type char byte_12CBCE;
// 12EF70: using guessed type char byte_12EF70;
// 12EFDA: using guessed type __int16 word_12EFDA;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004EFC0) --------------------------------------------------------
void sub_4EFC0fix(__int16 a1)
{
  int v1; // eax
  int v2; // eax

    //fix
  v2 = 0;
  //fix

  sub_19470(a1);
  if ( *(_BYTE *)(dword_AE408 + 8) )
  {
    if ( !byte_90B23 )
      sub_5C05C(0);
    LOWORD(v1) = sub_61CC0(0, 0x10u, 0);
    if ( (word_12F02E & 1) != 0 )
      sub_411D7(v1, (void *)dword_12EFF4, 0xC8u, 0);
    else
      sub_411FD(v1, (void *)dword_12EFF4, 0x1E0u, 0);
    if ( (word_12F02E & 1) != 0 )
      sub_5CDA0();
    else
      sub_599B0(480);
    sprintf(&unk_9ADC8, aIntroIntelDat);
    word_12EFDA = 0;
    word_12EFDC = 0;
    word_12EFDE = 0;
    byte_12EF70 = 0;
    word_90026 = 0;
    sub_107C0(1, 1, (int)dword_4A1E4);
    sub_4B480(0, 1);
    sub_61CC0(0, 0x10u, 0);
    sub_5D010();
    sub_20E60();
    if ( (word_12F02E & 1) != 0 )
      sub_411D7(v2, (void *)dword_12EFF4, 0xC8u, 0);
    else
      sub_411FD(v2, (void *)dword_12EFF4, 0x1E0u, 0);
    if ( (word_12F02E & 1) != 0 )
      sub_5CDA0();
    else
      sub_599B0(480);
  }
  byte_12CBCE = 9;
}
// 4F010: variable 'v1' is possibly undefined
// 4F0D5: variable 'v2' is possibly undefined
// 4A1E4: using guessed type int dword_4A1E4[2];
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 90026: using guessed type __int16 word_90026;
// 90B23: using guessed type char byte_90B23;
// AE408: using guessed type int dword_AE408;
// 12CBCE: using guessed type char byte_12CBCE;
// 12EF70: using guessed type char byte_12EF70;
// 12EFDA: using guessed type __int16 word_12EFDA;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004F120) --------------------------------------------------------
void sub_4F120()
{
  int v0; // ebx
  int v1; // eax
  __int16 v2; // dx

  v0 = dword_AC5D4;
  v1 = sub_1002D(dword_12CB6C, dword_12EFF4);
  v2 = word_12CB70 + 1;
  dword_12CB6C = v1;
  word_12CB70 = v2;
  if ( v2 == 5 )
  {
    word_12CB70 = 1;
    dword_12CB6C = dword_12CB68;
  }
  else if ( v2 == 1 && !dword_12CB68 )
  {
    dword_12CB68 = v1;
  }
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  if ( !word_12EFDE && !word_12EFDC && !word_12EFDA && !byte_12EF70 )
  {
    while ( v0 + 16 >= (unsigned int)dword_AC5D4 )
      ;
  }
}
// AC5D4: using guessed type int dword_AC5D4;
// 12CB68: using guessed type int dword_12CB68;
// 12CB6C: using guessed type int dword_12CB6C;
// 12CB70: using guessed type __int16 word_12CB70;
// 12EF70: using guessed type char byte_12EF70;
// 12EFDA: using guessed type __int16 word_12EFDA;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004F1E0) --------------------------------------------------------
int sub_4F1E0()
{
  int v0; // eax
  int v1; // eax
  int result; // eax

  //fix
  v1 = 0;
  //fix

  if ( !byte_90B23 )
    sub_5C05C(0);
  LOWORD(v0) = sub_61CC0(0, 0x10u, 0);
  if ( (word_12F02E & 1) != 0 )
    sub_411D7(v0, (void *)dword_12EFF4, 0xC8u, 0);
  else
    sub_411FD(v0, (void *)dword_12EFF4, 0x1E0u, 0);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  if ( *(_BYTE *)(dword_AE400 + 8608) == 32 )
  {
    sub_40440((int)"intro\\title-02.dat");
    dword_12CB6C = dword_12CB64;
    dword_12CB68 = 0;
    word_12CB70 = 0;
  }
  sprintf(&unk_9ADC8, aIntroTitle01Da);
  word_12EFDA = 0;
  word_12EFDC = 0;
  word_12EFDE = 0;
  byte_12EF70 = 0;
  if ( (byte_12CBD6 & 2) != 0 )
    word_90026 = 1;
  sub_107C0(1, 1, (int)dword_4A568);
  word_90026 = 0;
  if ( *(_BYTE *)(dword_AE400 + 8608) == 32 )
  {
    if ( !word_AC5DC )
      sub_4B480((int (*)(void))sub_4F120, 6);
  }
  else if ( !word_AC5DC )
  {
    sub_4B480(0, 6);
  }
  dword_12CBB0 = 0;
  sub_61CC0(0, 0x10u, 0);
  sub_5D010();
  sub_20E60();
  if ( (word_12F02E & 1) != 0 )
    sub_411D7(v1, (void *)dword_12EFF4, 0xC8u, 0);
  else
    sub_411FD(v1, (void *)dword_12EFF4, 0x1E0u, 0);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  result = dword_AE400;
  if ( *(_BYTE *)(dword_AE400 + 8608) == 32 )
    result = sub_61610((int)"intro\\title-02.dat");
  byte_12CBCE = 2;
  byte_12CBD6 &= ~2u;
  return result;
}
// 4F21E: variable 'v0' is possibly undefined
// 4F35C: variable 'v1' is possibly undefined
// 4A568: using guessed type int dword_4A568[2];
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 90026: using guessed type __int16 word_90026;
// 90B23: using guessed type char byte_90B23;
// AC5DC: using guessed type __int16 word_AC5DC;
// AE400: using guessed type int dword_AE400;
// 12CB64: using guessed type int dword_12CB64;
// 12CB68: using guessed type int dword_12CB68;
// 12CB6C: using guessed type int dword_12CB6C;
// 12CB70: using guessed type __int16 word_12CB70;
// 12CBB0: using guessed type int dword_12CBB0;
// 12CBCE: using guessed type char byte_12CBCE;
// 12CBD6: using guessed type char byte_12CBD6;
// 12EF70: using guessed type char byte_12EF70;
// 12EFDA: using guessed type __int16 word_12EFDA;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004F3F0) --------------------------------------------------------
void sub_4F3F0fix(__int16 a1)
{
  int v1; // ebx
  int v2; // eax
  __int16 v3; // si
  __int16 v4; // cx
  __int16 v5; // ax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // ebx
  char v17[56]; // [esp+0h] [ebp-38h] BYREF

  sprintf(v17, "%s%s\\language.inf", aC, aCarpetCd_1);
  v1 = 0;
  v2 = sub_5CDE0((int)v17, 514);
  if ( v2 != -1 )
  {
    sub_5CE50(v2);
    v16 = sub_5CDE0((int)v17, 512);
    if ( v16 == -1 )
      goto LABEL_58;
    sub_5CBD0(v16, dword_AE408 + 151, 1);
    goto LABEL_57;
  }
  dword_12CBB0 = 0;
  sub_3EEA0(aDataScreensLan, (char *)dword_12CB9C);
  v3 = dword_AE3FC;
  sub_3EEA0(aDataScreensLan_0, (char *)dword_AE3FC);
  sub_40440((int)"data\\screens\\langspr.dat");
  if ( (word_12F02E & 1) != 0 )
  {
    v3 = dword_12CB58;
    sub_65D70(dword_12CB58, dword_12CB5C, dword_12CB60);
  }
  else
  {
    a1 = dword_12CB60;
    sub_65DC0((unsigned int *)dword_12CB58, dword_12CB5C, dword_12CB60);
  }
  if ( (word_12F02E & 1) != 0 )
  {
    sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
  }
  else
  {
    a1 = dword_12EFF4;
    sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
  }
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  if ( !byte_90B23 )
    sub_5C05C(6 * (unsigned __int8)byte_12CBCE + dword_12CAEC);
  LOBYTE(v4) = dword_12CB9C;
  sub_61CC0((unsigned __int8 *)dword_12CB9C, 0x20u, 0);
  LOBYTE(v5) = byte_12CAE4 & 0xFE;
  byte_12CAE4 &= ~1u;
  v4 = (unsigned __int8)v4;
  HIBYTE(v5) = byte_12CBD5 | 1;
  byte_12EEF1 = 0;
  byte_12CBD5 |= 1u;
  do
  {
    sub_50770(v5, v4, a1, v3);
    if ( (byte_12CAE4 & 1) != 0 )
    {
      v6 = word_12CAE0 >> 1;
      if ( v6 < 64 || v6 > 139 || (v7 = word_12CAE2 >> 1, v7 < 43) || v7 > 82 )
      {
        v8 = word_12CAE0 >> 1;
        if ( v8 < 64 || v8 > 139 || (v9 = word_12CAE2 >> 1, v9 < 95) || v9 > 134 )
        {
          v10 = word_12CAE0 >> 1;
          if ( v10 < 179 || v10 > 254 || (v11 = word_12CAE2 >> 1, v11 < 43) || v11 > 82 )
          {
            v12 = word_12CAE0 >> 1;
            if ( v12 < 179 || v12 > 254 || (v13 = word_12CAE2 >> 1, v13 < 95) || v13 > 134 )
            {
              v14 = word_12CAE0 >> 1;
              if ( v14 >= 281 && v14 <= 304 )
              {
                v15 = word_12CAE2 >> 1;
                if ( v15 >= 115 && v15 <= 142 )
                  v1 = 1;
              }
            }
            else
            {
              *(_BYTE *)(dword_AE408 + 151) = 3;
            }
          }
          else
          {
            *(_BYTE *)(dword_AE408 + 151) = 2;
          }
        }
        else
        {
          *(_BYTE *)(dword_AE408 + 151) = 1;
        }
      }
      else
      {
        *(_BYTE *)(dword_AE408 + 151) = 0;
      }
      byte_12CAE4 &= ~1u;
    }
    if ( (word_12F02E & 1) != 0 )
    {
      sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
    }
    else
    {
      a1 = dword_12EFF4;
      sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
    }
    v4 = dword_12CB58;
    if ( (word_12F02E & 1) != 0 )
      sub_60CE0(
        2 * asc_4A8F4[2 * *(unsigned __int8 *)(dword_AE408 + 151) + 1],
        2 * asc_4A8F4[2 * *(unsigned __int8 *)(dword_AE408 + 151) + 2],
        dword_12CB58 + 6 * (*(unsigned __int8 *)(dword_AE408 + 151) + 1));
    else
      sub_60D18(
        2 * asc_4A8F4[2 * *(unsigned __int8 *)(dword_AE408 + 151) + 1],
        2 * asc_4A8F4[2 * *(unsigned __int8 *)(dword_AE408 + 151) + 2],
        dword_12CB58 + 6 * (*(unsigned __int8 *)(dword_AE408 + 151) + 1));
    if ( (word_12F02E & 1) != 0 )
      sub_5CDA0();
    else
      sub_599B0(480);
    ++dword_12CBB0;
  }
  while ( !v1 );
  sub_61CC0(0, 0x10u, 0);
  if ( !byte_90B23 )
    sub_5C05C(0);
  byte_12EEF1 = 0;
  byte_12CAE4 &= ~1u;
  v16 = sub_5CDE0((int)v17, 546);
  if ( v16 != -1 )
  {
    sub_62ED0(v16, dword_AE408 + 151, 1);
LABEL_57:
    sub_5CE50(v16);
  }
LABEL_58:
  switch ( *(_BYTE *)(dword_AE408 + 151) )
  {
    case 0:
      sub_40440((int)aDataEtextDat);
      break;
    case 1:
      sub_40440((int)aDataFtextDat);
      break;
    case 2:
      sub_40440((int)aDataGtextDat);
      break;
    case 3:
      sub_40440((int)aDataItextDat);
      break;
    default:
      break;
  }
  sub_61610((int)"data\\screens\\langspr.dat");
  sub_44700((const char *)dword_AE41C, (int)dword_AE238, 80);
  byte_12CBCE = 1;
  byte_12CBD5 &= ~1u;
}
// 4F578: variable 'v5' is possibly undefined
// 4A8F4: using guessed type wchar_t[5];
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 90B23: using guessed type char byte_90B23;
// AE238: using guessed type int dword_AE238[17];
// AE3FC: using guessed type int dword_AE3FC;
// AE408: using guessed type int dword_AE408;
// AE41C: using guessed type int dword_AE41C;
// 12CAE0: using guessed type __int16 word_12CAE0;
// 12CAE2: using guessed type __int16 word_12CAE2;
// 12CAE4: using guessed type char byte_12CAE4;
// 12CAEC: using guessed type int dword_12CAEC;
// 12CB58: using guessed type int dword_12CB58;
// 12CB5C: using guessed type int dword_12CB5C;
// 12CB60: using guessed type int dword_12CB60;
// 12CB9C: using guessed type int dword_12CB9C;
// 12CBB0: using guessed type int dword_12CBB0;
// 12CBCE: using guessed type char byte_12CBCE;
// 12CBD5: using guessed type char byte_12CBD5;
// 12EEF1: using guessed type char byte_12EEF1;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004F8D0) --------------------------------------------------------
int sub_4F8D0(int a1, void (*a2)(int))
{
  int v2; // ebx
  __int16 v3; // si
  __int16 v4; // cx
  __int16 v5; // ax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax

  //fix
  v5 = 0;
  //fix

  v2 = 0;
  v3 = 0;
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_AE3FC, (void *)dword_12CBA4, 0xC8u);
  else
    sub_62FC4((const void *)dword_AE3FC, (void *)dword_12CBA4, 0x1E0u);
  if ( !byte_90B23 )
    sub_5C05C(0);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  sprintf(&unk_9ADC8, aIntroScrollDat);
  dword_AC5C4 = (int (*)(_DWORD))sub_50470;
  word_90026 = 0;
  sub_107C0(0, 0, (int)dword_4A17C);
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_12EFF4, (void *)dword_AE3FC, 0xC8u);
  else
    sub_62FC4((const void *)dword_12EFF4, (void *)dword_AE3FC, 0x1E0u);
  HIBYTE(v4) = 0;
  dword_AC5C4 = 0;
  if ( !byte_90B23 )
    sub_5C05C(dword_12CAEC + 6 * (unsigned __int8)byte_12CBCE);
  sub_513E0();
  sub_51360(80, 73, 159, 48);
  do
  {
    if ( (word_12F02E & 1) != 0 )
    {
      HIBYTE(v4) = BYTE1(dword_12EFF4);
      sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
    }
    else
    {
      sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
    }
    LOBYTE(v4) = byte_90B23;
    if ( !byte_90B23 || (byte_90B23 & 0x23) != 0 && (v3 & 3) == 0 )
      sub_50770(v5, v4, 0, v3);
    if ( (word_12F02E & 1) != 0 )
      sub_60CE0(136, 210, dword_12CB04 + 30);
    else
      sub_60D18(136, 210, dword_12CB04 + 30);
    if ( (word_12F02E & 1) != 0 )
      v6 = sub_60CE0(480, 210, dword_12CB04 + 36);
    else
      v6 = sub_60D18(480, 210, dword_12CB04 + 36);
    if ( a2 )
      a2(v6);
    if ( (byte_12CAE4 & 1) != 0 || byte_12EEF1 || byte_12EF0C )
    {
      v7 = word_12CAE0 >> 1;
      if ( v7 >= 68 && v7 <= 81 && (v8 = word_12CAE2 >> 1, v8 >= 106) && v8 <= 116 || byte_12EF0C )
      {
        v2 = 1;
        a1 = 1;
      }
      else
      {
        v9 = word_12CAE0 >> 1;
        if ( v9 >= 240 && v9 <= 250 && (v10 = word_12CAE2 >> 1, v10 >= 105) && v10 <= 115 || byte_12EEF1 )
        {
          v2 = 1;
          a1 = 0;
        }
      }
      HIBYTE(v4) = 0;
      word_12EFDE = 0;
      byte_12CAE4 &= ~1u;
    }
    if ( (byte_90B23 & 0x23) != 0 )
    {
      if ( (word_12F02E & 1) != 0 )
        sub_60CE0(dword_9AD90, SHIWORD(dword_9AD90), dword_12CAEC + 6 * (unsigned __int8)byte_12CBCE);
      else
        sub_60D18(dword_9AD90, SHIWORD(dword_9AD90), 6 * (unsigned __int8)byte_12CBCE + dword_12CAEC);
    }
    if ( (word_12F02E & 1) != 0 )
      sub_5CDA0();
    else
      sub_599B0(480);
    ++v3;
  }
  while ( !v2 );
  sub_51400();
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_12CBA4, (void *)dword_AE3FC, 0xC8u);
  else
    sub_62FC4((const void *)dword_12CBA4, (void *)dword_AE3FC, 0x1E0u);
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
  else
    sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  word_12EFDC = 0;
  word_12EFDE = 0;
  byte_12EEF1 = 0;
  byte_12CAE4 &= 0xBEu;
  byte_12EF0C = 0;
  return a1;
}
// 4FA6D: variable 'v5' is possibly undefined
// 4A17C: using guessed type int dword_4A17C[6];
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 90026: using guessed type __int16 word_90026;
// 90B23: using guessed type char byte_90B23;
// 9AD90: using guessed type int dword_9AD90;
// AC5C4: using guessed type int (*dword_AC5C4)(_DWORD);
// AE3FC: using guessed type int dword_AE3FC;
// 12CAE0: using guessed type __int16 word_12CAE0;
// 12CAE2: using guessed type __int16 word_12CAE2;
// 12CAE4: using guessed type char byte_12CAE4;
// 12CAEC: using guessed type int dword_12CAEC;
// 12CB04: using guessed type int dword_12CB04;
// 12CBA4: using guessed type int dword_12CBA4;
// 12CBCE: using guessed type char byte_12CBCE;
// 12EEF1: using guessed type char byte_12EEF1;
// 12EF0C: using guessed type char byte_12EF0C;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004FD20) --------------------------------------------------------
int sub_4FD20(int a1)
{
  int result; // eax
  int v2; // esi
  int v3; // esi

  if ( sub_4F8D0(a1, (void (*)(int))sub_4FE00) )
  {
    sub_4CAC0();
    result = 2049 * *(__int16 *)(dword_AE400 + 8);
    *(_BYTE *)(dword_AE400 + result + 13327) = 1;
    dword_96880 = 1;
  }
  else
  {
    if ( (word_12F02E & 1) != 0 )
      sub_62FA8((const void *)dword_12CBA8, (void *)dword_AE3FC, 0xC8u);
    else
      sub_62FC4((const void *)dword_12CBA8, (void *)dword_AE3FC, 0x1E0u);
    byte_12CBCD = 0;
    v2 = dword_AE3FC;
    dword_AE3FC = dword_12EFF4;
    dword_12EFF4 = v2;
    sub_4CB70();
    result = dword_AE3FC;
    v3 = dword_AE3FC;
    dword_AE3FC = dword_12EFF4;
    dword_12EFF4 = v3;
  }
  return result;
}
// 96880: using guessed type int dword_96880;
// AE3FC: using guessed type int dword_AE3FC;
// AE400: using guessed type int dword_AE400;
// 12CBA8: using guessed type int dword_12CBA8;
// 12CBCD: using guessed type char byte_12CBCD;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004FE00) --------------------------------------------------------
int sub_4FE00()
{
  int v0; // eax

  sub_65EB0(65, 75, 189, 44);
  v0 = (int)*(unsigned __int8 *)(dword_12CB04 + 46) >> 1;
  if ( (word_12F02E & 1) != 0 )
    sub_60CE0(189 - v0, 44 - ((int)*(unsigned __int8 *)(dword_12CB04 + 47) >> 1), dword_12CB04 + 42);
  else
    sub_60D18(189 - v0, 44 - ((int)*(unsigned __int8 *)(dword_12CB04 + 47) >> 1), dword_12CB04 + 42);
  return sub_65EB0(0, 0, 320, 200);
}
// 12CB04: using guessed type int dword_12CB04;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0004FF30) --------------------------------------------------------
void sub_4FF30(int a1)
{
  int v1; // edx

  if ( byte_9687C )
  {
    byte_9687C = 0;
    byte_12CBD5 |= 8u;
    byte_12CBCE = 5;
    dword_96880 = 1;
  }
  else if ( sub_4F8D0(a1, (void (*)(int))sub_4FFE0) )
  {
    v1 = dword_AE400;
    *(_WORD *)(dword_AE408 + 17) = 0;
    byte_12CBCE = 5;
    memset((void*)(2049 * *(__int16 *)(v1 + 8) + v1 + 13323 + 1995), 0, 24);
    dword_96880 = 1;
    byte_12CBD5 |= 8u;
  }
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 9687C: using guessed type char byte_9687C;
// 96880: using guessed type int dword_96880;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// 12CBCE: using guessed type char byte_12CBCE;
// 12CBD5: using guessed type char byte_12CBD5;

//----- (0004FFE0) --------------------------------------------------------
void sub_4FFE0()
{
  int v0; // eax
  unsigned __int8 *v1; // [esp-4h] [ebp-1Ch]
  _DWORD v2[6]; // [esp+0h] [ebp-18h] BYREF

  sub_513A0(v2);
  v1 = (unsigned __int8 *)dword_AE2C8;
  v0 = sub_51420((uint32*)&dword_9688C, (char *)dword_AE2C8);
  sub_51560((uint8*)&dword_9688C, (__int16)((v2[4] - v0) / 2), 12, v1);
}
// 9688C: using guessed type int dword_9688C;
// AE2C8: using guessed type int dword_AE2C8;

//----- (00050030) --------------------------------------------------------
void sub_50030()
{
  int v0; // ecx
  void *v1; // edi
  int v2; // ebp

  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_AE3FC, (void *)dword_12CBA4, 0xC8u);
  else
    sub_62FC4((const void *)dword_AE3FC, (void *)dword_12CBA4, 0x1E0u);
  sprintf(&unk_9ADC8, aIntroScrollDat);
  dword_AC5C4 = (int (*)(_DWORD))sub_50470;
  if ( !byte_90B23 )
    sub_5C05C(0);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  word_90026 = 0;
  sub_107C0(0, 0, (int)dword_4A17C);
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_12EFF4, (void *)dword_AE3FC, 0xC8u);
  else
    sub_62FC4((const void *)dword_12EFF4, (void *)dword_AE3FC, 0x1E0u);
  if ( !byte_90B23 )
    sub_5C05C(dword_12CAEC + 6 * (unsigned __int8)byte_12CBCE);
  dword_AC5C4 = 0;
  sub_513E0();
  sub_51360(70, 73, 179, 48);
  sub_50D40(8, 25, 30, 0, (char *)(dword_AE408 + 29), 255, 0, sub_50350, 1, (int)&dword_9688C);
  byte_12CBD5 |= 0x20u;
  byte_12EF0C = 0;
  byte_12CAE4 &= ~1u;
  sub_50D40(8, 25, 8, 0, (char *)(dword_AE408 + 61), 255, 0, sub_503E0, 1, (int)&dword_9688C);
  byte_12EF0C = 0;
  byte_12CBD5 &= ~0x20u;
  byte_12CAE4 &= ~1u;
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_12CBA4, (void *)dword_AE3FC, 0xC8u);
  else
    sub_62FC4((const void *)dword_12CBA4, (void *)dword_AE3FC, 0x1E0u);
  byte_12CBCE = 2;
  v0 = dword_AE3FC;
  dword_AE3FC = dword_12EFF4;
  dword_12EFF4 = v0;
  sub_4CB70();
  v1 = (void *)dword_12EFF4;
  v2 = dword_AE3FC;
  dword_AE3FC = dword_12EFF4;
  dword_12EFF4 = v2;
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_12CBA4, v1, 0xC8u);
  else
    sub_62FC4((const void *)dword_12CBA4, v1, 0x1E0u);
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
  else
    sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
  sub_51400();
}
// 4A17C: using guessed type int dword_4A17C[6];
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 90026: using guessed type __int16 word_90026;
// 90B23: using guessed type char byte_90B23;
// 9688C: using guessed type int dword_9688C;
// AC5C4: using guessed type int (*dword_AC5C4)(_DWORD);
// AE3FC: using guessed type int dword_AE3FC;
// AE408: using guessed type int dword_AE408;
// 12CAE4: using guessed type char byte_12CAE4;
// 12CAEC: using guessed type int dword_12CAEC;
// 12CBA4: using guessed type int dword_12CBA4;
// 12CBCE: using guessed type char byte_12CBCE;
// 12CBD5: using guessed type char byte_12CBD5;
// 12EF0C: using guessed type char byte_12EF0C;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00050350) --------------------------------------------------------
void sub_50350()
{
  int v0; // eax
  unsigned __int8 *v1; // [esp-4h] [ebp-28h]
  _DWORD v2[9]; // [esp+0h] [ebp-24h] BYREF

  sub_513A0(v2);
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
  else
    sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
  v1 = (unsigned __int8 *)dword_AE2C0;
  v0 = sub_51420((uint32*)&dword_9688C, (char *)dword_AE2C0);
  sub_51560((uint8*)&dword_9688C, (__int16)((v2[4] - v0) / 2), 10, v1);
}
// 9688C: using guessed type int dword_9688C;
// AE2C0: using guessed type int dword_AE2C0;
// AE3FC: using guessed type int dword_AE3FC;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (000503E0) --------------------------------------------------------
void sub_503E0()
{
  int v0; // eax
  unsigned __int8 *v1; // [esp-4h] [ebp-28h]
  _DWORD v2[9]; // [esp+0h] [ebp-24h] BYREF

  sub_513A0(v2);
  if ( (word_12F02E & 1) != 0 )
    sub_62FA8((const void *)dword_AE3FC, (void *)dword_12EFF4, 0xC8u);
  else
    sub_62FC4((const void *)dword_AE3FC, (void *)dword_12EFF4, 0x1E0u);
  v1 = (unsigned __int8 *)dword_AE2C4;
  v0 = sub_51420((uint32*)&dword_9688C, (char *)dword_AE2C4);
  sub_51560((uint8*)&dword_9688C, (__int16)((v2[4] - v0) / 2), 10, v1);
}
// 9688C: using guessed type int dword_9688C;
// AE2C4: using guessed type int dword_AE2C4;
// AE3FC: using guessed type int dword_AE3FC;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00050470) --------------------------------------------------------
_BYTE *sub_50470()
{
  _BYTE *v0; // ebx
  _BYTE *result; // eax
  int v2; // edx

  v0 = (_BYTE *)dword_12CBA4;
  result = (_BYTE *)dword_12EFF4;
  v2 = 0;
  do
  {
    if ( !*result )
      *result = *v0;
    ++v0;
    ++v2;
    ++result;
  }
  while ( (unsigned __int16)v2 < 0xFA00u );
  return result;
}
// 12CBA4: using guessed type int dword_12CBA4;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (000504A0) --------------------------------------------------------
int sub_504A0()
{
  unsigned __int16 i; // bx
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v4; // esi
  int result; // eax
  unsigned __int16 v6; // dx
  unsigned __int16 v7; // [esp+0h] [ebp-18h]
  unsigned __int16 v8; // [esp+4h] [ebp-14h]

  for ( i = 0; i < 0x100u; ++i )
  {
    v1 = *(unsigned __int8 *)(3 * i + dword_12CB9C);
    v7 = v1 + 30 * v1 / 100;
    if ( v7 > 0x3Fu )
      LOBYTE(v7) = 63;
    v2 = *(unsigned __int8 *)(dword_12CB9C + 3 * i + 1);
    v3 = 30 * v2 / 100 + v2;
    if ( (unsigned __int16)v3 > 0x3Fu )
      LOBYTE(v3) = 63;
    v4 = *(unsigned __int8 *)(dword_12CB9C + 3 * i + 2);
    v8 = v4 + 30 * v4 / 100;
    if ( v8 > 0x3Fu )
      LOBYTE(v8) = 63;
    LOBYTE(result) = sub_5CC70((unsigned __int8 *)dword_12CB9C, v7, v3, v8);
    v6 = i;
    *(_BYTE *)(dword_12CBAC + v6) = result;
  }
  return result;
}
// 12CB9C: using guessed type int dword_12CB9C;
// 12CBAC: using guessed type int dword_12CBAC;

//----- (000505A0) --------------------------------------------------------
int sub_505A0()
{
  int v0; // ebp
  int v1; // eax
  int v2; // eax
  int v3; // ebx
  char v5[48]; // [esp+0h] [ebp-30h] BYREF

  sprintf(v5, "%s%s\\sndsetup.inf", aC, aCarpetCd_1);
  v0 = 0;
  v1 = sub_5CDE0((int)v5, 514);
  if ( v1 == -1 )
  {
    word_12C9C0 = word_A9990;
    word_12C9E0 = word_A9990;
    //fix word_12CA9E = (__int16*)word_A9990;
    word_12CA80[0] = word_A9990;
    //fix word_12CAB2 = (__int16*)word_A9990;
    word_12CA8A[0] = word_A9990;
    word_12CAC6 = (__int16)word_A9990;
    strcpy(byte_12C9A0, "NONE");
    word_12CAD0[0] = word_A9990;
    //fix word_12CAA8 = (__int16*)word_A9990;
    word_12CA94[0] = word_A9990;
    strcpy(byte_12CA00, "NONE");
  }
  else
  {
    sub_5CE50(v1);
    sprintf(v5, "%s%s\\sndsetup.dat", aC, aCarpetCd_1);
    v2 = sub_5CDE0((int)v5, 514);
    v3 = v2;
    if ( v2 != -1 )
    {
      sub_5CBD0(v2, (int)byte_12C9A0, 32);
      sub_5CBD0(v3, (int)&word_12C9C0, 32);
      sub_5CBD0(v3, (int)byte_12CA00, 32);
      sub_5CBD0(v3, (int)&word_12C9E0, 32);
      sub_5CBD0(v3, (int)&word_12CA9E, 10);
      sub_5CBD0(v3, (int)word_12CA80, 10);
      sub_5CBD0(v3, (int)&word_12CAB2, 10);
      sub_5CBD0(v3, (int)word_12CA8A, 10);
      sub_5CBD0(v3, (int)&word_12CAC6, 10);
      sub_5CBD0(v3, (int)word_12CAD0, 10);
      sub_5CBD0(v3, (int)&word_12CAA8, 10);
      sub_5CBD0(v3, (int)word_12CA94, 10);
      v0 = 1;
      sub_5CE50(v3);
    }
  }
  dword_12CABC = dword_A99A0;
  word_12CA20 = word_A9990;
  return v0;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// A9990: using guessed type __int16 word_A9990;
// A99A0: using guessed type int dword_A99A0;
// 12C9C0: using guessed type __int16 word_12C9C0;
// 12C9E0: using guessed type __int16 word_12C9E0;
// 12CA20: using guessed type __int16 word_12CA20;
// 12CA80: using guessed type __int16 word_12CA80[5];
// 12CA8A: using guessed type __int16 word_12CA8A[5];
// 12CA94: using guessed type __int16 word_12CA94[5];
// 12CA9E: using guessed type __int16 word_12CA9E;
// 12CAA8: using guessed type __int16 word_12CAA8;
// 12CAB2: using guessed type __int16 word_12CAB2;
// 12CABC: using guessed type int dword_12CABC;
// 12CAC6: using guessed type __int16 word_12CAC6;
// 12CAD0: using guessed type __int16 word_12CAD0[6];

//----- (00050770) --------------------------------------------------------
char sub_50770fix(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  char v4; // ch
  char v5; // dl
  char v6; // ah
  char v7; // bl
  char v8; // dh
  char v9; // cl
  char v10; // cl
  char v11; // ah
  char v12; // ah
  char v13; // bl
  char v14; // bl
  char v15; // ch
  char v16; // ch
  char v17; // dl
  char v18; // dl
  char v19; // bh
  char v20; // bl
  char v21; // ch
  char v22; // ch
  char v23; // dl

  LOBYTE(a1) = byte_12CBCF;
  if ( byte_12CBCF )
  {
    if ( (unsigned __int8)byte_12CBCF <= 1u )
    {
      if ( byte_12EF38 )
      {
        v10 = byte_12CAE7 & 0x7F;
        byte_12CAE7 &= ~0x80u;
        if ( (byte_12CAE8 & 1) != 0 )
          byte_12CAE7 = v10 & 0xBF;
        else
          byte_12CAE7 = v10 | 0x40;
        byte_12CAE8 |= 1u;
      }
      else
      {
        v11 = byte_12CAE7 & 0xBF;
        byte_12CAE7 &= ~0x40u;
        if ( (byte_12CAE8 & 1) != 0 )
          byte_12CAE7 = v11 | 0x80;
        else
          byte_12CAE7 = v11 & 0x7F;
        byte_12CAE8 &= ~1u;
      }
      if ( byte_12EF40 )
      {
        v12 = byte_12CAE8 & 0xFB;
        byte_12CAE8 = v12;
        if ( (v12 & 8) != 0 )
          byte_12CAE8 = v12 & 0xFD;
        else
          byte_12CAE8 = v12 | 2;
        byte_12CAE8 |= 8u;
      }
      else
      {
        v13 = byte_12CAE8 & 0xFD;
        byte_12CAE8 = v13;
        if ( (v13 & 8) != 0 )
          byte_12CAE8 = v13 | 4;
        else
          byte_12CAE8 = v13 & 0xFB;
        byte_12CAE8 &= ~8u;
      }
      if ( byte_12EF3B )
      {
        v14 = byte_12CAE7 & 0xFD;
        byte_12CAE7 = v14;
        if ( (v14 & 4) != 0 )
          byte_12CAE7 = v14 & 0xFE;
        else
          byte_12CAE7 = v14 | 1;
        byte_12CAE7 |= 4u;
      }
      else
      {
        v15 = byte_12CAE7 & 0xFE;
        byte_12CAE7 = v15;
        if ( (v15 & 4) != 0 )
          byte_12CAE7 = v15 | 2;
        else
          byte_12CAE7 = v15 & 0xFD;
        byte_12CAE7 &= ~4u;
      }
      if ( byte_12EF3D )
      {
        v16 = byte_12CAE7 & 0xEF;
        byte_12CAE7 = v16;
        if ( (v16 & 0x20) != 0 )
          byte_12CAE7 = v16 & 0xF7;
        else
          byte_12CAE7 = v16 | 8;
        byte_12CAE7 |= 0x20u;
      }
      else
      {
        v17 = byte_12CAE7 & 0xF7;
        byte_12CAE7 = v17;
        if ( (v17 & 0x20) != 0 )
          byte_12CAE7 = v17 | 0x10;
        else
          byte_12CAE7 = v17 & 0xEF;
        byte_12CAE7 &= ~0x20u;
      }
      if ( byte_12EF37 )
      {
        v18 = byte_12CAE5 & 0xDF;
        byte_12CAE5 = v18;
        if ( (v18 & 0x40) != 0 )
          byte_12CAE5 = v18 & 0xEF;
        else
          byte_12CAE5 = v18 | 0x10;
        byte_12CAE5 |= 0x40u;
      }
      else
      {
        v19 = byte_12CAE5 & 0xEF;
        byte_12CAE5 = v19;
        if ( (v19 & 0x40) != 0 )
          byte_12CAE5 = v19 | 0x20;
        else
          byte_12CAE5 = v19 & 0xDF;
        byte_12CAE5 &= ~0x40u;
      }
      LOBYTE(a1) = byte_12CAE6 & 0xFE;
      if ( byte_12EF39 )
      {
        byte_12CAE6 &= ~1u;
        if ( (a1 & 2) != 0 )
          byte_12CAE5 &= ~0x80u;
        else
          byte_12CAE5 |= 0x80u;
        byte_12CAE6 |= 2u;
      }
      else
      {
        byte_12CAE5 &= ~0x80u;
        if ( (byte_12CAE6 & 2) != 0 )
          byte_12CAE6 |= 1u;
        else
          byte_12CAE6 &= ~1u;
        byte_12CAE6 &= ~2u;
      }
      if ( byte_12EF3F )
      {
        v20 = byte_12CAE6 & 0xF7;
        byte_12CAE6 = v20;
        if ( (v20 & 0x10) != 0 )
          byte_12CAE6 = v20 & 0xFB;
        else
          byte_12CAE6 = v20 | 4;
        byte_12CAE6 |= 0x10u;
      }
      else
      {
        v21 = byte_12CAE6 & 0xFB;
        byte_12CAE6 = v21;
        if ( (v21 & 0x10) != 0 )
          byte_12CAE6 = v21 | 8;
        else
          byte_12CAE6 = v21 & 0xF7;
        byte_12CAE6 &= ~0x10u;
      }
      if ( !byte_12EF41 )
      {
        v23 = byte_12CAE6 & 0xDF;
        byte_12CAE6 = v23;
        if ( v23 >= 0 )
          byte_12CAE6 = v23 & 0xBF;
        else
          byte_12CAE6 = v23 | 0x40;
        byte_12CAE6 &= ~0x80u;
        goto LABEL_107;
      }
      v22 = byte_12CAE6 & 0xBF;
      byte_12CAE6 = v22;
      if ( v22 >= 0 )
        byte_12CAE6 = v22 | 0x20;
      else
        byte_12CAE6 = v22 & 0xDF;
      byte_12CAE6 |= 0x80u;
      word_12EFDC = 0;
      word_12EFDE = 0;
    }
    else
    {
      if ( byte_12CBCF != 2 )
      {
LABEL_107:
        word_12EFDC = 0;
        word_12EFDE = 0;
        return a1;
      }
      if ( (byte_90B23 & 0x23) != 0 )
        sub_3FCA0(a1, a2, a3, a4, 2, 0, 0, 640, 400, 4, 4);
      dword_12CADC = dword_9AD90;
      word_12CAE0 = word_9AD8C;
      LOBYTE(a1) = word_9AD8E;
      word_12CAE2 = word_9AD8E;
      if ( word_12EFE4 )
      {
        v4 = byte_12CAE4 & 0xFD;
        byte_12CAE4 = v4;
        if ( (v4 & 4) != 0 )
          byte_12CAE4 = v4 & 0xFE;
        else
          byte_12CAE4 = v4 | 1;
        byte_12CAE4 |= 4u;
      }
      else
      {
        v5 = byte_12CAE4 & 0xFE;
        byte_12CAE4 = v5;
        if ( (v5 & 4) != 0 )
          byte_12CAE4 = v5 | 2;
        else
          byte_12CAE4 = v5 & 0xFD;
        byte_12CAE4 &= ~4u;
      }
      if ( word_12EFE2 )
      {
        v6 = byte_12CAE4 & 0x7F;
        byte_12CAE4 &= ~0x80u;
        if ( (byte_12CAE5 & 1) != 0 )
          byte_12CAE4 = v6 & 0xBF;
        else
          byte_12CAE4 = v6 | 0x40;
        byte_12CAE5 |= 1u;
      }
      else
      {
        v7 = byte_12CAE4 & 0xBF;
        byte_12CAE4 &= ~0x40u;
        if ( (byte_12CAE5 & 1) != 0 )
          byte_12CAE4 = v7 | 0x80;
        else
          byte_12CAE4 = v7 & 0x7F;
        byte_12CAE5 &= ~1u;
      }
      if ( word_12EFE0 )
      {
        v8 = byte_12CAE4 & 0xEF;
        byte_12CAE4 = v8;
        if ( (v8 & 0x20) != 0 )
          byte_12CAE4 = v8 & 0xF7;
        else
          byte_12CAE4 = v8 | 8;
        byte_12CAE4 |= 0x20u;
        word_12EFDC = 0;
        word_12EFDE = 0;
      }
      else
      {
        v9 = byte_12CAE4 & 0xF7;
        byte_12CAE4 = v9;
        if ( (v9 & 0x20) != 0 )
        {
          byte_12CAE4 = v9 | 0x10;
        }
        else
        {
          LOBYTE(a1) = v9 & 0xEF;
          byte_12CAE4 = v9 & 0xEF;
        }
        byte_12CAE4 &= ~0x20u;
        word_12EFDC = 0;
        word_12EFDE = 0;
      }
    }
  }
  else
  {
    byte_12CAE7 &= 0x24u;
    byte_12CAE8 &= 0xF9u;
    word_12EFDC = 0;
    word_12EFDE = 0;
  }
  return a1;
}
// 90B23: using guessed type char byte_90B23;
// 9AD8C: using guessed type __int16 word_9AD8C;
// 9AD8E: using guessed type __int16 word_9AD8E;
// 9AD90: using guessed type int dword_9AD90;
// 12CADC: using guessed type int dword_12CADC;
// 12CAE0: using guessed type __int16 word_12CAE0;
// 12CAE2: using guessed type __int16 word_12CAE2;
// 12CAE4: using guessed type char byte_12CAE4;
// 12CAE5: using guessed type char byte_12CAE5;
// 12CAE6: using guessed type char byte_12CAE6;
// 12CAE7: using guessed type char byte_12CAE7;
// 12CAE8: using guessed type char byte_12CAE8;
// 12CBCF: using guessed type char byte_12CBCF;
// 12EF37: using guessed type char byte_12EF37;
// 12EF38: using guessed type char byte_12EF38;
// 12EF39: using guessed type char byte_12EF39;
// 12EF3B: using guessed type char byte_12EF3B;
// 12EF3D: using guessed type char byte_12EF3D;
// 12EF3F: using guessed type char byte_12EF3F;
// 12EF40: using guessed type char byte_12EF40;
// 12EF41: using guessed type char byte_12EF41;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;
// 12EFE0: using guessed type __int16 word_12EFE0;
// 12EFE2: using guessed type __int16 word_12EFE2;
// 12EFE4: using guessed type __int16 word_12EFE4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00050D40) --------------------------------------------------------
bool sub_50D40(
        int a1,
        __int16 a2,
        __int16 a3,
        char *a4,
        char *a5,
        char a6,
        int a7,
        void (*a8)(void),
        char a9,
        int a10)
{
  char *v10; // ebx
  unsigned int v11; // ebp
  char v12; // al
  char v13; // al
  unsigned int v14; // esi
  int v15; // esi
  int v16; // eax
  char *v17; // esi
  char *v18; // edi
  __int16 v19; // dx
  char v20; // al
  char v21; // al
  char v22; // al
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // esi
  int v28; // eax
  int v30; // [esp-14h] [ebp-B4h]
  int v31; // [esp-10h] [ebp-B0h]
  char v32[100]; // [esp+0h] [ebp-A0h] BYREF
  int v33[4]; // [esp+64h] [ebp-3Ch] BYREF
  int v34; // [esp+74h] [ebp-2Ch]
  unsigned int v35; // [esp+7Ch] [ebp-24h]
  char v36[4]; // [esp+80h] [ebp-20h] BYREF
  int v37; // [esp+84h] [ebp-1Ch]
  int v38; // [esp+88h] [ebp-18h]
  char v39; // [esp+8Ch] [ebp-14h]

  //fix
  v34 = 0;
  //fix

  v10 = a5;
  v11 = (unsigned int)&a5[strlen(a5)];
  v35 = (unsigned int)&a5[a3];
  v39 = 1;
  v37 = 0;
  v38 = 0;
  word_12EFDC = 0;
  word_12EFDE = 0;
  sub_513A0((uint32*)v33);
  if ( a4 )
    v37 = sub_51420((_DWORD *)a10, a4);
  v37 += a1;
  do
  {
    if ( word_12EFDE )
      v38 = 1;
    if ( (unsigned __int8)byte_12EF70 < 0x36u )
    {
      if ( (unsigned __int8)byte_12EF70 < 0xFu )
      {
        if ( byte_12EF70 )
        {
          if ( (unsigned __int8)byte_12EF70 <= 1u )
          {
            v38 = 2;
            goto LABEL_73;
          }
          if ( byte_12EF70 == 14 )
          {
            if ( v10 <= a5 )
              goto LABEL_73;
LABEL_71:
            --v10;
LABEL_72:
            --v11;
            sub_51330((int)v10, 1);
            goto LABEL_73;
          }
        }
      }
      else
      {
        if ( (unsigned __int8)byte_12EF70 <= 0xFu )
          goto LABEL_73;
        if ( (unsigned __int8)byte_12EF70 >= 0x1Cu )
        {
          if ( (unsigned __int8)byte_12EF70 <= 0x1Cu )
          {
            v38 = 1;
            goto LABEL_73;
          }
          if ( byte_12EF70 == 42 )
            goto LABEL_73;
        }
      }
    }
    else
    {
      if ( (unsigned __int8)byte_12EF70 <= 0x36u )
        goto LABEL_73;
      if ( (unsigned __int8)byte_12EF70 < 0x4Du )
      {
        if ( (unsigned __int8)byte_12EF70 >= 0x47u )
        {
          if ( (unsigned __int8)byte_12EF70 <= 0x47u )
          {
            v10 = a5;
            goto LABEL_73;
          }
          if ( byte_12EF70 == 75 )
          {
            if ( v10 > a5 )
              --v10;
            goto LABEL_73;
          }
        }
      }
      else
      {
        if ( (unsigned __int8)byte_12EF70 <= 0x4Du )
        {
          if ( (unsigned int)v10 < v11 )
            ++v10;
          goto LABEL_73;
        }
        if ( (unsigned __int8)byte_12EF70 < 0x52u )
        {
          if ( byte_12EF70 == 79 )
          {
            v10 = (char *)v11;
            goto LABEL_73;
          }
        }
        else
        {
          if ( (unsigned __int8)byte_12EF70 <= 0x52u )
            goto LABEL_73;
          if ( byte_12EF70 == 83 )
          {
            if ( (unsigned int)v10 >= v11 )
              goto LABEL_73;
            goto LABEL_72;
          }
        }
      }
    }
    if ( (byte_12CBD5 & 0x20) == 0
      || (!byte_12EF1A && !byte_12EF26
        ? (v12 = byte_4A84B[(unsigned __int8)byte_12EF70])
        : (v12 = byte_4A884[(unsigned __int8)byte_12EF70]),
          v12) )
    {
      if ( byte_12EF70 && (unsigned __int8)byte_12EF70 <= 0x39u && (v39 && v11 < v35 || !v39 && (unsigned int)v10 < v35) )
      {
        v13 = byte_12EF1A || byte_12EF26
            ? byte_4A93E[(unsigned __int8)byte_12EF70]
            : byte_4A905[(unsigned __int8)byte_12EF70];
        v36[0] = v13;
        v36[1] = 0;
        if ( v39 )
        {
          sub_512D0(v10, v36);
          if ( (unsigned int)v10 < v35 )
          {
            ++v10;
            ++v11;
          }
        }
        else
        {
          v14 = v35;
          *v10 = v13;
          if ( (unsigned int)v10 < v14 )
            ++v10;
          if ( (unsigned int)v10 > v11 )
          {
            v11 = (unsigned int)v10;
            *v10 = 0;
          }
        }
        v15 = a9 == 1 ? v34 - 2 * (__int16)a1 : v34 - (__int16)a1;
        if ( sub_51420((_DWORD *)a10, a5) >= v15 && v39 && v10 > a5 )
          goto LABEL_71;
      }
    }
LABEL_73:
    byte_12EF70 = 0;
    a8();
    *(_BYTE *)(a10 + 6) = a6;
    sub_51560((_BYTE *)a10, (__int16)a1, a2, (unsigned __int8 *)a4);
    if ( a9 )
    {
      if ( a9 == 1 )
      {
        v16 = sub_51420((_DWORD *)a10, a5);
        sub_51560((_BYTE *)a10, (__int16)((v34 - v16) / 2), a2, (unsigned __int8 *)a5);
      }
    }
    else
    {
      sub_51560((_BYTE *)a10, (__int16)v37, a2, (unsigned __int8 *)a5);
    }
    v17 = a5;
    v18 = v32;
    v19 = (_WORD)v10 - (_WORD)a5;
    do
    {
      v20 = *v17;
      *v18 = *v17;
      if ( !v20 )
        break;
      v21 = v17[1];
      v17 += 2;
      v18[1] = v21;
      v18 += 2;
    }
    while ( v21 );
    v22 = v32[v19];
    if ( !v22 )
      v22 = 32;
    v32[v19] = 0;
    v23 = *(_DWORD *)a10 + 6 * (v22 - 32);
    v31 = *(unsigned __int8 *)(v23 + 4);
    v30 = v33[2] + *(unsigned __int8 *)(v23 + 5) + a2 - 2;
    if ( a9 )
    {
      v26 = sub_51420((_DWORD *)a10, a5);
      v27 = (v34 - v26) / 2;
      v28 = sub_51420((_DWORD *)a10, v32);
      v25 = v33[0] + v27 + v28;
    }
    else
    {
      v24 = sub_51420((_DWORD *)a10, v32);
      v25 = v33[0] + (__int16)v37 + v24;
    }
    sub_51ECC(v25, v30, v31, 2, 255, 0);
    if ( (word_12F02E & 1) != 0 )
      sub_5CDA0();
    else
      sub_599B0(480);
  }
  while ( !(_WORD)v38 );
  word_12EFDC = 0;
  word_12EFDE = 0;
  byte_12EF70 = 0;
  byte_12EEF1 = 0;
  byte_12EF0C = 0;
  return (_WORD)v38 == 1;
}
// 12CBD5: using guessed type char byte_12CBD5;
// 12EEF1: using guessed type char byte_12EEF1;
// 12EF0C: using guessed type char byte_12EF0C;
// 12EF1A: using guessed type char byte_12EF1A;
// 12EF26: using guessed type char byte_12EF26;
// 12EF70: using guessed type char byte_12EF70;
// 12EFDC: using guessed type __int16 word_12EFDC;
// 12EFDE: using guessed type __int16 word_12EFDE;
// 12F02E: using guessed type __int16 word_12F02E;
// 50D40: using guessed type char var_A0[100];

//----- (000512D0) --------------------------------------------------------
char *sub_512D0(char *a1, const char *a2)
{
  __int16 v2; // si

  v2 = strlen(a2);
  memmove(&a1[v2], a1, strlen(a1) + 1);
  qmemcpy(a1, a2, v2);
  return a1;
}
// 660B5: using guessed type _DWORD memmove(_DWORD, _DWORD, _DWORD);

//----- (00051330) --------------------------------------------------------
int sub_51330(int a1, __int16 a2)
{
  return (int)memmove((void*)a1, (void*)(a1 + a2), strlen((const char *)(a1 + a2)) + 1);
}
// 660B5: using guessed type _DWORD memmove(_DWORD, _DWORD, _DWORD);

//----- (00051360) --------------------------------------------------------
int sub_51360(int a1, int a2, int a3, int a4)
{
  int result; // eax

  dword_12C970 = a1;
  dword_12C97C = a2 + a4;
  dword_12C978 = a2;
  dword_12C980 = a3;
  result = a4;
  dword_12C974 = a1 + a3;
  dword_12C984 = a4;
  return result;
}
// 12C970: using guessed type int dword_12C970;
// 12C974: using guessed type int dword_12C974;
// 12C978: using guessed type int dword_12C978;
// 12C97C: using guessed type int dword_12C97C;
// 12C980: using guessed type int dword_12C980;
// 12C984: using guessed type int dword_12C984;

//----- (000513A0) --------------------------------------------------------
_DWORD *sub_513A0(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = dword_12C970;
  a1[1] = dword_12C974;
  a1[2] = dword_12C978;
  a1[3] = dword_12C97C;
  a1[4] = dword_12C980;
  a1[5] = dword_12C984;
  return result;
}
// 12C970: using guessed type int dword_12C970;
// 12C974: using guessed type int dword_12C974;
// 12C978: using guessed type int dword_12C978;
// 12C97C: using guessed type int dword_12C97C;
// 12C980: using guessed type int dword_12C980;
// 12C984: using guessed type int dword_12C984;

//----- (000513E0) --------------------------------------------------------
void sub_513E0()
{
  dword_12CA78 = 0;
  qmemcpy(&unk_12C988, &dword_12C970, 0x18u);
}
// 12C970: using guessed type int dword_12C970;
// 12CA78: using guessed type int dword_12CA78;

//----- (00051400) --------------------------------------------------------
void sub_51400()
{
  dword_12CA78 = 0;
  qmemcpy(&dword_12C970, &unk_12C988, 0x18u);
}
// 12C970: using guessed type int dword_12C970;
// 12CA78: using guessed type int dword_12CA78;

//----- (00051420) --------------------------------------------------------
int sub_51420(_DWORD *a1, char *a2)
{
  char *v2; // eax
  __int16 v3; // bx
  __int16 v4; // dx
  char v5; // cl

  v2 = a2;
  v3 = 0;
  v4 = 0;
  if ( *a2 )
  {
    do
    {
      v5 = *v2;
      if ( *v2 <= 31 )
      {
        if ( v5 == 10 )
        {
          if ( v4 > v3 )
            v3 = v4;
          v4 = 0;
        }
      }
      else
      {
        v4 += *(unsigned __int8 *)(6 * (v5 - 32) + *a1 + 4) - 1;
      }
    }
    while ( *++v2 );
  }
  if ( v4 > v3 )
    return v4;
  return v3;
}

//----- (00051480) --------------------------------------------------------
char sub_51480(int a1, _DWORD *a2, unsigned __int8 *a3)
{
  char result; // al

  sub_519E0((int)a2);
  *(_DWORD *)a1 = *a2 + 6;
  *(_BYTE *)(a1 + 6) = sub_5CC70(a3, 0xFFu, 0xFFu, 0xFFu);
  result = sub_5CC70(a3, 0, 0, 0);
  *(_WORD *)(a1 + 4) = 3;
  *(_BYTE *)(a1 + 7) = result;
  return result;
}

//----- (00051560) --------------------------------------------------------
void sub_51560(_BYTE *a1, int a2, __int16 a3, unsigned __int8 *a4)
{
  int v4; // edi
  unsigned __int8 *v5; // ebx
  unsigned __int8 v6; // ah
  char v7; // al
  char v8; // al
  int v9; // eax
  int v10; // ebp

  v4 = a2;
  v5 = a4;
  if ( a4 )
  {
    while ( 1 )
    {
      v6 = *v5;
      if ( !*v5 )
        break;
      if ( v6 >= 0x20u )
      {
        v9 = 6 * (unsigned __int8)(v6 - 32);
        ++v5;
        v10 = v9 + *(_DWORD *)a1;
        if ( (a1[4] & 0x10) != 0 )
        {
          if ( *(v5 - 1) != 32 )
            sub_60D18(v4, a3, v9 + *(_DWORD *)a1);
          v4 += *(unsigned __int8 *)(v10 + 4) - 2;
        }
        else
        {
          sub_51650((int)a1, (__int16)v4, a3, v9 + *(_DWORD *)a1);
          v4 += *(unsigned __int8 *)(v10 + 4) - 1;
        }
      }
      else
      {
        switch ( v6 )
        {
          case 1u:
            v7 = *++v5;
            a1[6] = v7;
            break;
          case 2u:
            v8 = *++v5;
            a1[7] = v8;
            break;
          case 3u:
            a1[4] |= 3u;
            break;
          case 4u:
            a1[4] &= 0xFCu;
            break;
          case 5u:
            a1[4] |= 5u;
            break;
          case 6u:
            a1[4] &= 0xFAu;
            break;
          case 0xAu:
            v4 = a2;
            a3 += *(unsigned __int8 *)(*(_DWORD *)a1 + 5);
            break;
          default:
            break;
        }
        ++v5;
      }
    }
  }
  JUMPOUT(0x4D39E);
}
// 51578: control flows out of bounds to 4D39E

//----- (00051650) --------------------------------------------------------
__int16 sub_51650(int a1, int a2, __int16 a3, int a4)
{
  int v4; // edi
  __int16 v5; // cx
  unsigned __int8 v6; // dh
  int v7; // eax
  unsigned __int8 v8; // dl
  __int16 v9; // bx
  int v10; // edi
  _BYTE *v11; // edx
  char *v12; // ecx
  int v13; // ecx
  int v14; // ebx
  _BYTE *v15; // ebp
  _BYTE *v16; // eax
  char v17; // ch
  int v18; // ecx
  _BOOL1 v19; // zf
  int v20; // edx
  unsigned __int8 v22; // ch
  char v23; // cl
  unsigned __int8 v24; // cl
  int v25; // edi
  char *v26; // eax
  char *v27; // eax
  char v28; // ch
  int v30; // [esp+8h] [ebp-40h]
  _BYTE *v31; // [esp+Ch] [ebp-3Ch]
  _BYTE *v32; // [esp+10h] [ebp-38h]
  char *v33; // [esp+14h] [ebp-34h]
  __int16 v34; // [esp+1Ch] [ebp-2Ch]
  int v35; // [esp+24h] [ebp-24h]
  unsigned __int8 v36; // [esp+28h] [ebp-20h]
  unsigned __int8 v37; // [esp+2Ch] [ebp-1Ch]
  unsigned __int8 v38; // [esp+30h] [ebp-18h]
  unsigned __int8 v39; // [esp+34h] [ebp-14h]

  LOWORD(v4) = dword_12C970 + a2;
  v5 = dword_12C978 + a3;
  v6 = *(_BYTE *)(a4 + 4);
  v7 = -a2;
  v8 = *(_BYTE *)(a4 + 5);
  if ( (-(__int16)a2 & 0x8000u) != 0 || (_WORD)a2 == 0 )
  {
    v37 = 0;
  }
  else
  {
    if ( (__int16)v7 >= v6 )
      return v7;
    v37 = -(char)a2;
  }
  LOWORD(v7) = v6 + (_WORD)v4 - dword_12C974;
  if ( (__int16)v7 > 0 )
  {
    if ( (__int16)v7 >= v6 )
      return v7;
    v6 = dword_12C974 - v4;
  }
  v39 = v6;
  LOWORD(v7) = -a3;
  if ( a3 >= 0 )
  {
    LOBYTE(v9) = 0;
  }
  else
  {
    if ( (__int16)v7 >= v8 )
      return v7;
    LOBYTE(v9) = -(char)a3;
  }
  LOWORD(v7) = v5 + v8 - dword_12C97C;
  if ( (__int16)v7 > 0 )
  {
    if ( (__int16)v7 >= v8 )
      return v7;
    v8 = dword_12C97C - v5;
  }
  v4 = (__int16)v4;
  v36 = v8 - v9;
  v38 = v6 - v37;
  v11 = (_BYTE *)(v37 + (__int16)v4 + dword_12EFF4 + dword_12EFF0 * (v5 + (unsigned __int8)v9));
  v7 = *(_DWORD *)a4;
  v34 = dword_12EFF0;
  if ( (_BYTE)v9 )
  {
    HIBYTE(v9) = 0;
    do
    {
      while ( *(char *)v7 > 0 )
        v7 += *(char *)v7 + 1;
      v12 = (char *)v7++;
    }
    while ( *v12 || --v9 );
  }
  v13 = v36;
  v14 = v38;
  v35 = v36;
  v15 = &v11[(__int16)dword_12EFF0];
  if ( v37 )
  {
LABEL_57:
    if ( !v37 )
      goto LABEL_22;
    v22 = v37;
    while ( 1 )
    {
      while ( 1 )
      {
        v23 = *(_BYTE *)v7;
        if ( *(char *)v7 > 0 )
          break;
        if ( !*(_BYTE *)v7 )
        {
          v14 = 0;
          goto LABEL_22;
        }
        v10 = v23;
        if ( v23 < -v22 )
        {
          BYTE1(v13) = -v23 - v22;
          if ( BYTE1(v13) > v38 )
            BYTE1(v13) = v39 - v37;
          v10 = BYTE1(v13);
          ++v7;
          LOBYTE(v13) = BYTE1(v13);
          v11 += BYTE1(v13);
          BYTE1(v13) = 0;
          v14 -= v13;
          goto LABEL_22;
        }
        ++v7;
        v22 += v23;
        if ( !v22 )
          goto LABEL_22;
      }
      if ( v23 > (int)v22 )
        break;
      v10 = v23 + 1;
      v22 -= v23;
      v7 += v10;
      if ( !v22 )
        goto LABEL_22;
    }
    v24 = v23 - v22;
    if ( v24 > v38 )
      v24 = v39 - v37;
    v31 = &v11[v24];
    v25 = *(char *)v7;
    v26 = (char *)(v7 + 1);
    v33 = &v26[v25];
    v27 = &v26[v22];
    v14 -= v24;
    v10 = *(_WORD *)(a1 + 4) & 0xC000;
    if ( (unsigned __int16)v10 >= 0x4000u )
    {
      if ( (unsigned __int16)v10 <= 0x4000u )
      {
        do
        {
          ++v27;
          ++v11;
          --v24;
        }
        while ( v24 );
      }
      else if ( (_WORD)v10 == 0x8000 )
      {
        do
        {
          ++v27;
          ++v11;
          --v24;
        }
        while ( v24 );
      }
      goto LABEL_82;
    }
    if ( (_WORD)v10 )
    {
LABEL_82:
      v7 = (int)v33;
      v11 = v31;
      goto LABEL_22;
    }
    while ( 1 )
    {
      if ( *v27 )
      {
        if ( (unsigned __int8)*v27 > 1u )
        {
          if ( *v27 != 2 || (*(_BYTE *)(a1 + 4) & 2) == 0 )
            goto LABEL_77;
          v28 = *(_BYTE *)(a1 + 7);
          goto LABEL_76;
        }
        if ( (*(_BYTE *)(a1 + 4) & 1) != 0 )
        {
          v28 = *(_BYTE *)(a1 + 6);
LABEL_76:
          *v11 = v28;
        }
      }
LABEL_77:
      ++v27;
      ++v11;
      if ( !--v24 )
        goto LABEL_82;
    }
  }
LABEL_22:
  while ( 2 )
  {
    if ( (__int16)v14 <= 0 )
    {
      HIWORD(v20) = HIWORD(v35);
      LOWORD(v20) = v35 - 1;
      v19 = (_WORD)v35 == 1;
      v35 = v20;
      if ( !v19 )
      {
        do
        {
          while ( *(char *)v7 > 0 )
            v7 += *(char *)v7 + 1;
        }
        while ( *(_BYTE *)v7++ );
        BYTE1(v14) = 0;
        v13 = v34;
        v11 = v15;
        goto LABEL_56;
      }
    }
    else
    {
      LOBYTE(v13) = *(_BYTE *)v7;
      if ( *(char *)v7 > 0 )
      {
        if ( (char)v13 >= (__int16)v14 )
          v13 = (__int16)v14;
        else
          v13 = *(char *)v7;
        LOWORD(v10) = *(char *)v7;
        v14 -= v10;
        v32 = &v11[(unsigned __int8)v13];
        v30 = *(char *)v7 + v7 + 1;
        v10 = *(_WORD *)(a1 + 4) & 0xC000;
        v16 = (_BYTE *)(v7 + 1);
        if ( (unsigned __int16)v10 >= 0x4000u )
        {
          if ( (unsigned __int16)v10 <= 0x4000u )
          {
            do
            {
              ++v16;
              ++v11;
              LOBYTE(v13) = v13 - 1;
            }
            while ( (_BYTE)v13 );
          }
          else if ( (_WORD)v10 == 0x8000 )
          {
            do
            {
              ++v16;
              ++v11;
              LOBYTE(v13) = v13 - 1;
            }
            while ( (_BYTE)v13 );
          }
          goto LABEL_46;
        }
        if ( (_WORD)v10 )
        {
LABEL_46:
          v11 = v32;
          v7 = v30;
          continue;
        }
        while ( 1 )
        {
          if ( *v16 )
          {
            if ( *v16 > 1u )
            {
              if ( *v16 != 2 || (*(_BYTE *)(a1 + 4) & 2) == 0 )
                goto LABEL_41;
              v17 = *(_BYTE *)(a1 + 7);
              goto LABEL_40;
            }
            if ( (*(_BYTE *)(a1 + 4) & 1) != 0 )
            {
              v17 = *(_BYTE *)(a1 + 6);
LABEL_40:
              *v11 = v17;
            }
          }
LABEL_41:
          ++v16;
          ++v11;
          LOBYTE(v13) = v13 - 1;
          if ( !(_BYTE)v13 )
            goto LABEL_46;
        }
      }
      if ( *(char *)v7 < 0 )
      {
        LOWORD(v13) = (char)v13;
        v14 += v13;
        v13 = *(char *)v7++;
        v11 -= v13;
        continue;
      }
      HIWORD(v18) = HIWORD(v35);
      LOWORD(v18) = v35 - 1;
      v19 = (_WORD)v35 == 1;
      v35 = v18;
      if ( !v19 )
      {
        v13 = v34;
        v11 = v15;
        v14 = 0;
        ++v7;
LABEL_56:
        LOBYTE(v14) = v39 - v37;
        v15 += v13;
        goto LABEL_57;
      }
    }
    return v7;
  }
}
// 12C970: using guessed type int dword_12C970;
// 12C974: using guessed type int dword_12C974;
// 12C978: using guessed type int dword_12C978;
// 12C97C: using guessed type int dword_12C97C;
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (000519E0) --------------------------------------------------------
unsigned int *sub_519E0(int a1)
{
  unsigned int *result; // eax
  unsigned int v2; // esi

  result = *(unsigned int **)a1;
  if ( *(_DWORD *)a1 < *(_DWORD *)(a1 + 4) )
  {
    do
    {
      v2 = *(_DWORD *)(a1 + 8);
      if ( *result < v2 )
        *result += v2;
      result = (unsigned int *)((char *)result + 6);
    }
    while ( (unsigned int)result < *(_DWORD *)(a1 + 4) );
  }
  return result;
}

//----- (00051A10) --------------------------------------------------------
int sub_51A10()
{
  int v0; // esi
  int v1; // esi
  int v2; // ebx
  int result; // eax
  char v4[40]; // [esp+0h] [ebp-40h] BYREF
  int v5; // [esp+28h] [ebp-18h] BYREF
  unsigned __int8 i; // [esp+2Ch] [ebp-14h]

  v5 = 4;
  for ( i = 0; i < 6u; ++i )
  {
    v0 = i;
    sprintf(v4, "%s%s\\save\\carpdd%02X.gam", aC, aCarpetCd_1, i);
    v1 = v0;
    v2 = sub_5CDE0((int)v4, 512);
    if ( v2 == -1 )
    {
      result = sprintf(off_96864[v1], asc_A9ACC);
    }
    else
    {
      sub_5CBD0(v2, (int)&v5, 4);
      if ( v5 == 4 )
        sub_5CBD0(v2, (int)off_96864[v1], 20);
      else
        sprintf(off_96864[v1], asc_A9ACC);
      result = sub_5CE50(v2);
    }
  }
  return result;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 96864: using guessed type char *off_96864[5];

//----- (00051AF0) --------------------------------------------------------
int sub_51AF0(char a1)
{
  int v1; // esi
  int v2; // ebx
  char v4[40]; // [esp+0h] [ebp-40h] BYREF
  int v5; // [esp+28h] [ebp-18h] BYREF
  int v6[5]; // [esp+2Ch] [ebp-14h] BYREF

  v6[0] = 4;
  v5 = 4 * ((unsigned __int8)byte_12CBD1 + (unsigned __int8)byte_12CBD0 + *(unsigned __int16 *)(dword_AE408 + 17));
  sprintf(v4, "%s%s\\save\\carpdd%02X.gam", aC, aCarpetCd_1, (unsigned __int8)(a1 - 1));
  v1 = 0;
  v2 = sub_5CDE0((int)v4, 512);
  if ( v2 != -1 )
  {
    sub_5CBD0(v2, (int)v6, 4);
    if ( v6[0] == 4 )
    {
      sub_5CBD0(v2, (int)off_96864[(unsigned __int8)(a1 - 1)], 20);
      sub_5CBD0(v2, dword_AE408 + 29, 32);
      sub_5CBD0(v2, dword_AE408 + 61, 32);
      sub_5CBD0(v2, dword_AE400 + 8597, 12);
      sub_5CBD0(v2, (int)&v5, 4);
      sub_5CBD0(v2, dword_AE400 + 15318, 24);
      sub_5CBD0(v2, (int)&byte_12CBD0, 1);
      sub_5CBD0(v2, (int)&byte_12CBD1, 1);
      sub_5CBD0(v2, dword_AE400 + 8597, 12);
      byte_9687C = 0;
      v1 = 1;
      *(_WORD *)(dword_AE408 + 17) = v5 / v6[0] - (unsigned __int8)byte_12CBD0 - (unsigned __int8)byte_12CBD1;
    }
    sub_5CE50(v2);
  }
  return v1;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 96864: using guessed type char *off_96864[5];
// 9687C: using guessed type char byte_9687C;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// 12CBD0: using guessed type char byte_12CBD0;
// 12CBD1: using guessed type char byte_12CBD1;
// 51AF0: using guessed type int var_14[5];

//----- (00051C90) --------------------------------------------------------
int sub_51C90(char a1)
{
  int v1; // esi
  int v2; // eax
  int v3; // ebx
  char v5[40]; // [esp+0h] [ebp-3Ch] BYREF
  int v6; // [esp+28h] [ebp-14h] BYREF
  int v7[4]; // [esp+2Ch] [ebp-10h] BYREF

  v7[0] = 4;
  v1 = 0;
  v6 = 4 * (*(unsigned __int16 *)(dword_AE408 + 17) + (unsigned __int8)byte_12CBD0 + (unsigned __int8)byte_12CBD1);
  sprintf(v5, "%s%s\\save\\carpdd%02X.gam", aC, aCarpetCd_1, (unsigned __int8)(a1 - 1));
  v2 = sub_5CDE0((int)v5, 546);
  v3 = v2;
  if ( v2 != -1 )
  {
    sub_62ED0(v2, (int)v7, 4);
    sub_62ED0(v3, (int)off_96864[(unsigned __int8)(a1 - 1)], 20);
    sub_62ED0(v3, dword_AE408 + 29, 32);
    sub_62ED0(v3, dword_AE408 + 61, 32);
    sub_62ED0(v3, dword_AE400 + 8597, 12);
    sub_62ED0(v3, (int)&v6, 4);
    sub_62ED0(v3, dword_AE400 + 15318, 24);
    sub_62ED0(v3, (int)&byte_12CBD0, 1);
    sub_62ED0(v3, (int)&byte_12CBD1, 1);
    sub_62ED0(v3, dword_AE400 + 8597, 12);
    v1 = 1;
    sub_5CE50(v3);
  }
  return v1;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 96864: using guessed type char *off_96864[5];
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// 12CBD0: using guessed type char byte_12CBD0;
// 12CBD1: using guessed type char byte_12CBD1;
// 51C90: using guessed type int var_10[4];

//----- (00051DF0) --------------------------------------------------------
void sub_51DF0(char a1)
{
  __int16 v1; // cx
  char v2; // dl

  //fix
  v1 = 0;
  //fix

  byte_90B23 = 0;
  if ( (a1 & 2) != 0 )
  {
    sub_3F7D0(dword_12CAF8 + 36);
    if ( !dword_9AD98 )
      goto LABEL_8;
  }
  else
  {
    if ( (a1 & 1) == 0 && (a1 & 0x20) == 0 )
      goto LABEL_8;
    sub_3F820(dword_12CAF8 + 60, v1, dword_12CAF8 + 60, dword_12CAF8 + 30, dword_12CAF8 + 36, a1);
    if ( !dword_9AD98 )
      goto LABEL_8;
  }
  sub_3F370();
LABEL_8:
  if ( (a1 & 8) != 0 )
  {
    if ( sub_5AF50() )
    {
      v2 = byte_90B23 | 8;
      *(_BYTE *)(dword_AE400 + 8606) = 1;
      byte_90B23 = v2;
    }
  }
}
// 51E3F: variable 'v1' is possibly undefined
// 90B23: using guessed type char byte_90B23;
// 9AD98: using guessed type int dword_9AD98;
// AE400: using guessed type int dword_AE400;
// 12CAF8: using guessed type int dword_12CAF8;

//----- (00051E84) --------------------------------------------------------
void sub_51E84(_BYTE *a1, _BYTE *a2, _BYTE *a3, int a4, char a5)
{
  _BYTE *v5; // esi
  _BYTE *v6; // edi
  int v8; // ecx
  int v9; // eax

  v5 = a1;
  if ( a1 )
  {
    v6 = a2;
    if ( a2 )
    {
      v8 = dword_12EFF0 * dword_12EFF8;
      v9 = 0;
      if ( a4 )
      {
        do
        {
          LOBYTE(v9) = *v5++;
          if ( *a3 == a5 )
            LOBYTE(v9) = *(_BYTE *)(v9 + a4);
          *v6++ = v9;
          ++a3;
          --v8;
        }
        while ( v8 );
      }
    }
  }
}
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF8: using guessed type int dword_12EFF8;

//----- (00051ECC) --------------------------------------------------------
int sub_51ECC(int a1, int a2, int a3, int a4, char a5, char a6)
{
  int v6; // edi
  int v7; // edi
  int v8; // eax
  _BYTE *v9; // edi
  int v10; // edx
  int v11; // ebx
  int result; // eax
  int v13; // ecx
  int v14; // [esp+4h] [ebp-4h]

  //fix
  v14 = 0;
  //fix

  v6 = a2;
  if ( a2 >= dword_12F010 )
    return v14;
  if ( a2 < 0 )
  {
    a4 += a2;
    v6 = 0;
  }
  if ( a4 + v6 > dword_12F028 )
    a4 = dword_12F028 - v6;
  if ( a4 <= 0 )
    return v14;
  v7 = dword_12EFF0 * (dword_12F018 + v6);
  v8 = a1;
  if ( a1 >= dword_12F024 )
    return v14;
  if ( a1 < 0 )
  {
    a3 += a1;
    v8 = 0;
  }
  if ( a3 + v8 > dword_12F000 )
    a3 = dword_12F000 - v8;
  if ( a3 <= 0 )
    return v14;
  v9 = (_BYTE *)(dword_12EFF4 + dword_12F008 + v8 + v7);
  v10 = a4;
  v11 = dword_12EFF0 - a3;
  switch ( a6 & 3 )
  {
    case 0:
      do
      {
        v13 = a3;
        do
        {
          *v9++ = a5;
          --v13;
        }
        while ( v13 );
        v9 += v11;
        --v10;
      }
      while ( v10 );
      result = v14;
      break;
    case 1:
      result = v14;
      break;
    case 2:
      result = v14;
      break;
    case 3:
      result = v14;
      break;
  }
  return result;
}
// 51F74: variable 'v14' is possibly undefined
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F000: using guessed type int dword_12F000;
// 12F008: using guessed type int dword_12F008;
// 12F010: using guessed type int dword_12F010;
// 12F018: using guessed type int dword_12F018;
// 12F024: using guessed type int dword_12F024;
// 12F028: using guessed type int dword_12F028;

//----- (00051FC0) --------------------------------------------------------
void sub_51FC0()
{
  __int16 i; // bx
  __int16 v1; // si
  __int16 j; // bx

  if ( byte_939E4 && byte_939E5 )
  {
    for ( i = 0; i < 32; ++i )
    {
      v1 = 0;
      if ( byte_12CC20[i] )
      {
        if ( sub_651F8(dword_CC140, i) )
        {
          v1 = 1;
        }
        else
        {
          HIBYTE(word_CC070[i]) += 8;
          if ( (unsigned __int16)word_CC070[i] >= 0x7FFFu )
          {
            v1 = 1;
            word_CC070[i] = 0x7FFF;
          }
          if ( (unsigned __int16)word_CC070[i] >= ((unsigned __int16)word_12CC40[i] << 8) - 1 )
          {
            word_CC070[i] = (word_12CC40[i] << 8) - 1;
            v1 = 1;
          }
          sub_66118(dword_CC140, i, word_CC070[i]);
        }
      }
      if ( v1 )
        byte_12CC20[i] = 0;
    }
  }
  else
  {
    for ( j = 0; j < 32; ++j )
    {
      if ( byte_12CC20[j] )
        byte_12CC20[j] = 0;
    }
  }
}
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// CC070: using guessed type __int16 word_CC070[];
// CC140: using guessed type int dword_CC140;
// 12CC40: using guessed type __int16 word_12CC40[];

//----- (000520F0) --------------------------------------------------------
void sub_520F0(__int16 a1, __int16 a2, char a3, __int16 a4)
{
  word_968D8 = a4;
  if ( a3 == 3 )
    sub_52120(a1, a2);
}
// 968D8: using guessed type __int16 word_968D8;

//----- (00052120) --------------------------------------------------------
void sub_52120(__int16 a1, __int16 a2)
{
  char v2; // bh
  __int16 *v3; // esi
  unsigned __int8 v4; // bl
  unsigned __int8 v5; // bl
  int v6; // edx
  int v7; // edx
  int v8; // eax
  int v9; // edx
  int v10; // eax

  if ( byte_939E4 && byte_939E5 && a2 <= (int)(unsigned __int16)word_CC1C6 )
  {
    v2 = 0;
    v3 = word_CBFF0;
    v4 = 0;
    while ( __PAIR32__(a2, a1) != *(_DWORD *)v3 || sub_651F8(dword_CC140, v4) )
    {
      ++v4;
      v3 += 2;
      if ( v4 >= 0x20u )
        goto LABEL_12;
    }
    v2 = 1;
    if ( byte_12CC20[v4] )
      return;
    if ( byte_12CCC0[v4] )
      byte_12CCC0[v4] = 0;
    byte_12CC20[v4] = 1;
    word_12CC40[v4] = word_968D8;
LABEL_12:
    if ( !v2 )
    {
      v5 = 0;
      while ( !sub_651F8(dword_CC140, v5) )
      {
        if ( ++v5 >= 0x20u )
          goto LABEL_17;
      }
      v2 = 1;
LABEL_17:
      if ( v2 )
      {
          //fix word_939F4 = __DS__;
        word_93A0C = 17152;
        word_93A00 = 0;
        word_CBFF0[2 * v5] = a1;
        word_93A22 = 0x7FFF;
        word_939FC = -1;
        word_93A02 = v5;
        v6 = dword_CC154;
        word_CBFF2[2 * v5] = a2;
        v7 = 32 * a2 + v6;
        word_CC070[v5] = 0;
        v8 = *(_DWORD *)(v7 + 26) - 16;
        v9 = *(_DWORD *)(v7 + 18);
        dword_939F8 = v8;
        dword_939F0 = v9;
        v10 = sub_6535C(dword_CC140, (unsigned int)&dword_939F0);
        BYTE1(v9) = byte_12CC20[v5];
        dword_CC144 = v10;
        if ( BYTE1(v9) )
        {
          if ( byte_12CCC0[v5] )
            byte_12CCC0[v5] = 0;
        }
        byte_12CC20[v5] = 1;
        word_12CC40[v5] = word_968D8;
      }
    }
  }
}
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// 939F0: using guessed type int dword_939F0;
// 939F4: using guessed type __int16 word_939F4;
// 939F8: using guessed type int dword_939F8;
// 939FC: using guessed type __int16 word_939FC;
// 93A00: using guessed type __int16 word_93A00;
// 93A02: using guessed type __int16 word_93A02;
// 93A0C: using guessed type __int16 word_93A0C;
// 93A22: using guessed type __int16 word_93A22;
// 968D8: using guessed type __int16 word_968D8;
// CBFF0: using guessed type __int16 word_CBFF0[];
// CBFF2: using guessed type __int16 word_CBFF2[63];
// CC070: using guessed type __int16 word_CC070[];
// CC140: using guessed type int dword_CC140;
// CC144: using guessed type int dword_CC144;
// CC154: using guessed type int dword_CC154;
// CC1C6: using guessed type __int16 word_CC1C6;
// 12CC40: using guessed type __int16 word_12CC40[];

//----- (000522E0) --------------------------------------------------------
void sub_522E0()
{
  __int16 v0; // si
  int v1; // ebx
  signed __int16 v2; // cx
  __int16 i; // si
  __int16 v4; // [esp+0h] [ebp-10h]

  if ( byte_939E4 && byte_939E5 )
  {
    v0 = 0;
    while ( 1 )
    {
      v4 = 0;
      if ( byte_12CCC0[v0] )
        break;
LABEL_12:
      if ( ++v0 >= 32 )
        return;
    }
    if ( !sub_651F8(dword_CC140, v0) )
    {
      v1 = v0;
      v2 = word_12CCE0[v1] - 2048;
      word_12CCE0[v1] = v2;
      if ( v2 > 4096 )
      {
        word_CC070[v0] = v2;
        sub_66118(dword_CC140, v0, v2);
        goto LABEL_10;
      }
      sub_65965(dword_CC140, v0);
      word_12CCE0[v0] = 0;
      word_CC070[v0] = 0;
    }
    v4 = 1;
LABEL_10:
    if ( v4 )
      byte_12CCC0[v0] = 0;
    goto LABEL_12;
  }
  for ( i = 0; i < 32; ++i )
  {
    if ( byte_12CCC0[i] )
      byte_12CCC0[i] = 0;
  }
}
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// CC070: using guessed type __int16 word_CC070[];
// CC140: using guessed type int dword_CC140;
// 12CCE0: using guessed type __int16 word_12CCE0[32];

//----- (00052400) --------------------------------------------------------
void sub_52400(__int16 a1, __int16 a2, __int16 a3)
{
  __int16 *v3; // esi
  __int16 v4; // bx
  int v5; // eax
  __int16 v6; // bx

  if ( byte_939E4 && byte_939E5 )
  {
    v3 = word_CBFF0;
    v4 = 0;
    while ( a1 != *v3 || a2 != v3[1] || sub_651F8(dword_CC140, v4) )
    {
      ++v4;
      v3 += 2;
      if ( v4 >= 32 )
        return;
    }
    if ( !byte_12CCC0[v4] )
    {
      if ( byte_12CC20[v4] )
        byte_12CC20[v4] = 0;
      v5 = v4;
      word_12CC80[v4] = a3;
      v6 = word_CC070[v4];
      byte_12CCC0[v5] = 1;
      word_12CCE0[v5] = v6;
    }
  }
}
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// CBFF0: using guessed type __int16 word_CBFF0[];
// CC070: using guessed type __int16 word_CC070[];
// CC140: using guessed type int dword_CC140;
// 12CC80: using guessed type __int16 word_12CC80[];
// 12CCE0: using guessed type __int16 word_12CCE0[32];

//----- (000524C0) --------------------------------------------------------
int sub_524C0(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_BYTE *)(a1 + 65) != 2 )
    *(_WORD *)(a1 + 76) += *(_WORD *)(a1 + 78);
  return result;
}

//----- (000524E0) --------------------------------------------------------
int sub_524E0(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_BYTE *)(a1 + 65) != 2 )
    *(_WORD *)(a1 + 76) -= *(_WORD *)(a1 + 78);
  return result;
}

//----- (00052500) --------------------------------------------------------
int sub_52500(_WORD *a1, int a2)
{
  sub_524C0(a2);
  a1[17] = sub_42150(a1 + 36, (_WORD *)(a2 + 72));
  a1[18] = sub_42180(a1 + 36, (_WORD *)(a2 + 72));
  return sub_524E0(a2);
}

//----- (00052550) --------------------------------------------------------
int sub_52550(int a1, int a2)
{
  __int16 v3; // ax
  int v4; // esi
  __int16 v5; // ax
  int v6; // esi
  __int16 v7; // ax

  sub_524C0(a2);
  *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(a2 + 72));
  v3 = sub_42180((_WORD *)(a1 + 72), (_WORD *)(a2 + 72));
  v4 = *(_DWORD *)(a1 + 156);
  *(_WORD *)(a1 + 36) = v3;
  v5 = *(_WORD *)(a1 + 30)
     + sub_422A0(*(_WORD *)(a1 + 30), *(_WORD *)(a1 + 34), *(unsigned __int16 *)(v4 + 4), *(_WORD *)(v4 + 2));
  HIBYTE(v5) &= 7u;
  v6 = *(_DWORD *)(a1 + 156);
  *(_WORD *)(a1 + 30) = v5;
  v7 = *(_WORD *)(a1 + 32)
     + sub_422A0(*(_WORD *)(a1 + 32), *(_WORD *)(a1 + 36), *(unsigned __int16 *)(v6 + 8), *(_WORD *)(v6 + 6));
  HIBYTE(v7) &= 7u;
  *(_WORD *)(a1 + 32) = v7;
  return sub_524E0(a2);
}

//----- (00052610) --------------------------------------------------------
__int16 sub_52610(int a1, int a2)
{
  __int16 v3; // ax
  int v4; // esi
  __int16 v5; // ax
  int v6; // esi
  __int16 result; // ax

  *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(a2 + 72));
  v3 = sub_42180((_WORD *)(a1 + 72), (_WORD *)(a2 + 72));
  v4 = *(_DWORD *)(a1 + 156);
  *(_WORD *)(a1 + 36) = v3;
  v5 = *(_WORD *)(a1 + 30)
     + sub_422A0(*(_WORD *)(a1 + 30), *(_WORD *)(a1 + 34), *(unsigned __int16 *)(v4 + 4), *(_WORD *)(v4 + 2));
  HIBYTE(v5) &= 7u;
  v6 = *(_DWORD *)(a1 + 156);
  *(_WORD *)(a1 + 30) = v5;
  result = *(_WORD *)(a1 + 32)
         + sub_422A0(*(_WORD *)(a1 + 32), *(_WORD *)(a1 + 36), *(unsigned __int16 *)(v6 + 8), *(_WORD *)(v6 + 6));
  HIBYTE(result) &= 7u;
  *(_WORD *)(a1 + 32) = result;
  return result;
}

//----- (000526C0) --------------------------------------------------------
char sub_526C0(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // eax
  unsigned int v4; // edx
  int v5; // ebp

  LOBYTE(v3) = *(_BYTE *)(a1 + 65);
  if ( (unsigned __int8)v3 < 3u )
  {
    if ( (unsigned __int8)v3 > 1u )
      return v3;
  }
  else if ( (unsigned __int8)v3 > 3u && ((unsigned __int8)v3 < 7u || (unsigned __int8)v3 > 9u && (_BYTE)v3 != 19) )
  {
    return v3;
  }
  v4 = dword_AE400 + 29795;
  v3 = dword_AE400 + 29795 + 164 * *(__int16 *)(a1 + 24);
  if ( *(_BYTE *)(v3 + 64) == 3 && !*(_BYTE *)(v3 + 65) )
  {
    ++*(_DWORD *)(*(_DWORD *)(v3 + 160) + 343);
    if ( v4 < a2 && a3 > v4 && *(_WORD *)(a2 + 24) == *(_WORD *)(a3 + 24) )
    {
      v5 = *(_DWORD *)(v3 + 160);
      if ( v5 )
        ++*(_DWORD *)(v5 + 347);
    }
  }
  return v3;
}
// AE400: using guessed type int dword_AE400;

//----- (00052770) --------------------------------------------------------
char sub_52770(int a1)
{
  int v1; // edx
  char v2; // dl
  int v3; // eax
  __int16 v4; // ax
  int v5; // eax
  unsigned int v6; // ebp
  char v7; // cl
  int v8; // edi
  __int16 v9; // ax
  int v10; // esi
  int v11; // eax
  int v12; // edx
  unsigned int v13; // eax
  int v14; // edi
  int v15; // eax
  __int16 v16; // dx
  int v17; // eax
  int v18; // esi
  int v19; // edi
  _WORD *v20; // esi
  unsigned int v22; // [esp+0h] [ebp-18h]
  char v23; // [esp+4h] [ebp-14h]

  v23 = 0;
  v1 = 164 * *(unsigned __int16 *)(a1 + 146);
  v22 = dword_AE400 + 29795 + v1;
  if ( dword_AE400 + 29795 >= v22 )
  {
    v2 = *(_BYTE *)(a1 + 16);
    if ( (v2 & 2) == 0 )
    {
      *(_BYTE *)(a1 + 16) = v2 | 2;
      if ( sub_54520(a1) )
      {
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 36);
      }
      else
      {
        *(_WORD *)(a1 + 34) = *(_WORD *)(a1 + 30);
        *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 32);
      }
    }
  }
  else
  {
    sub_52550(a1, dword_AE400 + 29795 + v1);
  }
  v3 = *(__int16 *)(a1 + 128) - *(__int16 *)(a1 + 126);
  if ( v3 )
    v3 /= (int)abs32(v3);
  *(_WORD *)(a1 + 126) += 2 * v3;
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  v4 = (unsigned __int16)sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 126));
  sub_41C70(v4, a1, (int)&word_AE454);
  v5 = sub_11980(a1);
  v6 = v5;
  if ( !v5 )
  {
    LOWORD(v15) = sub_11F50((__int16 *)(a1 + 72));
    v16 = *(_WORD *)(a1 + 76);
    word_AE458 = v15;
    if ( (__int16)v15 <= v16 )
    {
      v18 = *(_DWORD *)(a1 + 12) - 1;
      *(_DWORD *)(a1 + 12) = v18;
      if ( v18 >= 0 )
        goto LABEL_25;
    }
    else if ( *(_BYTE *)(a1 + 65) != 4 )
    {
      v15 = sub_11810((__int16 *)(a1 + 72));
      if ( v15 == 1 )
      {
        v17 = sub_373F0(a1 + 72, 10, 5);
        if ( v17 )
          *(_WORD *)(v17 + 24) = *(_WORD *)(a1 + 24);
        LOBYTE(v15) = sub_41E80(a1);
        goto LABEL_25;
      }
    }
    v23 = 1;
    goto LABEL_25;
  }
  if ( *(char *)(v5 + 17) < 0
    && (*(_DWORD *)(a1 + 140) - (__CFSHL__(*(int *)(a1 + 140) >> 31, 2) + 4 * (*(int *)(a1 + 140) >> 31))) >> 2 <= *(_DWORD *)(v5 + 140)
    && *(_BYTE *)(a1 + 68) == 10 )
  {
    v7 = *(_BYTE *)(a1 + 69);
    if ( v7 == 1 || v7 == 17 )
    {
      sub_55370((v5 - (dword_AE400 + 29795)) / 164, -1, 28);
      v8 = dword_AE400 + 29795 + 164 * *(__int16 *)(a1 + 24);
      *(_DWORD *)(v6 + 140) -= (*(_DWORD *)(a1 + 140)
                              - (__CFSHL__(*(int *)(a1 + 140) >> 31, 2)
                               + 4 * (*(int *)(a1 + 140) >> 31))) >> 2;
      v9 = *(_WORD *)(a1 + 30);
      HIBYTE(v9) = (HIBYTE(v9) + 4) & 7;
      *(_WORD *)(a1 + 34) = v9;
      v10 = sub_42240(0, *(_WORD *)(a1 + 32));
      v11 = -(v10 * sub_42210(0, *(_WORD *)(a1 + 32)));
      BYTE1(v11) &= 7u;
      *(_WORD *)(a1 + 36) = v11;
      v12 = *(_DWORD *)(a1 + 4);
      *(_WORD *)(a1 + 32) = v11;
      v13 = 9377 * v12 + 9439;
      *(_DWORD *)(a1 + 4) = v13;
      v14 = v8 - (dword_AE400 + 29795);
      *(_WORD *)(a1 + 30) = v13 % 0x2D + *(_WORD *)(a1 + 34) - 22;
      *(_WORD *)(a1 + 146) = v14 / 164;
      *(_WORD *)(a1 + 24) = *(_WORD *)(v6 + 24);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)&word_AE454 = *(_DWORD *)(v6 + 72);
      *(&word_AE454 + 2) = *(_WORD *)(v6 + 76);
      LOWORD(v13) = *(_WORD *)(v6 + 84);
      word_AE458 += v13;
      LOBYTE(v15) = sub_41C70(v13, a1, (int)&word_AE454);
      return v15;
    }
  }
  sub_524C0(v5);
  sub_41C70(v6 + 72, a1, v6 + 72);
  sub_524E0(v6);
  LOBYTE(v15) = 1;
  v23 = 1;
LABEL_25:
  if ( v23 )
  {
    v15 = sub_373F0(a1 + 72, *(char *)(a1 + 68), *(char *)(a1 + 69));
    v19 = v15;
    v20 = (_WORD *)v15;
    if ( v15 )
    {
      sub_526C0(a1, v6, v22);
      if ( *(_BYTE *)(a1 + 69) == 34 )
        *(_DWORD *)(v19 + 12) = *(unsigned __int16 *)(a1 + 44);
      v20[12] = *(_WORD *)(a1 + 24);
      v20[15] = *(_WORD *)(a1 + 30);
      v20[16] = *(_WORD *)(a1 + 32);
      v20[73] = (int)(v6 - (dword_AE400 + 29795)) / 164;
      v20[22] = *(_WORD *)(a1 + 44);
      LOBYTE(v15) = sub_41E80(a1);
    }
  }
  return v15;
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE458: using guessed type __int16 word_AE458;

//----- (00052B30) --------------------------------------------------------
int sub_52B30(int a1)
{
  int v1; // ebp
  char v2; // dl
  __int16 v3; // si
  __int16 v4; // dx
  __int16 v5; // ax
  __int16 v6; // ax
  int v7; // eax
  int v8; // ebp
  unsigned int v9; // edi
  int result; // eax
  int v11; // edi
  __int16 v12; // ax
  int v13; // esi
  int v14; // eax
  int v15; // edx
  unsigned int v16; // eax
  __int16 v17; // cx
  int v18; // eax
  int v19; // esi
  _WORD *v20; // ebp
  int v21; // [esp+0h] [ebp-20h] BYREF
  __int16 v22; // [esp+4h] [ebp-1Ch]
  unsigned int v23; // [esp+8h] [ebp-18h]
  char v24; // [esp+Ch] [ebp-14h]

  v24 = 0;
  v1 = 164 * *(unsigned __int16 *)(a1 + 146);
  v23 = dword_AE400 + 29795 + v1;
  if ( dword_AE400 + 29795 >= v23 )
  {
    v2 = *(_BYTE *)(a1 + 16);
    if ( (v2 & 2) == 0 )
    {
      *(_BYTE *)(a1 + 16) = v2 | 2;
      if ( sub_54520(a1) )
      {
        v3 = sub_42210(*(_WORD *)(a1 + 30), *(_WORD *)(a1 + 34));
        if ( v3 < 0 )
          v3 = 0;
        if ( v3 > 34 )
          v3 = 34;
        v4 = v3 * sub_42240(*(unsigned __int16 *)(a1 + 30), *(_WORD *)(a1 + 34)) + *(_WORD *)(a1 + 30);
        v5 = *(_WORD *)(a1 + 36);
        *(_WORD *)(a1 + 30) = v4;
        *(_WORD *)(a1 + 32) = v5;
      }
      else
      {
        *(_WORD *)(a1 + 34) = *(_WORD *)(a1 + 30);
        *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 32);
      }
    }
  }
  else
  {
    sub_52550(a1, dword_AE400 + 29795 + v1);
  }
  v21 = *(_DWORD *)(a1 + 72);
  v22 = *(_WORD *)(a1 + 76);
  *(_DWORD *)&word_AE454 = v21;
  *(&word_AE454 + 2) = v22;
  v6 = (unsigned __int16)sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 126));
  sub_41C70(v6, a1, (int)&word_AE454);
  v7 = sub_11980(a1);
  v8 = v7;
  v9 = v7;
  if ( v7 )
  {
    if ( *(char *)(v7 + 17) >= 0 )
    {
      sub_524C0(v7);
      sub_41C70(v8 + 72, a1, v8 + 72);
      result = sub_524E0(v8);
      v24 = 1;
    }
    else
    {
      result = (*(_DWORD *)(a1 + 140) - (__CFSHL__(*(int *)(a1 + 140) >> 31, 2) + 4 * (*(int *)(a1 + 140) >> 31))) >> 2;
      if ( result <= *(_DWORD *)(v8 + 140) )
      {
        sub_55370((v8 - (dword_AE400 + 29795)) / 164, -1, 28);
        v11 = dword_AE400 + 29795 + 164 * *(__int16 *)(a1 + 24);
        *(_DWORD *)(v8 + 140) -= (*(_DWORD *)(a1 + 140)
                                - (__CFSHL__(*(int *)(a1 + 140) >> 31, 2)
                                 + 4 * (*(int *)(a1 + 140) >> 31))) >> 2;
        v12 = *(_WORD *)(a1 + 30);
        HIBYTE(v12) = (HIBYTE(v12) + 4) & 7;
        *(_WORD *)(a1 + 34) = v12;
        v13 = sub_42240(0, *(_WORD *)(a1 + 32));
        v14 = -(v13 * sub_42210(0, *(_WORD *)(a1 + 32)));
        BYTE1(v14) &= 7u;
        *(_WORD *)(a1 + 36) = v14;
        v15 = *(_DWORD *)(a1 + 4);
        *(_WORD *)(a1 + 32) = v14;
        v16 = 9377 * v15 + 9439;
        *(_DWORD *)(a1 + 4) = v16;
        *(_WORD *)(a1 + 30) = v16 % 0x5B + *(_WORD *)(a1 + 34) - 45;
        *(_WORD *)(a1 + 146) = (v11 - (dword_AE400 + 29795)) / 164;
        *(_WORD *)(a1 + 24) = *(_WORD *)(v8 + 24);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
        *(_DWORD *)&word_AE454 = *(_DWORD *)(v8 + 72);
        *(&word_AE454 + 2) = *(_WORD *)(v8 + 76);
        LOWORD(v16) = *(_WORD *)(v8 + 84);
        word_AE458 += v16;
        return sub_41C70(v16, a1, (int)&word_AE454);
      }
    }
  }
  else
  {
    result = sub_11F50((__int16 *)(a1 + 72));
    v17 = *(_WORD *)(a1 + 76);
    word_AE458 = result;
    if ( (__int16)result <= v17 )
    {
      v19 = *(_DWORD *)(a1 + 12) - 1;
      *(_DWORD *)(a1 + 12) = v19;
      if ( v19 >= 0 )
        goto LABEL_24;
    }
    else
    {
      result = sub_41C70((__int16)&v21, a1, (int)&v21);
      if ( *(_BYTE *)(a1 + 65) != 4 )
      {
        result = sub_11810((__int16 *)(a1 + 72));
        if ( result == 1 )
        {
          v18 = sub_373F0(a1 + 72, 10, 5);
          if ( v18 )
            *(_WORD *)(v18 + 24) = *(_WORD *)(a1 + 24);
          result = sub_41E80(a1);
          goto LABEL_24;
        }
      }
    }
    v24 = 1;
  }
LABEL_24:
  if ( v24 )
  {
    result = sub_373F0(a1 + 72, *(char *)(a1 + 68), *(char *)(a1 + 69));
    v20 = (_WORD *)result;
    if ( result )
    {
      sub_526C0(a1, v9, v23);
      v20[12] = *(_WORD *)(a1 + 24);
      v20[15] = *(_WORD *)(a1 + 30);
      v20[16] = *(_WORD *)(a1 + 32);
      return sub_41E80(a1);
    }
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE458: using guessed type __int16 word_AE458;

//----- (00052ED0) --------------------------------------------------------
char sub_52ED0(int a1)
{
  unsigned __int16 v1; // si
  unsigned int v2; // ebp
  char v3; // dl
  __int16 v4; // ax
  int v5; // eax
  int v6; // esi
  unsigned int v7; // edi
  int v8; // eax
  __int16 v9; // cx
  int v10; // edx
  _WORD *v11; // esi
  char v13; // [esp+0h] [ebp-14h]

  v1 = *(_WORD *)(a1 + 146);
  v13 = 0;
  v2 = dword_AE400 + 29795 + 164 * v1;
  if ( v2 <= dword_AE400 + 29795 )
  {
    v3 = *(_BYTE *)(a1 + 16);
    if ( (v3 & 2) == 0 )
    {
      *(_BYTE *)(a1 + 16) = v3 | 2;
      if ( sub_54520(a1) )
      {
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 36);
      }
    }
  }
  else
  {
    sub_52550(a1, dword_AE400 + 29795 + 164 * v1);
  }
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 126));
  v4 = sub_11F50(&word_AE454);
  if ( v4 > word_AE458 )
    word_AE458 = v4;
  sub_41C70(v4, a1, (int)&word_AE454);
  v5 = sub_11AC0((_WORD *)a1);
  v6 = v5;
  v7 = v5;
  if ( v5 )
  {
    sub_524C0(v5);
    sub_41C70(v6 + 72, a1, v6 + 72);
    sub_524E0(v6);
    LOBYTE(v8) = 1;
    v13 = 1;
  }
  else
  {
    LOWORD(v8) = sub_11F50((__int16 *)(a1 + 72));
    v9 = *(_WORD *)(a1 + 76);
    word_AE458 = v8;
    if ( (__int16)v8 > v9 || (v10 = *(_DWORD *)(a1 + 12) - 1, *(_DWORD *)(a1 + 12) = v10, v10 < 0) )
      v13 = 1;
  }
  if ( v13 )
  {
    v8 = sub_373F0(a1 + 72, *(char *)(a1 + 68), *(char *)(a1 + 69));
    v11 = (_WORD *)v8;
    if ( v8 )
    {
      sub_526C0(a1, v7, v2);
      v11[12] = *(_WORD *)(a1 + 24);
      v11[15] = *(_WORD *)(a1 + 30);
      v11[16] = *(_WORD *)(a1 + 32);
      LOBYTE(v8) = sub_41E80(a1);
    }
  }
  return v8;
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE458: using guessed type __int16 word_AE458;

//----- (00053060) --------------------------------------------------------
char sub_53060(int a1)
{
  return sub_52770(a1);
}

//----- (00053070) --------------------------------------------------------
char sub_53070(int a1)
{
  int v1; // eax
  char v2; // dh

  LOBYTE(v1) = sub_52770(a1);
  if ( *(_BYTE *)(a1 + 64) )
  {
    v1 = sub_373F0(a1 + 72, 10, 1);
    if ( v1 )
    {
      *(_BYTE *)(v1 + 16) |= 0x80u;
      v2 = *(_BYTE *)(v1 + 18) | 1;
      *(_WORD *)(v1 + 24) = *(_WORD *)(a1 + 24);
      *(_BYTE *)(v1 + 18) = v2;
    }
  }
  return v1;
}

//----- (000530B0) --------------------------------------------------------
char sub_530B0(int a1)
{
  return sub_530C0(a1);
}

//----- (000530C0) --------------------------------------------------------
char sub_530C0(int a1)
{
  int v1; // edx
  char v2; // dl
  int v3; // eax
  __int16 v4; // ax
  int v5; // eax
  unsigned int v6; // ebp
  char v7; // cl
  int v8; // edi
  __int16 v9; // ax
  int v10; // esi
  int v11; // eax
  int v12; // ecx
  int v13; // edi
  int v14; // eax
  __int16 v15; // dx
  int v16; // eax
  int v17; // esi
  int v18; // edi
  _WORD *v19; // esi
  unsigned int v21; // [esp+0h] [ebp-18h]
  char v22; // [esp+4h] [ebp-14h]

  v22 = 0;
  v1 = 164 * *(unsigned __int16 *)(a1 + 146);
  v21 = dword_AE400 + 29795 + v1;
  if ( dword_AE400 + 29795 >= v21 )
  {
    v2 = *(_BYTE *)(a1 + 16);
    if ( (v2 & 2) == 0 )
    {
      *(_BYTE *)(a1 + 16) = v2 | 2;
      if ( sub_54520(a1) )
      {
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 36);
      }
      else
      {
        *(_WORD *)(a1 + 34) = *(_WORD *)(a1 + 30);
        *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 32);
      }
    }
  }
  else
  {
    sub_52550(a1, dword_AE400 + 29795 + v1);
  }
  v3 = *(__int16 *)(a1 + 128) - *(__int16 *)(a1 + 126);
  if ( v3 )
    v3 /= (int)abs32(v3);
  *(_WORD *)(a1 + 126) += 2 * v3;
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  v4 = (unsigned __int16)sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 126));
  sub_41C70(v4, a1, (int)&word_AE454);
  v5 = sub_11980(a1);
  v6 = v5;
  if ( v5 )
  {
    if ( *(char *)(v5 + 17) < 0
      && (*(_DWORD *)(a1 + 140) - (__CFSHL__(*(int *)(a1 + 140) >> 31, 2) + 4 * (*(int *)(a1 + 140) >> 31))) >> 2 <= *(_DWORD *)(v5 + 140)
      && *(_BYTE *)(a1 + 68) == 10 )
    {
      v7 = *(_BYTE *)(a1 + 69);
      if ( v7 == 1 || v7 == 17 )
      {
        sub_55370((v5 - (dword_AE400 + 29795)) / 164, -1, 28);
        v8 = dword_AE400 + 29795 + 164 * *(__int16 *)(a1 + 24);
        *(_DWORD *)(v6 + 140) -= (*(_DWORD *)(a1 + 140)
                                - (__CFSHL__(*(int *)(a1 + 140) >> 31, 2)
                                 + 4 * (*(int *)(a1 + 140) >> 31))) >> 2;
        v9 = *(_WORD *)(a1 + 30);
        HIBYTE(v9) = (HIBYTE(v9) + 4) & 7;
        *(_WORD *)(a1 + 34) = v9;
        v10 = sub_42240(0, *(_WORD *)(a1 + 32));
        v11 = -(v10 * sub_42210(0, *(_WORD *)(a1 + 32)));
        BYTE1(v11) &= 7u;
        *(_WORD *)(a1 + 36) = v11;
        v12 = *(_DWORD *)(a1 + 4);
        *(_WORD *)(a1 + 32) = v11;
        *(_DWORD *)(a1 + 4) = 9377 * v12 + 9439;
        v13 = v8 - (dword_AE400 + 29795);
        *(_WORD *)(a1 + 30) = (9377 * v12 + 9439) % 0x2Du + *(_WORD *)(a1 + 34) - 22;
        *(_WORD *)(a1 + 146) = v13 / 164;
        *(_WORD *)(a1 + 24) = *(_WORD *)(v6 + 24);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
        *(_DWORD *)&word_AE454 = *(_DWORD *)(v6 + 72);
        *(&word_AE454 + 2) = *(_WORD *)(v6 + 76);
        LOWORD(v11) = *(_WORD *)(v6 + 84);
        word_AE458 += v11;
        LOBYTE(v14) = sub_41C70(v11, a1, (int)&word_AE454);
        return v14;
      }
    }
    sub_524C0(v5);
    sub_41C70(v6 + 72, a1, v6 + 72);
    sub_524E0(v6);
    LOBYTE(v14) = 1;
    v22 = 1;
  }
  else
  {
    LOWORD(v14) = sub_11F50((__int16 *)(a1 + 72));
    v15 = *(_WORD *)(a1 + 76);
    word_AE458 = v14;
    if ( (__int16)v14 <= v15 )
    {
      v17 = *(_DWORD *)(a1 + 12) - 1;
      *(_DWORD *)(a1 + 12) = v17;
      if ( v17 >= 0 )
        goto LABEL_25;
    }
    else if ( *(_BYTE *)(a1 + 65) != 4 )
    {
      v14 = sub_11810((__int16 *)(a1 + 72));
      if ( v14 == 1 )
      {
        v16 = sub_373F0(a1 + 72, 10, 5);
        if ( v16 )
          *(_WORD *)(v16 + 24) = *(_WORD *)(a1 + 24);
        LOBYTE(v14) = sub_41E80(a1);
        goto LABEL_25;
      }
    }
    v22 = 1;
  }
LABEL_25:
  if ( v22 )
  {
    if ( v6 && *(_BYTE *)(v6 + 64) == 3 && *(_BYTE *)(v6 + 65) <= 1u )
    {
      v14 = sub_373F0(a1 + 72, *(char *)(a1 + 68), *(char *)(a1 + 69));
      v18 = v14;
      v19 = (_WORD *)v14;
      if ( v14 )
      {
        sub_526C0(a1, v6, v21);
        if ( *(_BYTE *)(a1 + 69) == 34 )
          *(_DWORD *)(v18 + 12) = *(unsigned __int16 *)(a1 + 44);
        v19[12] = *(_WORD *)(a1 + 24);
        v19[15] = *(_WORD *)(a1 + 30);
        v19[16] = *(_WORD *)(a1 + 32);
        v19[73] = (int)(v6 - (dword_AE400 + 29795)) / 164;
        v19[22] = *(_WORD *)(a1 + 44);
        LOBYTE(v14) = sub_41E80(a1);
      }
    }
    else
    {
      sub_526C0(a1, 0, v21);
      LOBYTE(v14) = sub_41E80(a1);
    }
  }
  return v14;
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE458: using guessed type __int16 word_AE458;

//----- (000534C0) --------------------------------------------------------
char sub_534C0(int a1)
{
  char v1; // dl
  int v2; // eax
  int v3; // esi
  __int16 v4; // dx
  int v5; // edx
  char v7; // [esp+0h] [ebp-10h]

  v7 = 0;
  if ( dword_AE400 + 29795 + 164 * (unsigned int)*(unsigned __int16 *)(a1 + 146) <= dword_AE400 + 29795 )
  {
    v1 = *(_BYTE *)(a1 + 16);
    if ( (v1 & 2) == 0 )
    {
      *(_BYTE *)(a1 + 16) = v1 | 2;
      if ( sub_54520(a1) )
      {
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 36);
      }
      else
      {
        *(_WORD *)(a1 + 34) = *(_WORD *)(a1 + 30);
        *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 32);
      }
    }
  }
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 126));
  *(_DWORD *)(a1 + 72) = *(_DWORD *)&word_AE454;
  *(_WORD *)(a1 + 76) = *(&word_AE454 + 2);
  v2 = sub_11980(a1);
  if ( v2 )
  {
    v3 = v2 + 72;
    LOBYTE(v2) = 1;
    *(_DWORD *)(a1 + 72) = *(_DWORD *)v3;
    *(_WORD *)(a1 + 76) = *(_WORD *)(v3 + 4);
    v7 = 1;
  }
  else
  {
    LOWORD(v2) = sub_11F50((__int16 *)(a1 + 72));
    v4 = *(_WORD *)(a1 + 76);
    word_AE458 = v2;
    if ( (__int16)v2 > v4 || (v5 = *(_DWORD *)(a1 + 12) - 1, *(_DWORD *)(a1 + 12) = v5, v5 < 0) )
      v7 = 1;
  }
  if ( v7 )
    LOBYTE(v2) = sub_41E80(a1);
  return v2;
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE458: using guessed type __int16 word_AE458;

//----- (000535E0) --------------------------------------------------------
__int16 sub_535E0(unsigned int a1)
{
  __int16 v1; // ax
  __int16 v2; // di
  __int16 v3; // si
  char v4; // ah
  char v5; // dl
  int v6; // edx
  unsigned int v7; // eax
  int v8; // esi
  __int16 v9; // si
  __int16 v10; // cx
  unsigned int v11; // eax
  int v12; // esi
  int v13; // eax
  int v14; // esi
  unsigned int v15; // eax
  unsigned __int16 v16; // ax
  int v17; // edi
  int v18; // eax
  _WORD *v19; // esi
  int v20; // ebp
  int v21; // edx
  int v23; // [esp+0h] [ebp-3Ch]
  __int16 v24; // [esp+4h] [ebp-38h]
  int v25; // [esp+8h] [ebp-34h] BYREF
  __int16 v26; // [esp+Ch] [ebp-30h]
  int v27; // [esp+10h] [ebp-2Ch] BYREF
  int v28; // [esp+14h] [ebp-28h]
  unsigned int v29; // [esp+18h] [ebp-24h]
  int v30; // [esp+1Ch] [ebp-20h]
  int v31; // [esp+20h] [ebp-1Ch]
  int v32; // [esp+24h] [ebp-18h]
  int v33; // [esp+28h] [ebp-14h]

  v1 = *(_WORD *)(a1 + 128);
  *(_WORD *)(a1 + 126) = v1;
  v23 = *(_DWORD *)(a1 + 72);
  v24 = *(_WORD *)(a1 + 76);
  sub_41DD0(v1, a1);
  sub_534C0(a1);
  v2 = *(_WORD *)(a1 + 30);
  v3 = *(_WORD *)(a1 + 32);
  v4 = *(_BYTE *)(a1 + 17);
  v30 = 1;
  if ( (v4 & 4) == 0 )
  {
    do
    {
      sub_534C0(a1);
      v5 = *(_BYTE *)(a1 + 17);
      ++v30;
    }
    while ( (v5 & 4) == 0 );
  }
  *(_WORD *)(a1 + 30) = v2;
  *(_WORD *)(a1 + 32) = v3;
  v27 = 0;
  LOWORD(v28) = 0;
  v6 = *(__int16 *)(a1 + 126);
  v30 *= 8;
  v33 = (v6 - (__CFSHL__(v6 >> 31, 3) + 8 * (v6 >> 31))) >> 3;
  sub_41EC0((uint16*)&v27, *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 32), v33);
  v31 = 0;
  v32 = 0;
  *(_DWORD *)&word_AE454 = v23;
  *(&word_AE454 + 2) = v24;
  v25 = v23;
  v26 = v24;
  if ( (v30 & 0x8000u) == 0 )
  {
    while ( 1 )
    {
      v7 = sub_372C0();
      v8 = v7;
      if ( v7 )
      {
        *(_BYTE *)(v7 + 70) = 14;
        *(_BYTE *)(v7 + 64) = 9;
        *(_BYTE *)(v7 + 65) = 9;
        *(_WORD *)(v7 + 24) = *(_WORD *)(a1 + 24);
        *(_DWORD *)(v7 + 8) = (v7 >= a1) - 1;
        sub_36FA0(v7, 216);
        sub_41CF0(v8, (int)&v25);
        sub_36DE0(v8);
      }
      v9 = (__int16)v30 / 2;
      if ( (__int16)v30 / 2 < 0 )
        v9 = 0;
      if ( v9 > 8 )
        v9 = 8;
      if ( v9 >= (__int16)v32 )
      {
        v10 = v32;
        if ( (__int16)v32 >= -v9 )
        {
          v11 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
          *(_DWORD *)(a1 + 4) = v11;
          v32 = 2 * (v11 % 0x9D / 79i64) - 1 + v10;
        }
        else
        {
          ++v32;
        }
      }
      else
      {
        --v32;
      }
      if ( v9 < (__int16)v31 )
        break;
      v13 = -v9;
      v14 = (__int16)v31;
      if ( (__int16)v31 >= v13 )
      {
        v15 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
        *(_DWORD *)(a1 + 4) = v15;
        v12 = 2 * (v15 % 0x9D / 79i64) - 1 + v14;
        goto LABEL_20;
      }
      ++v31;
LABEL_21:
      word_AE454 += v27;
      word_AE456 += HIWORD(v27);
      word_AE458 += v28;
      v25 = *(_DWORD *)&word_AE454;
      v26 = v32
          * ((int)((__int16)v33
                 - (__CFSHL__((unsigned __int64)(__int16)v33 >> 32, 2)
                  + 4 * ((unsigned __int64)(__int16)v33 >> 32))) >> 2)
          + word_AE458;
      v16 = *(_WORD *)(a1 + 30);
      HIBYTE(v16) = (HIBYTE(v16) + 2) & 7;
      sub_41EC0(
          (uint16*)&v25,
        v16,
        0,
        v32
      * ((int)((__int16)v33
             - (__CFSHL__((unsigned __int64)(__int16)v33 >> 32, 2)
              + 4 * ((unsigned __int64)(__int16)v33 >> 32))) >> 2));
      if ( (--v30 & 0x8000u) != 0 )
        goto LABEL_22;
    }
    v12 = v31 - 1;
LABEL_20:
    v31 = v12;
    goto LABEL_21;
  }
LABEL_22:
  v17 = sub_11980(a1);
  v29 = 164 * *(unsigned __int16 *)(a1 + 146) + dword_AE400 + 29795;
  v18 = sub_373F0((int)&v25, *(char *)(a1 + 68), *(char *)(a1 + 69));
  v19 = (_WORD *)v18;
  v20 = v18;
  if ( v18 )
  {
    sub_526C0(a1, v17, v29);
    v19[12] = *(_WORD *)(a1 + 24);
    v19[15] = *(_WORD *)(a1 + 30);
    v21 = dword_AE400 + 29795;
    v19[16] = *(_WORD *)(a1 + 32);
    v19[73] = (v17 - v21) / 164;
    if ( v17
      && *(char *)(v17 + 17) < 0
      && *(_BYTE *)(v17 + 64) == 3
      && (*(_DWORD *)(a1 + 140) - (__CFSHL__(*(int *)(a1 + 140) >> 31, 2) + 4 * (*(int *)(a1 + 140) >> 31))) >> 2 <= *(_DWORD *)(v17 + 140) )
    {
      v18 = (int)*(unsigned __int16 *)(a1 + 44) >> 2;
      v19[22] = v18;
    }
    else
    {
      LOWORD(v18) = *(_WORD *)(a1 + 44);
      *(_WORD *)(v20 + 44) = v18;
    }
  }
  return v18;
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE456: using guessed type __int16 word_AE456;
// AE458: using guessed type __int16 word_AE458;

//----- (00053980) --------------------------------------------------------
char sub_53980(int a1)
{
  unsigned __int16 v1; // cx
  unsigned int v2; // ebp
  __int16 v3; // ax
  int v4; // ecx
  int v5; // eax
  __int16 v6; // ax
  bool v7; // eax
  __int16 v8; // dx
  int v9; // edx
  int v10; // eax
  char v12; // [esp+0h] [ebp-14h]

  v1 = *(_WORD *)(a1 + 146);
  v12 = 0;
  v2 = dword_AE400 + 29795 + 164 * v1;
  if ( v2 > dword_AE400 + 29795 )
  {
    sub_52610(a1, dword_AE400 + 29795 + 164 * v1);
    v4 = *(__int16 *)(a1 + 128) - *(__int16 *)(a1 + 126);
    if ( v4 )
      v5 = v4 / (int)abs32(v4);
    else
      LOWORD(v5) = 0;
    *(_WORD *)(a1 + 126) += 2 * v5;
    *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
    *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
    v6 = (unsigned __int16)sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 126));
    sub_41C70(v6, a1, (int)&word_AE454);
    v7 = sub_11950(a1, v2);
    if ( v7 )
    {
      LOBYTE(v3) = sub_41C70(v7, a1, v2 + 72);
      v12 = 1;
    }
    else
    {
      v3 = sub_11F50((__int16 *)(a1 + 72));
      v8 = *(_WORD *)(a1 + 76);
      word_AE458 = v3;
      if ( v3 > v8 || (v9 = *(_DWORD *)(a1 + 12) - 1, *(_DWORD *)(a1 + 12) = v9, v9 < 0) )
        v12 = 1;
    }
    if ( v12 )
    {
      if ( *(_BYTE *)(a1 + 68) == 3 && *(_WORD *)(*(_DWORD *)(dword_AE400 + 164 * *(__int16 *)(a1 + 24) + 29955) + 50) )
      {
        LOBYTE(v3) = sub_41E80(a1);
      }
      else
      {
        v10 = sub_373F0(a1 + 72, *(char *)(a1 + 68), *(char *)(a1 + 69));
        if ( v10 )
        {
          *(_WORD *)(v10 + 24) = *(_WORD *)(a1 + 24);
          LOBYTE(v3) = sub_41E80(a1);
        }
        else
        {
          LOBYTE(v3) = sub_46D20(dword_AE400 + 29795 + 164 * *(__int16 *)(a1 + 24), 0);
        }
      }
    }
  }
  else
  {
    LOBYTE(v3) = sub_53B50(a1);
  }
  return v3;
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE458: using guessed type __int16 word_AE458;

//----- (00053B50) --------------------------------------------------------
char sub_53B50(int a1)
{
  char v1; // dh
  int v2; // eax
  __int16 v3; // ax
  __int16 v4; // ax
  int v5; // ecx
  int v6; // eax
  __int16 v7; // ax
  int v8; // esi
  __int16 v9; // ax
  __int16 v10; // di
  int v11; // edx
  unsigned __int16 v12; // ax
  __int16 v13; // ax
  char v15; // [esp+0h] [ebp-14h]
  char v16; // [esp+4h] [ebp-10h]

  v1 = *(_BYTE *)(a1 + 16);
  v15 = 0;
  v16 = 0;
  if ( (v1 & 2) != 0 )
  {
    *(_WORD *)(a1 + 34) = sub_42150((_WORD *)(a1 + 72), (_WORD *)(a1 + 150));
    *(_WORD *)(a1 + 36) = sub_42180((_WORD *)(a1 + 72), (_WORD *)(a1 + 150));
    v3 = *(_WORD *)(a1 + 30)
       + sub_422A0(
           *(_WORD *)(a1 + 30),
           *(_WORD *)(a1 + 34),
           *(unsigned __int16 *)(*(_DWORD *)(a1 + 156) + 4),
           *(_WORD *)(*(_DWORD *)(a1 + 156) + 2));
    HIBYTE(v3) &= 7u;
    *(_WORD *)(a1 + 30) = v3;
    v4 = *(_WORD *)(a1 + 32)
       + sub_422A0(
           *(_WORD *)(a1 + 32),
           *(_WORD *)(a1 + 36),
           *(unsigned __int16 *)(*(_DWORD *)(a1 + 156) + 8),
           *(_WORD *)(*(_DWORD *)(a1 + 156) + 6));
    HIBYTE(v4) &= 7u;
    *(_WORD *)(a1 + 32) = v4;
    v5 = *(__int16 *)(a1 + 128) - *(__int16 *)(a1 + 126);
    if ( v5 )
      v6 = v5 / (int)abs32(v5);
    else
      LOWORD(v6) = 0;
    *(_WORD *)(a1 + 126) += 2 * v6;
    *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
    *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
    v7 = (unsigned __int16)sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 126));
    sub_41C70(v7, a1, (int)&word_AE454);
    v8 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 146);
    if ( sub_11950(a1, v8) )
    {
      v9 = sub_524C0(v8);
      LOBYTE(v2) = sub_41C70(v9, a1, v8 + 72);
      v15 = 1;
    }
    else
    {
      LOWORD(v2) = sub_11F50((__int16 *)(a1 + 72));
      v10 = *(_WORD *)(a1 + 76);
      word_AE458 = v2;
      if ( (__int16)v2 > v10
        || (v11 = *(_DWORD *)(a1 + 12) - 1, *(_DWORD *)(a1 + 12) = v11, v11 < 0)
        || (LOBYTE(v2) = !sub_12F70((_WORD *)(a1 + 72)), (v16 = v2) != 0) )
      {
        v15 = 1;
      }
    }
    if ( v15 )
    {
      if ( v16 )
      {
        *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
        *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
        v12 = *(_WORD *)(a1 + 30);
        HIBYTE(v12) = (HIBYTE(v12) + 4) & 7;
        v13 = (unsigned __int16)sub_41EC0((uint16*)&word_AE454, v12, *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 126));
        sub_41C70(v13, a1, (int)&word_AE454);
      }
      v2 = sub_373F0(a1 + 72, *(char *)(a1 + 68), *(char *)(a1 + 69));
      if ( v2 )
      {
        *(_WORD *)(v2 + 24) = *(_WORD *)(a1 + 24);
        LOBYTE(v2) = sub_41E80(a1);
      }
    }
  }
  else
  {
    *(_BYTE *)(a1 + 16) = v1 | 2;
    LOBYTE(v2) = sub_12F70((_WORD *)(a1 + 72));
    if ( !(_BYTE)v2 )
    {
      sub_46D20(a1, 0);
      LOBYTE(v2) = sub_41E80(a1);
    }
  }
  return v2;
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE458: using guessed type __int16 word_AE458;

//----- (00053DC0) --------------------------------------------------------
char sub_53DC0(int a1)
{
  int v1; // edx
  char v2; // dl
  int v3; // eax
  __int16 v4; // ax
  int v5; // eax
  unsigned int v6; // ebp
  char v7; // cl
  int v8; // edi
  __int16 v9; // ax
  int v10; // esi
  int v11; // eax
  int v12; // edx
  unsigned int v13; // eax
  int v14; // eax
  __int16 v15; // dx
  int v16; // eax
  int v17; // esi
  int v18; // edi
  int v19; // esi
  unsigned int v21; // [esp+0h] [ebp-18h]
  char v22; // [esp+4h] [ebp-14h]

  v22 = 0;
  v1 = 164 * *(unsigned __int16 *)(a1 + 146);
  v21 = dword_AE400 + 29795 + v1;
  if ( dword_AE400 + 29795 >= v21 )
  {
    v2 = *(_BYTE *)(a1 + 16);
    if ( (v2 & 2) == 0 )
    {
      *(_BYTE *)(a1 + 16) = v2 | 2;
      if ( sub_54520(a1) )
      {
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 36);
      }
      else
      {
        *(_WORD *)(a1 + 34) = *(_WORD *)(a1 + 30);
        *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 32);
      }
    }
  }
  else
  {
    sub_52550(a1, dword_AE400 + 29795 + v1);
  }
  v3 = *(__int16 *)(a1 + 128) - *(__int16 *)(a1 + 126);
  if ( v3 )
    v3 /= (int)abs32(v3);
  *(_WORD *)(a1 + 126) += 2 * v3;
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  v4 = (unsigned __int16)sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 126));
  sub_41C70(v4, a1, (int)&word_AE454);
  v5 = sub_11980(a1);
  v6 = v5;
  if ( !v5 )
  {
    LOWORD(v14) = sub_11F50((__int16 *)(a1 + 72));
    v15 = *(_WORD *)(a1 + 76);
    word_AE458 = v14;
    if ( (__int16)v14 <= v15 )
    {
      v17 = *(_DWORD *)(a1 + 12) - 1;
      *(_DWORD *)(a1 + 12) = v17;
      if ( v17 >= 0 )
        goto LABEL_25;
    }
    else if ( *(_BYTE *)(a1 + 65) != 4 )
    {
      v14 = sub_11810((__int16 *)(a1 + 72));
      if ( v14 == 1 )
      {
        v16 = sub_373F0(a1 + 72, 10, 5);
        if ( v16 )
          *(_WORD *)(v16 + 24) = *(_WORD *)(a1 + 24);
        LOBYTE(v14) = sub_41E80(a1);
        goto LABEL_25;
      }
    }
    v22 = 1;
    goto LABEL_25;
  }
  if ( *(char *)(v5 + 17) < 0
    && (*(_DWORD *)(a1 + 140) - (__CFSHL__(*(int *)(a1 + 140) >> 31, 2) + 4 * (*(int *)(a1 + 140) >> 31))) >> 2 <= *(_DWORD *)(v5 + 140)
    && *(_BYTE *)(a1 + 68) == 10 )
  {
    v7 = *(_BYTE *)(a1 + 69);
    if ( v7 == 1 || v7 == 17 )
    {
      sub_55370((v5 - (dword_AE400 + 29795)) / 164, -1, 28);
      v8 = dword_AE400 + 29795 + 164 * *(__int16 *)(a1 + 24);
      *(_DWORD *)(v6 + 140) -= (*(_DWORD *)(a1 + 140)
                              - (__CFSHL__(*(int *)(a1 + 140) >> 31, 2)
                               + 4 * (*(int *)(a1 + 140) >> 31))) >> 2;
      v9 = *(_WORD *)(a1 + 30);
      HIBYTE(v9) = (HIBYTE(v9) + 4) & 7;
      *(_WORD *)(a1 + 34) = v9;
      v10 = sub_42240(0, *(_WORD *)(a1 + 32));
      v11 = -(v10 * sub_42210(0, *(_WORD *)(a1 + 32)));
      BYTE1(v11) &= 7u;
      *(_WORD *)(a1 + 36) = v11;
      v12 = *(_DWORD *)(a1 + 4);
      *(_WORD *)(a1 + 32) = v11;
      v13 = 9377 * v12 + 9439;
      *(_DWORD *)(a1 + 4) = v13;
      *(_WORD *)(a1 + 30) = v13 % 0x2D + *(_WORD *)(a1 + 34) - 22;
      *(_WORD *)(a1 + 146) = (v8 - (dword_AE400 + 29795)) / 164;
      *(_WORD *)(a1 + 24) = *(_WORD *)(v6 + 24);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)&word_AE454 = *(_DWORD *)(v6 + 72);
      *(&word_AE454 + 2) = *(_WORD *)(v6 + 76);
      LOWORD(v13) = *(_WORD *)(v6 + 84);
      word_AE458 += v13;
      LOBYTE(v14) = sub_41C70(v13, a1, (int)&word_AE454);
      return v14;
    }
  }
  sub_524C0(v5);
  sub_41C70(v6 + 72, a1, v6 + 72);
  sub_524E0(v6);
  LOBYTE(v14) = 1;
  v22 = 1;
LABEL_25:
  if ( v22 )
  {
    v14 = sub_373F0(a1 + 72, 10, 38);
    v18 = v14;
    v19 = v14;
    if ( v14 )
    {
      sub_526C0(a1, v6, v21);
      if ( *(_BYTE *)(a1 + 69) == 34 )
        *(_DWORD *)(v18 + 12) = *(unsigned __int16 *)(a1 + 44);
      *(_WORD *)(v19 + 24) = *(_WORD *)(a1 + 24);
      *(_WORD *)(v19 + 30) = *(_WORD *)(a1 + 30);
      *(_WORD *)(v19 + 32) = *(_WORD *)(a1 + 32);
      *(_WORD *)(v19 + 146) = (int)(v6 - (dword_AE400 + 29795)) / 164;
      *(_WORD *)(v19 + 44) = *(_WORD *)(a1 + 44);
      *(_BYTE *)(v19 + 68) = *(_BYTE *)(a1 + 68);
      *(_BYTE *)(v19 + 69) = *(_BYTE *)(a1 + 69);
      LOBYTE(v14) = sub_41E80(a1);
    }
  }
  return v14;
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE458: using guessed type __int16 word_AE458;

//----- (00054180) --------------------------------------------------------
int sub_54180(int a1)
{
  int v1; // eax
  int v2; // edi
  int v3; // eax

  if ( (*(_BYTE *)(a1 + 16) & 2) == 0 )
  {
    v1 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
    *(_DWORD *)(a1 + 4) = v1;
    sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, (v1 & 3) + 33);
    *(_BYTE *)(a1 + 16) |= 2u;
  }
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 126));
  v2 = sub_11980(a1);
  if ( (__int16)sub_11F50(&word_AE454) <= word_AE458 )
  {
    v3 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 12) = v3 - 1;
    if ( v3 )
    {
      if ( !v2 )
        return sub_41C70(v3, a1, (int)&word_AE454);
    }
  }
  if ( v2 )
  {
    sub_524C0(v2);
    sub_41C70(v2 + 72, a1, v2 + 72);
    sub_524E0(v2);
  }
  sub_120B0(a1, 0, *(_WORD *)(a1 + 44));
  return sub_41E80(a1);
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE458: using guessed type __int16 word_AE458;

//----- (00054290) --------------------------------------------------------
int sub_54290(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = result - 1;
  if ( result < 0 )
    return sub_41E80(a1);
  return result;
}

//----- (000542B0) --------------------------------------------------------
char sub_542B0(int a1)
{
  unsigned __int16 v1; // si
  unsigned int v2; // ebp
  char v3; // dl
  __int16 v4; // ax
  int v5; // eax
  int v6; // esi
  unsigned int v7; // edi
  int v8; // eax
  __int16 v9; // cx
  int v10; // edx
  _WORD *v11; // esi
  _WORD *v12; // esi
  char v14; // [esp+0h] [ebp-14h]

  v1 = *(_WORD *)(a1 + 146);
  v14 = 0;
  v2 = dword_AE400 + 29795 + 164 * v1;
  if ( v2 <= dword_AE400 + 29795 )
  {
    v3 = *(_BYTE *)(a1 + 16);
    if ( (v3 & 2) == 0 )
    {
      *(_BYTE *)(a1 + 16) = v3 | 2;
      if ( sub_54520(a1) )
      {
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 36);
      }
    }
  }
  else
  {
    sub_52550(a1, dword_AE400 + 29795 + 164 * v1);
  }
  *(_DWORD *)&word_AE454 = *(_DWORD *)(a1 + 72);
  *(&word_AE454 + 2) = *(_WORD *)(a1 + 76);
  sub_41EC0((uint16*)&word_AE454, *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 126));
  v4 = sub_11F50(&word_AE454);
  if ( v4 > word_AE458 )
    word_AE458 = v4;
  sub_41C70(v4, a1, (int)&word_AE454);
  v5 = sub_11C00((__int16 *)a1);
  v6 = v5;
  v7 = v5;
  if ( v5 )
  {
    sub_524C0(v5);
    sub_41C70(v6 + 72, a1, v6 + 72);
    sub_524E0(v6);
    LOBYTE(v8) = 1;
    v14 = 1;
  }
  else
  {
    LOWORD(v8) = sub_11F50((__int16 *)(a1 + 72));
    v9 = *(_WORD *)(a1 + 76);
    word_AE458 = v8;
    if ( (__int16)v8 > v9 || (v10 = *(_DWORD *)(a1 + 12) - 1, *(_DWORD *)(a1 + 12) = v10, v10 < 0) )
      v14 = 1;
  }
  if ( v14 )
  {
    v11 = (_WORD *)sub_373F0(a1 + 72, 10, 12);
    if ( v11 )
    {
      sub_526C0(a1, v7, v2);
      v11[12] = *(_WORD *)(a1 + 24);
      v11[15] = *(_WORD *)(a1 + 30);
      v11[16] = *(_WORD *)(a1 + 32);
    }
    v8 = sub_373F0(a1 + 72, *(char *)(a1 + 68), *(char *)(a1 + 69));
    v12 = (_WORD *)v8;
    if ( v8 )
    {
      sub_526C0(a1, v7, v2);
      v12[12] = *(_WORD *)(a1 + 24);
      v12[15] = *(_WORD *)(a1 + 30);
      v12[16] = *(_WORD *)(a1 + 32);
      LOBYTE(v8) = sub_41E80(a1);
    }
  }
  return v8;
}
// AE400: using guessed type int dword_AE400;
// AE454: using guessed type __int16 word_AE454;
// AE458: using guessed type __int16 word_AE458;

//----- (00054480) --------------------------------------------------------
_WORD *sub_54480(int a1)
{
  _WORD *result; // eax

  result = (_WORD *)sub_373F0(a1 + 72, *(char *)(a1 + 68), *(char *)(a1 + 69));
  if ( result )
  {
    result[12] = *(_WORD *)(a1 + 24);
    result[15] = *(_WORD *)(a1 + 30);
    result[16] = *(_WORD *)(a1 + 32);
    result[22] = *(_WORD *)(a1 + 44);
    return (_WORD *)sub_41E80(a1);
  }
  return result;
}

//----- (00054520) --------------------------------------------------------
int sub_54520(int a1)
{
  unsigned int v1; // edi
  int v2; // ebp
  unsigned int v3; // ebx
  unsigned int v4; // eax
  unsigned int ii; // ebx
  unsigned int v6; // eax
  unsigned int v8; // edi
  int v9; // ebp
  unsigned int v10; // ebx
  unsigned int v11; // eax
  unsigned int j; // ebx
  unsigned int v13; // eax
  unsigned int v14; // ebp
  unsigned int k; // edi
  unsigned int v16; // eax
  unsigned int m; // ebx
  unsigned int v18; // eax
  unsigned int v19; // ebx
  int v20; // ebp
  unsigned int v21; // edi
  unsigned int v22; // eax
  unsigned int v23; // [esp+4h] [ebp-34h]
  unsigned int v24; // [esp+4h] [ebp-34h]
  unsigned int v25; // [esp+4h] [ebp-34h]
  int i; // [esp+Ch] [ebp-2Ch]
  int v27; // [esp+14h] [ebp-24h]
  int v28; // [esp+18h] [ebp-20h]
  int v29; // [esp+1Ch] [ebp-1Ch]
  int n; // [esp+20h] [ebp-18h]

  if ( *(__int16 *)(a1 + 26) > 16 )
    *(_WORD *)(a1 + 26) = 16;
  switch ( *(_BYTE *)(a1 + 65) )
  {
    case 0:
    case 3:
    case 4:
      v8 = -1;
      v9 = 0;
      v10 = *(_DWORD *)(dword_AE408 + 36462);
      v28 = 164 * *(__int16 *)(a1 + 24) + dword_AE400 + 29795;
      while ( 1 )
      {
        if ( v10 <= dword_AE400 + 29795 )
        {
          for ( i = 0; i != 80; i += 4 )
          {
            for ( j = *(_DWORD *)(i + dword_AE408 + 36382); j > dword_AE400 + 29795; j = *(_DWORD *)j )
            {
              if ( *(_WORD *)(j + 24) != *(_WORD *)(a1 + 24) )
              {
                if ( *(_BYTE *)(j + 58) )
                {
                  v13 = sub_54A90((__int16 *)a1, j, 0x71u, 0x71u);
                  if ( v13 < v8 )
                  {
                    v9 = j;
                    v8 = v13;
                  }
                }
              }
            }
          }
          if ( !v9 )
            return 0;
          *(_WORD *)(a1 + 146) = (v9 - (dword_AE400 + 29795)) / 164;
          sub_52500((_WORD *)a1, v9);
          if ( *(_BYTE *)(v9 + 64) == 3 && !*(_BYTE *)(v9 + 65) )
            sub_46520(v9);
          return 1;
        }
        if ( *(_WORD *)(v10 + 24) != *(_WORD *)(a1 + 24) && (*(_BYTE *)(v10 + 16) & 0x20) == 0 )
        {
          v24 = *(__int16 *)(*(_DWORD *)(v28 + 156) + 28);
          if ( sub_42340((_WORD *)(v10 + 72), (_WORD *)(a1 + 72)) <= v24 )
          {
            if ( *(_BYTE *)(v10 + 65) == 2 )
            {
              v11 = sub_54BD0((__int16 *)a1, v10, 0x71u, 0x71u);
              if ( v11 >= v8 )
                goto LABEL_35;
            }
            else
            {
              v11 = sub_54A90((__int16 *)a1, v10, 0x71u, 0x71u);
              if ( v11 >= v8 )
                goto LABEL_35;
            }
            v9 = v10;
            v8 = v11;
          }
        }
LABEL_35:
        v10 = *(_DWORD *)v10;
      }
    case 1:
      v14 = -1;
      v29 = 0;
      for ( k = *(_DWORD *)(dword_AE408 + 36466); k > dword_AE400 + 29795; k = *(_DWORD *)k )
      {
        if ( *(unsigned __int16 *)(k + 144) != *(__int16 *)(a1 + 24) )
        {
          if ( *(_BYTE *)(k + 58) )
          {
            v16 = sub_54A90((__int16 *)a1, k, 0x71u, 0x71u);
            if ( v16 < v14 )
            {
              v29 = k;
              v14 = v16;
            }
          }
        }
      }
      for ( m = *(_DWORD *)(dword_AE408 + 36470); m > dword_AE400 + 29795; m = *(_DWORD *)m )
      {
        if ( *(unsigned __int16 *)(m + 144) != *(__int16 *)(a1 + 24) )
        {
          if ( *(_BYTE *)(m + 58) )
          {
            v18 = sub_54A90((__int16 *)a1, m, 0x71u, 0x71u);
            if ( v18 < v14 )
            {
              v29 = m;
              v14 = v18;
            }
          }
        }
      }
      if ( !v29 )
        return 0;
      *(_WORD *)(a1 + 146) = (v29 - (dword_AE400 + 29795)) / 164;
      sub_52500((_WORD *)a1, v29);
      return 1;
    case 7:
    case 8:
    case 0xB:
    case 0xC:
      v19 = -1;
      v20 = 0;
      v27 = 164 * *(__int16 *)(a1 + 24) + dword_AE400 + 29795;
      v21 = *(_DWORD *)(dword_AE408 + 36462);
      while ( 2 )
      {
        if ( v21 <= dword_AE400 + 29795 )
        {
          if ( !v20 )
            return 0;
          *(_WORD *)(a1 + 146) = (v20 - (dword_AE400 + 29795)) / 164;
          sub_52500((_WORD *)a1, v20);
          if ( *(_BYTE *)(v20 + 64) == 3 && !*(_BYTE *)(v20 + 65) )
            sub_46520(v20);
          return 1;
        }
        if ( *(_WORD *)(v21 + 24) == *(_WORD *)(a1 + 24) )
          goto LABEL_76;
        if ( (*(_BYTE *)(v21 + 16) & 0x20) != 0 )
          goto LABEL_76;
        v25 = *(__int16 *)(*(_DWORD *)(v27 + 156) + 28);
        if ( sub_42340((_WORD *)(v21 + 72), (_WORD *)(a1 + 72)) > v25 )
          goto LABEL_76;
        if ( *(_BYTE *)(v21 + 65) == 2 )
        {
          v22 = sub_54A90((__int16 *)a1, v21, 0x71u, 0x71u);
          if ( v22 < v19 )
            goto LABEL_75;
        }
        else
        {
          v22 = sub_54A90((__int16 *)a1, v21, 0x71u, 0x71u);
          if ( v22 < v19 )
          {
LABEL_75:
            v20 = v21;
            v19 = v22;
          }
        }
LABEL_76:
        v21 = *(_DWORD *)v21;
        continue;
      }
    case 9:
      v1 = -1;
      v2 = 0;
      v3 = *(_DWORD *)(dword_AE408 + 36462);
      while ( 2 )
      {
        if ( v3 > dword_AE400 + 29795 )
        {
          if ( *(_WORD *)(v3 + 24) == *(_WORD *)(a1 + 24) )
            goto LABEL_13;
          if ( (*(_BYTE *)(v3 + 16) & 0x20) != 0 )
            goto LABEL_13;
          v23 = *(__int16 *)(a1 + 128) * *(_DWORD *)(a1 + 8);
          if ( sub_42340((_WORD *)(v3 + 72), (_WORD *)(a1 + 72)) > v23 )
            goto LABEL_13;
          if ( *(_BYTE *)(v3 + 65) == 2 )
          {
            v4 = sub_54BD0((__int16 *)a1, v3, 0x71u, 0x71u);
            if ( v4 < v1 )
              goto LABEL_12;
          }
          else
          {
            v4 = sub_54A90((__int16 *)a1, v3, 0x71u, 0x71u);
            if ( v4 < v1 )
            {
LABEL_12:
              v2 = v3;
              v1 = v4;
            }
          }
LABEL_13:
          v3 = *(_DWORD *)v3;
          continue;
        }
        break;
      }
      for ( n = 0; n != 80; n += 4 )
      {
        for ( ii = *(_DWORD *)(n + dword_AE408 + 36382); ii > dword_AE400 + 29795; ii = *(_DWORD *)ii )
        {
          if ( *(_WORD *)(ii + 24) != *(_WORD *)(a1 + 24) )
          {
            if ( *(_BYTE *)(ii + 58) )
            {
              v6 = sub_54A90((__int16 *)a1, ii, 0x71u, 0x200u);
              if ( v6 < v1 )
              {
                v2 = ii;
                v1 = v6;
              }
            }
          }
        }
      }
      if ( !v2 )
        return 0;
      *(_WORD *)(a1 + 146) = (v2 - (dword_AE400 + 29795)) / 164;
      sub_52500((_WORD *)a1, v2);
      return 1;
    default:
      return 0;
  }
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00054A90) --------------------------------------------------------
int sub_54A90(__int16 *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  __int16 v4; // ax
  __int16 v5; // ax
  signed int v7; // ebx
  int v8; // esi
  int v9; // edi
  int v10; // eax
  int v11; // edx
  unsigned __int16 v12; // [esp+0h] [ebp-18h]
  unsigned __int16 v13; // [esp+4h] [ebp-14h]

  sub_524C0(a2);
  v4 = sub_42150((uint16*)(a1 + 36), (_WORD *)(a2 + 72));
  v12 = sub_42210(a1[15], v4);
  if ( v12 <= a3 && (v5 = sub_42180((uint16*)(a1 + 36), (_WORD *)(a2 + 72)), v13 = sub_42210(a1[16], v5), v13 <= a4) )
  {
    v7 = sub_423D0((uint16*)(a1 + 36), (_WORD *)(a2 + 72));
    sub_524E0(a2);
    if ( v7 <= 5120 )
    {
      v8 = v7 * (_DWORD)off_9134C[v12];
      v9 = v7 * dword_90B4C[v12];
      v10 = v7 * (_DWORD)off_9134C[v13];
      v11 = (__int16)((dword_90B4C[v13] * v7) >> 14);
      return (v10 >> 16) * (v10 >> 16) + (v8 >> 16) * (v8 >> 16) + (__int16)(v9 >> 14) * (__int16)(v9 >> 14) + v11 * v11;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    sub_524E0(a2);
    return -1;
  }
}
// 90B4C: using guessed type int dword_90B4C[256];
// 9134C: using guessed type void (*off_9134C[2])();

//----- (00054BD0) --------------------------------------------------------
int sub_54BD0(__int16 *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  _WORD *v4; // ebx
  _WORD *v5; // esi
  __int16 v6; // ax
  __int16 v8; // ax
  unsigned __int16 v9; // di
  signed int v10; // eax
  int v11; // ebx
  int v12; // ecx
  int v13; // esi
  int v14; // eax
  unsigned __int16 v15; // [esp+0h] [ebp-10h]

  v4 = (_WORD *)(a2 + 72);
  v5 = (uint16*)(a1 + 36);
  v6 = sub_42150((uint16*)(a1 + 36), (_WORD *)(a2 + 72));
  v15 = sub_42210(a1[15], v6);
  if ( v15 > a3 )
    return -1;
  v8 = sub_42180(v5, v4);
  v9 = sub_42210(a1[16], v8);
  if ( v9 > a4 )
    return -1;
  v10 = sub_423D0(v5, v4);
  if ( v10 > 5120 )
    return -1;
  v11 = v10 * (_DWORD)off_9134C[v15];
  v12 = v10 * dword_90B4C[v15];
  v13 = v10 * (_DWORD)off_9134C[v9];
  v14 = (__int16)((dword_90B4C[v9] * v10) >> 14);
  return (__int16)(v12 >> 14) * (__int16)(v12 >> 14) + (v11 >> 16) * (v11 >> 16) + (v13 >> 16) * (v13 >> 16) + v14 * v14;
}
// 90B4C: using guessed type int dword_90B4C[256];
// 9134C: using guessed type void (*off_9134C[2])();

//----- (00054F00) --------------------------------------------------------
int sub_54F00()
{
  __int16 i; // si
  unsigned int j; // ebx
  _DWORD *k; // ebx
  int result; // eax

  for ( i = 0; i < 20; ++i )
  {
    for ( j = *(_DWORD *)(dword_AE408 + 4 * i + 36382); j > dword_AE400 + 29795; j = *(_DWORD *)j )
    {
      if ( *(int *)(j + 12) >= 0 )
      {
        sub_54F80(j);
      }
      else
      {
        *(_BYTE *)(j + 58) = -6;
        *(_BYTE *)(j + 59) = 0;
      }
    }
  }
  for ( k = *(_DWORD **)(dword_AE408 + 36466); ; k = (_DWORD *)*k )
  {
    result = dword_AE400 + 29795;
    if ( (unsigned int)k <= dword_AE400 + 29795 )
      break;
    sub_54F80((int)k);
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00054F80) --------------------------------------------------------
int sub_54F80(int a1)
{
  int v1; // edi
  char v2; // ah
  char v3; // dh
  unsigned int v4; // edx
  int v5; // eax
  int v6; // edi
  __int16 v7; // ax
  unsigned __int16 v8; // dx
  unsigned int v9; // ebx
  unsigned int i; // eax
  int result; // eax
  unsigned int v12; // eax
  unsigned int v13; // edx

  v1 = dword_AE400;
  v2 = *(_BYTE *)(a1 + 58);
  if ( v2 )
  {
    *(_BYTE *)(a1 + 58) = v2 - 1;
    v12 = 164 * *(unsigned __int16 *)(a1 + 54) + v1 + 29795;
    v13 = v1 + 29795;
    if ( v12 > v1 + 29795 )
    {
      do
      {
        *(_BYTE *)(v12 + 58) = *(_BYTE *)(a1 + 58);
        v12 = v13 + 164 * *(unsigned __int16 *)(v12 + 54);
      }
      while ( v12 > v13 );
      result = 0;
      dword_AE400 = v1;
    }
    else
    {
      result = 0;
      dword_AE400 = v1;
    }
  }
  else
  {
    v3 = *(_BYTE *)(a1 + 59);
    if ( v3 )
    {
      *(_BYTE *)(a1 + 59) = v3 - 1;
      result = 0;
      dword_AE400 = v1;
    }
    else
    {
      v4 = *(unsigned __int16 *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13333);
      v5 = sub_42410((_WORD *)(a1 + 72), (_WORD *)(164 * (unsigned __int16)v4 + dword_AE400 + 29795 + 72));
      v6 = dword_AE400;
      if ( v5 < 37748736 )
      {
        v7 = sub_410CE(v4);
        v8 = *(_WORD *)(a1 + 54);
        *(_WORD *)(a1 + 48) = v7;
        v6 = dword_AE400;
        *(_BYTE *)(a1 + 58) = 16;
        v9 = v6 + 29795;
        for ( i = 164 * v8 + v6 + 29795; i > v9; i = v9 + 164 * *(unsigned __int16 *)(i + 54) )
          *(_BYTE *)(i + 58) = *(_BYTE *)(a1 + 58) + 2;
      }
      *(_BYTE *)(a1 + 59) = 0;
      result = 0;
      dword_AE400 = v6;
    }
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00055100) --------------------------------------------------------
int sub_55100()
{
  int result; // eax
  __int16 i; // di
  int v2; // ebx

  if ( byte_939E5 )
  {
    if ( byte_939E4 )
    {
      result = dword_AE408;
      if ( (*(_BYTE *)(dword_AE408 + 2) & 1) == 0 )
      {
        sub_522E0();
        sub_51FC0();
        for ( i = 0; i < 47; ++i )
        {
          v2 = 5 * i;
          switch ( word_12CD20[v2] )
          {
            case 1:
              sub_483C0(word_12CD26[5 * i], i, word_12CD24[5 * i], word_12CD22[5 * i]);
              word_12CD20[5 * i] = 0;
              word_12CD28[5 * i] = 2;
              break;
            case 2:
              sub_48520(word_12CD26[5 * i], i, word_12CD24[5 * i], word_12CD22[5 * i]);
              word_12CD20[5 * i] = 0;
              goto LABEL_13;
            case 3:
              sub_48470(word_12CD26[5 * i], i, word_12CD24[5 * i], word_12CD22[5 * i]);
              word_12CD20[5 * i] = 0;
              word_12CD28[5 * i] = 2;
              break;
            case 4:
              if ( word_12CD24[5 * i] == 512 )
              {
                sub_5D750(0, i);
              }
              else
              {
                sub_5D460(0, i, -1);
                sub_66250(0, i, (int)(unsigned __int16)word_12CD24[5 * i] >> 8);
              }
              v2 = 5 * i;
              word_12CD20[v2] = 0;
LABEL_13:
              word_12CD28[v2] = 2;
              break;
            default:
              break;
          }
          result = 10 * i;
          *(__int16 *)((char *)word_12CD24 + result) = 0;
        }
      }
    }
  }
  return result;
}
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// AE408: using guessed type int dword_AE408;
// 12CD20: using guessed type __int16 word_12CD20[];
// 12CD22: using guessed type __int16 word_12CD22[];
// 12CD24: using guessed type __int16 word_12CD24[];
// 12CD26: using guessed type __int16 word_12CD26[];
// 12CD28: using guessed type __int16 word_12CD28[236];

//----- (00055370) --------------------------------------------------------
void sub_55370(__int16 a1, __int16 a2, __int16 a3)
{
  unsigned int v3; // esi
  unsigned __int16 v4; // si
  int v5; // ebp
  int v6; // ebx
  __int16 v7; // ax
  int v8; // esi
  int v9; // edi
  __int16 v10; // ax
  __int16 v11; // si
  int v12; // [esp+0h] [ebp-24h]
  __int16 v13; // [esp+8h] [ebp-1Ch]
  signed int v14; // [esp+Ch] [ebp-18h]
  __int16 v15; // [esp+10h] [ebp-14h]

  v15 = 0;
  if ( byte_939E5 && byte_939E4 )
  {
    v3 = dword_AE400 + 29795 + 164 * a1;
    if ( v3 <= dword_AE400 + 29795 )
    {
      v6 = 0x7FFF;
      LOWORD(v8) = 0x7FFF;
    }
    else
    {
      if ( *(char *)(v3 + 16) < 0 )
        return;
      if ( sub_42410(
             (_WORD *)(164 * *(unsigned __int16 *)(2049 * *(__int16 *)(dword_AE400 + 8) + dword_AE400 + 13333)
                     + dword_AE400
                     + 29795
                     + 72),
             (_WORD *)(v3 + 72)) > 150994944 )
        return;
      v12 = 164 * *(unsigned __int16 *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13333)
          + dword_AE400
          + 29795;
      v15 = *(_WORD *)(v3 + 24);
      v14 = sub_423D0((_WORD *)(v12 + 72), (_WORD *)(v3 + 72));
      v13 = sub_42150((_WORD *)(v12 + 72), (_WORD *)(v3 + 72));
      v4 = sub_42210(*(_WORD *)(v12 + 30), v13);
      v5 = (12288 * (512 - v4 / 2 + 512)
          - (__CFSHL__((12288 * (512 - v4 / 2 + 512)) >> 31, 10)
           + ((12288 * (512 - v4 / 2 + 512)) >> 31 << 10))) >> 10;
      v6 = 0x7FFF * (v5 - v14) / v5;
      v7 = sub_42240(*(unsigned __int16 *)(v12 + 30), v13);
      if ( v6 < 512 )
        return;
      if ( v6 > 0x7FFF )
        v6 = 0x7FFF;
      if ( v14 > 320 )
      {
        if ( v4 > 0x200u )
          v4 = 1024 - v4;
        v8 = ((v7 * (v4 << 15) - (__CFSHL__((v7 * (v4 << 15)) >> 31, 9) + ((v7 * (v4 << 15)) >> 31 << 9))) >> 9)
           + 0x7FFF;
        if ( v8 < 0 )
          v8 = 0;
        if ( v8 > 0xFFFF )
          LOWORD(v8) = -1;
      }
      else
      {
        LOWORD(v8) = 0x7FFF;
      }
    }
    switch ( a3 )
    {
      case 1:
      case 2:
        if ( a2 == *(_WORD *)(dword_AE400 + 8) && byte_939EC != 3 )
          sub_520F0(0, a3, 3, 70);
        break;
      case 3:
      case 9:
      case 15:
      case 16:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 30:
      case 40:
      case 43:
      case 44:
      case 45:
        if ( sub_55870(v6, (unsigned __int16)word_12CD24[5 * a3]) )
        {
          word_12CD24[5 * a3] = v6;
          word_12CD22[5 * a3] = v8;
          word_12CD26[5 * a3] = v15;
          word_12CD20[5 * a3] = 1;
        }
        break;
      case 4:
      case 14:
      case 29:
        v9 = 5 * a3;
        if ( sub_55870(v6, (unsigned __int16)word_12CD24[v9]) )
        {
          if ( a2 == *(_WORD *)(dword_AE400 + 8) )
          {
            word_12CD24[5 * a3] = v6;
            word_12CD22[5 * a3] = v8;
            word_12CD26[5 * a3] = 0;
            word_12CD20[5 * a3] = 1;
          }
          else if ( a2 == -1 )
          {
            word_12CD24[5 * a3] = v6;
            v10 = v15;
            word_12CD22[5 * a3] = v8;
            v11 = 1;
            goto LABEL_43;
          }
        }
        break;
      case 5:
        if ( a2 == *(_WORD *)(dword_AE400 + 8) )
          sub_520F0(0, a3, 3, 120);
        break;
      case 7:
      case 8:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 41:
        if ( sub_55870(v6, (unsigned __int16)word_12CD24[5 * a3]) )
        {
          word_12CD24[5 * a3] = v6;
          word_12CD22[5 * a3] = v8;
          word_12CD26[5 * a3] = v15;
          word_12CD20[5 * a3] = 3;
        }
        break;
      case 17:
        v9 = 5 * a3;
        if ( sub_55870(v6, (unsigned __int16)word_12CD24[v9]) )
        {
          if ( a2 == *(_WORD *)(dword_AE400 + 8) )
          {
            word_12CD24[5 * a3] = v6;
            word_12CD22[5 * a3] = v8;
            word_12CD26[5 * a3] = 0;
            word_12CD20[5 * a3] = 3;
          }
          else if ( a2 == -1 )
          {
            word_12CD24[5 * a3] = v6;
            v10 = v15;
            word_12CD22[5 * a3] = v8;
            v11 = 3;
LABEL_43:
            word_12CD26[v9] = v10;
            word_12CD20[v9] = v11;
          }
        }
        break;
      case 31:
        if ( a2 == *(_WORD *)(dword_AE400 + 8) && byte_939EC != 3 )
          sub_520F0(0, a3, 3, 85);
        break;
      case 42:
        if ( sub_55870(v6, (unsigned __int16)word_12CD24[5 * a3]) )
        {
          word_12CD24[5 * a3] = v6;
          word_12CD22[5 * a3] = v8;
          word_12CD26[5 * a3] = v15;
          word_12CD20[5 * a3] = 1;
        }
        break;
      default:
        return;
    }
  }
}
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// 939EC: using guessed type char byte_939EC;
// AE400: using guessed type int dword_AE400;
// 12CD20: using guessed type __int16 word_12CD20[];
// 12CD22: using guessed type __int16 word_12CD22[];
// 12CD24: using guessed type __int16 word_12CD24[];
// 12CD26: using guessed type __int16 word_12CD26[];

//----- (00055870) --------------------------------------------------------
bool sub_55870(int a1, int a2)
{
  return a1 - a2 >= -8;
}

//----- (00055890) --------------------------------------------------------
void sub_55890(int a1, __int16 a2, __int16 a3)
{
  if ( byte_939E5 && byte_939E4 )
  {
    if ( (unsigned __int16)a3 >= 5u )
    {
      if ( (unsigned __int16)a3 <= 5u )
      {
LABEL_10:
        if ( a2 == *(_WORD *)(dword_AE400 + 8) )
          sub_52400(0, a3, 0);
        return;
      }
      if ( a3 != 31 )
        return;
LABEL_9:
      if ( byte_939EC == 3 )
        return;
      goto LABEL_10;
    }
    if ( a3 && (unsigned __int16)a3 <= 2u )
      goto LABEL_9;
  }
}
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// 939EC: using guessed type char byte_939EC;
// AE400: using guessed type int dword_AE400;

//----- (000558F0) --------------------------------------------------------
int sub_558F0()
{
  int v0; // eax
  void *retaddr[2]; // [esp+0h] [ebp+0h]

  v0 = sub_5F83E(--byte_968E0);
  if ( !byte_968E0 )
    v0 = sub_55960();
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(v0);
}
// 968E0: using guessed type char byte_968E0;

//----- (00055960) --------------------------------------------------------
int sub_55960()
{
  int result; // eax

  if ( byte_968E1 )
  {
    sub_5DC91(dword_80120);
    sub_20E60();
    result = sub_5F83E(127);
    byte_968E0 = 127;
    byte_968E1 = 0;
  }
  return result;
}
// 80120: using guessed type int dword_80120;
// 968E0: using guessed type char byte_968E0;
// 968E1: using guessed type char byte_968E1;

//----- (000559A0) --------------------------------------------------------
int sub_559A0()
{
  if ( byte_939E4 && byte_939E5 )
    return sub_66324(dword_CC140);
  else
    return 0;
}
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// CC140: using guessed type int dword_CC140;

//----- (00055A40) --------------------------------------------------------
int sub_55A40(int a1, char a2, char a3)
{
  int v3; // edx
  __int16 v4; // ax
  int result; // eax
  int v6; // esi
  unsigned int v7; // eax
  char v8; // bl
  int v9; // edx
  char v10; // bh
  int v11; // esi
  unsigned int i; // eax
  int v13; // ecx
  int v14; // edx
  int v15; // ebx
  int v16; // ebx
  unsigned int v17; // edx
  unsigned int v18; // eax
  int v19; // esi
  int v20; // ebx
  int v21; // ebx
  unsigned int v22; // eax
  unsigned int *v23; // [esp+0h] [ebp-1Ch]
  char v24; // [esp+4h] [ebp-18h]
  char v25; // [esp+8h] [ebp-14h]

  v3 = *(_DWORD *)(a1 + 12);
  if ( v3 )
  {
    *(_DWORD *)(a1 + 12) = v3 - 1;
    if ( v3 == 1 )
    {
      sub_41E80(a1);
      return 0;
    }
  }
  v4 = sub_11F50((__int16 *)(a1 + 72));
  if ( sub_42090(a1 + 72, v4, 0, 0, -128) == -1 )
  {
    sub_41E80(a1);
    return 0;
  }
  v6 = dword_AE400;
  if ( (*(_BYTE *)(a1 + 63) & 3) != 0 )
  {
LABEL_42:
    dword_AE400 = v6;
    return 0;
  }
  v7 = *(_DWORD *)(dword_AE408 + 36462);
  while ( 1 )
  {
    v23 = (unsigned int *)v7;
    if ( v6 + 29795 >= v7 )
      goto LABEL_42;
    v8 = *(_BYTE *)(v7 + 65);
    dword_AE400 = v6;
    if ( !v8 && *(int *)(v7 + 12) >= 0 )
    {
      v9 = *(_DWORD *)(v7 + 160);
      if ( *(_WORD *)(v6 + 8) == *(_WORD *)(v9 + 48) )
      {
        v10 = *(_BYTE *)(a1 + 16);
        if ( (v10 & 1) == 0 )
        {
          if ( *(_WORD *)(v9 + 2 * *(char *)(a1 + 65) + 676) )
            *(_BYTE *)(a1 + 16) = v10 | 1;
        }
      }
      if ( sub_11950(v7, a1) )
        break;
    }
LABEL_40:
    v7 = *v23;
    v6 = dword_AE400;
  }
  v11 = dword_AE400;
  for ( i = *(_DWORD *)(dword_AE408 + 36462); i > v11 + 29795; i = *(_DWORD *)i )
  {
    if ( *(_BYTE *)(i + 65) == 1 )
    {
      v13 = *(char *)(a1 + 65);
      v14 = *(_DWORD *)(i + 160);
      v15 = v14 + 2 * v13;
      if ( !*(_WORD *)(v15 + 676) && !*(_WORD *)(v15 + 628) && *(_BYTE *)(v13 + v14 + 796) == 1 )
        *(_WORD *)(v15 + 628) = 200;
    }
  }
  v16 = 0;
  v24 = -1;
  v25 = 0;
  v17 = v23[40];
  while ( 1 )
  {
    v18 = v11 + 29795 + 164 * *(_DWORD *)(v17 + 532);
    if ( v18 <= v11 + 29795 )
    {
      if ( v24 == -1 )
        v24 = v16;
      goto LABEL_30;
    }
    if ( *(_BYTE *)(v18 + 64) == 12 && a2 == *(_BYTE *)(v18 + 65) )
      break;
LABEL_30:
    ++v16;
    v17 += 4;
    if ( v16 >= 24 )
      goto LABEL_31;
  }
  v25 = 1;
LABEL_31:
  dword_AE400 = v11;
  if ( v25 || v24 == -1 )
    goto LABEL_40;
  if ( (*(_BYTE *)(a1 + 18) & 4) != 0 )
    *(_DWORD *)(a1 + 132) = 0;
  dword_AE400 = v11;
  sub_55370(((int)v23 - v11 - 29795) / 164, -1, 18);
  v19 = dword_AE400;
  v20 = dword_AE400 + 29795;
  *(_BYTE *)(a1 + 16) |= 1u;
  *(_WORD *)(a1 + 42) = ((int)v23 - v20) / 164;
  *(_BYTE *)(a1 + 70) = a3;
  *(_DWORD *)(v23[40] + 4 * v24 + 532) = (a1 - v20) / 164;
  *(_WORD *)(v23[40] + 940) = v24;
  v21 = 0;
  v22 = v23[40];
  while ( *(char *)(v22 + 772) != -1 )
  {
    ++v21;
    ++v22;
    if ( v21 >= 10 )
      goto LABEL_39;
  }
  *(_BYTE *)(v22 + 772) = v24;
LABEL_39:
  result = 1;
  dword_AE400 = v19;
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00055D30) --------------------------------------------------------
int sub_55D30(int a1)
{
  int result; // eax
  int v2; // ebx

  byte_968E4 = 0;
  result = sub_55A40(a1, *(_BYTE *)(a1 + 65), *(_BYTE *)(a1 + 70) - 2);
  if ( result )
  {
    result = (*(int (**)(int))((char *)&off_987DE + 14 * *(char *)(a1 + 65)))(a1 + 72);
    if ( result )
    {
      *(_BYTE *)(result + 70) += 2;
      if ( byte_968E4 )
      {
        v2 = *(_DWORD *)(a1 + 16) & 0x40000;
        LOBYTE(v2) = 1;
        *(_DWORD *)(result + 16) |= v2;
      }
      if ( (*(_BYTE *)(result + 18) & 4) != 0 )
        *(_WORD *)(result + 86) = 280;
    }
  }
  return result;
}
// 968E4: using guessed type char byte_968E4;
// 987DE: using guessed type int (*off_987DE)(int);

//----- (00055DB0) --------------------------------------------------------
int sub_55DB0(int a1)
{
  return sub_55A40(a1, *(_BYTE *)(a1 + 65), *(_BYTE *)(a1 + 70) - 1);
}

//----- (00055DD0) --------------------------------------------------------
int sub_55DD0(int a1, int *a2)
{
  int v2; // edi
  int v3; // eax

  if ( a2[35] < 0 )
    goto LABEL_11;
  if ( a2[3] < 0 )
    goto LABEL_11;
  v2 = *(_DWORD *)(a1 + 132);
  if ( v2 )
  {
    v3 = a2[40];
    if ( !*(_WORD *)(v3 + 50) || v2 > *(_DWORD *)(dword_AE400 + 164 * *(unsigned __int16 *)(v3 + 50) + 29935) )
      goto LABEL_11;
  }
  if ( a2[35] >= *(_DWORD *)(a1 + 136) && *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
    return 1;
  if ( *(_WORD *)(a1 + 48) != *(_WORD *)(a1 + 50) )
    return 1;
LABEL_11:
  sub_55370(0, *(_WORD *)(a2[40] + 48), 29);
  return 0;
}
// AE400: using guessed type int dword_AE400;

//----- (00055E80) --------------------------------------------------------
int sub_55E80(int a1, int a2)
{
  __int16 v2; // bx
  int v3; // ebx

  v2 = *(_WORD *)(a1 + 48);
  if ( v2 == *(_WORD *)(a1 + 50) )
  {
    v3 = *(_DWORD *)(a2 + 132);
    //fix 
    /*
    if ( v3 >= 0 )
      *(_DWORD *)(a2 + 132) = -*(_DWORD *)(a1 + 136);
    else
      *(_DWORD *)(a2 + 132) = v3 - *(_DWORD *)(a1 + 136);
      * */
    return 1;
  }
  else
  {
    if ( v2 && *(int *)(a2 + 132) > 0 )
      *(_DWORD *)(a2 + 132) = 0;
    return 0;
  }
}

//----- (00055EF0) --------------------------------------------------------
int sub_55EF0(__int16 a1, int a2, int a3)
{
  unsigned __int16 v3; // ax
  int v4; // ebx
  int v5; // esi
  int v6; // ebx
  unsigned __int16 v7; // ax
  int v8; // esi
  int v9; // ebx
  int v10; // esi
  int v12; // [esp+0h] [ebp-18h] BYREF
  __int16 v13; // [esp+4h] [ebp-14h]

  v12 = *(_DWORD *)(a3 + 72);
  v13 = *(_WORD *)(a3 + 76);
  HIBYTE(a1) = *(_BYTE *)(a2 + 17);
  if ( (a1 & 0x100) != 0 )
  {
    v3 = *(_WORD *)(a2 + 30) - 512;
    HIBYTE(v3) &= 7u;
    sub_41EC0((uint16*)&v12, v3, 0, 256);
    a1 = sub_11F50((__int16 *)&v12);
    if ( a1 > v13 )
    {
      v12 = *(_DWORD *)(a3 + 72);
      v13 = *(_WORD *)(a3 + 76);
    }
    v4 = dword_AE400;
    v5 = 164 * *(unsigned __int16 *)(a3 + 54);
    while ( 1 )
    {
      v6 = v5 + v4 + 29795;
      if ( v6 == dword_AE400 + 29795 )
        break;
      a1 = sub_41C70(a1, v6, (int)&v12);
      v5 = 164 * *(unsigned __int16 *)(v6 + 54);
      v4 = dword_AE400;
    }
  }
  else if ( (a1 & 0x200) != 0 )
  {
    v7 = *(_WORD *)(a2 + 30);
    HIBYTE(v7) = (HIBYTE(v7) + 2) & 7;
    sub_41EC0((uint16*)&v12, v7, 0, 256);
    a1 = sub_11F50((__int16 *)&v12);
    if ( a1 > v13 )
    {
      v12 = *(_DWORD *)(a3 + 72);
      v13 = *(_WORD *)(a3 + 76);
    }
    v8 = 164 * *(unsigned __int16 *)(a3 + 54);
    v9 = dword_AE400 + 29795;
    while ( 1 )
    {
      v10 = v9 + v8;
      if ( v10 == dword_AE400 + 29795 )
        break;
      a1 = sub_41C70(a1, v10, (int)&v12);
      v9 = 164 * *(unsigned __int16 *)(v10 + 54);
      v8 = dword_AE400 + 29795;
    }
  }
  return sub_41C70(a1, a3, (int)&v12);
}
// AE400: using guessed type int dword_AE400;

//----- (00056090) --------------------------------------------------------
int sub_56090(int a1)
{
  int result; // eax
  unsigned __int16 v2; // dx
  unsigned int v3; // ebp
  int v4; // ebx
  __int16 v5; // ax

  result = a1;
  if ( *(__int16 *)(a1 + 48) > 0 )
  {
    v2 = *(_WORD *)(a1 + 42);
    v3 = dword_AE400 + 29795 + 164 * v2;
    if ( v3 <= dword_AE400 + 29795 )
    {
LABEL_5:
      result = a1;
      --*(_WORD *)(a1 + 48);
      return result;
    }
    if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * v2)) )
    {
      *(_WORD *)(a1 + 48) = 1;
      goto LABEL_5;
    }
    while ( *(char *)(a1 + 61) >= 0 )
    {
      if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
      {
        v4 = sub_373F0(v3 + 72, 9, 0);
        if ( v4 )
        {
          v5 = *(_WORD *)(v3 + 126);
          *(_WORD *)(v4 + 126) += v5;
          sub_55EF0(v5, v3, v4);
          *(_BYTE *)(v4 + 68) = 10;
          *(_BYTE *)(v4 + 69) = 0;
          *(_WORD *)(v4 + 24) = *(_WORD *)(v3 + 24);
          *(_WORD *)(v4 + 44) = *(_WORD *)(a1 + 44);
          *(_DWORD *)(v4 + 140) = *(_DWORD *)(a1 + 140);
          *(_WORD *)(v4 + 76) += *(_WORD *)(v3 + 84);
          *(_WORD *)(v4 + 30) = *(_WORD *)(v3 + 30);
          *(_WORD *)(v4 + 32) = *(_WORD *)(v3 + 32);
          *(_WORD *)(v4 + 26) = *(unsigned __int8 *)(*(_DWORD *)(v3 + 160) + 326);
          *(_BYTE *)(*(_DWORD *)(v3 + 160) + 326) = 0;
          *(_DWORD *)(v4 + 150) = *(_DWORD *)(v3 + 72);
          *(_WORD *)(v4 + 154) = *(_WORD *)(v3 + 76);
          sub_41EC0((_WORD *)(v4 + 150), *(_WORD *)(v3 + 30), *(_WORD *)(v3 + 32), 0x4000);
          sub_55370((v4 - (dword_AE400 + 29795)) / 164, -1, 9);
        }
      }
      sub_55E80(a1, v3);
      --*(_BYTE *)(a1 + 61);
    }
    *(_BYTE *)(a1 + 61) = 0;
    result = a1;
    --*(_WORD *)(a1 + 48);
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00056270) --------------------------------------------------------
void sub_56270(int a1)
{
  _DWORD *v1; // ebx
  int v2; // edi
  int v3; // ebp

  if ( *(__int16 *)(a1 + 48) > 0 )
  {
    v1 = (_DWORD *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42));
    if ( (unsigned int)v1 > dword_AE400 + 29795 )
    {
      if ( sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42)))
        && v1[3] < v1[2]
        && v1[35] >= *(_DWORD *)(a1 + 136) )
      {
        if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
          sub_55370(((int)v1 - dword_AE400 - 29795) / 164, -1, 25);
        v2 = 5 * v1[2] / 100 + v1[3];
        v3 = v1[2];
        v1[3] = v2;
        if ( v2 > v3 )
          v1[3] = v3;
        if ( (int)v1[33] >= 0 )
        {
          //fix v1[33] = -*(_DWORD *)(a1 + 136);
          --*(_WORD *)(a1 + 48);
          return;
        }
        v1[33] -= *(_DWORD *)(a1 + 136);
      }
      else
      {
        *(_WORD *)(a1 + 48) = 1;
      }
    }
    --*(_WORD *)(a1 + 48);
  }
}
// AE400: using guessed type int dword_AE400;

//----- (00056380) --------------------------------------------------------
void sub_56380(int a1)
{
  unsigned int v1; // esi
  int v2; // eax
  char v3; // dh
  __int16 v4; // ax
  int v5; // edx
  int v6; // eax
  __int16 v7; // ax

  if ( *(__int16 *)(a1 + 48) > 0 )
  {
    v1 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42);
    if ( v1 > dword_AE400 + 29795 )
    {
      if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42)))
        || *(_WORD *)(*(_DWORD *)(v1 + 160) + 14) )
      {
        if ( *(_WORD *)(*(_DWORD *)(v1 + 160) + 14) )
          *(_WORD *)(a1 + 48) = 1;
      }
      else
      {
        if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) && *(char *)(a1 + 16) >= 0 )
        {
          v2 = dword_AE400 + 29795;
          *(_BYTE *)(a1 + 16) |= 0x80u;
          sub_55370((int)(v1 - v2) / 164, -1, 19);
        }
        if ( *(__int16 *)(a1 + 48) == *(__int16 *)(a1 + 50) - 2 )
        {
          v3 = *(_BYTE *)(a1 + 16);
          if ( v3 < 0 )
            *(_BYTE *)(a1 + 16) = v3 & 0x7F;
        }
        ((void (*)(unsigned int))locret_455C0)(v1);
        if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
        {
          v4 = 3 * *(_WORD *)(v1 + 128);
          v5 = *(_DWORD *)(v1 + 160);
        }
        else
        {
          v5 = *(_DWORD *)(v1 + 160);
          v4 = 2 * *(_WORD *)(v1 + 128);
        }
        *(_WORD *)(v5 + 12) = v4;
        *(_WORD *)(v1 + 126) = *(_WORD *)(*(_DWORD *)(v1 + 160) + 12);
        if ( (*(_BYTE *)(a1 + 63) & 3) == 0 )
        {
          v6 = sub_373F0(v1 + 72, 10, 2);
          if ( v6 )
          {
            *(_WORD *)(v6 + 24) = *(_WORD *)(v1 + 24);
            *(_DWORD *)(v6 + 12) *= 4;
          }
        }
        sub_55E80(a1, v1);
      }
      v7 = *(_WORD *)(a1 + 48) - 1;
      *(_WORD *)(a1 + 48) = v7;
      if ( !v7 )
      {
        *(_WORD *)(*(_DWORD *)(v1 + 160) + 12) = *(_WORD *)(v1 + 128);
        *(_WORD *)(v1 + 126) = *(_WORD *)(*(_DWORD *)(v1 + 160) + 12);
        *(_BYTE *)(a1 + 16) &= ~0x80u;
      }
    }
  }
}
// AE400: using guessed type int dword_AE400;

//----- (00056510) --------------------------------------------------------
int sub_56510(int a1)
{
  int result; // eax
  unsigned __int16 v2; // dx
  unsigned int v3; // ebp
  int v4; // ebx
  __int16 v5; // ax
  int v6; // eax

  result = a1;
  if ( *(__int16 *)(a1 + 48) > 0 )
  {
    v2 = *(_WORD *)(a1 + 42);
    v3 = dword_AE400 + 29795 + 164 * v2;
    if ( v3 <= dword_AE400 + 29795 )
    {
LABEL_5:
      result = a1;
      --*(_WORD *)(a1 + 48);
      return result;
    }
    if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * v2)) )
    {
      *(_WORD *)(a1 + 48) = 1;
      goto LABEL_5;
    }
    while ( *(char *)(a1 + 61) >= 0 )
    {
      if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
      {
        v4 = sub_373F0(v3 + 72, 9, 1);
        if ( v4 )
        {
          v5 = *(_WORD *)(v3 + 126);
          *(_WORD *)(v4 + 126) += v5;
          sub_55EF0(v5, v3, v4);
          *(_BYTE *)(v4 + 68) = 10;
          *(_BYTE *)(v4 + 69) = 12;
          *(_WORD *)(v4 + 24) = *(_WORD *)(v3 + 24);
          *(_WORD *)(v4 + 76) += *(_WORD *)(v3 + 84);
          v6 = *(_DWORD *)(a1 + 140);
          *(_WORD *)(v4 + 26) = 200;
          *(_DWORD *)(v4 + 140) = v6;
          *(_BYTE *)(*(_DWORD *)(v3 + 160) + 326) = 0;
          *(_DWORD *)(v4 + 150) = *(_DWORD *)(v3 + 72);
          *(_WORD *)(v4 + 154) = *(_WORD *)(v3 + 76);
          sub_41EC0((_WORD *)(v4 + 150), *(_WORD *)(v3 + 30), *(_WORD *)(v3 + 32), 10240);
          *(_WORD *)(v4 + 30) = *(_WORD *)(v3 + 30);
          *(_WORD *)(v4 + 32) = *(_WORD *)(v3 + 32);
          sub_55370((v4 - (dword_AE400 + 29795)) / 164, -1, 40);
        }
      }
      sub_55E80(a1, v3);
      --*(_BYTE *)(a1 + 61);
    }
    *(_BYTE *)(a1 + 61) = 0;
    result = a1;
    --*(_WORD *)(a1 + 48);
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (000566C0) --------------------------------------------------------
int sub_566C0(int a1)
{
  int result; // eax
  unsigned int v2; // esi

  result = dword_AE400 + 29795;
  v2 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42);
  if ( v2 > dword_AE400 + 29795 && *(__int16 *)(a1 + 48) > 0 )
  {
    result = sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42)));
    if ( result )
    {
      *(_BYTE *)(v2 + 17) |= 0x40u;
      result = sub_55E80(a1, v2);
    }
    else
    {
      *(_WORD *)(a1 + 48) = 1;
    }
    --*(_WORD *)(a1 + 48);
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00056730) --------------------------------------------------------
void sub_56730(int a1)
{
  unsigned __int16 v1; // dx
  unsigned int v2; // esi

  if ( *(__int16 *)(a1 + 48) > 0 )
  {
    v1 = *(_WORD *)(a1 + 42);
    v2 = dword_AE400 + 29795 + 164 * v1;
    if ( v2 > dword_AE400 + 29795 )
    {
      if ( sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * v1)) )
        sub_55E80(a1, v2);
      else
        *(_WORD *)(a1 + 48) = 1;
    }
    --*(_WORD *)(a1 + 48);
  }
}
// AE400: using guessed type int dword_AE400;

//----- (000567A0) --------------------------------------------------------
int sub_567A0(int a1)
{
  int result; // eax
  int v2; // ebx
  unsigned int v3; // ebp
  int v4; // ebx
  __int16 v5; // ax
  __int16 v6; // ax
  int v7; // edx

  result = a1;
  if ( *(__int16 *)(a1 + 48) <= 0 )
    return result;
  v2 = 164 * *(unsigned __int16 *)(a1 + 42);
  v3 = dword_AE400 + 29795 + v2;
  if ( v3 <= dword_AE400 + 29795 )
    goto LABEL_9;
  if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + v2)) )
  {
    *(_WORD *)(a1 + 48) = 1;
    goto LABEL_9;
  }
  if ( *(_WORD *)(a1 + 48) != *(_WORD *)(a1 + 50) )
  {
LABEL_9:
    result = a1;
    --*(_WORD *)(a1 + 48);
    return result;
  }
  v4 = sub_373F0(v3 + 72, 9, 2);
  if ( v4 )
  {
    v5 = *(_WORD *)(v3 + 126);
    *(_WORD *)(v4 + 126) += v5;
    sub_55EF0(v5, v3, v4);
    *(_BYTE *)(v4 + 68) = 10;
    *(_BYTE *)(v4 + 69) = 15;
    *(_WORD *)(v4 + 24) = *(_WORD *)(v3 + 24);
    *(_WORD *)(v4 + 76) += *(_WORD *)(v3 + 84);
    *(_WORD *)(v4 + 30) = *(_WORD *)(v3 + 30);
    *(_WORD *)(v4 + 32) = *(_WORD *)(v3 + 32);
    *(_DWORD *)(v4 + 140) = *(_DWORD *)(a1 + 140);
    *(_WORD *)(v4 + 26) = *(unsigned __int8 *)(*(_DWORD *)(v3 + 160) + 326);
    *(_WORD *)(v4 + 44) = *(_WORD *)(a1 + 44);
    *(_BYTE *)(*(_DWORD *)(v3 + 160) + 326) = 0;
    *(_DWORD *)(v4 + 150) = *(_DWORD *)(v3 + 72);
    *(_WORD *)(v4 + 154) = *(_WORD *)(v3 + 76);
    sub_41EC0((_WORD *)(v4 + 150), *(_WORD *)(v3 + 30), 0, 4096);
    v6 = sub_11F50((__int16 *)(v4 + 150));
    v7 = dword_AE400 + 29795;
    *(_WORD *)(v4 + 154) = v6;
    sub_55370((v4 - v7) / 164, -1, 9);
  }
  sub_55E80(a1, v3);
  result = a1;
  --*(_WORD *)(a1 + 48);
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00056950) --------------------------------------------------------
int sub_56950(int a1)
{
  int result; // eax
  int v2; // ebx
  unsigned int v3; // ebp
  int v4; // ebx
  __int16 v5; // ax
  int v6; // edx

  result = a1;
  if ( *(__int16 *)(a1 + 48) <= 0 )
    return result;
  v2 = 164 * *(unsigned __int16 *)(a1 + 42);
  v3 = dword_AE400 + 29795 + v2;
  if ( v3 <= dword_AE400 + 29795 )
  {
LABEL_9:
    result = a1;
    --*(_WORD *)(a1 + 48);
    return result;
  }
  if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + v2)) )
  {
    *(_WORD *)(a1 + 48) = 1;
    goto LABEL_9;
  }
  if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
  {
    v4 = sub_373F0(v3 + 72, 9, 3);
    if ( v4 )
    {
      v5 = *(_WORD *)(v3 + 126);
      *(_WORD *)(v4 + 126) += v5;
      sub_55EF0(v5, v3, v4);
      *(_BYTE *)(v4 + 68) = 10;
      *(_BYTE *)(v4 + 69) = 17;
      *(_WORD *)(v4 + 24) = *(_WORD *)(v3 + 24);
      *(_WORD *)(v4 + 76) += *(_WORD *)(v3 + 84);
      *(_DWORD *)(v4 + 140) = *(_DWORD *)(a1 + 140);
      *(_WORD *)(v4 + 44) = *(_WORD *)(a1 + 44);
      *(_WORD *)(v4 + 26) = *(unsigned __int8 *)(*(_DWORD *)(v3 + 160) + 326);
      *(_BYTE *)(*(_DWORD *)(v3 + 160) + 326) = 0;
      *(_DWORD *)(v4 + 150) = *(_DWORD *)(v3 + 72);
      *(_WORD *)(v4 + 154) = *(_WORD *)(v3 + 76);
      sub_41EC0((_WORD *)(v4 + 150), *(_WORD *)(v3 + 30), *(_WORD *)(v3 + 32), 10240);
      *(_WORD *)(v4 + 30) = *(_WORD *)(v3 + 30);
      v6 = dword_AE400 + 29795;
      *(_WORD *)(v4 + 32) = *(_WORD *)(v3 + 32);
      sub_55370((v4 - v6) / 164, -1, 15);
    }
  }
  sub_55E80(a1, v3);
  result = a1;
  --*(_WORD *)(a1 + 48);
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00056AF0) --------------------------------------------------------
int sub_56AF0(int a1)
{
  int result; // eax
  int v2; // ebx
  unsigned int v3; // ebp
  int v4; // ebx
  __int16 v5; // ax
  int v6; // edx

  result = a1;
  if ( *(__int16 *)(a1 + 48) <= 0 )
    return result;
  v2 = 164 * *(unsigned __int16 *)(a1 + 42);
  v3 = dword_AE400 + 29795 + v2;
  if ( v3 <= dword_AE400 + 29795 )
  {
LABEL_9:
    result = a1;
    --*(_WORD *)(a1 + 48);
    return result;
  }
  if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + v2)) )
  {
    *(_WORD *)(a1 + 48) = 1;
    goto LABEL_9;
  }
  if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
  {
    v4 = sub_373F0(v3 + 72, 9, 4);
    if ( v4 )
    {
      v5 = *(_WORD *)(v3 + 126);
      *(_WORD *)(v4 + 126) += v5;
      sub_55EF0(v5, v3, v4);
      *(_BYTE *)(v4 + 68) = 10;
      *(_BYTE *)(v4 + 69) = 9;
      *(_WORD *)(v4 + 24) = *(_WORD *)(v3 + 24);
      *(_WORD *)(v4 + 76) += *(_WORD *)(v3 + 84);
      *(_DWORD *)(v4 + 140) = *(_DWORD *)(a1 + 140);
      *(_WORD *)(v4 + 44) = *(_WORD *)(a1 + 44);
      *(_WORD *)(v4 + 26) = *(unsigned __int8 *)(*(_DWORD *)(v3 + 160) + 326);
      *(_BYTE *)(*(_DWORD *)(v3 + 160) + 326) = 0;
      *(_DWORD *)(v4 + 150) = *(_DWORD *)(v3 + 72);
      *(_WORD *)(v4 + 154) = *(_WORD *)(v3 + 76);
      sub_41EC0((_WORD *)(v4 + 150), *(_WORD *)(v3 + 30), 0, 4096);
      *(_WORD *)(v4 + 154) = sub_11F50((__int16 *)(v4 + 150));
      *(_WORD *)(v4 + 30) = *(_WORD *)(v3 + 30);
      v6 = dword_AE400 + 29795;
      *(_WORD *)(v4 + 32) = *(_WORD *)(v3 + 32);
      sub_55370((v4 - v6) / 164, -1, 15);
    }
  }
  sub_55E80(a1, v3);
  result = a1;
  --*(_WORD *)(a1 + 48);
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00056CA0) --------------------------------------------------------
int sub_56CA0(int a1)
{
  int result; // eax
  int v2; // ebx
  unsigned int v3; // ebp
  int v4; // ebx
  __int16 v5; // ax
  __int16 v6; // ax
  __int16 v7; // ax
  int v8; // edx

  result = a1;
  if ( *(__int16 *)(a1 + 48) <= 0 )
    return result;
  v2 = 164 * *(unsigned __int16 *)(a1 + 42);
  v3 = dword_AE400 + 29795 + v2;
  if ( v3 <= dword_AE400 + 29795 )
  {
LABEL_9:
    result = a1;
    --*(_WORD *)(a1 + 48);
    return result;
  }
  if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + v2)) )
  {
    *(_WORD *)(a1 + 48) = 1;
    goto LABEL_9;
  }
  if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
  {
    v4 = sub_373F0(v3 + 72, 9, 5);
    if ( v4 )
    {
      v5 = *(_WORD *)(v3 + 126);
      *(_WORD *)(v4 + 126) += v5;
      sub_55EF0(v5, v3, v4);
      v6 = *(_WORD *)(a1 + 44);
      *(_BYTE *)(v4 + 68) = 10;
      *(_BYTE *)(v4 + 69) = 11;
      *(_WORD *)(v4 + 44) = v6;
      *(_WORD *)(v4 + 24) = *(_WORD *)(v3 + 24);
      *(_WORD *)(v4 + 76) += *(_WORD *)(v3 + 84);
      *(_WORD *)(v4 + 30) = *(_WORD *)(v3 + 30);
      *(_WORD *)(v4 + 32) = *(_WORD *)(v3 + 32);
      *(_DWORD *)(v4 + 140) = *(_DWORD *)(a1 + 140);
      *(_WORD *)(v4 + 26) = *(unsigned __int8 *)(*(_DWORD *)(v3 + 160) + 326);
      *(_BYTE *)(*(_DWORD *)(v3 + 160) + 326) = 0;
      *(_DWORD *)(v4 + 150) = *(_DWORD *)(v3 + 72);
      *(_WORD *)(v4 + 154) = *(_WORD *)(v3 + 76);
      sub_41EC0((_WORD *)(v4 + 150), *(_WORD *)(v3 + 30), 0, 4096);
      v7 = sub_11F50((__int16 *)(v4 + 150));
      v8 = dword_AE400 + 29795;
      *(_WORD *)(v4 + 154) = v7;
      sub_55370((v4 - v8) / 164, -1, 15);
    }
  }
  sub_55E80(a1, v3);
  result = a1;
  --*(_WORD *)(a1 + 48);
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00056E50) --------------------------------------------------------
void sub_56E50(int a1)
{
  unsigned int v1; // ebp
  __int16 v2; // ax
  unsigned int v3; // edx
  int v4; // eax
  __int16 v5; // ax
  __int16 v6; // di
  __int16 v7; // [esp-Ch] [ebp-20h]

  if ( *(__int16 *)(a1 + 48) > 0 )
  {
    v1 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42);
    if ( v1 > dword_AE400 + 29795 )
    {
      if ( sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42))) )
      {
        if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
        {
          v2 = dword_AE400 + 29795;
          v3 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(*(_DWORD *)(v1 + 160) + 50);
          if ( v3 <= dword_AE400 + 29795 )
          {
            *(_DWORD *)(a1 + 150) = *(_DWORD *)(v1 + 72);
            *(_WORD *)(a1 + 154) = *(_WORD *)(v1 + 76);
            v4 = 9377 * *(_DWORD *)(a1 + 4) + 9439;
            *(_DWORD *)(a1 + 4) = v4;
            v5 = (unsigned __int16)sub_41EC0((_WORD *)(a1 + 150), v4 & 0x7FF, 0, 0x4000);
            sub_41C70(v5, v1, a1 + 150);
            *(_WORD *)(*(_DWORD *)(v1 + 160) + 12) = 0;
            v7 = (int)(v1 - (dword_AE400 + 29795)) / 164;
            *(_WORD *)(a1 + 154) = 0;
            sub_55370(v7, -1, 22);
          }
          else
          {
            if ( *(_WORD *)(a1 + 154) )
            {
              sub_41C70(v2, v1, a1 + 150);
              *(_WORD *)(a1 + 154) = 0;
            }
            else
            {
              *(_DWORD *)(a1 + 150) = *(_DWORD *)(v1 + 72);
              *(_WORD *)(a1 + 154) = *(_WORD *)(v1 + 76);
              sub_41C70(v2, v1, v3 + 72);
            }
            *(_WORD *)(*(_DWORD *)(v1 + 160) + 12) = 0;
            sub_55370((int)(v1 - (dword_AE400 + 29795)) / 164, -1, 22);
          }
        }
        sub_55E80(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 48) = 1;
      }
      v6 = *(_WORD *)(a1 + 48) - 1;
      *(_WORD *)(a1 + 48) = v6;
      if ( !v6 )
        *(_WORD *)(*(_DWORD *)(v1 + 160) + 12) = 0;
    }
  }
}
// AE400: using guessed type int dword_AE400;

//----- (00057040) --------------------------------------------------------
int sub_57040(int a1)
{
  int result; // eax
  unsigned __int16 v2; // dx
  unsigned int v3; // ebp
  int v4; // eax
  int v5; // ebx
  __int16 v6; // ax

  result = a1;
  if ( *(__int16 *)(a1 + 48) <= 0 )
    return result;
  v2 = *(_WORD *)(a1 + 42);
  v3 = dword_AE400 + 29795 + 164 * v2;
  if ( v3 <= dword_AE400 + 29795 )
  {
LABEL_9:
    result = a1;
    --*(_WORD *)(a1 + 48);
    return result;
  }
  if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * v2)) )
  {
    *(_WORD *)(a1 + 48) = 1;
    goto LABEL_9;
  }
  if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
  {
    v4 = sub_373F0(v3 + 72, 9, 7);
    v5 = v4;
    if ( v4 )
    {
      sub_55EF0(v4, v3, v4);
      v6 = *(_WORD *)(a1 + 44);
      *(_BYTE *)(v5 + 68) = 10;
      *(_BYTE *)(v5 + 69) = 26;
      *(_WORD *)(v5 + 44) = v6;
      *(_WORD *)(v5 + 24) = *(_WORD *)(v3 + 24);
      *(_WORD *)(v5 + 76) += *(_WORD *)(v3 + 84);
      *(_DWORD *)(v5 + 140) = *(_DWORD *)(a1 + 140);
      *(_DWORD *)(v5 + 150) = *(_DWORD *)(v3 + 72);
      *(_WORD *)(v5 + 154) = *(_WORD *)(v3 + 76);
      sub_41EC0((_WORD *)(v5 + 150), *(_WORD *)(v3 + 30), *(_WORD *)(v3 + 32), 10240);
      *(_WORD *)(v5 + 30) = *(_WORD *)(v3 + 30);
      *(_WORD *)(v5 + 32) = *(_WORD *)(v3 + 32);
      sub_55370((v5 - (dword_AE400 + 29795)) / 164, -1, 9);
    }
  }
  sub_55E80(a1, v3);
  result = a1;
  --*(_WORD *)(a1 + 48);
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (000571B0) --------------------------------------------------------
void sub_571B0(int a1)
{
  unsigned int v1; // esi
  __int16 v2; // di

  if ( *(__int16 *)(a1 + 48) > 0 )
  {
    v1 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42);
    if ( v1 > dword_AE400 + 29795 )
    {
      if ( sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42))) )
      {
        if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
        {
          *(_WORD *)(*(_DWORD *)(a1 + 160) + 331) = 0;
          *(_BYTE *)(v1 + 16) |= 0x20u;
        }
        else if ( (*(_BYTE *)(v1 + 16) & 0x20) == 0 )
        {
          *(_WORD *)(a1 + 48) = 1;
        }
        sub_55E80(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 48) = 1;
      }
    }
    v2 = *(_WORD *)(a1 + 48) - 1;
    *(_WORD *)(a1 + 48) = v2;
    if ( !v2 )
      *(_BYTE *)(v1 + 16) &= ~0x20u;
  }
}
// AE400: using guessed type int dword_AE400;

//----- (00057250) --------------------------------------------------------
int sub_57250(int a1)
{
  int result; // eax
  int v2; // ebx
  unsigned int v3; // ebp
  int v4; // ebx
  __int16 v5; // ax
  __int16 v6; // ax
  int v7; // eax
  int v8; // edx

  result = a1;
  if ( *(__int16 *)(a1 + 48) <= 0 )
    return result;
  v2 = 164 * *(unsigned __int16 *)(a1 + 42);
  v3 = dword_AE400 + 29795 + v2;
  if ( v3 <= dword_AE400 + 29795 )
  {
LABEL_9:
    result = a1;
    --*(_WORD *)(a1 + 48);
    return result;
  }
  if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + v2)) )
  {
    *(_WORD *)(a1 + 48) = 1;
    goto LABEL_9;
  }
  if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
  {
    v4 = sub_373F0(v3 + 72, 9, 8);
    if ( v4 )
    {
      v5 = *(_WORD *)(v3 + 126);
      *(_WORD *)(v4 + 126) += v5;
      sub_55EF0(v5, v3, v4);
      v6 = *(_WORD *)(a1 + 44);
      *(_BYTE *)(v4 + 68) = 10;
      *(_BYTE *)(v4 + 69) = 25;
      *(_WORD *)(v4 + 44) = v6;
      *(_WORD *)(v4 + 24) = *(_WORD *)(v3 + 24);
      *(_WORD *)(v4 + 76) += *(_WORD *)(v3 + 84);
      v7 = *(_DWORD *)(a1 + 140);
      *(_WORD *)(v4 + 44) = 2000;
      *(_DWORD *)(v4 + 140) = v7;
      *(_WORD *)(v4 + 26) = *(unsigned __int8 *)(*(_DWORD *)(v3 + 160) + 326);
      *(_BYTE *)(*(_DWORD *)(v3 + 160) + 326) = 0;
      *(_DWORD *)(v4 + 150) = *(_DWORD *)(v3 + 72);
      *(_WORD *)(v4 + 154) = *(_WORD *)(v3 + 76);
      sub_41EC0((_WORD *)(v4 + 150), *(_WORD *)(v3 + 30), *(_WORD *)(v3 + 32), 0x4000);
      *(_WORD *)(v4 + 30) = *(_WORD *)(v3 + 30);
      v8 = dword_AE400 + 29795;
      *(_WORD *)(v4 + 32) = *(_WORD *)(v3 + 32);
      sub_55370((v4 - v8) / 164, -1, 9);
    }
  }
  sub_55E80(a1, v3);
  result = a1;
  --*(_WORD *)(a1 + 48);
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (000573F0) --------------------------------------------------------
int sub_573F0(int a1)
{
  int result; // eax
  unsigned int v2; // ebx

  result = dword_AE400 + 29795;
  v2 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42);
  if ( v2 > dword_AE400 + 29795 )
  {
    if ( *(__int16 *)(a1 + 48) <= 0 )
    {
      *(_BYTE *)(v2 + 17) &= ~0x80u;
    }
    else
    {
      result = sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42)));
      if ( result )
      {
        *(_BYTE *)(v2 + 17) |= 0x80u;
        result = sub_55E80(a1, v2);
      }
      else
      {
        *(_WORD *)(a1 + 48) = 1;
      }
      --*(_WORD *)(a1 + 48);
    }
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00057470) --------------------------------------------------------
int sub_57470(int a1)
{
  int result; // eax
  int v2; // ebx
  unsigned int v3; // ebp
  int v4; // ebx
  __int16 v5; // ax

  result = a1;
  if ( *(__int16 *)(a1 + 48) <= 0 )
    return result;
  v2 = 164 * *(unsigned __int16 *)(a1 + 42);
  v3 = dword_AE400 + 29795 + v2;
  if ( v3 <= dword_AE400 + 29795 )
  {
LABEL_9:
    result = a1;
    --*(_WORD *)(a1 + 48);
    return result;
  }
  if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + v2)) )
  {
    *(_WORD *)(a1 + 48) = 1;
    goto LABEL_9;
  }
  if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
  {
    v4 = sub_373F0(v3 + 72, 9, 9);
    if ( v4 )
    {
      v5 = *(_WORD *)(v3 + 126);
      *(_WORD *)(v4 + 126) += v5;
      sub_55EF0(v5, v3, v4);
      *(_BYTE *)(v4 + 68) = 10;
      *(_BYTE *)(v4 + 69) = 23;
      *(_WORD *)(v4 + 24) = *(_WORD *)(v3 + 24);
      *(_DWORD *)(v4 + 140) = *(_DWORD *)(a1 + 140);
      *(_WORD *)(v4 + 76) += *(_WORD *)(v3 + 84);
      *(_WORD *)(v4 + 30) = *(_WORD *)(v3 + 30);
      *(_WORD *)(v4 + 32) = *(_WORD *)(v3 + 32);
      *(_WORD *)(v4 + 26) = *(unsigned __int8 *)(*(_DWORD *)(v3 + 160) + 326);
      *(_WORD *)(v4 + 44) = *(_WORD *)(a1 + 44);
      *(_BYTE *)(*(_DWORD *)(v3 + 160) + 326) = 0;
      *(_DWORD *)(v4 + 150) = *(_DWORD *)(v3 + 72);
      *(_WORD *)(v4 + 154) = *(_WORD *)(v3 + 76);
      sub_41EC0((_WORD *)(v4 + 150), *(_WORD *)(v3 + 30), *(_WORD *)(v3 + 32), 0x4000);
      sub_55370((v4 - (dword_AE400 + 29795)) / 164, -1, 23);
    }
  }
  sub_55E80(a1, v3);
  result = a1;
  --*(_WORD *)(a1 + 48);
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00057610) --------------------------------------------------------
void sub_57610(int a1)
{
  unsigned __int16 v1; // dx
  unsigned int v2; // ebp
  int v3; // ebx
  __int16 v4; // ax
  unsigned __int16 v5; // dx
  __int16 v6; // ax

  if ( *(__int16 *)(a1 + 48) > 0 )
  {
    v1 = *(_WORD *)(a1 + 42);
    v2 = dword_AE400 + 29795 + 164 * v1;
    if ( v2 > dword_AE400 + 29795 )
    {
      if ( sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * v1)) )
      {
        if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
        {
          sub_55E80(a1, v2);
          v3 = sub_373F0(v2 + 72, 9, 10);
          if ( v3 )
          {
            *(_WORD *)(a1 + 48) = *(_WORD *)(a1 + 50) - 1;
            v4 = *(_WORD *)(v2 + 126);
            *(_WORD *)(v3 + 126) += v4;
            sub_55EF0(v4, v2, v3);
            *(_WORD *)(v3 + 44) = *(_WORD *)(a1 + 44);
            *(_WORD *)(v3 + 24) = *(_WORD *)(v2 + 24);
            *(_WORD *)(v3 + 76) += *(_WORD *)(v2 + 84);
            *(_DWORD *)(v3 + 140) = *(_DWORD *)(a1 + 140);
            v5 = *(_WORD *)(*(_DWORD *)(v2 + 160) + 50);
            if ( dword_AE400 + 29795 + 164 * (unsigned int)v5 <= dword_AE400 + 29795 )
            {
              *(_DWORD *)(v3 + 150) = *(_DWORD *)(v2 + 72);
              *(_WORD *)(v3 + 154) = *(_WORD *)(v2 + 76);
              sub_41EC0((_WORD *)(v3 + 150), *(_WORD *)(v2 + 30), 0, 4096);
              v6 = sub_11F50((__int16 *)(v3 + 150));
              *(_BYTE *)(v3 + 68) = 3;
              *(_BYTE *)(v3 + 69) = 2;
              *(_WORD *)(v3 + 154) = v6;
            }
            else
            {
              *(_BYTE *)(v3 + 68) = 10;
              *(_BYTE *)(v3 + 69) = 43;
              *(_WORD *)(v3 + 146) = 164 * v5 / 164;
            }
            *(_WORD *)(v3 + 26) = *(unsigned __int8 *)(*(_DWORD *)(v2 + 160) + 326);
            *(_BYTE *)(*(_DWORD *)(v2 + 160) + 326) = 0;
            *(_WORD *)(v3 + 30) = *(_WORD *)(v2 + 30);
            *(_WORD *)(v3 + 32) = *(_WORD *)(v2 + 32);
            sub_55370((v3 - (dword_AE400 + 29795)) / 164, -1, 15);
          }
        }
      }
      else
      {
        *(_WORD *)(a1 + 48) = 0;
      }
    }
  }
}
// AE400: using guessed type int dword_AE400;

//----- (00057800) --------------------------------------------------------
void sub_57800(int a1)
{
  unsigned int v1; // ebx
  int v2; // esi
  __int16 v3; // ax
  __int16 v4; // ax
  int v5; // eax
  unsigned __int16 v6; // cx

  if ( *(__int16 *)(a1 + 48) <= 0 )
    return;
  v1 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42);
  if ( v1 <= dword_AE400 + 29795 )
  {
LABEL_12:
    --*(_WORD *)(a1 + 48);
    return;
  }
  if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42))) )
  {
    *(_WORD *)(a1 + 48) = 1;
    goto LABEL_12;
  }
  if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
  {
    v2 = sub_373F0(v1 + 72, 9, 11);
    if ( v2 )
    {
      v3 = *(_WORD *)(v1 + 126);
      *(_WORD *)(v2 + 126) += v3;
      sub_55EF0(v3, v1, v2);
      v4 = *(_WORD *)(a1 + 44);
      *(_BYTE *)(v2 + 68) = 10;
      *(_BYTE *)(v2 + 69) = 36;
      *(_WORD *)(v2 + 44) = v4;
      *(_WORD *)(v2 + 24) = *(_WORD *)(v1 + 24);
      *(_WORD *)(v2 + 76) += *(_WORD *)(v1 + 84);
      v5 = *(_DWORD *)(a1 + 140);
      *(_WORD *)(v2 + 44) = 1;
      *(_DWORD *)(v2 + 140) = v5;
      v6 = *(_WORD *)(*(_DWORD *)(v1 + 160) + 50);
      if ( v6 )
      {
        if ( *(_DWORD *)(dword_AE400 + 164 * v6 + 29931) >= *(_DWORD *)(a1 + 136) )
          *(_WORD *)(v2 + 44) = *(_WORD *)(a1 + 136);
      }
      *(_WORD *)(v2 + 26) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 160) + 326);
      *(_BYTE *)(*(_DWORD *)(v1 + 160) + 326) = 0;
      *(_DWORD *)(v2 + 150) = *(_DWORD *)(v1 + 72);
      *(_WORD *)(v2 + 154) = *(_WORD *)(v1 + 76);
      sub_41EC0((_WORD *)(v2 + 150), *(_WORD *)(v1 + 30), *(_WORD *)(v1 + 32), 0x4000);
      *(_WORD *)(v2 + 30) = *(_WORD *)(v1 + 30);
      *(_WORD *)(v2 + 32) = *(_WORD *)(v1 + 32);
      sub_55370((v2 - (dword_AE400 + 29795)) / 164, -1, 9);
    }
  }
  sub_55E80(a1, v1);
  --*(_WORD *)(a1 + 48);
}
// AE400: using guessed type int dword_AE400;

//----- (000579D0) --------------------------------------------------------
int sub_579D0(int a1)
{
  int result; // eax
  unsigned __int16 v2; // dx
  unsigned int v3; // ebp
  int v4; // ebx
  __int16 v5; // ax
  __int16 v6; // ax
  int v7; // edx

  result = a1;
  if ( *(__int16 *)(a1 + 48) <= 0 )
    return result;
  v2 = *(_WORD *)(a1 + 42);
  v3 = dword_AE400 + 29795 + 164 * v2;
  if ( v3 <= dword_AE400 + 29795 )
  {
LABEL_9:
    result = a1;
    --*(_WORD *)(a1 + 48);
    return result;
  }
  if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * v2)) )
  {
    *(_WORD *)(a1 + 48) = 1;
    goto LABEL_9;
  }
  if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
  {
    v4 = sub_373F0(v3 + 72, 9, 12);
    if ( v4 )
    {
      v5 = *(_WORD *)(v3 + 126);
      *(_WORD *)(v4 + 126) += v5;
      sub_55EF0(v5, v3, v4);
      v6 = *(_WORD *)(a1 + 44);
      *(_BYTE *)(v4 + 68) = 9;
      *(_BYTE *)(v4 + 69) = 9;
      *(_WORD *)(v4 + 44) = v6;
      *(_WORD *)(v4 + 24) = *(_WORD *)(v3 + 24);
      *(_WORD *)(v4 + 76) += *(_WORD *)(v3 + 84);
      *(_DWORD *)(v4 + 140) = *(_DWORD *)(a1 + 140);
      *(_WORD *)(v4 + 44) = *(_WORD *)(a1 + 44);
      *(_WORD *)(v4 + 26) = *(unsigned __int8 *)(*(_DWORD *)(v3 + 160) + 326);
      *(_BYTE *)(*(_DWORD *)(v3 + 160) + 326) = 0;
      *(_DWORD *)(v4 + 150) = *(_DWORD *)(v3 + 72);
      *(_WORD *)(v4 + 154) = *(_WORD *)(v3 + 76);
      sub_41EC0((_WORD *)(v4 + 150), *(_WORD *)(v3 + 30), *(_WORD *)(v3 + 32), 0x4000);
      *(_WORD *)(v4 + 30) = *(_WORD *)(v3 + 30);
      v7 = dword_AE400 + 29795;
      *(_WORD *)(v4 + 32) = *(_WORD *)(v3 + 32);
      sub_55370((v4 - v7) / 164, -1, 9);
    }
  }
  sub_55E80(a1, v3);
  result = a1;
  --*(_WORD *)(a1 + 48);
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00057B80) --------------------------------------------------------
int sub_57B80(int a1)
{
  int result; // eax
  unsigned __int16 v2; // dx
  unsigned int v3; // ebp
  int v4; // ebx
  __int16 v5; // ax

  result = a1;
  if ( *(__int16 *)(a1 + 48) > 0 )
  {
    v2 = *(_WORD *)(a1 + 42);
    v3 = dword_AE400 + 29795 + 164 * v2;
    if ( v3 <= dword_AE400 + 29795 )
    {
LABEL_5:
      result = a1;
      --*(_WORD *)(a1 + 48);
      return result;
    }
    if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * v2)) )
    {
      *(_WORD *)(a1 + 48) = 1;
      goto LABEL_5;
    }
    while ( *(char *)(a1 + 61) >= 0 )
    {
      if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
      {
        v4 = sub_373F0(v3 + 72, 9, 17);
        if ( v4 )
        {
          v5 = *(_WORD *)(v3 + 126);
          *(_WORD *)(v4 + 126) += v5;
          sub_55EF0(v5, v3, v4);
          *(_BYTE *)(v4 + 68) = 10;
          *(_BYTE *)(v4 + 69) = 54;
          *(_WORD *)(v4 + 24) = *(_WORD *)(v3 + 24);
          *(_WORD *)(v4 + 44) = *(_WORD *)(a1 + 44);
          *(_DWORD *)(v4 + 140) = *(_DWORD *)(a1 + 140);
          *(_WORD *)(v4 + 76) += *(_WORD *)(v3 + 84);
          *(_WORD *)(v4 + 30) = *(_WORD *)(v3 + 30);
          *(_WORD *)(v4 + 32) = *(_WORD *)(v3 + 32);
          *(_WORD *)(v4 + 26) = *(unsigned __int8 *)(*(_DWORD *)(v3 + 160) + 326);
          *(_BYTE *)(*(_DWORD *)(v3 + 160) + 326) = 0;
          *(_DWORD *)(v4 + 150) = *(_DWORD *)(v3 + 72);
          *(_WORD *)(v4 + 154) = *(_WORD *)(v3 + 76);
          sub_41EC0((_WORD *)(v4 + 150), *(_WORD *)(v3 + 30), *(_WORD *)(v3 + 32), 0x4000);
          sub_55370((v4 - (dword_AE400 + 29795)) / 164, -1, 40);
        }
      }
      sub_55E80(a1, v3);
      --*(_BYTE *)(a1 + 61);
    }
    *(_BYTE *)(a1 + 61) = 0;
    result = a1;
    --*(_WORD *)(a1 + 48);
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00057D40) --------------------------------------------------------
int sub_57D40(int a1)
{
  int result; // eax
  unsigned __int16 v2; // dx
  unsigned int v3; // ebp
  int v4; // ebx
  __int16 v5; // ax

  result = a1;
  if ( *(__int16 *)(a1 + 48) > 0 )
  {
    v2 = *(_WORD *)(a1 + 42);
    v3 = dword_AE400 + 29795 + 164 * v2;
    if ( v3 <= dword_AE400 + 29795 )
    {
LABEL_5:
      result = a1;
      --*(_WORD *)(a1 + 48);
      return result;
    }
    if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * v2)) )
    {
      *(_WORD *)(a1 + 48) = 1;
      goto LABEL_5;
    }
    while ( *(char *)(a1 + 61) >= 0 )
    {
      if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
      {
        v4 = sub_373F0(v3 + 72, 9, 16);
        if ( v4 )
        {
          v5 = *(_WORD *)(v3 + 126);
          *(_WORD *)(v4 + 126) += v5;
          sub_55EF0(v5, v3, v4);
          *(_BYTE *)(v4 + 68) = 10;
          *(_BYTE *)(v4 + 69) = 53;
          *(_WORD *)(v4 + 24) = *(_WORD *)(v3 + 24);
          *(_WORD *)(v4 + 44) = *(_WORD *)(a1 + 44);
          *(_DWORD *)(v4 + 140) = *(_DWORD *)(a1 + 140);
          *(_WORD *)(v4 + 76) += *(_WORD *)(v3 + 84);
          *(_WORD *)(v4 + 30) = *(_WORD *)(v3 + 30);
          *(_WORD *)(v4 + 32) = *(_WORD *)(v3 + 32);
          *(_WORD *)(v4 + 26) = *(unsigned __int8 *)(*(_DWORD *)(v3 + 160) + 326);
          *(_BYTE *)(*(_DWORD *)(v3 + 160) + 326) = 0;
          *(_DWORD *)(v4 + 150) = *(_DWORD *)(v3 + 72);
          *(_WORD *)(v4 + 154) = *(_WORD *)(v3 + 76);
          sub_41EC0((_WORD *)(v4 + 150), *(_WORD *)(v3 + 30), *(_WORD *)(v3 + 32), 0x4000);
          sub_55370((v4 - (dword_AE400 + 29795)) / 164, -1, 9);
        }
      }
      sub_55E80(a1, v3);
      --*(_BYTE *)(a1 + 61);
    }
    *(_BYTE *)(a1 + 61) = 0;
    result = a1;
    --*(_WORD *)(a1 + 48);
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00057F00) --------------------------------------------------------
void sub_57F00(int a1)
{
  unsigned int v1; // esi
  int v2; // eax
  char v3; // dh
  int v4; // eax
  __int16 v5; // di

  if ( *(__int16 *)(a1 + 48) > 0 )
  {
    v1 = dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42);
    if ( v1 > dword_AE400 + 29795 )
    {
      if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * *(unsigned __int16 *)(a1 + 42)))
        || *(_WORD *)(*(_DWORD *)(v1 + 160) + 14) )
      {
        if ( *(_WORD *)(*(_DWORD *)(v1 + 160) + 14) )
          *(_WORD *)(a1 + 48) = 1;
      }
      else
      {
        if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) && *(char *)(a1 + 16) >= 0 )
        {
          v2 = dword_AE400 + 29795;
          *(_BYTE *)(a1 + 16) |= 0x80u;
          sub_55370((int)(v1 - v2) / 164, -1, 19);
        }
        if ( *(__int16 *)(a1 + 48) == *(__int16 *)(a1 + 50) - 2 )
        {
          v3 = *(_BYTE *)(a1 + 16);
          if ( v3 < 0 )
            *(_BYTE *)(a1 + 16) = v3 & 0x7F;
        }
        ((void (*)(unsigned int))locret_455C0)(v1);
        if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
          *(_WORD *)(*(_DWORD *)(v1 + 160) + 12) = -3 * *(_WORD *)(v1 + 128);
        else
          *(_WORD *)(*(_DWORD *)(v1 + 160) + 12) = -2 * *(_WORD *)(v1 + 128);
        *(_WORD *)(v1 + 126) = *(_WORD *)(*(_DWORD *)(v1 + 160) + 12);
        if ( (*(_BYTE *)(a1 + 63) & 3) == 0 )
        {
          v4 = sub_373F0(v1 + 72, 10, 2);
          if ( v4 )
          {
            *(_WORD *)(v4 + 24) = *(_WORD *)(v1 + 24);
            *(_DWORD *)(v4 + 12) *= 4;
          }
        }
        sub_55E80(a1, v1);
      }
      v5 = *(_WORD *)(a1 + 48) - 1;
      *(_WORD *)(a1 + 48) = v5;
      if ( !v5 )
      {
        *(_WORD *)(*(_DWORD *)(v1 + 160) + 12) = -*(_WORD *)(v1 + 128);
        *(_WORD *)(v1 + 126) = *(_WORD *)(*(_DWORD *)(v1 + 160) + 12);
        *(_BYTE *)(a1 + 16) &= ~0x80u;
      }
    }
  }
}
// AE400: using guessed type int dword_AE400;

//----- (000580A0) --------------------------------------------------------
int sub_580A0(int a1)
{
  int result; // eax
  unsigned __int16 v2; // bx
  unsigned int v3; // ebp
  int v4; // ebx
  __int16 v5; // ax

  result = a1;
  if ( *(__int16 *)(a1 + 48) > 0 )
  {
    v2 = *(_WORD *)(a1 + 42);
    v3 = dword_AE400 + 29795 + 164 * v2;
    if ( v3 <= dword_AE400 + 29795 )
    {
LABEL_5:
      result = a1;
      --*(_WORD *)(a1 + 48);
      return result;
    }
    if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * v2)) )
    {
      *(_WORD *)(a1 + 48) = 1;
      goto LABEL_5;
    }
    while ( *(char *)(a1 + 61) >= 0 )
    {
      if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
      {
        v4 = sub_373F0(v3 + 72, 9, 18);
        if ( v4 )
        {
          v5 = *(_WORD *)(v3 + 126);
          *(_WORD *)(v4 + 126) += v5;
          sub_55EF0(v5, v3, v4);
          *(_BYTE *)(v4 + 68) = 10;
          *(_BYTE *)(v4 + 69) = 55;
          *(_WORD *)(v4 + 24) = *(_WORD *)(v3 + 24);
          *(_WORD *)(v4 + 44) = *(_WORD *)(a1 + 44);
          *(_DWORD *)(v4 + 140) = *(_DWORD *)(a1 + 140);
          *(_WORD *)(v4 + 76) += *(_WORD *)(v3 + 84);
          *(_WORD *)(v4 + 30) = *(_WORD *)(v3 + 30);
          *(_WORD *)(v4 + 32) = *(_WORD *)(v3 + 32);
          *(_WORD *)(v4 + 26) = *(unsigned __int8 *)(*(_DWORD *)(v3 + 160) + 326);
          *(_BYTE *)(*(_DWORD *)(v3 + 160) + 326) = 0;
          *(_DWORD *)(v4 + 150) = *(_DWORD *)(v3 + 72);
          *(_WORD *)(v4 + 154) = *(_WORD *)(v3 + 76);
          sub_41EC0((_WORD *)(v4 + 150), *(_WORD *)(v3 + 30), *(_WORD *)(v3 + 32), 0x4000);
        }
      }
      sub_55E80(a1, v3);
      --*(_BYTE *)(a1 + 61);
    }
    *(_BYTE *)(a1 + 61) = 0;
    result = a1;
    --*(_WORD *)(a1 + 48);
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00058240) --------------------------------------------------------
int sub_58240(int a1)
{
  int result; // eax
  unsigned __int16 v2; // dx
  unsigned int v3; // ebp
  int v4; // ebx
  __int16 v5; // ax

  result = a1;
  if ( *(__int16 *)(a1 + 48) > 0 )
  {
    v2 = *(_WORD *)(a1 + 42);
    v3 = dword_AE400 + 29795 + 164 * v2;
    if ( v3 <= dword_AE400 + 29795 )
    {
LABEL_5:
      result = a1;
      --*(_WORD *)(a1 + 48);
      return result;
    }
    if ( !sub_55DD0(a1, (int *)(dword_AE400 + 29795 + 164 * v2)) )
    {
      *(_WORD *)(a1 + 48) = 1;
      goto LABEL_5;
    }
    while ( *(char *)(a1 + 61) >= 0 )
    {
      if ( *(_WORD *)(a1 + 48) == *(_WORD *)(a1 + 50) )
      {
        v4 = sub_373F0(v3 + 72, 9, 0);
        if ( v4 )
        {
          v5 = *(_WORD *)(v3 + 126);
          *(_WORD *)(v4 + 126) += v5;
          sub_55EF0(v5, v3, v4);
          *(_BYTE *)(v4 + 68) = 10;
          *(_BYTE *)(v4 + 69) = 0;
          *(_WORD *)(v4 + 24) = *(_WORD *)(v3 + 24);
          *(_WORD *)(v4 + 44) = *(_WORD *)(a1 + 44);
          *(_DWORD *)(v4 + 140) = *(_DWORD *)(a1 + 140);
          *(_WORD *)(v4 + 76) += *(_WORD *)(v3 + 84);
          *(_WORD *)(v4 + 30) = *(_WORD *)(v3 + 30);
          *(_WORD *)(v4 + 32) = *(_WORD *)(v3 + 32);
          *(_WORD *)(v4 + 26) = *(unsigned __int8 *)(*(_DWORD *)(v3 + 160) + 326);
          *(_BYTE *)(*(_DWORD *)(v3 + 160) + 326) = 0;
          *(_DWORD *)(v4 + 150) = *(_DWORD *)(v3 + 72);
          *(_WORD *)(v4 + 154) = *(_WORD *)(v3 + 76);
          sub_41EC0((_WORD *)(v4 + 150), *(_WORD *)(v3 + 30), *(_WORD *)(v3 + 32), 0x4000);
          sub_55370((v4 - (dword_AE400 + 29795)) / 164, -1, 9);
        }
      }
      sub_55E80(a1, v3);
      --*(_BYTE *)(a1 + 61);
    }
    *(_BYTE *)(a1 + 61) = 0;
    result = a1;
    --*(_WORD *)(a1 + 48);
  }
  return result;
}
// AE400: using guessed type int dword_AE400;

//----- (00058768) --------------------------------------------------------
int sub_58768(__int16 a1, __int16 a2, int a3, unsigned __int8 a4)
{
  __int16 v4; // dx
  char *v5; // esi
  int v7; // [esp+4h] [ebp-4h]

  //fix
  v7 = 0;
  //fix

  v4 = *(_WORD *)(a3 + 4);
  v5 = *(char **)a3;
  if ( (word_12F02E & 1) != 0 )
  {
    sub_60D50(v4, a2, a1, v5, a4, 0);
    return v7;
  }
  else
  {
    if ( (word_12F02E & 8) != 0 )
      sub_60D65(v4, a2, a1, v5, a4, 0);
    return v7;
  }
}
// 587AA: variable 'v7' is possibly undefined
// 12EFF4: using guessed type int dword_12EFF4;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (000587E0) --------------------------------------------------------
char sub_587E0()
{
  char v1[64]; // [esp+0h] [ebp-40h] BYREF

  sprintf(v1, "%s%s/%s/%s.dat", "C:", aCarpetCd_4, aData_1, aTmaps00_0);
  dword_968EC = sub_5CDE0((int)v1, 512);
  if ( dword_968EC == -1 )
  {
    sprintf(v1, "data/%s.dat", aTmaps00_0);
    dword_968EC = sub_5CDE0((int)v1, 512);
  }
  return 1;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 968EC: using guessed type int dword_968EC;

//----- (00058860) --------------------------------------------------------
int sub_58860(unsigned __int16 a1, char *a2)
{
  int v2; // esi
  int v3; // esi
  int result; // eax

  if ( dword_968EC == -1 )
    return dword_968EC;
  v2 = 10 * a1;
  sub_62B30(dword_968EC, *(_DWORD *)(v2 + dword_12D744 + 4), 0);
  v3 = *(_DWORD *)(10 * (a1 + 1) + dword_12D744 + 4) - *(_DWORD *)(dword_12D744 + v2 + 4);
  sub_5CBD0(dword_968EC, (int)a2, v3);
  result = sub_62B60((int)a2, a2);
  if ( result >= 0 )
  {
    if ( !result )
      return v3;
  }
  else
  {
    printf("ERROR decompressing tmap%03d\n", a1);
    return -2;
  }
  return result;
}
// 5CC03: using guessed type _DWORD printf(const char *, ...);
// 968EC: using guessed type int dword_968EC;
// 12D744: using guessed type int dword_12D744;

//----- (00058910) --------------------------------------------------------
char sub_58910(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  __int16 v2; // di
  unsigned __int16 v3; // bx
  _BYTE **v4; // ecx
  _DWORD *v5; // eax

  v1 = *(_WORD *)(10 * a1 + dword_12D744 + 8);
  if ( byte_12E7D0[v1] )
    return 0;
  v2 = *(_WORD *)(10 * a1 + dword_12D744 + 8);
  if ( !dword_12DF8C[v1] )
    return 0;
  v3 = *(_WORD *)(10 * a1 + dword_12D744 + 8);
  if ( v1 < 0x211u )
  {
    do
    {
      if ( v2 != *(_WORD *)(10 * v3 + dword_12D744 + 8) )
        break;
      v4 = (_BYTE **)dword_12DF8C[v3];
      if ( v4 )
      {
        if ( (**v4 & 1) != 0 )
        {
          v5 = (_DWORD *)sub_10FD0(dword_AE3E0, v3);
          sub_10F10(v5);
        }
        sub_36A90(dword_AE3EC, dword_12D748[v3]);
        dword_12DF8C[v3] = 0;
        dword_12D748[v3] = 0;
        dword_12CF00[v3] = 0;
      }
      ++v3;
    }
    while ( v3 < 0x211u );
  }
  return 1;
}
// AE3E0: using guessed type int dword_AE3E0;
// AE3EC: using guessed type int dword_AE3EC;
// 12CF00: using guessed type int dword_12CF00[529];
// 12D744: using guessed type int dword_12D744;
// 12D748: using guessed type int dword_12D748[529];
// 12DF8C: using guessed type int dword_12DF8C[529];

//----- (00058A00) --------------------------------------------------------
char sub_58A00(unsigned __int16 a1)
{
  unsigned __int16 v1; // di
  unsigned __int16 v2; // bx
  _BYTE **v3; // ecx
  _DWORD *v4; // eax

  v1 = *(_WORD *)(dword_12D744 + 10 * a1 + 8);
  if ( !dword_12DF8C[v1] )
    return 0;
  v2 = *(_WORD *)(dword_12D744 + 10 * a1 + 8);
  if ( v1 < 0x211u )
  {
    do
    {
      if ( v1 != *(_WORD *)(10 * v2 + dword_12D744 + 8) )
        break;
      v3 = (_BYTE **)dword_12DF8C[v2];
      if ( v3 )
      {
        if ( (**v3 & 1) != 0 )
        {
          v4 = (_DWORD *)sub_10FD0(dword_AE3E0, v2);
          sub_10F10(v4);
        }
        sub_36A90(dword_AE3EC, dword_12D748[v2]);
        dword_12DF8C[v2] = 0;
        dword_12D748[v2] = 0;
        dword_12CF00[v2] = 0;
      }
      ++v2;
    }
    while ( v2 < 0x211u );
  }
  return 1;
}
// AE3E0: using guessed type int dword_AE3E0;
// AE3EC: using guessed type int dword_AE3EC;
// 12CF00: using guessed type int dword_12CF00[529];
// 12D744: using guessed type int dword_12D744;
// 12D748: using guessed type int dword_12D748[529];
// 12DF8C: using guessed type int dword_12DF8C[529];

//----- (00058AD0) --------------------------------------------------------
int sub_58AD0(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  int v2; // ebx
  unsigned __int16 i; // si
  int v4; // edx

  v1 = *(_WORD *)(10 * a1 + dword_12D744 + 8);
  v2 = 0;
  for ( i = v1; v1 < 0x211u; v2 += *(_DWORD *)v4 + 10 )
  {
    v4 = dword_12D744 + 10 * v1;
    if ( i != *(_WORD *)(v4 + 8) )
      break;
    ++v1;
  }
  return v2;
}
// 12D744: using guessed type int dword_12D744;

//----- (00058B30) --------------------------------------------------------
__int16 sub_58B30(unsigned __int16 a1)
{
  int v1; // eax
  int v2; // ebp
  int *v3; // esi
  unsigned __int16 i; // [esp+0h] [ebp-18h]
  __int16 v6; // [esp+4h] [ebp-14h]

  LOWORD(v1) = *(_WORD *)(dword_12D744 + 10 * a1 + 8);
  v2 = *(_DWORD *)(dword_AE408 + 4);
  v6 = v1;
  for ( i = v1; i < 0x211u; ++i )
  {
    v1 = dword_12D744 + 10 * i;
    if ( v6 != *(_WORD *)(v1 + 8) )
      break;
    if ( !dword_12DF8C[i] )
    {
      v1 = sub_369E0(dword_AE3EC, (unsigned __int16)(4 * ((unsigned int)(*(_DWORD *)v1 + 13) >> 2)), i);
      v3 = (int *)v1;
      if ( v1 )
      {
        v1 = sub_58860(i, *(char **)v1);
        if ( v1 != -1 )
        {
          dword_12D748[i] = (int)v3;
          dword_12DF8C[i] = (int)v3;
          dword_12CF00[i] = v2;
          v1 = *v3;
          if ( (*(_BYTE *)*v3 & 1) != 0 )
            LOWORD(v1) = sub_10D40((unsigned __int16 *)dword_AE3E0, v3, i);
        }
      }
    }
  }
  return v1;
}
// AE3E0: using guessed type int dword_AE3E0;
// AE3EC: using guessed type int dword_AE3EC;
// AE408: using guessed type int dword_AE408;
// 12CF00: using guessed type int dword_12CF00[529];
// 12D744: using guessed type int dword_12D744;
// 12D748: using guessed type int dword_12D748[529];
// 12DF8C: using guessed type int dword_12DF8C[529];

//----- (00058C30) --------------------------------------------------------
int sub_58C30(unsigned int a1)
{
  int v1; // esi
  int v2; // eax
  unsigned __int16 v3; // dx
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // ecx
  unsigned int v8; // edx
  int v9; // ebx
  int v10; // ebx
  unsigned int v11; // edi
  int v12; // ebx
  int result; // eax
  unsigned int v14; // [esp+0h] [ebp-40h]
  unsigned int v15; // [esp+4h] [ebp-3Ch]
  unsigned int v16; // [esp+8h] [ebp-38h]
  unsigned int v17; // [esp+Ch] [ebp-34h]
  unsigned int v18; // [esp+10h] [ebp-30h]
  int v19; // [esp+14h] [ebp-2Ch]
  int v20; // [esp+18h] [ebp-28h]
  int v21; // [esp+1Ch] [ebp-24h]
  int v22; // [esp+20h] [ebp-20h]
  int v23; // [esp+24h] [ebp-1Ch]
  int v24; // [esp+28h] [ebp-18h]
  char v25; // [esp+2Ch] [ebp-14h]

  //fix
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  //fix

  v1 = dword_12D744;
  v25 = 1;
  v2 = 0;
  do
  {
    v3 = v2++;
    *(&v14 + v3) = -1;
    *(&v19 + v3) = -1;
  }
  while ( (unsigned __int16)v2 < 5u );
  v4 = 0;
  do
  {
    v5 = *(unsigned __int16 *)(10 * (unsigned __int16)v4 + v1 + 8);
    if ( dword_12DF8C[(unsigned __int16)v5] && !byte_12E7D0[v5] )
      v25 = 0;
    while ( (unsigned __int16)v4 < 0x211u && *(unsigned __int16 *)(10 * ((unsigned __int16)v4 + 1) + v1 + 8) == v5 )
      ++v4;
    ++v4;
  }
  while ( (unsigned __int16)v4 < 0x211u );
  v6 = 0;
  do
  {
    v7 = *(unsigned __int16 *)(v1 + 10 * (unsigned __int16)v6 + 8);
    if ( (!byte_12E7D0[(unsigned __int16)v7] || v25) && dword_12DF8C[v7] )
    {
      v8 = dword_12CF00[v7];
      v9 = *(unsigned __int16 *)(v1 + 10 * (unsigned __int16)v6 + 8);
      if ( v8 < v14 )
      {
        v10 = v8 ^ v14;
        v8 = v14;
        v14 ^= v10;
        v19 ^= v7;
        v9 = v7 ^ v19;
        v19 = v7;
      }
      if ( v8 < v15 )
      {
        v15 ^= v8;
        v20 ^= v9;
        v8 ^= v15;
        v9 ^= v20;
        v15 ^= v8;
        v20 ^= v9;
      }
      if ( v8 < v16 )
      {
        v16 ^= v8;
        v21 ^= v9;
        v8 ^= v16;
        v9 ^= v21;
        v16 ^= v8;
        v21 ^= v9;
      }
      if ( v8 < v17 )
      {
        v17 ^= v8;
        v22 ^= v9;
        v8 ^= v17;
        v9 ^= v22;
        v17 ^= v8;
        v22 ^= v9;
      }
      if ( v8 < v18 )
      {
        v18 = v8;
        v23 = v9;
      }
    }
    while ( (unsigned __int16)v6 < 0x211u && *(unsigned __int16 *)(10 * ((unsigned __int16)v6 + 1) + v1 + 8) == v7 )
      ++v6;
    ++v6;
  }
  while ( (unsigned __int16)v6 < 0x211u );
  v11 = 0;
  v24 = 0;
  do
  {
    if ( v11 >= a1 || (v12 = 4 * (unsigned __int16)v24, *(int *)((char *)&v19 + v12) <= -1) )
    {
      result = v11;
      dword_12D744 = v1;
      return result;
    }
    dword_12D744 = v1;
    if ( v25 )
    {
      if ( !sub_58A00(*((_WORD *)&v19 + 2 * (unsigned __int16)v24)) )
        goto LABEL_38;
    }
    else if ( !sub_58910(*((_WORD *)&v19 + 2 * (unsigned __int16)v24)) )
    {
      goto LABEL_38;
    }
    v11 += sub_58AD0(*(_WORD *)((char *)&v19 + v12));
LABEL_38:
    v1 = dword_12D744;
    ++v24;
  }
  while ( (unsigned __int16)v24 < 5u );
  return v11;
}
// 12CF00: using guessed type int dword_12CF00[529];
// 12D744: using guessed type int dword_12D744;
// 12DF8C: using guessed type int dword_12DF8C[529];

//----- (00058E70) --------------------------------------------------------
__int16 sub_58E70()
{
  dword_AE3EC = sub_36700(*(_DWORD *)(dword_AE408 + 172), 0x211u, *(_DWORD *)(dword_AE408 + 168));
  if ( dword_AE3EC )
    dword_AE3E0 = sub_10CB0(0x211u);
  sub_587E0();
  memset(dword_12DF8C, 0, sizeof(dword_12DF8C));
  memset(dword_12D748, 0, sizeof(dword_12D748));
  memset(dword_12CF00, 0, sizeof(dword_12CF00));
  sub_59320();
  return sub_59370();
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// AE3E0: using guessed type int dword_AE3E0;
// AE3EC: using guessed type int dword_AE3EC;
// AE408: using guessed type int dword_AE408;
// 12CF00: using guessed type int dword_12CF00[529];
// 12D748: using guessed type int dword_12D748[529];
// 12DF8C: using guessed type int dword_12DF8C[529];

//----- (00058F00) --------------------------------------------------------
int sub_58F00(int a1, int a2)
{
  int v2; // eax

  sub_36C10(&dword_AE3EC);
  sub_11010(&dword_AE3E0);
  sub_59140();
  memset(dword_12DF8C, 0, sizeof(dword_12DF8C));
  memset(dword_12D748, 0, sizeof(dword_12D748));
  v2 = (int)memset(dword_12CF00, 0, sizeof(dword_12CF00));
  BYTE1(v2) = 0;
  byte_968E8 = 0;
  //return sub_58F70((uint32)v2, a2);
  return sub_58F70();//fix
}
// 58F70: using guessed type int sub_58F70(_DWORD, _DWORD);
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 968E8: using guessed type char byte_968E8;
// AE3E0: using guessed type int dword_AE3E0;
// AE3EC: using guessed type int dword_AE3EC;
// 12CF00: using guessed type int dword_12CF00[529];
// 12D748: using guessed type int dword_12D748[529];
// 12DF8C: using guessed type int dword_12DF8C[529];

//----- (00058F70) --------------------------------------------------------
int sub_58F70()
{
  int result; // eax

  if ( dword_968EC != -1 )
  {
    result = sub_5CE50(dword_968EC);
    dword_968EC = -1;
  }
  return result;
}
// 968EC: using guessed type int dword_968EC;

//----- (00058F90) --------------------------------------------------------
int sub_58F90()
{
  unsigned __int16 *v0; // ebx
  int v1; // esi

  sub_587E0();
  v0 = (unsigned __int16 *)&unk_99BA0;
  v1 = dword_12EFF4;
  while ( v0[3] || v0[4] )
  {
    if ( sub_58860(*v0, (char *)v1) == -1 )
    {
      *(_WORD *)(v1 + 2) = 255;
      *(_WORD *)(v1 + 4) = 255;
      *(_BYTE *)(v1 + 1) = 1;
    }
    if ( v0[3] )
    {
      if ( !v0[4] )
        v0[4] = v0[3] * *(unsigned __int16 *)(v1 + 4) / *(unsigned __int16 *)(v1 + 2);
    }
    else
    {
      v0[3] = v0[4] * *(unsigned __int16 *)(v1 + 2) / *(unsigned __int16 *)(v1 + 4);
    }
    v0 += 7;
    *((_BYTE *)v0 - 2) = *(_BYTE *)(v1 + 1);
  }
  return sub_58F70();
}
// 12EFF4: using guessed type int dword_12EFF4;

//----- (00059050) --------------------------------------------------------
bool sub_59050(unsigned __int16 a1)
{
  int v1; // eax
  int v2; // esi
  signed int i; // ebx
  unsigned __int16 v4; // ax

  //fix
  i = 0;
  //fix

  v1 = sub_58AD0(a1);
  v2 = 0;
  //fix
  /*
  for (i = v1 - ios::failure::cause(dword_AE3EC) + 20; i > 0; i -= sub_58C30(i))
  {
    v4 = v2++;
    if ( v4 >= 4u )
      break;
  }*/
  if ( i <= 0 )
  {
    sub_58B30(a1);
    *(_BYTE *)(dword_AE408 + 149) = 5;
  }
  return dword_12DF8C[a1] != 0;
}
// 369D0: using guessed type _DWORD ios::failure::cause(_DWORD);
// AE3EC: using guessed type int dword_AE3EC;
// AE408: using guessed type int dword_AE408;
// 12DF8C: using guessed type int dword_12DF8C[529];

//----- (000590D0) --------------------------------------------------------
char *sub_590D0()
{
  unsigned __int16 i; // bx
  char *result; // eax
  char **v2; // ecx
  char v3; // cl
  int v4; // eax

  //fix
  result = 0;
  //fix

  for ( i = 0; i < 0x211u; ++i )
  {
    result = (char *)(4 * i);
    v2 = *(char ***)((char *)dword_12DF8C + (_DWORD)result);
    if ( v2 )
    {
      result = *v2;
      v3 = **v2;
      if ( (v3 & 8) != 0 )
      {
        *result = v3 & 0xF7;
        if ( (v3 & 1) != 0 )
        {
          v4 = sub_10FD0(dword_AE3E0, i);
          result = (char *)sub_10EB0(v4);
        }
      }
    }
  }
  return result;
}
// AE3E0: using guessed type int dword_AE3E0;
// 12DF8C: using guessed type int dword_12DF8C[529];

//----- (00059140) --------------------------------------------------------
int sub_59140()
{
  return (uint32)memset(&byte_12E9E1, 0, 529);
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 12E9E1: using guessed type char byte_12E9E1;

//----- (00059160) --------------------------------------------------------
__int16 *sub_59160(unsigned __int16 a1, unsigned __int16 a2, signed __int16 a3)
{
  __int16 *result; // eax
  unsigned __int16 *v4; // ebx
  __int16 *v5; // edx
  __int16 v6; // cx
  unsigned __int16 v7; // di

  result = &word_989C6;
  v4 = 0;
  if ( word_989C6 >= 0 )
  {
    v5 = &word_989C6 + 2;
    do
    {
      if ( *result == a1 && result[1] == a2 )
        v4 = (unsigned __int16 *)v5;
      v5 += 17;
      v6 = result[17];
      result += 17;
    }
    while ( v6 >= 0 );
  }
  if ( v4 )
  {
    while ( 1 )
    {
      v7 = *v4;
      if ( (*v4 & 0x8000u) != 0 )
        break;
      ++v4;
      result = (__int16 *)sub_591E0(v7);
    }
  }
  else if ( a3 >= 0 )
  {
    return (__int16 *)sub_591E0(a3);
  }
  return result;
}
// 989C6: using guessed type __int16 word_989C6;

//----- (000591E0) --------------------------------------------------------
int sub_591E0(unsigned __int16 a1)
{
  unsigned __int16 *v1; // eax
  char v2; // bl
  int result; // eax

  v1 = (unsigned __int16 *)((char *)&unk_99BA0 + 14 * a1);
  v2 = *((_BYTE *)v1 + 11);
  result = *(unsigned __int16 *)(dword_12D744 + 10 * *v1 + 8);
  byte_12E9E1[result] = v2;
  return result;
}
// 12D744: using guessed type int dword_12D744;

//----- (00059230) --------------------------------------------------------
char sub_59230()
{
  unsigned __int16 v0; // bx
  char result; // al
  unsigned int v2; // edi
  unsigned __int16 i; // si
  char v4; // [esp+0h] [ebp-18h]
  char v5; // [esp+4h] [ebp-14h]

  v5 = 0;
  if ( !dword_AE3EC )
    sub_58E70();
  v0 = 0;
  memset(dword_12CF00, 0, sizeof(dword_12CF00));
  do
  {
    result = v0;
    if ( !byte_12E9E1[v0] )
      result = sub_58910(v0);
    ++v0;
  }
  while ( v0 < 0x211u );
  v4 = -1;
  do
  {
    if ( v5 )
      break;
    for ( i = 0; i < 0x211u; ++i )
    {
      if ( v5 )
        break;
      if ( v4 == byte_12E9E1[i] && !dword_12DF8C[i] )
      {
        v2 = sub_58AD0(i);
        //fix
        /*
        if ( v2 >= ios::failure::cause(dword_AE3EC) )
        {
          if ( (unsigned int)ios::failure::cause < 0x400 )
            v5 = 1;
        }
        else
        {
          sub_58B30(i);
        }*/
      }
    }
    result = --v4;
  }
  while ( v4 );
  return result;
}
// 369D0: using guessed type _DWORD ios::failure::cause(_DWORD);
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// AE3EC: using guessed type int dword_AE3EC;
// 12CF00: using guessed type int dword_12CF00[529];
// 12DF8C: using guessed type int dword_12DF8C[529];

//----- (00059320) --------------------------------------------------------
void sub_59320()
{
  unsigned __int16 *v0; // ebx

  v0 = (unsigned __int16 *)&unk_99BA0;
  memset(byte_12E7D0, 0, sizeof(byte_12E7D0));
  if ( byte_968F0 )
  {
    while ( v0[3] || v0[4] )
    {
      if ( *((_BYTE *)v0 + 11) == 0xFF )
        byte_12E7D0[*v0] = -1;
      v0 += 7;
    }
  }
  JUMPOUT(0x59319);
}
// 59342: control flows out of bounds to 59319
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 968F0: using guessed type char byte_968F0;

//----- (00059370) --------------------------------------------------------
__int16 sub_59370()
{
  unsigned __int16 i; // bx
  __int16 result; // ax

  for ( i = 0; i < 0x211u; ++i )
  {
    result = i;
    if ( byte_12E7D0[i] )
      result = sub_58B30(i);
  }
  return result;
}

//----- (000593B0) --------------------------------------------------------
int sub_593B0()
{
  int v0; // esi
  int result; // eax

  memset((void*)(dword_AE400 + 44), 0, 532);
  v0 = dword_AE400;
  result = 0;
  do
  {
    if ( dword_12DF8C[(unsigned __int16)result] )
    {
      *(_BYTE *)(v0 + (unsigned __int16)result + 44) = 1;
      if ( byte_12E7D0[(unsigned __int16)result] )
        ++*(_BYTE *)(v0 + (unsigned __int16)result + 44);
    }
    ++result;
  }
  while ( (unsigned __int16)result < 0x211u );
  dword_AE400 = v0;
  return result;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// AE400: using guessed type int dword_AE400;
// 12DF8C: using guessed type int dword_12DF8C[529];

//----- (00059420) --------------------------------------------------------
char sub_59420()
{
  unsigned __int16 i; // bx
  char result; // al
  unsigned int v2; // edi
  unsigned __int16 j; // si
  char v4; // [esp+0h] [ebp-14h]
  char v5; // [esp+4h] [ebp-10h]

  v5 = 0;
  if ( !dword_AE3EC )
    sub_58E70();
  for ( i = 0; i < 0x211u; ++i )
  {
    result = i;
    if ( !*(_BYTE *)(dword_AE400 + i + 44) )
      result = sub_58910(i);
  }
  v4 = 2;
  do
  {
    if ( v5 )
      break;
    for ( j = 0; j < 0x211u; ++j )
    {
      if ( v5 )
        break;
      if ( v4 == *(_BYTE *)(j + dword_AE400 + 44) && !dword_12DF8C[j] )
      {
        v2 = sub_58AD0(j);
        //fix
        /*
        if ( v2 >= ios::failure::cause(dword_AE3EC) )
        {
          if ( ios::failure::cause(dword_AE3EC) < 0x400u )
            v5 = 1;
        }
        else
        {
          sub_58B30(j);
        }*/
      }
    }
    result = --v4;
  }
  while ( v4 );
  return result;
}
// 369D0: using guessed type _DWORD ios::failure::cause(_DWORD);
// AE3EC: using guessed type int dword_AE3EC;
// AE400: using guessed type int dword_AE400;
// 12DF8C: using guessed type int dword_12DF8C[529];

//----- (00059500) --------------------------------------------------------
unsigned int sub_59500(unsigned int **a1)
{
  unsigned int **v1; // ebx
  unsigned int result; // eax
  unsigned int *v3; // ecx

  v1 = a1;
  if ( *a1 )
  {
    do
    {
      if ( (word_12F02E & 1) != 0 )
        result = sub_65D70(**v1, *v1[1], *v1[2]);
      else
        result = (unsigned int)sub_65DC0((unsigned int *)**v1, *v1[1], *v1[2]);
      v3 = v1[3];
      v1 += 3;
    }
    while ( v3 );
  }
  return result;
}
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00059560) --------------------------------------------------------
unsigned int sub_59560(unsigned int **a1)
{
  unsigned int **v1; // ebx
  unsigned int result; // eax
  unsigned int *v3; // ecx

  v1 = a1;
  if ( *a1 )
  {
    do
    {
      if ( (word_12F02E & 1) != 0 )
        result = sub_66390(**v1, *v1[1], *v1[2]);
      else
        result = (unsigned int)sub_66410((unsigned int *)**v1, *v1[1], *v1[2]);
      v3 = v1[3];
      v1 += 3;
    }
    while ( v3 );
  }
  return result;
}
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00059720) --------------------------------------------------------
int sub_59720()
{
  if ( word_12F02E == 1 )
    return sub_59750(320, 200);
  else
    return sub_59750(320, 240);
}
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00059750) --------------------------------------------------------
int sub_59750(__int16 a1, __int16 a2)
{
  __int16 v2; // si
  __int16 v3; // bx
  int result; // eax
  __int16 v5; // ax
  __int16 v6[14]; // [esp+0h] [ebp-40h] BYREF
  char v7[36]; // [esp+1Ch] [ebp-24h] BYREF

  v2 = a1;
  v3 = a2;
  memset(v6, 0, sizeof(v6));
  result = (int)memset(v7, 0, 28);
  if ( dword_9AD98 > 0 )
  {
    if ( a1 != -1 || (result = a2, a2 != -1) )
    {
      result = a1;
      if ( a1 != -1 )
      {
        v6[0] = 4;
        if ( a1 <= 0 )
        {
          if ( (word_12F02E & 1) != 0 )
            goto LABEL_12;
        }
        else
        {
          if ( a1 > 638 )
            v2 = 638;
          word_9AD90 = v2;
          if ( (word_12F02E & 1) != 0 )
          {
LABEL_12:
            v6[4] = v2;
            if ( a2 <= 0 )
            {
              if ( (word_12F02E & 1) != 0 )
                v5 = word_9AD92;
              else
                v5 = 8 * word_9AD92;
              v6[6] = v5;
              return int386(51, (uint32)v6, (uint32)v7);
            }
            if ( (word_12F02E & 1) != 0 )
            {
              if ( a2 > 398 )
                v3 = 398;
              word_9AD92 = v3;
              if ( (word_12F02E & 1) != 0 )
              {
                v6[6] = v3;
                return int386(51, (uint32)v6, (uint32)v7);
              }
            }
            else
            {
              if ( a2 > 478 )
                v3 = 478;
              word_9AD92 = v3;
              if ( (word_12F02E & 1) != 0 )
              {
                v6[6] = v3;
                return int386(51, (uint32)v6, (uint32)v7);
              }
            }
            v6[6] = 8 * v3;
            return int386(51, (uint32)v6, (uint32)v7);
          }
        }
        v2 *= 8;
        goto LABEL_12;
      }
    }
  }
  return result;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 62F78: using guessed type _DWORD int386(_DWORD, _DWORD, _DWORD);
// 9AD90: using guessed type __int16 word_9AD90;
// 9AD92: using guessed type __int16 word_9AD92;
// 9AD98: using guessed type int dword_9AD98;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (000599B0) --------------------------------------------------------
void sub_599B0(__int16 a1)
{
  char *v1; // esi
  char *v2; // esi

  if ( !byte_9AD96 )
    sub_5BDF8();
  sub_61A1C(0);
  qmemcpy(&unk_A0000, (const void *)dword_12EFF4, 0x10000u);
  v1 = (char *)(dword_12EFF4 + 0x10000);
  sub_61A1C(1);
  qmemcpy(&unk_A0000, v1, 0x10000u);
  v1 += 0x10000;
  sub_61A1C(2);
  qmemcpy(&unk_A0000, v1, 0x10000u);
  v2 = v1 + 0x10000;
  sub_61A1C(3);
  if ( a1 == 400 )
  {
    qmemcpy(&unk_A0000, v2, 0xE800u);
    sub_5BE50();
  }
  else
  {
    qmemcpy(&unk_A0000, v2, 0x10000u);
    sub_61A1C(4);
    qmemcpy(&unk_A0000, v2 + 0x10000, 0xB000u);
    if ( !byte_9AD96 )
      sub_5BE50();
  }
}
// 9AD96: using guessed type char byte_9AD96;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (00059A80) --------------------------------------------------------
int sub_59A80(int a1)
{
  int result; // eax

  result = sub_5A090(a1, 1);
  if ( result )
  {
    sub_37440(*(__int16 *)(a1 + 24), 1);
    return sub_41E80(a1);
  }
  return result;
}

//----- (00059AB0) --------------------------------------------------------
int sub_59AB0(int a1)
{
  int result; // eax

  result = sub_5A090(a1, 0);
  if ( result )
  {
    sub_37440(*(__int16 *)(a1 + 24), 1);
    return sub_41E80(a1);
  }
  return result;
}

//----- (00059AE0) --------------------------------------------------------
int sub_59AE0(int a1)
{
  int result; // eax

  if ( *(_WORD *)(a1 + 26) )
  {
    result = sub_5A120(a1, 1);
    if ( !result )
      --*(_WORD *)(a1 + 26);
  }
  else
  {
    result = sub_5A090(a1, 1);
    if ( result )
    {
      result = sub_37440(*(__int16 *)(a1 + 24), 0);
      *(_WORD *)(a1 + 26) = 10;
    }
  }
  return result;
}

//----- (00059B30) --------------------------------------------------------
int sub_59B30(int a1)
{
  int result; // eax

  if ( *(_WORD *)(a1 + 26) )
  {
    result = sub_5A120(a1, 0);
    if ( !result )
      --*(_WORD *)(a1 + 26);
  }
  else
  {
    result = sub_5A090(a1, 0);
    if ( result )
    {
      result = sub_37440(*(__int16 *)(a1 + 24), 0);
      *(_WORD *)(a1 + 26) = 10;
    }
  }
  return result;
}

//----- (00059B80) --------------------------------------------------------
void sub_59B80(int a1)
{
  int v1; // esi
  int v2; // eax
  int v3; // edx
  int v4; // eax

  v1 = 164 * *(unsigned __int16 *)(dword_AE400 + 13333) + dword_AE400 + 29795;
  v2 = *(_DWORD *)(v1 + 160);
  if ( *(_WORD *)(v2 + 50) )
  {
    if ( (*(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(v2 + 48) + 13325) & 2) != 0 )
    {
      sub_37440(*(__int16 *)(a1 + 24), 0);
      sub_41E80(a1);
      v3 = 2049 * *(__int16 *)(*(_DWORD *)(v1 + 160) + 48);
      v4 = dword_AE400 + 29795;
      *(_BYTE *)(v3 + v4 - 16470) = *(_BYTE *)(v3 + dword_AE400 + 13325) & 0xFD;
      sub_55370((a1 - v4) / 164, -1, 41);
    }
  }
}
// AE400: using guessed type int dword_AE400;

//----- (00059C40) --------------------------------------------------------
int sub_59C40(int a1)
{
  int result; // eax

  result = sub_5A090(a1, 1);
  if ( result )
  {
    sub_37440(*(__int16 *)(a1 + 24), 1);
    return sub_41E80(a1);
  }
  return result;
}

//----- (00059C70) --------------------------------------------------------
int sub_59C70(int a1)
{
  int result; // eax

  result = sub_5A090(a1, 0);
  if ( result )
  {
    sub_37440(*(__int16 *)(a1 + 24), 1);
    return sub_41E80(a1);
  }
  return result;
}

//----- (00059CA0) --------------------------------------------------------
int sub_59CA0(int a1)
{
  int result; // eax

  if ( *(_WORD *)(a1 + 26) )
  {
    result = sub_5A120(a1, 1);
    if ( !result )
      --*(_WORD *)(a1 + 26);
  }
  else
  {
    result = sub_5A090(a1, 1);
    if ( result )
    {
      result = sub_37440(*(__int16 *)(a1 + 24), 0);
      *(_WORD *)(a1 + 26) = 10;
    }
  }
  return result;
}

//----- (00059CF0) --------------------------------------------------------
int sub_59CF0(int a1)
{
  int result; // eax

  if ( *(_WORD *)(a1 + 26) )
  {
    result = sub_5A120(a1, 0);
    if ( !result )
      --*(_WORD *)(a1 + 26);
  }
  else
  {
    result = sub_5A090(a1, 0);
    if ( result )
    {
      result = sub_37440(*(__int16 *)(a1 + 24), 0);
      *(_WORD *)(a1 + 26) = 10;
    }
  }
  return result;
}

//----- (00059D40) --------------------------------------------------------
int sub_59D40(int a1)
{
  int result; // eax

  result = sub_5A090(a1, 1);
  if ( result )
  {
    sub_37440(*(__int16 *)(a1 + 24), 1);
    return sub_41E80(a1);
  }
  return result;
}

//----- (00059D70) --------------------------------------------------------
int sub_59D70(int a1)
{
  int result; // eax

  result = sub_5A090(a1, 0);
  if ( result )
  {
    sub_37440(*(__int16 *)(a1 + 24), 1);
    return sub_41E80(a1);
  }
  return result;
}

//----- (00059DA0) --------------------------------------------------------
int sub_59DA0(int a1)
{
  int result; // eax

  if ( *(_WORD *)(a1 + 26) )
  {
    result = sub_5A120(a1, 1);
    if ( !result )
      --*(_WORD *)(a1 + 26);
  }
  else
  {
    result = sub_5A090(a1, 1);
    if ( result )
    {
      result = sub_37440(*(__int16 *)(a1 + 24), 0);
      *(_WORD *)(a1 + 26) = 10;
    }
  }
  return result;
}

//----- (00059DF0) --------------------------------------------------------
int sub_59DF0(int a1)
{
  int result; // eax

  if ( *(_WORD *)(a1 + 26) )
  {
    result = sub_5A120(a1, 0);
    if ( !result )
      --*(_WORD *)(a1 + 26);
  }
  else
  {
    result = sub_5A090(a1, 0);
    if ( result )
    {
      result = sub_37440(*(__int16 *)(a1 + 24), 0);
      *(_WORD *)(a1 + 26) = 10;
    }
  }
  return result;
}

//----- (00059E40) --------------------------------------------------------
int sub_59E40(int a1, int a2)
{
  int result; // eax
  __int16 v3; // dx
  int v4; // edx
  __int16 v5; // di

  result = a2;
  if ( a2 == -1 )
  {
    result = 0;
    v4 = 0;
    while ( (unsigned int)result > 0xB && result != 16 || !*(_DWORD *)(v4 + dword_AE408 + 36382) )
    {
      ++result;
      v4 += 4;
      if ( result > 16 )
      {
        v5 = *(_WORD *)(a1 + 26);
        if ( !v5 )
        {
          *(_WORD *)(a1 + 26) = 16;
          return result;
        }
        if ( v5 != 1 )
        {
          *(_WORD *)(a1 + 26) = v5 - 1;
          return result;
        }
        goto LABEL_6;
      }
    }
  }
  else if ( !*(_DWORD *)(dword_AE408 + 4 * a2 + 36382) )
  {
    v3 = *(_WORD *)(a1 + 26);
    if ( v3 )
    {
      if ( v3 == 1 )
      {
LABEL_6:
        sub_55370((a1 - (dword_AE400 + 29795)) / 164, -1, 41);
        sub_37440(*(__int16 *)(a1 + 24), 1);
        return sub_41E80(a1);
      }
      else
      {
        *(_WORD *)(a1 + 26) = v3 - 1;
      }
    }
    else
    {
      *(_WORD *)(a1 + 26) = 16;
    }
  }
  return result;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (00059F60) --------------------------------------------------------
int sub_59F60(int a1)
{
  return sub_59E40(a1, 0);
}

//----- (00059F70) --------------------------------------------------------
int sub_59F70(int a1)
{
  return sub_59E40(a1, 1);
}

//----- (00059F80) --------------------------------------------------------
int sub_59F80(int a1)
{
  return sub_59E40(a1, 2);
}

//----- (00059F90) --------------------------------------------------------
int sub_59F90(int a1)
{
  return sub_59E40(a1, 3);
}

//----- (00059FA0) --------------------------------------------------------
int sub_59FA0(int a1)
{
  return sub_59E40(a1, 4);
}

//----- (00059FB0) --------------------------------------------------------
int sub_59FB0(int a1)
{
  return sub_59E40(a1, 5);
}

//----- (00059FC0) --------------------------------------------------------
int sub_59FC0(int a1)
{
  return sub_59E40(a1, 6);
}

//----- (00059FD0) --------------------------------------------------------
int sub_59FD0(int a1)
{
  return sub_59E40(a1, 7);
}

//----- (00059FE0) --------------------------------------------------------
int sub_59FE0(int a1)
{
  return sub_59E40(a1, 8);
}

//----- (00059FF0) --------------------------------------------------------
int sub_59FF0(int a1)
{
  return sub_59E40(a1, 9);
}

//----- (0005A000) --------------------------------------------------------
int sub_5A000(int a1)
{
  return sub_59E40(a1, 10);
}

//----- (0005A010) --------------------------------------------------------
int sub_5A010(int a1)
{
  return sub_59E40(a1, 11);
}

//----- (0005A020) --------------------------------------------------------
int sub_5A020(int a1)
{
  return sub_59E40(a1, 12);
}

//----- (0005A030) --------------------------------------------------------
int sub_5A030(int a1)
{
  return sub_59E40(a1, 13);
}

//----- (0005A040) --------------------------------------------------------
int sub_5A040(int a1)
{
  return sub_59E40(a1, 14);
}

//----- (0005A050) --------------------------------------------------------
int sub_5A050(int a1)
{
  return sub_59E40(a1, 15);
}

//----- (0005A060) --------------------------------------------------------
int sub_5A060(int a1)
{
  return sub_59E40(a1, 16);
}

//----- (0005A070) --------------------------------------------------------
int sub_5A070(int a1)
{
  return sub_59E40(a1, -1);
}

//----- (0005A090) --------------------------------------------------------
int sub_5A090(int a1, int a2)
{
  unsigned int i; // ebx

  if ( (*(_BYTE *)(a1 + 63) & 7) == 0 )
  {
    for ( i = *(_DWORD *)(dword_AE408 + 36462); i > dword_AE400 + 29795; i = *(_DWORD *)i )
    {
      if ( !*(_BYTE *)(i + 65) && sub_11950(a1, i) == a2 )
      {
        sub_55370((int)(i - (dword_AE400 + 29795)) / 164, -1, 41);
        return 1;
      }
    }
    *(_WORD *)(a1 + 76) = sub_11F50((__int16 *)(a1 + 72));
  }
  return 0;
}
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;

//----- (0005A120) --------------------------------------------------------
int sub_5A120(int a1, int a2)
{
  unsigned __int16 v2; // si
  int v3; // ebx

  v2 = 0;
  v3 = dword_AE400 + 13323;
  while ( v2 < *(_WORD *)(dword_AE400 + 10) )
  {
    if ( sub_11950(a1, 164 * *(unsigned __int16 *)(v3 + 10) + dword_AE400 + 29795) == a2 )
      return 1;
    v3 += 2049;
    ++v2;
  }
  return 0;
}
// AE400: using guessed type int dword_AE400;

//----- (0005A180) --------------------------------------------------------
int sub_5A180(_BYTE *a1, int a2, __int16 a3, unsigned __int8 a4)
{
  _BYTE *v4; // esi
  int v5; // ebx
  char v6; // ah
  int result; // eax
  unsigned __int16 v8; // ax
  int v9; // edi
  int v10; // eax

  v4 = a1;
  v5 = a2;
  v6 = *a1;
  word_9ADFC = 64;
  if ( !v6 )
  {
    result = a2;
    word_9ADFC = 0;
    return result;
  }
  while ( (__int16)v5 < 640 )
  {
    v8 = (unsigned __int8)*v4;
    if ( v8 < 0xAu )
    {
      if ( *v4 )
      {
        if ( v8 != 9 )
          goto LABEL_13;
        goto LABEL_15;
      }
    }
    else if ( (unsigned __int8)*v4 <= 0xAu )
    {
      v5 = a2;
      a3 += sub_5A3B0();
    }
    else
    {
      if ( v8 < 0xDu )
        goto LABEL_13;
      if ( v8 > 0xDu )
      {
        if ( v8 != 32 )
        {
LABEL_13:
          if ( *v4 )
          {
            v9 = 6 * ((unsigned __int8)*v4 + 1);
            sub_58768(v5, a3, v9 + dword_AE44C, a4);
            HIWORD(v10) = HIWORD(dword_AE44C);
            LOWORD(v10) = *(unsigned __int8 *)(v9 + dword_AE44C + 4);
LABEL_16:
            v5 += v10;
            goto LABEL_17;
          }
        }
LABEL_15:
        LOWORD(v10) = sub_5A3A0();
        goto LABEL_16;
      }
    }
LABEL_17:
    if ( !*++v4 )
      break;
  }
  result = v5;
  word_9ADFC = 0;
  return result;
}
// 5A23A: variable 'v10' is possibly undefined
// 9ADFC: using guessed type __int16 word_9ADFC;
// AE44C: using guessed type int dword_AE44C;

//----- (0005A3A0) --------------------------------------------------------
__int16 sub_5A3A0()
{
  return *(unsigned __int8 *)(dword_AE44C + 202);
}
// AE44C: using guessed type int dword_AE44C;

//----- (0005A3B0) --------------------------------------------------------
__int16 sub_5A3B0()
{
  return *(unsigned __int8 *)(dword_AE44C + 203);
}
// AE44C: using guessed type int dword_AE44C;

//----- (0005A3C0) --------------------------------------------------------
int sub_5A3C0(__int16 a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  v2 = dword_AE3B8[result];
  if ( !v2 )
    v2 = dword_AE3B8[0];
  dword_AE44C = v2;
  return result * 4;
}
// AE3B8: using guessed type int dword_AE3B8[];
// AE44C: using guessed type int dword_AE44C;

//----- (0005A3E3) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_5A3E3(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7)
{
  int v7; // [esp-4h] [ebp-4h] BYREF
  //fix 
  /*
  ((void (*)(_DWORD, _DWORD, _DWORD, _DWORD, int, int, int, int, int *, int, int, int))_GETDS)(
    (unsigned __int16)__GS__,
    (unsigned __int16)__FS__,
    (unsigned __int16)__ES__,
    (unsigned __int16)__DS__,
    a1,
    a2,
    a3,
    a4,
    &v7,
    a5,
    a6,
    a7);*/
}
// 5A458: positive sp value 4 has been found
// 62455: using guessed type _DWORD outp(_DWORD, char);
// 62460: using guessed type _DWORD chain_intr(_DWORD);
// AC5D4: using guessed type int dword_AC5D4;
// AE408: using guessed type int dword_AE408;

//----- (0005A459) --------------------------------------------------------
int sub_5A459(int a1, __int16 a2)
{
  int v2; // eax
  int result; // eax

  //fix
  result = 0;
  //fix

  *(_DWORD *)(dword_AE408 + 206) = 9903;
  *(_DWORD *)(dword_AE408 + 210) = 0;
  v2 = dos_getvect(8);
  word_12EC04 = a2;
  dword_12EC00 = v2;
  outp(67, 54);
  outp(64, *(_DWORD *)(dword_AE408 + 206));
  outp(64, BYTE1(*(_DWORD *)(dword_AE408 + 206)));
  //fix result = dos_setvect(8, sub_5A3E3, (unsigned __int16)__CS__);
  byte_9AD04 = 1;
  return result;
}
// 62455: using guessed type _DWORD outp(_DWORD, char);
// 62481: using guessed type _DWORD dos_getvect(_DWORD);
// 624B5: using guessed type _DWORD dos_setvect(_DWORD, _DWORD, _DWORD);
// 9AD04: using guessed type char byte_9AD04;
// AE408: using guessed type int dword_AE408;
// 12EC00: using guessed type int dword_12EC00;
// 12EC04: using guessed type __int16 word_12EC04;

//----- (0005A4EA) --------------------------------------------------------
int sub_5A4EA()
{
  int result; // eax

  if ( byte_9AD04 == 1 )
  {
    outp(67, 54);
    outp(64, 0);
    outp(64, 0);
    result = dos_setvect(8, dword_12EC00, (unsigned __int16)word_12EC04);
  }
  byte_9AD04 = 0;
  return result;
}
// 62455: using guessed type _DWORD outp(_DWORD, char);
// 624B5: using guessed type _DWORD dos_setvect(_DWORD, _DWORD, _DWORD);
// 9AD04: using guessed type char byte_9AD04;
// 12EC00: using guessed type int dword_12EC00;
// 12EC04: using guessed type __int16 word_12EC04;

//----- (0005A560) --------------------------------------------------------
int sub_5A560()
{
  __int16 v0; // bx
  __int16 v1; // bx
  __int16 v2; // bx
  __int16 v3; // bx
  __int16 v4; // bx
  __int16 v5; // bx
  __int16 v6; // bx
  __int16 v7; // bx
  __int16 v8; // bx
  __int16 v9; // bx
  __int16 v10; // bx
  __int16 v11; // bx
  __int16 v12; // bx
  __int16 v13; // bx
  __int16 v14; // bx
  __int16 v15; // bx
  __int16 v16; // bx
  __int16 v17; // bx
  __int16 v18; // bx
  __int16 v19; // bx
  int v20; // eax
  __int16 v21; // bx
  __int16 v22; // bx
  __int16 v23; // bx
  __int16 v24; // bx
  __int16 v25; // bx
  int *v26; // edi
  __int16 v27; // si
  int i; // ebx
  unsigned __int8 v29; // al
  int v30; // eax
  int result; // eax
  char v32[272]; // [esp+0h] [ebp-110h] BYREF

  if ( (*(_BYTE *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13328) & 8) != 0 )
  {
    sub_5A3C0(1);
    sub_5A180((uint8*)aProductName, 320, 0, byte_AE068);
    v0 = sub_5A3B0();
    sub_5A180((uint8*)aMagicCarpet, 320, v0, byte_AD177);
    v1 = sub_5A3B0() + v0;
    sub_5A180((uint8*)aVersionNumber, 320, v1, byte_AE068);
    v2 = sub_5A3B0() + v1;
    sub_5A180((uint8*)aBetaV80, 320, v2, byte_AD177);
    v3 = sub_5A3B0() + v2;
    sub_5A180((uint8*)aVersionDate, 320, v3, byte_AE068);
    v4 = sub_5A3B0() + v3;
    sprintf(v32, "%s %s", a162618, aJun051995);
    sub_5A180((uint8*)v32, 320, v4, byte_AD177);
    v5 = sub_5A3B0() + v4;
    sub_5A180((uint8*)aProgrammer, 320, v5, byte_AE068);
    v6 = sub_5A3B0() + v5;
    sub_5A180((uint8*)aBullfrogSeanCo, 320, v6, byte_AD177);
    v7 = sub_5A3B0() + v6;
    sub_5A180((uint8*)aSuppliedTo, 320, v7, byte_AE068);
    v8 = sub_5A3B0() + v7;
    sub_5A180((uint8*)aPublic, 320, v8, byte_AD177);
    v9 = sub_5A3B0() + v8;
    sub_5A180((uint8*)aLevelNumber, 320, v9, byte_AE068);
    v10 = sub_5A3B0() + v9;
    sprintf(v32, "%d", *(unsigned __int16 *)(dword_AE408 + 17));
    sub_5A180((uint8*)v32, 320, v10, byte_AD177);
    v11 = sub_5A3B0() + v10;
    if ( (*(_BYTE *)dword_AE408 & 0x10) != 0 )
    {
      sub_5A180((uint8*)aTransferRate, 320, v11, byte_AE068);
      v12 = sub_5A3B0() + v11;
      sprintf(v32, "%d", *(_DWORD *)(dword_AE408 + 157));
      sub_5A180((uint8*)v32, 320, v12, byte_AD177);
      v11 = sub_5A3B0() + v12;
    }
    sub_5A180((uint8*)aGameturn, 320, v11, byte_AE068);
    v13 = sub_5A3B0() + v11;
    sprintf(v32, "%d", *(_DWORD *)(dword_AE408 + 153));
    sub_5A180((uint8*)v32, 320, v13, byte_AD177);
    v14 = sub_5A3B0() + v13;
    sub_5A180((uint8*)aSoundNumber, 320, v14, byte_AE068);
    v15 = sub_5A3B0() + v14;
    sprintf(v32, "%d", (unsigned __int8)byte_939EC);
    sub_5A180((uint8*)v32, 320, v15, byte_AD177);
    v16 = sub_5A3B0() + v15;
    sub_5A180((uint8*)aGameTurn, 320, v16, byte_AE068);
    v17 = sub_5A3B0() + v16;
    sprintf(v32, "%d %d", *(_DWORD *)(dword_AE400 + 2049 * *(__int16 *)(dword_AE400 + 8) + 13341), dword_AC5D4);
    sub_5A180((uint8*)v32, 320, v17, byte_AD177);
    v18 = sub_5A3B0() + v17;
    sub_5A180((uint8*)aThing, 320, v18, byte_AE068);
    v19 = sub_5A3B0() + v18;
    v20 = sub_37710();
    sprintf(v32, "Thing %d, Active %d", 164, 1000 - v20);
    sub_5A180((uint8*)v32, 320, v19, byte_AD177);
    v21 = sub_5A3B0() + v19;
    sprintf(v32, "Carpet %d", sub_38D09);
    sub_5A180((uint8*)v32, 320, v21, byte_AD177);
    v22 = sub_5A3B0() + v21;
    sprintf(v32, "Tape %d", 36478);
    sub_5A180((uint8*)v32, 320, v22, byte_AD177);
    v23 = sub_5A3B0() + v22;
    sprintf(v32, "Heap %d", *(_DWORD *)(dword_AE408 + 172));
    sub_5A180((uint8*)v32, 320, v23, byte_AD177);
    v24 = sub_5A3B0() + v23;
    sub_63338();
    sub_5A180((uint8*)aMemoryUsedFree, 320, v24, byte_AE068);
    v25 = sub_5A3B0() + v24;
    sprintf(v32, "%d/%d", dword_1314A8, dword_1314A4);
    sub_5A180((uint8*)v32, 320, v25, byte_AD177);
    sub_5A3B0();
    v26 = &dword_1302A0;
    v27 = 0;
    for ( i = 0; v26; v26 = (int *)v26[2] )
    {
      sprintf(v32, "s%7.7d,u%01d", v26[1], *((unsigned __int8 *)v26 + 16));
      if ( dword_12F6A4[3 * *((unsigned __int8 *)v26 + 17)] )
        v29 = byte_AD168[0];
      else
        v29 = byte_AE068;
      sub_5A180((uint8*)v32, v27, i, v29);
      LOWORD(v30) = sub_5A3B0();
      i += v30;
      if ( (__int16)i > 400 - sub_5A3B0() )
      {
        i = 0;
        v27 += 12 * sub_5A3A0();
      }
    }
  }
  result = dword_AE408;
  if ( *(_DWORD *)(dword_AE408 + 25) == 16273849 )
    *(_BYTE *)(dword_AE408 + 24) |= 2u;
  return result;
}
// 5AC1C: variable 'v30' is possibly undefined
// 38D09: using guessed type int sub_38D09();
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 939EC: using guessed type char byte_939EC;
// AC5D4: using guessed type int dword_AC5D4;
// AD177: using guessed type char byte_AD177;
// AE068: using guessed type char byte_AE068;
// AE400: using guessed type int dword_AE400;
// AE408: using guessed type int dword_AE408;
// 12F02E: using guessed type __int16 word_12F02E;
// 12F6A4: using guessed type int dword_12F6A4[];
// 1302A0: using guessed type int dword_1302A0;
// 1314A4: using guessed type int dword_1314A4;
// 1314A8: using guessed type int dword_1314A8;

//----- (0005ACA0) --------------------------------------------------------
int sub_5ACA0()
{
  printf("Copyright (c) 1995 Bullfrog Productions Ltd.\n");
  printf("All rights reserved.\n");
  return printf("%s \n", aMagicCarpet);
}
// 5CC03: using guessed type _DWORD printf(const char *, ...);

//----- (0005AD10) --------------------------------------------------------
int sub_5AD10(int a1)
{
  int result; // eax

  result = dword_AE408;
  if ( (*(_BYTE *)(dword_AE408 + 1) & 1) != 0 )
    return printf((const char *)&off_ABCE0, a1);
  return result;
}
// 5CC03: using guessed type _DWORD printf(const char *, ...);
// ABCE0: using guessed type void *off_ABCE0;
// AE408: using guessed type int dword_AE408;

//----- (0005AD30) --------------------------------------------------------
int sub_5AD30()
{
  int v0; // ebx
  int v1; // esi

  v0 = 96;
  v1 = 24576;
  do
  {
    memset(&unk_12EEA4, 0, 50);
    dword_12EEC0 = v1 | 0x7F;
    dword_12EEB4 = 0;
    dword_12EEBC = 0;
    dword_12EEB8 = 0;
    sub_5B3E0((int)&unk_12EEA4);
    if ( (v0 | 0x7F00) == dword_12EEC0 )
      return v1 & 0xFF00;
    ++v0;
    v1 += 256;
  }
  while ( v0 <= 112 );
  return 0;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 12EEB4: using guessed type int dword_12EEB4;
// 12EEB8: using guessed type int dword_12EEB8;
// 12EEBC: using guessed type int dword_12EEBC;
// 12EEC0: using guessed type int dword_12EEC0;

//----- (0005ADB0) --------------------------------------------------------
int sub_5ADB0(int a1, _DWORD *a2, _BYTE *a3)
{
  int v3; // ebx
  int v4; // eax
  _BYTE *v5; // eax

  v3 = 0;
  memset(&unk_12EEA4, 0, 50);
  v4 = a1;
  LOBYTE(v4) = a1 | 3;
  dword_12EEBC = 0;
  dword_12EEC0 = v4;
  dword_12EEB8 = 0;
  word_12EEC6 = word_12EED8;
  sub_5B3E0((int)&unk_12EEA4);
  v5 = (_BYTE *)dword_12EE98;
  if ( dword_12EEBC > 0 )
  {
    do
    {
      *a3++ = *v5;
      ++v3;
      ++v5;
    }
    while ( v3 < dword_12EEBC );
  }
  *a2 = dword_12EEBC;
  return dword_12EEC0;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 12EE98: using guessed type int dword_12EE98;
// 12EEB8: using guessed type int dword_12EEB8;
// 12EEBC: using guessed type int dword_12EEBC;
// 12EEC0: using guessed type int dword_12EEC0;
// 12EEC6: using guessed type __int16 word_12EEC6;
// 12EED8: using guessed type __int16 word_12EED8;

//----- (0005AE30) --------------------------------------------------------
int sub_5AE30(int a1, char *a2)
{
  int v2; // edx
  char *v3; // eax
  char v4; // bl
  int v5; // eax

  v2 = dword_12EE98;
  v3 = a2;
  do
  {
    ++v2;
    v4 = *v3++;
    *(_BYTE *)(v2 - 1) = v4;
  }
  while ( v3 != a2 + 256 );
  memset(&unk_12EEA4, 0, 50);
  v5 = a1;
  LOBYTE(v5) = a1 | 4;
  dword_12EEBC = 0;
  dword_12EEC0 = v5;
  dword_12EEB8 = 0;
  word_12EEC6 = word_12EED8;
  sub_5B3E0((int)&unk_12EEA4);
  return dword_12EEC0;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 12EE98: using guessed type int dword_12EE98;
// 12EEB8: using guessed type int dword_12EEB8;
// 12EEBC: using guessed type int dword_12EEBC;
// 12EEC0: using guessed type int dword_12EEC0;
// 12EEC6: using guessed type __int16 word_12EEC6;
// 12EED8: using guessed type __int16 word_12EED8;

//----- (0005AEB0) --------------------------------------------------------
int sub_5AEB0(int a1, _DWORD *a2, _BYTE *a3)
{
  int v3; // ebx
  int v4; // eax
  _BYTE *v5; // eax

  v3 = 0;
  memset(&unk_12EEA4, 0, 50);
  v4 = a1;
  LOBYTE(v4) = a1 | 5;
  dword_12EEBC = 0;
  dword_12EEC0 = v4;
  dword_12EEB8 = 0;
  word_12EEC6 = word_12EED8;
  sub_5B3E0((int)&unk_12EEA4);
  v5 = (_BYTE *)dword_12EE98;
  if ( dword_12EEBC > 0 )
  {
    do
    {
      *a3++ = *v5;
      ++v3;
      ++v5;
    }
    while ( v3 < dword_12EEBC );
  }
  *a2 = dword_12EEBC;
  return dword_12EEC0;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 12EE98: using guessed type int dword_12EE98;
// 12EEB8: using guessed type int dword_12EEB8;
// 12EEBC: using guessed type int dword_12EEBC;
// 12EEC0: using guessed type int dword_12EEC0;
// 12EEC6: using guessed type __int16 word_12EEC6;
// 12EED8: using guessed type __int16 word_12EED8;

//----- (0005AF50) --------------------------------------------------------
int sub_5AF50()
{
  unsigned __int8 *v1; // eax
  int v2; // eax
  char v3; // dl
  char *v4; // eax
  int v5; // edx
  int v6; // ebx
  int v7; // ecx
  char v8; // dh
  char v9; // bh
  int v10; // ebp
  int v11; // ebx
  int v12; // esi
  char v13; // dh
  char v14; // cl
  char v15; // ch
  unsigned __int8 *v16; // [esp+0h] [ebp-14h] BYREF

  memset(&word_12EE9C, 0, 6);
  memset(&word_12EEDA, 0, 7);
  dword_12EE98 = sub_5B480(256, &word_12EED8, (uint16*)&word_12EED6);
  if ( !dword_12EE98 )
    return 0;
  v1 = (unsigned __int8 *)getenv(aVipport);
  if ( v1 )
  {
    dword_12EE94 = sub_6660D(v1, &v16, 16);
    dword_12EE24 = dword_12EE94 + 1;
    v2 = sub_5AD30();
    dword_12EE10 = v2;
    if ( !v2 || sub_5ADB0(v2, (uint32*)&dword_12EE18, (uint8*)byte_12EC10) )
      goto LABEL_21;
    dword_12EE14 = 0;
    dword_12EE2C = 0;
    dword_12EE1C = 0;
    for ( dword_12EE30 = (int)byte_12ED10; dword_12EE1C < dword_12EE18; dword_12EE1C += dword_12EE28 )
    {
      v3 = byte_12EC11[dword_12EE1C];
      dword_12EE28 = byte_12EC10[dword_12EE1C];
      v4 = &byte_12EC10[dword_12EE1C];
      switch ( v3 )
      {
        case 0:
          dword_12EE1C = dword_12EE18;
          break;
        case 1:
          dword_12EE40 = (int)&byte_12EC10[dword_12EE1C];
          break;
        case 2:
          dword_12EE38 = (int)&byte_12EC10[dword_12EE1C];
          byte_12EEE1 = strcmp(v4 + 34, aVfx1Cyberpuck) == 0;
          break;
        case 6:
          v5 = dword_12EE2C;
          if ( dword_12EE2C < 6 )
          {
            v6 = 6 * dword_12EE2C;
            v7 = dword_12EE30;
            dword_12EE68 = (int)&byte_12EC10[dword_12EE1C];
            //fix *(_WORD *)&byte_12EE6E[v6 + 4] = __DS__;
            *(_DWORD *)&byte_12EE6E[v6] = v7;
            dword_12EE2C = v5 + 1;
            dword_12EE30 = v7 + 6;
            if ( byte_12EEE1 )
            {
              v8 = v4[14];
              v4[22] |= 0x80u;
              v9 = v4[30];
              v4[14] = v8 | 0x80;
              v4[30] = v9 | 0x80;
            }
          }
          break;
        case 7:
          v10 = dword_12EE14;
          if ( dword_12EE14 < 6 )
          {
            v11 = 6 * dword_12EE14;
            v12 = dword_12EE30;
            v13 = byte_12EEE1;
            dword_12EE3C = (int)&byte_12EC10[dword_12EE1C];
            //fix *(_WORD *)&byte_12EE44[v11 + 4] = __DS__;
            *(_DWORD *)&byte_12EE44[v11] = v12;
            dword_12EE14 = v10 + 1;
            dword_12EE30 = v12 + 7;
            if ( v13 )
            {
              v14 = v4[30] | 0x80;
              v4[14] |= 0x80u;
              v4[30] = v14;
              v15 = v4[33] | 0x80;
              v4[22] |= 0x80u;
              v4[33] = v15;
            }
          }
          break;
        default:
          continue;
      }
    }
    if ( sub_5AE30(dword_12EE10, byte_12EC10) )
    {
LABEL_21:
      sub_5B3B0();
      return 0;
    }
    else
    {
      if ( dword_12EE2C )
        byte_9AD08 = 1;
      if ( dword_12EE14 )
        byte_9AD09 = 1;
      return 1;
    }
  }
  else
  {
    dword_12EE94 = 768;
    sub_5B3B0();
    return 0;
  }
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 629F4: using guessed type _DWORD getenv(_DWORD);
// 639E0: using guessed type _DWORD strcmp(_DWORD, _DWORD);
// 9AD08: using guessed type char byte_9AD08;
// 9AD09: using guessed type char byte_9AD09;
// 12ED10: using guessed type _BYTE byte_12ED10[256];
// 12EE10: using guessed type int dword_12EE10;
// 12EE14: using guessed type int dword_12EE14;
// 12EE18: using guessed type int dword_12EE18;
// 12EE1C: using guessed type int dword_12EE1C;
// 12EE24: using guessed type int dword_12EE24;
// 12EE28: using guessed type int dword_12EE28;
// 12EE2C: using guessed type int dword_12EE2C;
// 12EE30: using guessed type int dword_12EE30;
// 12EE38: using guessed type int dword_12EE38;
// 12EE3C: using guessed type int dword_12EE3C;
// 12EE40: using guessed type int dword_12EE40;
// 12EE68: using guessed type int dword_12EE68;
// 12EE94: using guessed type int dword_12EE94;
// 12EE98: using guessed type int dword_12EE98;
// 12EE9C: using guessed type __int16 word_12EE9C;
// 12EED6: using guessed type __int16 word_12EED6;
// 12EED8: using guessed type __int16 word_12EED8;
// 12EEDA: using guessed type __int16 word_12EEDA;
// 12EEE1: using guessed type char byte_12EEE1;

//----- (0005B210) --------------------------------------------------------
int sub_5B210()
{
  unsigned __int16 v1; // ax
  unsigned __int8 v2; // al

  if ( sub_5AEB0(dword_12EE10, (uint32*)&dword_12EE18, byte_12ED10) )
  {
    sub_5B3B0();
    return 0;
  }
  else
  {
    if ( byte_9AD08 )
    {
      word_12EE9C = __readgsword(*(unsigned int *)byte_12EE6E);
      v1 = __readgsword(*(_DWORD *)byte_12EE6E + 4);
      word_12EE9E = __readgsword(*(_DWORD *)byte_12EE6E + 2);
      word_12EEA0 = v1;
    }
    if ( byte_9AD09 )
    {
      word_12EEDA = __readgsword(*(unsigned int *)byte_12EE44);
      word_12EEDC = __readgsword(*(_DWORD *)byte_12EE44 + 2);
      v2 = __readgsbyte(*(_DWORD *)byte_12EE44 + 6);
      word_12EEDE = __readgsword(*(_DWORD *)byte_12EE44 + 4);
      byte_12EEE0 = v2;
    }
    return 1;
  }
}
// 9AD08: using guessed type char byte_9AD08;
// 9AD09: using guessed type char byte_9AD09;
// 12ED10: using guessed type _BYTE byte_12ED10[256];
// 12EE10: using guessed type int dword_12EE10;
// 12EE18: using guessed type int dword_12EE18;
// 12EE9C: using guessed type __int16 word_12EE9C;
// 12EE9E: using guessed type __int16 word_12EE9E;
// 12EEA0: using guessed type __int16 word_12EEA0;
// 12EEDA: using guessed type __int16 word_12EEDA;
// 12EEDC: using guessed type __int16 word_12EEDC;
// 12EEDE: using guessed type __int16 word_12EEDE;
// 12EEE0: using guessed type char byte_12EEE0;

//----- (0005B2B0) --------------------------------------------------------
int sub_5B2B0()
{
  int result; // eax
  __int16 v1[14]; // [esp+0h] [ebp-1Ch] BYREF

  //fix
  result = 0;
  //fix

  if ( byte_9AD08 )
  {
    memset(v1, 0, sizeof(v1));
    v1[0] = 24584;
    v1[2] = *(unsigned __int8 *)(dword_12EE68 + 3) | 0x800;
    return int386(51, (uint32)v1, (uint32)v1);
  }
  return result;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 62F78: using guessed type _DWORD int386(_DWORD, _DWORD, _DWORD);
// 9AD08: using guessed type char byte_9AD08;
// 12EE68: using guessed type int dword_12EE68;

//----- (0005B310) --------------------------------------------------------
unsigned __int8 sub_5B310(int a1, unsigned __int8 *a2)
{
  unsigned __int8 v3; // al
  char v5; // dl
  unsigned __int8 v6; // al
  int v7; // ecx
  unsigned __int8 v8; // al
  unsigned __int8 *v9; // ebx
  unsigned __int8 v10; // al
  unsigned __int8 result; // al

  __outbyte(dword_12EE94, 7u);
  __outbyte(dword_12EE24, 0xFFu);
  __outbyte(dword_12EE94, 6u);
  v3 = __inbyte(dword_12EE24);
  v5 = v3 & 0xF8;
  if ( a1 )
  {
    if ( a1 == 1 )
      v6 = v5 | 1;
    else
      v6 = v3 & 0xFA | 4;
  }
  else
  {
    v6 = v5 | 3;
  }
  __outbyte(dword_12EE24, v6);
  __outbyte(dword_12EE94, 9u);
  __outbyte(dword_12EE24, 0);
  v7 = 0;
  __outbyte(dword_12EE94, 0xAu);
  do
  {
    v8 = *a2;
    v9 = a2 + 1;
    __outbyte(dword_12EE24, v8);
    v10 = *v9++;
    __outbyte(dword_12EE24, v10);
    ++v7;
    result = *v9;
    a2 = v9 + 1;
    __outbyte(dword_12EE24, result);
  }
  while ( v7 < 256 );
  return result;
}
// 12EE24: using guessed type int dword_12EE24;
// 12EE94: using guessed type int dword_12EE94;

//----- (0005B3B0) --------------------------------------------------------
int sub_5B3B0()
{
  int result; // eax

  if ( dword_12EE98 )
  {
    result = sub_5B450(word_12EED6);
    dword_12EE98 = 0;
  }
  return result;
}
// 12EE98: using guessed type int dword_12EE98;
// 12EED6: using guessed type __int16 word_12EED6;

//----- (0005B3E0) --------------------------------------------------------
int sub_5B3E0(int a1)
{
  int v2[7]; // [esp+0h] [ebp-30h] BYREF
  __int16 v3[10]; // [esp+1Ch] [ebp-14h] BYREF

  memset(v3, 0, 12);
  memset(v2, 0, sizeof(v2));
  v2[0] = 768;
  v2[1] = 51;
  v2[2] = 0;
  v2[5] = a1;
  //fix v3[0] = __DS__;
  return int386x(49, (uint32)v2, (uint32)v2, (uint32)v3);
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 636E6: using guessed type _DWORD int386x(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0005B450) --------------------------------------------------------
int sub_5B450(__int16 a1)
{
  int v2[7]; // [esp+0h] [ebp-1Ch] BYREF

  v2[3] = a1;
  v2[0] = 257;
  return int386(49, (uint32)v2, (uint32)v2);
}
// 62F78: using guessed type _DWORD int386(_DWORD, _DWORD, _DWORD);

//----- (0005B480) --------------------------------------------------------
int sub_5B480(int a1, __int16 *a2, _WORD *a3)
{
  int v3; // ebx
  int v5[3]; // [esp+0h] [ebp-34h] BYREF
  int v6; // [esp+Ch] [ebp-28h]
  int v7; // [esp+18h] [ebp-1Ch]
  char v8[24]; // [esp+1Ch] [ebp-18h] BYREF

  //fix
  v6 = 0;
  v7 = 0;
  //fix

  *a2 = 0;
  *a3 = 0;
  segread((uint32)v8);
  v5[0] = 256;
  v5[1] = (unsigned int)(a1 + 15) >> 4;
  int386(49, (uint32)v5, (uint32)v5);
  v3 = 0;
  if ( !v7 )
  {
    *a2 = v5[0];
    *a3 = v6;
    return 16 * *a2;
  }
  return v3;
}
// 62F78: using guessed type _DWORD int386(_DWORD, _DWORD, _DWORD);
// 636BC: using guessed type _DWORD segread(_DWORD);
// 5B480: using guessed type char var_18[24];

//----- (0005B500) --------------------------------------------------------
void sub_5B500()
{
  __outbyte(0x302u, 2u);
  __outbyte(0x303u, 0x10u);
  memset((void*)dword_12EFF4, 0, dword_12EFF8 * dword_12EFF0);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12EFF8: using guessed type int dword_12EFF8;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0005B560) --------------------------------------------------------
void sub_5B560()
{
  __outbyte(0x302u, 2u);
  __outbyte(0x303u, 1u);
  memset((void*)dword_12EFF4, 0, dword_12EFF8 * dword_12EFF0);
  if ( (word_12F02E & 1) != 0 )
    sub_5CDA0();
  else
    sub_599B0(480);
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12EFF8: using guessed type int dword_12EFF8;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0005B5E0) --------------------------------------------------------
void sub_5B5E0()
{
  ;
}

//----- (0005B5F4) --------------------------------------------------------
void sub_5B5F4()
{
  ;
}

//----- (0005B650) --------------------------------------------------------
int sub_5B650()
{
  int result; // eax
  _BYTE *v1; // eax
  _BYTE *v2; // eax

  dword_12EF80 = dword_9AD90;
  if ( (word_12F02E & 1) != 0 )
  {
    LOWORD(dword_12EF80) = (__int16)dword_12EF80 >> 1;
    SHIWORD(dword_12EF80) >>= 1;
  }
  dword_12EF8C = ((int)unk_12EF7E >> 16) + (dword_12EF80 >> 16) * dword_12EFF0;
  if ( (word_12F02E & 8) != 0 )
  {
    word_12EFD0 = HIWORD(dword_12EF8C);
    sub_61A1C(SHIWORD(dword_12EF8C));
  }
  unk_12EF84 = dword_12EFF0 - dword_12EF80;
  if ( (__int16)(dword_12EFF0 - dword_12EF80) > word_12EFC4 )
    unk_12EF84 = word_12EFC4;
  word_12EF86 = dword_12EFF8 - HIWORD(dword_12EF80);
  if ( (__int16)(dword_12EFF8 - HIWORD(dword_12EF80)) > word_12EFC6 )
    word_12EF86 = word_12EFC6;
  dword_12EFA8 = dword_12EF88;
  dword_12EFA4 = (int)&unk_A0000 + (unsigned __int16)dword_12EF8C;
  dword_12EFA0 = dword_12EFC8;
  if ( (word_12F02E & 1) != 0 )
  {
    for ( word_12EFD4 = 0; ; ++word_12EFD4 )
    {
      result = (int)unk_12EF84 >> 16;
      if ( (unsigned __int16)word_12EFD4 >= (int)unk_12EF84 >> 16 )
        break;
      for ( word_12EFD2 = 0; (unsigned __int16)word_12EFD2 < *(int *)((char *)&dword_12EF80 + 2) >> 16; ++word_12EFD2 )
      {
        v1 = (_BYTE *)dword_12EFA8++;
        *v1 = *(_BYTE *)dword_12EFA4;
        if ( *(_BYTE *)dword_12EFA0 != 0xFE )
          *(_BYTE *)dword_12EFA4 = *(_BYTE *)dword_12EFA0;
        ++dword_12EFA4;
        ++dword_12EFA0;
      }
      dword_12EFA4 += dword_12EFF0 - (*(int *)((char *)&dword_12EF80 + 2) >> 16);
      dword_12EFA0 += (*(int *)((char *)&dword_12EFC8 + 2) >> 16) - (*(int *)((char *)&dword_12EF80 + 2) >> 16);
    }
  }
  else
  {
    for ( word_12EFD4 = 0; ; ++word_12EFD4 )
    {
      result = (int)unk_12EF84 >> 16;
      if ( (unsigned __int16)word_12EFD4 >= (int)unk_12EF84 >> 16 )
        break;
      for ( word_12EFD2 = 0; (unsigned __int16)word_12EFD2 < *(int *)((char *)&dword_12EF80 + 2) >> 16; ++word_12EFD2 )
      {
        v2 = (_BYTE *)dword_12EFA8++;
        *v2 = *(_BYTE *)dword_12EFA4;
        if ( *(_BYTE *)dword_12EFA0 != 0xFE )
          *(_BYTE *)dword_12EFA4 = *(_BYTE *)dword_12EFA0;
        if ( ++dword_12EFA4 >= (unsigned int)&unk_B0000 )
        {
          sub_61A1C(++word_12EFD0);
          dword_12EFA4 -= (int)sub_10000;
        }
        ++dword_12EFA0;
      }
      dword_12EFA4 += dword_12EFF0 - (*(int *)((char *)&dword_12EF80 + 2) >> 16);
      if ( dword_12EFA4 >= (unsigned int)&unk_B0000 )
      {
        sub_61A1C(++word_12EFD0);
        dword_12EFA4 -= (int)sub_10000;
      }
      dword_12EFA0 += (*(int *)((char *)&dword_12EFC8 + 2) >> 16) - (*(int *)((char *)&dword_12EF80 + 2) >> 16);
    }
  }
  return result;
}
// 10000: using guessed type void sub_10000();
// 9AD90: using guessed type int dword_9AD90;
// 12EF80: using guessed type int dword_12EF80;
// 12EF86: using guessed type __int16 word_12EF86;
// 12EF88: using guessed type int dword_12EF88;
// 12EF8C: using guessed type int dword_12EF8C;
// 12EFA0: using guessed type int dword_12EFA0;
// 12EFA4: using guessed type int dword_12EFA4;
// 12EFA8: using guessed type int dword_12EFA8;
// 12EFC4: using guessed type __int16 word_12EFC4;
// 12EFC6: using guessed type __int16 word_12EFC6;
// 12EFC8: using guessed type int dword_12EFC8;
// 12EFCC: using guessed type int dword_12EFCC;
// 12EFD0: using guessed type __int16;
// 12EFD2: using guessed type __int16 word_12EFD2;
// 12EFD4: using guessed type __int16 word_12EFD4;
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF8: using guessed type int dword_12EFF8;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0005B95C) --------------------------------------------------------
int sub_5B95C()
{
  int result; // eax
  _BYTE *v1; // eax
  _BYTE *v2; // edx

  dword_12EF90 = dword_9AD90;
  dword_12EF80 = dword_9AD90;
  if ( (word_12F02E & 1) != 0 )
  {
    LOWORD(dword_12EF90) = (__int16)dword_12EF90 >> 1;
    SHIWORD(dword_12EF90) >>= 1;
  }
  dword_12EF9C = (*(int *)((char *)&dword_12EF8C + 2) >> 16) + (dword_12EF90 >> 16) * dword_12EFF0;
  dword_12EF8C = dword_12EF9C;
  LOWORD(dword_12EF94) = dword_12EFF0 - dword_12EF90;
  if ( (__int16)(dword_12EFF0 - dword_12EF90) > word_12EFC4 )
    LOWORD(dword_12EF94) = word_12EFC4;
  unk_12EF84 = dword_12EF94;
  HIWORD(dword_12EF94) = dword_12EFF8 - HIWORD(dword_12EF90);
  if ( (__int16)(dword_12EFF8 - HIWORD(dword_12EF90)) > word_12EFC6 )
    HIWORD(dword_12EF94) = word_12EFC6;
  word_12EF86 = HIWORD(dword_12EF94);
  dword_12EFA8 = dword_12EF98;
  dword_12EFAC = dword_12EF88;
  dword_12EFA4 = dword_12EF9C + dword_12EFF4;
  dword_12EFA0 = dword_12EFC8;
  for ( word_12EFD4 = 0; ; ++word_12EFD4 )
  {
    result = dword_12EF94 >> 16;
    if ( (unsigned __int16)word_12EFD4 >= dword_12EF94 >> 16 )
      break;
    for ( word_12EFD2 = 0; (unsigned __int16)word_12EFD2 < *(int *)((char *)&dword_12EF90 + 2) >> 16; ++word_12EFD2 )
    {
      v1 = (_BYTE *)dword_12EFA8++;
      *v1 = *(_BYTE *)dword_12EFA4;
      v2 = (_BYTE *)dword_12EFAC++;
      *v2 = *(_BYTE *)dword_12EFA4;
      if ( *(_BYTE *)dword_12EFA0 != 0xFE )
        *(_BYTE *)dword_12EFA4 = *(_BYTE *)dword_12EFA0;
      ++dword_12EFA4;
      ++dword_12EFA0;
    }
    dword_12EFA4 += dword_12EFF0 - (*(int *)((char *)&dword_12EF90 + 2) >> 16);
    dword_12EFA0 += (*(int *)((char *)&dword_12EFC8 + 2) >> 16) - (*(int *)((char *)&dword_12EF90 + 2) >> 16);
  }
  return result;
}
// 9AD90: using guessed type int dword_9AD90;
// 12EF80: using guessed type int;
// 12EF86: using guessed type __int16 word_12EF86;
// 12EF88: using guessed type int dword_12EF88;
// 12EF8C: using guessed type int dword_12EF8C;
// 12EF90: using guessed type int dword_12EF90;
// 12EF94: using guessed type int dword_12EF94;
// 12EF98: using guessed type int dword_12EF98;
// 12EF9C: using guessed type int dword_12EF9C;
// 12EFA0: using guessed type int dword_12EFA0;
// 12EFA4: using guessed type int dword_12EFA4;
// 12EFA8: using guessed type int dword_12EFA8;
// 12EFAC: using guessed type int dword_12EFAC;
// 12EFC4: using guessed type __int16 word_12EFC4;
// 12EFC6: using guessed type __int16 word_12EFC6;
// 12EFC8: using guessed type int dword_12EFC8;
// 12EFD2: using guessed type __int16 word_12EFD2;
// 12EFD4: using guessed type __int16 word_12EFD4;
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12EFF8: using guessed type int dword_12EFF8;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0005BB60) --------------------------------------------------------
int sub_5BB60()
{
  int result; // eax
  _BYTE *v1; // eax
  _BYTE *v2; // edx
  _BYTE *v3; // eax
  _BYTE *v4; // edx

  if ( (word_12F02E & 1) == 0 )
  {
    word_12EFD0 = HIWORD(dword_12EF8C);
    sub_61A1C(SHIWORD(dword_12EF8C));
  }
  dword_12EFA8 = dword_12EF88;
  dword_12EFA4 = (int)&unk_A0000 + (unsigned __int16)dword_12EF8C;
  if ( (word_12F02E & 1) != 0 )
  {
    for ( word_12EFD4 = 0; ; ++word_12EFD4 )
    {
      result = (int)unk_12EF84 >> 16;
      if ( (unsigned __int16)word_12EFD4 >= (int)unk_12EF84 >> 16 )
        break;
      for ( word_12EFD2 = 0; (unsigned __int16)word_12EFD2 < *(int *)((char *)&dword_12EF80 + 2) >> 16; ++word_12EFD2 )
      {
        v1 = (_BYTE *)dword_12EFA8++;
        v2 = (_BYTE *)dword_12EFA4++;
        *v2 = *v1;
      }
      dword_12EFA4 += dword_12EFF0 - (*(int *)((char *)&dword_12EF80 + 2) >> 16);
    }
  }
  else
  {
    for ( word_12EFD4 = 0; ; ++word_12EFD4 )
    {
      result = (int)unk_12EF84 >> 16;
      if ( (unsigned __int16)word_12EFD4 >= (int)unk_12EF84 >> 16 )
        break;
      for ( word_12EFD2 = 0; (unsigned __int16)word_12EFD2 < *(int *)((char *)&dword_12EF80 + 2) >> 16; ++word_12EFD2 )
      {
        v3 = (_BYTE *)dword_12EFA8++;
        v4 = (_BYTE *)dword_12EFA4++;
        *v4 = *v3;
        if ( dword_12EFA4 >= (unsigned int)&unk_B0000 )
        {
          sub_61A1C(++word_12EFD0);
          dword_12EFA4 -= (int)sub_10000;
        }
      }
      dword_12EFA4 += dword_12EFF0 - (*(int *)((char *)&dword_12EF80 + 2) >> 16);
      if ( dword_12EFA4 >= (unsigned int)&unk_B0000 )
      {
        sub_61A1C(++word_12EFD0);
        dword_12EFA4 -= (int)sub_10000;
      }
    }
  }
  return result;
}
// 10000: using guessed type void sub_10000();
// 12EF80: using guessed type int dword_12EF80;
// 12EF88: using guessed type int dword_12EF88;
// 12EF8C: using guessed type int dword_12EF8C;
// 12EFA4: using guessed type int dword_12EFA4;
// 12EFA8: using guessed type int dword_12EFA8;
// 12EFCC: using guessed type int dword_12EFCC;
// 12EFD0: using guessed type __int16 word_12EFD0;
// 12EFD2: using guessed type __int16 word_12EFD2;
// 12EFD4: using guessed type __int16 word_12EFD4;
// 12EFF0: using guessed type int dword_12EFF0;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0005BD40) --------------------------------------------------------
int sub_5BD40()
{
  int result; // eax
  _BYTE *v1; // eax
  _BYTE *v2; // edx

  dword_12EFA8 = dword_12EF98;
  dword_12EFA4 = dword_12EF9C + dword_12EFF4;
  for ( word_12EFD4 = 0; ; ++word_12EFD4 )
  {
    result = dword_12EF94 >> 16;
    if ( (unsigned __int16)word_12EFD4 >= dword_12EF94 >> 16 )
      break;
    for ( word_12EFD2 = 0; (unsigned __int16)word_12EFD2 < *(int *)((char *)&dword_12EF90 + 2) >> 16; ++word_12EFD2 )
    {
      v1 = (_BYTE *)dword_12EFA8++;
      v2 = (_BYTE *)dword_12EFA4++;
      *v2 = *v1;
    }
    dword_12EFA4 += dword_12EFF0 - (*(int *)((char *)&dword_12EF90 + 2) >> 16);
  }
  return result;
}
// 12EF90: using guessed type int dword_12EF90;
// 12EF94: using guessed type int dword_12EF94;
// 12EF98: using guessed type int dword_12EF98;
// 12EF9C: using guessed type int dword_12EF9C;
// 12EFA4: using guessed type int dword_12EFA4;
// 12EFA8: using guessed type int dword_12EFA8;
// 12EFD2: using guessed type __int16 word_12EFD2;
// 12EFD4: using guessed type __int16 word_12EFD4;
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (0005BDF8) --------------------------------------------------------
int sub_5BDF8()
{
  int result; // eax

  //fix
  result = 0;
  //fix

  if ( dword_9AD98 )
  {
    dword_9AD88 = 1;
    return sub_5B95C();
  }
  return result;
}
// 9AD88: using guessed type int dword_9AD88;
// 9AD98: using guessed type int dword_9AD98;

//----- (0005BE50) --------------------------------------------------------
void sub_5BE50()
{
  dword_9AD88 = 0;
}
// 9AD88: using guessed type int dword_9AD88;

//----- (0005C05C) --------------------------------------------------------
int sub_5C05C(int a1)
{
  int result; // eax
  unsigned int i; // [esp+0h] [ebp-10h]
  int v3; // [esp+4h] [ebp-Ch]
  __int16 v4; // [esp+8h] [ebp-8h]
  int v5; // [esp+Ch] [ebp-4h]

  dword_9AD88 = 1;
  v5 = dword_12EFF4;
  dword_12EFF4 = dword_12EFC8;
  if ( a1 )
  {
    word_12EFC4 = *(unsigned __int8 *)(a1 + 4);
    word_12EFC6 = *(unsigned __int8 *)(a1 + 5);
  }
  else
  {
    word_12EFC4 = 0;
    word_12EFC6 = 0;
  }
  if ( (word_12F02E & 1) != 0 )
  {
    word_12EFC4 >>= 1;
    word_12EFC6 >>= 1;
  }
  dword_12F014 = dword_12F018;
  dword_12F00C = dword_12F010;
  dword_12F004 = dword_12F008;
  dword_12F01C = dword_12F024;
  dword_12EFFC = dword_12F000;
  dword_12F020 = dword_12F028;
  dword_12F018 = 0;
  dword_12F010 = 64;
  dword_12F008 = 0;
  dword_12F024 = 64;
  dword_12F000 = 64;
  dword_12F028 = 64;
  v4 = word_9ADFC;
  word_9ADFC = 0;
  v3 = dword_12EFF0;
  dword_12EFF0 = 64;
  for ( i = 0; i < 0x1000; ++i )
    *(_BYTE *)(i + dword_12EFC8) = -2;
  if ( a1 )
    sub_60CE0(0, 0, a1);
  dword_12EFF0 = v3;
  word_9ADFC = v4;
  dword_12F018 = dword_12F014;
  dword_12F010 = dword_12F00C;
  dword_12F008 = dword_12F004;
  dword_12F024 = dword_12F01C;
  dword_12F000 = dword_12EFFC;
  dword_12F028 = dword_12F020;
  result = v5;
  dword_12EFF4 = v5;
  dword_9AD88 = 0;
  return result;
}
// 9AD88: using guessed type int dword_9AD88;
// 9ADFC: using guessed type __int16 word_9ADFC;
// 12EFC4: using guessed type __int16 word_12EFC4;
// 12EFC6: using guessed type __int16 word_12EFC6;
// 12EFC8: using guessed type int dword_12EFC8;
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12EFFC: using guessed type int dword_12EFFC;
// 12F000: using guessed type int dword_12F000;
// 12F004: using guessed type int dword_12F004;
// 12F008: using guessed type int dword_12F008;
// 12F00C: using guessed type int dword_12F00C;
// 12F010: using guessed type int dword_12F010;
// 12F014: using guessed type int dword_12F014;
// 12F018: using guessed type int dword_12F018;
// 12F01C: using guessed type int dword_12F01C;
// 12F020: using guessed type int dword_12F020;
// 12F024: using guessed type int dword_12F024;
// 12F028: using guessed type int dword_12F028;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0005C214) --------------------------------------------------------
int sub_5C214()
{
  __int16 v1[14]; // [esp+0h] [ebp-54h] BYREF
  __int16 v2[4]; // [esp+1Ch] [ebp-38h] BYREF
  __int16 v3; // [esp+24h] [ebp-30h]
  int (*v4)(); // [esp+28h] [ebp-2Ch]
  __int16 v5[6]; // [esp+38h] [ebp-1Ch] BYREF
  int (*v6)(); // [esp+44h] [ebp-10h]
  int v7; // [esp+48h] [ebp-Ch]
  int i; // [esp+4Ch] [ebp-8h]

  dword_9AD98 = 0;
  segread((uint32)v5);
  v2[0] = 0;
  int386(51, (uint32)v2, (uint32)v1);
  if ( v1[0] != -1 )
    return 0;
  v2[0] = 12;
  v3 = 127;
  //fix LOWORD(v7) = __CS__;
  v6 = (int (*)())sub_5BE6C;
  v4 = (int (*)())sub_5BE6C;
  //fix v5[0] = __CS__;
  int386x(51, (uint32)v2, (uint32)v1, (uint32)v5);
  sub_5C468();
  if ( !dword_12EFC8 )
    dword_12EFC8 = sub_42540(4096);
  if ( !dword_12EF98 )
    dword_12EF98 = sub_42540(4096);
  if ( !dword_12EF88 )
    dword_12EF88 = sub_42540(4096);
  if ( !dword_12EFC8 || !dword_12EF98 || !dword_12EF88 )
    return 0;
  word_12EFC4 = 0;
  word_12EFC6 = 0;
  LOWORD(dword_12EFCC) = 64;
  for ( i = 0; i < 4096; ++i )
    *(_BYTE *)(i + dword_12EFC8) = -2;
  if ( dword_12EFB4 )
    sub_5C05C(dword_12EFB4);
  v2[0] = 2;
  int386(51, (uint32)v2, (uint32)v1);
  if ( (word_12F02E & 8) != 0 )
  {
    v2[0] = 15;
    v3 = 1;
    LOWORD(v4) = 1;
    int386(51, (uint32)v2, (uint32)v1);
  }
  dword_9AD98 = 1;
  return 1;
}
// 5BE6C: using guessed type int sub_5BE6C();
// 62F78: using guessed type _DWORD int386(_DWORD, _DWORD, _DWORD);
// 636BC: using guessed type _DWORD segread(_DWORD);
// 636E6: using guessed type _DWORD int386x(_DWORD, _DWORD, _DWORD, _DWORD);
// 9AD98: using guessed type int dword_9AD98;
// 12EF88: using guessed type int dword_12EF88;
// 12EF98: using guessed type int dword_12EF98;
// 12EFB4: using guessed type int dword_12EFB4;
// 12EFC4: using guessed type __int16 word_12EFC4;
// 12EFC6: using guessed type __int16 word_12EFC6;
// 12EFC8: using guessed type int dword_12EFC8;
// 12EFCC: using guessed type int dword_12EFCC;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0005C468) --------------------------------------------------------
int sub_5C468()
{
  int result; // eax
  char v1[28]; // [esp+0h] [ebp-38h] BYREF
  __int16 v2[4]; // [esp+1Ch] [ebp-1Ch] BYREF
  __int16 v3; // [esp+24h] [ebp-14h]
  __int16 v4; // [esp+28h] [ebp-10h]

  if ( word_12F02E == 8 )
  {
    v2[0] = 7;
    v3 = 0;
    v4 = 5120;
    int386(51, (uint32)v2, (uint32)v1);
    v2[0] = 8;
    v3 = 0;
    v4 = 3840;
    result = int386(51, (uint32)v2, (uint32)v1);
  }
  if ( word_12F02E == 2 )
  {
    v2[0] = 7;
    v3 = 0;
    v4 = 640;
    int386(51, (uint32)v2, (uint32)v1);
    v2[0] = 8;
    v3 = 0;
    v4 = 480;
    result = int386(51, (uint32)v2, (uint32)v1);
  }
  if ( word_12F02E == 4 )
  {
    v2[0] = 7;
    v3 = 0;
    v4 = 640;
    int386(51, (uint32)v2, (uint32)v1);
    v2[0] = 8;
    v3 = 0;
    v4 = 400;
    result = int386(51, (uint32)v2, (uint32)v1);
  }
  if ( word_12F02E == 1 )
  {
    v2[0] = 7;
    v3 = 0;
    v4 = 640;
    int386(51, (uint32)v2, (uint32)v1);
    v2[0] = 8;
    v3 = 0;
    v4 = 400;
    return int386(51, (uint32)v2, (uint32)v1);
  }
  return result;
}
// 62F78: using guessed type _DWORD int386(_DWORD, _DWORD, _DWORD);
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0005C76B) --------------------------------------------------------
__int16 sub_5C76B()
{
  __int16 result; // ax

  sub_5D1A0(dword_9ADC0, (int)&word_9ADA8, 2u);
  sub_5D1A0(dword_9ADC0, dword_AE3FC, 8u);
  while ( 1 )
  {
    result = word_9ADA8;
    if ( !word_9ADA8 )
      break;
    --word_9ADA8;
    sub_5D1A0(dword_9ADC0, (int)&dword_9ADA4, 4u);
    sub_5D1A0(dword_9ADC0, (int)&word_9AD9C, 2u);
    switch ( word_9AD9C )
    {
      case 7:
        sub_5C969();
        break;
      case 12:
        sub_5CA40();
        break;
      case 4:
        sub_5C8CD();
        break;
      case 15:
        sub_5CAE7();
        break;
      case 16:
        sub_5C891();
        break;
      default:
        sub_5C8AF();
        break;
    }
  }
  return result;
}
// 9AD9C: using guessed type __int16 word_9AD9C;
// 9ADA4: using guessed type int dword_9ADA4;
// 9ADA8: using guessed type __int16 word_9ADA8;
// 9ADC0: using guessed type int dword_9ADC0;
// AE3FC: using guessed type int dword_AE3FC;

//----- (0005C82E) --------------------------------------------------------
__int16 sub_5C82E()
{
  __int16 result; // ax

  sub_5D1A0(dword_9ADC0, dword_AE3FC, dword_9ADA4 - 6);
  dword_9AD9E = *(_DWORD *)dword_AE3FC;
  result = *(_WORD *)(dword_AE3FC + 4);
  word_9ADA2 = result;
  return result;
}
// 9AD9E: using guessed type int dword_9AD9E;
// 9ADA2: using guessed type __int16 word_9ADA2;
// 9ADA4: using guessed type int dword_9ADA4;
// 9ADC0: using guessed type int dword_9ADC0;
// AE3FC: using guessed type int dword_AE3FC;

//----- (0005C891) --------------------------------------------------------
int sub_5C891()
{
  return sub_5D1A0(dword_9ADC0, dword_12EFF4, dword_9ADA4 - 6);
}
// 9ADA4: using guessed type int dword_9ADA4;
// 9ADC0: using guessed type int dword_9ADC0;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (0005C8AF) --------------------------------------------------------
int sub_5C8AF()
{
  return sub_5D1A0(dword_9ADC0, dword_AE3FC, dword_9ADA4 - 6);
}
// 9ADA4: using guessed type int dword_9ADA4;
// 9ADC0: using guessed type int dword_9ADC0;
// AE3FC: using guessed type int dword_AE3FC;

//----- (0005C8CD) --------------------------------------------------------
int sub_5C8CD()
{
  int result; // eax

  result = sub_5D1A0(dword_9ADC0, dword_AE424, dword_9ADA4 - 6);
  word_9ADFA = 1;
  return result;
}
// 9ADA4: using guessed type int dword_9ADA4;
// 9ADC0: using guessed type int dword_9ADC0;
// 9ADFA: using guessed type __int16 word_9ADFA;
// AE424: using guessed type int dword_AE424;

//----- (0005C8F4) --------------------------------------------------------
void sub_5C8F4()
{
  __int16 v0; // ax
  char *v1; // edi
  _BYTE *v2; // esi
  int v3; // ecx
  char *v4; // edi
  char v5; // dl
  char v6; // al
  char *v7; // edi
  _BYTE *v8; // esi
  char v9; // al
  char v10; // al
  __int16 v11; // [esp-2h] [ebp-6h]

  word_9ADFA = 0;
  if ( dword_9ADBC == 1 )
  {
    v0 = *(_WORD *)dword_AE424;
    v1 = (char *)(dword_AE424 + 2);
    v2 = (_BYTE *)dword_AE418;
    do
    {
      v11 = v0;
      v3 = (unsigned __int8)*v1;
      v4 = v1 + 1;
      v2 += v3 + v3 + v3;
      v5 = *v4;
      v1 = v4 + 1;
      do
      {
        v6 = *v1;
        v7 = v1 + 1;
        *v2 = v6;
        v8 = v2 + 1;
        v9 = *v7++;
        *v8++ = v9;
        v10 = *v7;
        v1 = v7 + 1;
        *v8 = v10;
        v2 = v8 + 1;
        --v5;
      }
      while ( v5 );
      v0 = v11 - 1;
    }
    while ( v11 != 1 );
    sub_319A0((unsigned __int8 *)dword_AE418);
  }
}
// 9ADBC: using guessed type int dword_9ADBC;
// 9ADFA: using guessed type __int16 word_9ADFA;
// AE418: using guessed type int dword_AE418;
// AE424: using guessed type int dword_AE424;

//----- (0005C969) --------------------------------------------------------
__int16 sub_5C969()
{
  _WORD *v0; // esi
  __int16 *v1; // edi
  __int16 result; // ax
  unsigned __int8 v3; // bl
  _BYTE *v4; // edi
  char v5; // dl
  __int16 v6; // bx
  __int16 v7; // bx
  _WORD *v8; // [esp+0h] [ebp-10h]
  __int16 i; // [esp+6h] [ebp-Ah]
  __int16 v10; // [esp+8h] [ebp-8h]
  int v11; // [esp+Ch] [ebp-4h]

  v11 = (unsigned __int16)word_9ADA0;
  sub_5D1A0(dword_9ADC0, dword_AE3FC, dword_9ADA4 - 6);
  v0 = (_WORD *)dword_12EFF4;
  v10 = *(_WORD *)dword_AE3FC;
  v1 = (__int16 *)(dword_AE3FC + 2);
  do
  {
    while ( 1 )
    {
      result = *v1++;
      v8 = v0;
      if ( result >= 0 )
        goto LABEL_6;
      if ( (result & 0x4000) == 0 )
        break;
      v0 = (_WORD *)((char *)v0 + v11 * -result);
    }
    *((_BYTE *)v0 + v11 - 1) = result;
LABEL_6:
    for ( i = result; i; --i )
    {
      while ( 1 )
      {
        v3 = *(_BYTE *)v1;
        v4 = (uint8*)((char *)v1 + 1);
        v0 = (_WORD *)((char *)v0 + v3);
        v5 = *v4;
        v1 = (__int16 *)(v4 + 1);
        if ( v5 > 0 )
          break;
        v6 = *v1++;
        do
        {
          *v0++ = v6;
          ++v5;
        }
        while ( v5 );
        if ( !--i )
          goto LABEL_14;
      }
      do
      {
        v7 = *v1++;
        *v0++ = v7;
        --v5;
      }
      while ( v5 );
    }
LABEL_14:
    v0 = (_WORD *)((char *)v8 + v11);
    --v10;
  }
  while ( v10 );
  return result;
}
// 9ADA0: using guessed type __int16 word_9ADA0;
// 9ADA4: using guessed type int dword_9ADA4;
// 9ADC0: using guessed type int dword_9ADC0;
// AE3FC: using guessed type int dword_AE3FC;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (0005CA40) --------------------------------------------------------
int sub_5CA40()
{
  int v0; // eax
  char *v1; // esi
  char *v2; // edi
  __int16 v3; // ax
  int v4; // eax
  _BYTE *v5; // esi
  char *v6; // edi
  unsigned __int8 v7; // al
  char *v8; // esi
  unsigned int v9; // ecx
  char v10; // al
  int result; // eax
  int v12; // [esp+0h] [ebp-10h]
  __int16 i; // [esp+6h] [ebp-Ah]
  __int16 v14; // [esp+8h] [ebp-8h]
  int v15; // [esp+Ch] [ebp-4h]

  v15 = (unsigned __int16)word_9ADA0;
  v0 = sub_5D1A0(dword_9ADC0, dword_AE3FC, dword_9ADA4 - 6);
  LOWORD(v0) = *(_WORD *)dword_AE3FC;
  v12 = v15 * v0 + dword_12EFF4;
  v1 = (char *)(dword_AE3FC + 4);
  v14 = *(_WORD *)(dword_AE3FC + 2);
  do
  {
    v2 = (char *)v12;
    v3 = (unsigned __int8)*v1++;
    for ( i = v3; i; --i )
    {
      v4 = (unsigned __int8)*v1;
      v5 = (uint8*)(v1 + 1);
      v6 = &v2[v4];
      v7 = *v5;
      v8 = (char*)(v5 + 1);
      if ( (v7 & 0x80u) != 0 )
      {
        v9 = (unsigned __int8)-v7;
        v10 = *v8;
        v1 = v8 + 1;
        memset(v6, v10, v9);
        v2 = &v6[v9];
      }
      else
      {
        qmemcpy(v6, v8, v7);
        v1 = &v8[v7];
        v2 = &v6[v7];
      }
    }
    result = (unsigned __int16)word_9ADA0;
    v12 += (unsigned __int16)word_9ADA0;
    --v14;
  }
  while ( v14 );
  return result;
}
// 9ADA0: using guessed type __int16 word_9ADA0;
// 9ADA4: using guessed type int dword_9ADA4;
// 9ADC0: using guessed type int dword_9ADC0;
// AE3FC: using guessed type int dword_AE3FC;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (0005CAE7) --------------------------------------------------------
char sub_5CAE7()
{
  _BYTE *v0; // esi
  char *v1; // edi
  __int16 v2; // bx
  __int16 v3; // cx
  char v4; // dl
  __int16 v5; // ax
  char v6; // dh
  char v7; // dh
  __int16 v9; // [esp+0h] [ebp-4h]
  __int16 v10; // [esp+2h] [ebp-2h]

  v10 = word_9ADA0;
  v9 = word_9ADA2;
  sub_5D1A0(dword_9ADC0, dword_AE3FC, dword_9ADA4 - 6);
  v0 = (_BYTE *)dword_12EFF4;
  v1 = (char *)dword_AE3FC;
  v2 = v9;
  do
  {
    ++v1;
    v3 = v10;
    do
    {
      v4 = *v1++;
      if ( v4 > 0 )
      {
        LOBYTE(v5) = v4;
        v3 -= (unsigned __int8)v4;
      }
      else
      {
        HIBYTE(v5) = -1;
        LOBYTE(v5) = v4;
        v3 += v5;
      }
      if ( v4 > 0 )
      {
        v7 = *v1++;
        do
        {
          *v0++ = v7;
          --v4;
        }
        while ( v4 );
      }
      else
      {
        do
        {
          v6 = *v1++;
          *v0++ = v6;
          ++v4;
        }
        while ( v4 );
      }
    }
    while ( v3 );
    --v2;
  }
  while ( v2 );
  return v5;
}
// 9ADA0: using guessed type __int16 word_9ADA0;
// 9ADA2: using guessed type __int16 word_9ADA2;
// 9ADA4: using guessed type int dword_9ADA4;
// 9ADC0: using guessed type int dword_9ADC0;
// AE3FC: using guessed type int dword_AE3FC;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (0005CB73) --------------------------------------------------------
void sub_5CB73(int a1, __int16 a2)
{
  __int16 v2; // cx

  if ( dword_9ADC4 )
  {
    do
    {
      do
      {
          //fix __asm { int     21h; DOS - GET CURRENT TIME }
        v2 = 100 * HIBYTE(a2) + (unsigned __int8)a2;
        a2 = v2 - word_9ADB4;
      }
      while ( v2 == word_9ADB4 );
      if ( a2 <= 0 )
        a2 += 6000;
    }
    while ( (unsigned __int16)a2 < dword_9ADC4 );
    word_9ADB4 = v2;
  }
}
// 9ADB4: using guessed type __int16 word_9ADB4;
// 9ADC4: using guessed type int dword_9ADC4;

//----- (0005CBD0) --------------------------------------------------------
int sub_5CBD0(int a1, int a2, int a3)
{
  return read(a1, a2, a3);
}
// 6692C: using guessed type _DWORD read(_DWORD, _DWORD, _DWORD);

//----- (0005CC54) --------------------------------------------------------
unsigned __int8 sub_5CC54()
{
  unsigned __int8 result; // al

  do
    result = __inbyte(0x3DAu);
  while ( (result & 8) == 0 );
  return result;
}

//----- (0005CC70) --------------------------------------------------------
char sub_5CC70(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  unsigned __int8 v4; // al
  __int16 v5; // cx
  unsigned __int8 v6; // al
  __int16 v7; // bx
  unsigned __int16 v9; // [esp+0h] [ebp-20h]
  __int16 v11; // [esp+10h] [ebp-10h]
  __int16 v12; // [esp+14h] [ebp-Ch]
  char v13; // [esp+18h] [ebp-8h]

  if ( (word_12F02E & 6) != 0 )
    v9 = 16;
  else
    v9 = 256;
  v11 = 0;
  v12 = 9999;
  while ( v11 < (int)v9 )
  {
    v4 = a1[1];
    v5 = (a2 - *a1) * (a2 - *a1) + (a3 - v4) * (a3 - v4);
    v6 = a1[2];
    v7 = a4 - v6;
    if ( (__int16)(v7 * v7 + v5) < v12 )
    {
      v12 = v7 * (a4 - v6) + v5;
      v13 = v11;
    }
    ++v11;
    a1 += 3;
  }
  return v13;
}
// 5CD61: variable 'v13' is possibly undefined
// 12F02E: using guessed type __int16 word_12F02E;

//----- (0005CD70) --------------------------------------------------------
int sub_5CD70()
{
  char v1[28]; // [esp+0h] [ebp-38h] BYREF
  int v2[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  v2[0] = (unsigned __int16)word_12F02C;
  return int386(16, (uint32)v2, (uint32)v1);
}
// 62F78: using guessed type _DWORD int386(_DWORD, _DWORD, _DWORD);
// 12F02C: using guessed type __int16 word_12F02C;
// 5CD70: using guessed type int var_1C[7];
// 5CD70: using guessed type char var_38[28];

//----- (0005CDA0) --------------------------------------------------------
void sub_5CDA0()
{
  if ( !byte_9AD96 )
    sub_5BDF8();
  qmemcpy(&unk_A0000, (const void *)dword_12EFF4, 0xFA00u);
  if ( !byte_9AD96 )
    sub_5BE50();
}
// 9AD96: using guessed type char byte_9AD96;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (0005CDE0) --------------------------------------------------------
int sub_5CDE0(int a1, int a2)
{
  int v3; // [esp+4h] [ebp-4h]

  if ( a2 == 546 )
  {
    v3 = creat(a1, 448);
    setmode(v3, 512);
    close(v3);
  }
  return sopen(a1, a2, 64);
}
// 6691E: using guessed type _DWORD close(_DWORD);
// 66BA3: using guessed type _DWORD creat(_DWORD, _DWORD);
// 66BBA: using guessed type _DWORD setmode(_DWORD, _DWORD);

//----- (0005CE50) --------------------------------------------------------
int sub_5CE50(int a1)
{
  return close(a1);
}
// 6691E: using guessed type _DWORD close(_DWORD);

//----- (0005CEF0) --------------------------------------------------------
int sub_5CEF0(unsigned __int16 a1)
{
  if ( !byte_939CC )
    return 1;
  sprintf(aDataMusic00Dat, "data/music%d-%d.dat", a1, (unsigned __int8)byte_CBFEE);
  sprintf(aDataMusic00Tab, "data/music%d-%d.tab", a1, (unsigned __int8)byte_CBFEE);
  if ( (unsigned __int16)sub_634E0((int)aDataMusic00Dat) != 1 )
    return 1;
  if ( (unsigned __int16)sub_634E0((int)aDataMusic00Tab) != 1 )
  {
    sub_634A0((int)aDataMusic00Dat);
    return 1;
  }
  sub_5CFA4();
  return 0;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 939CC: using guessed type char byte_939CC;
// CBFEE: using guessed type char byte_CBFEE;

//----- (0005CFA4) --------------------------------------------------------
unsigned int sub_5CFA4()
{
  unsigned int result; // eax
  unsigned int v1; // [esp+0h] [ebp-4h]

  if ( dword_CBF60 && dword_CBF68 )
  {
    v1 = dword_CBF60 + 32;
    for ( word_939D6 = 0; ; ++word_939D6 )
    {
      result = v1;
      if ( v1 >= dword_CBF64 )
        break;
      *(_DWORD *)(v1 + 18) += dword_CBF68;
      v1 += 32;
    }
  }
  return result;
}
// 939D6: using guessed type __int16 word_939D6;
// CBF60: using guessed type int dword_CBF60;
// CBF64: using guessed type int dword_CBF64;
// CBF68: using guessed type int dword_CBF68;

//----- (0005D010) --------------------------------------------------------
void sub_5D010()
{
  unsigned __int8 i; // [esp+0h] [ebp-4h]

  if ( byte_939E4 )
  {
    for ( i = 0; i < 0x20u; ++i )
    {
      while ( !sub_651F8(dword_CC140, i) )
        sub_65965(dword_CC140, i);
    }
  }
}
// 939E4: using guessed type char byte_939E4;
// CC140: using guessed type int dword_CC140;

//----- (0005D070) --------------------------------------------------------
int sub_5D070(unsigned __int8 a1)
{
  if ( !byte_939E4 )
    return 1;
  sprintf(aDataSnds00Dat, "data/snds%d-%d.dat", a1, (unsigned __int8)byte_939EC);
  sprintf(aDataSnds00Tab, "data/snds%d-%d.tab", a1, (unsigned __int8)byte_939EC);
  if ( (unsigned __int16)sub_634E0((int)aDataSnds00Dat) != 1 )
    return 1;
  if ( (unsigned __int16)sub_634E0((int)aDataSnds00Tab) != 1 )
  {
    sub_634A0((int)aDataSnds00Dat);
    return 1;
  }
  sub_5D138();
  return 0;
}
// 60CAC: using guessed type _DWORD sprintf(_DWORD, _DWORD, ...);
// 939E4: using guessed type char byte_939E4;
// 939EC: using guessed type char byte_939EC;

//----- (0005D138) --------------------------------------------------------
unsigned int sub_5D138()
{
  unsigned int result; // eax
  unsigned int v1; // [esp+0h] [ebp-4h]

  if ( dword_CC154 && dword_CC130 )
  {
    v1 = dword_CC154 + 32;
    for ( word_CC1C6 = 0; ; ++word_CC1C6 )
    {
      result = v1;
      if ( v1 >= dword_CC1C0 )
        break;
      *(_DWORD *)(v1 + 18) += dword_CC130;
      v1 += 32;
    }
  }
  return result;
}
// CC130: using guessed type int dword_CC130;
// CC154: using guessed type int dword_CC154;
// CC1C0: using guessed type int dword_CC1C0;
// CC1C6: using guessed type __int16 word_CC1C6;

//----- (0005D1A0) --------------------------------------------------------
int sub_5D1A0(int a1, int a2, unsigned int a3)
{
  _BYTE *v3; // eax
  _BYTE *v4; // edx
  unsigned int i; // [esp+4h] [ebp-4h]

  if ( !dword_9AF08 )
    return sub_5CBD0(a1, a2, a3);
  for ( i = 0; i < a3 && dword_9AF14 + i < dword_9AF10; ++i )
  {
    v3 = (_BYTE *)dword_9AF0C++;
    v4 = (_BYTE *)a2++;
    *v4 = *v3;
  }
  dword_9AF14 += a3;
  return i;
}
// 9AF08: using guessed type int dword_9AF08;
// 9AF0C: using guessed type int dword_9AF0C;
// 9AF10: using guessed type int dword_9AF10;
// 9AF14: using guessed type int dword_9AF14;

//----- (0005D230) --------------------------------------------------------
int sub_5D230(int a1, int a2, int a3)
{
  int result; // eax

  result = read(a1, dword_9AF08, a3);
  dword_9AF0C = dword_9AF08;
  dword_9AF10 = result;
  dword_9AF14 = 0;
  return result;
}
// 6692C: using guessed type _DWORD read(_DWORD, _DWORD, _DWORD);
// 9AF08: using guessed type int dword_9AF08;
// 9AF0C: using guessed type int dword_9AF0C;
// 9AF10: using guessed type int dword_9AF10;
// 9AF14: using guessed type int dword_9AF14;

//----- (0005D290) --------------------------------------------------------
void sub_5D290(__int16 a1)
{
  int v1; // edx
  char *v2; // eax
  char *v3; // eax
  int v4; // [esp+64h] [ebp-8h]
  int v5; // [esp+64h] [ebp-8h]

  //fix
  v4 = 0;
  //fix

  if ( byte_939CC && byte_939CD && a1 <= (int)(unsigned __int16)word_939D6 && (unsigned __int16)word_939D2 != a1 )
  {
    if ( word_939D2 )
    {
      if ( !sub_5D7F0(dword_CBFD8) )
        sub_5F420(dword_CBFD8);
      sub_5F355(dword_CBFD8);
      sub_6091D(dword_CBFDC);
      if ( byte_9AF9C )
        sub_6091D(dword_12F074);
      word_939D2 = 0;
    }
    v1 = *(_DWORD *)(dword_CBF60 + 32 * a1 + 18);
    //fix word_12F034 = __DS__;
    dword_12F030 = v1;
    word_12F03C = 0;
    dword_12F038 = 0;
    //fix
    /*
    v4 = sub_5EE22(
           (unsigned int)&dword_12F030,
           (unsigned __int16)__DS__,
           (int)&unk_9AF18,
           __DS__,
           (unsigned int)&dword_CBFD8);*/
    if ( v4 )
    {
      v2 = sub_6378C(v4);
      printf("\nError : %s", v2);
      sub_6080C(dword_CBFDC, 1);
      sub_60335();
      byte_939CC = 0;
    }
    else
    {
      v5 = sub_5F398(dword_CBFD8);
      if ( v5 )
      {
        v3 = sub_6378C(v5);
        printf("\nError : %s", v3);
        sub_6080C(dword_CBFDC, 1);
        sub_60335();
      }
      else
      {
        sub_5EDD6(0);
        word_939D0 = 100;
        word_939D2 = a1;
      }
    }
  }
}
// 5CC03: using guessed type _DWORD printf(const char *, ...);
// 939CC: using guessed type char byte_939CC;
// 939CD: using guessed type char byte_939CD;
// 939D0: using guessed type __int16 word_939D0;
// 939D2: using guessed type __int16 word_939D2;
// 939D6: using guessed type __int16 word_939D6;
// 9AF9C: using guessed type char byte_9AF9C;
// CBF60: using guessed type int dword_CBF60;
// CBFD8: using guessed type int dword_CBFD8;
// CBFDC: using guessed type int dword_CBFDC;
// 12F030: using guessed type int dword_12F030;
// 12F034: using guessed type __int16 word_12F034;
// 12F038: using guessed type int dword_12F038;
// 12F03C: using guessed type __int16 word_12F03C;
// 12F074: using guessed type int dword_12F074;

//----- (0005D460) --------------------------------------------------------
void sub_5D460(__int16 a1, __int16 a2, __int16 a3)
{
  int v3; // edx
  __int16 *v4; // [esp+0h] [ebp-10h]
  char v5; // [esp+4h] [ebp-Ch]
  char v6; // [esp+8h] [ebp-8h]
  unsigned __int8 i; // [esp+Ch] [ebp-4h]
  unsigned __int8 j; // [esp+Ch] [ebp-4h]

  if ( byte_939E4 && byte_939E5 && a2 <= (int)(unsigned __int16)word_CC1C6 )
  {
    v5 = 0;
    v4 = word_CBFF0;
    for ( i = 0; i < 0x20u; ++i )
    {
      if ( *v4 == a1 && v4[1] == a2 && !sub_651F8(dword_CC140, i) )
      {
        v5 = 1;
        break;
      }
      v4 += 2;
    }
    if ( !v5 )
    {
      v6 = 0;
      for ( j = 0; j < 0x20u; ++j )
      {
        if ( sub_651F8(dword_CC140, j) )
        {
          v6 = 1;
          break;
        }
      }
      if ( v6 )
      {
        word_CBFF0[2 * j] = a1;
        word_CBFF2[2 * j] = a2;
        word_93A0C = 16640;
        word_939FC = a3;
        word_93A00 = 0x7FFF;
        word_CC070[j] = 0x7FFF;
        word_93A02 = j;
        dword_939F8 = *(_DWORD *)(32 * a2 + dword_CC154 + 26) - 16;
        v3 = *(_DWORD *)(32 * a2 + dword_CC154 + 18);
        //fix word_939F4 = __DS__;
        dword_939F0 = v3;
        dword_CC144 = sub_6535C(dword_CC140, (unsigned int)&dword_939F0);
      }
    }
  }
}
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// 939F0: using guessed type int dword_939F0;
// 939F4: using guessed type __int16 word_939F4;
// 939F8: using guessed type int dword_939F8;
// 939FC: using guessed type __int16 word_939FC;
// 93A00: using guessed type __int16 word_93A00;
// 93A02: using guessed type __int16 word_93A02;
// 93A0C: using guessed type __int16 word_93A0C;
// CBFF0: using guessed type __int16 word_CBFF0[];
// CBFF2: using guessed type __int16 word_CBFF2[63];
// CC070: using guessed type __int16 word_CC070[];
// CC140: using guessed type int dword_CC140;
// CC144: using guessed type int dword_CC144;
// CC154: using guessed type int dword_CC154;
// CC1C6: using guessed type __int16 word_CC1C6;

//----- (0005D610) --------------------------------------------------------
void sub_5D610(__int16 a1, __int16 a2)
{
  int v2; // edx
  unsigned __int8 i; // [esp+0h] [ebp-8h]
  char v4; // [esp+4h] [ebp-4h]

  if ( byte_939E4 && byte_939E5 && a2 <= (int)(unsigned __int16)word_CC1C6 )
  {
    v4 = 0;
    for ( i = 0; i < 0x20u; ++i )
    {
      if ( sub_651F8(dword_CC140, i) )
      {
        v4 = 1;
        break;
      }
    }
    if ( v4 )
    {
      word_CBFF0[2 * i] = a1;
      word_CBFF2[2 * i] = a2;
      word_93A02 = i;
      word_93A0C = 256;
      word_93A00 = 0x7FFF;
      word_CC070[i] = 0x7FFF;
      dword_939F8 = *(_DWORD *)(32 * a2 + dword_CC154 + 26) - 16;
      v2 = *(_DWORD *)(32 * a2 + dword_CC154 + 18);
      //fix word_939F4 = __DS__;
      dword_939F0 = v2;
      dword_CC144 = sub_6535C(dword_CC140, (unsigned int)&dword_939F0);
    }
  }
}
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// 939F0: using guessed type int dword_939F0;
// 939F4: using guessed type __int16 word_939F4;
// 939F8: using guessed type int dword_939F8;
// 93A00: using guessed type __int16 word_93A00;
// 93A02: using guessed type __int16 word_93A02;
// 93A0C: using guessed type __int16 word_93A0C;
// CBFF0: using guessed type __int16 word_CBFF0[];
// CBFF2: using guessed type __int16 word_CBFF2[63];
// CC070: using guessed type __int16 word_CC070[];
// CC140: using guessed type int dword_CC140;
// CC144: using guessed type int dword_CC144;
// CC154: using guessed type int dword_CC154;
// CC1C6: using guessed type __int16 word_CC1C6;

//----- (0005D750) --------------------------------------------------------
void sub_5D750(__int16 a1, __int16 a2)
{
  __int16 *v2; // [esp+0h] [ebp-8h]
  __int16 i; // [esp+4h] [ebp-4h]

  if ( byte_939E4 )
  {
    v2 = word_CBFF0;
    for ( i = 0; i < 32; ++i )
    {
      if ( *v2 == a1 && v2[1] == a2 && !sub_651F8(dword_CC140, i) )
      {
        sub_65965(dword_CC140, i);
        return;
      }
      v2 += 2;
    }
  }
}
// 939E4: using guessed type char byte_939E4;
// CBFF0: using guessed type __int16 word_CBFF0[];
// CC140: using guessed type int dword_CC140;

//----- (0005D7DF) --------------------------------------------------------
void sub_5D7DF()
{
  ;
}

//----- (0005D7F0) --------------------------------------------------------
bool sub_5D7F0(int a1)
{
  return dword_9C136[a1] == 0;
}
// 9C136: using guessed type int dword_9C136[8];

//----- (0005D829) --------------------------------------------------------
void sub_5D829()
{
  ;
}

//----- (0005D872) --------------------------------------------------------
void sub_5D872()
{
  ;
}

//----- (0005D883) --------------------------------------------------------
int sub_5D883(int a1, unsigned int a2, char a3)
{
  if ( (a3 & 1) != 0 )
  {
    LOBYTE(dword_A01C4) = 0;
  }
  else
  {
    LOBYTE(dword_A01C4) = 1;
    sub_66DF5();
    //fix sub_66D6A(a1, 0xFFFF, (int)sub_5DE91, __CS__);
    sub_66E21();
  }
  if ( a2 && (a3 & 1) == 0 )
  {
    if ( a2 == 65280 )
    {
      sub_5DE63(0xFFFF);
      dword_A043D = 65280;
    }
    else
    {
      sub_5DE63((unsigned int)&unk_1234DC / a2);
      dword_A043D = a2;
    }
    //fix word_A03FF = __CS__;
    dword_A03FB = (int)sub_5DF4B;
    dword_A047D = (int)sub_10000;
  }
  else
  {
    dword_A039D = 0xFFFF;
  }
  return 0;
}
// 10000: using guessed type void sub_10000();
// A01C4: using guessed type int dword_A01C4;
// A039D: using guessed type int dword_A039D;
// A03FB: using guessed type int dword_A03FB;
// A03FF: using guessed type __int16 word_A03FF;
// A043D: using guessed type int dword_A043D;
// A047D: using guessed type int dword_A047D;

//----- (0005D948) --------------------------------------------------------
int sub_5D948()
{
  if ( (_BYTE)dword_A01C4 )
  {
    sub_66DF5();
    sub_66E4D();
    sub_66E21();
  }
  return 0;
}
// A01C4: using guessed type int dword_A01C4;

//----- (0005D97B) --------------------------------------------------------
int sub_5D97B(unsigned int a1, int a2, __int16 a3, unsigned int a4)
{
  int v4; // edx
  unsigned int v7; // [esp+4h] [ebp-8h]
  unsigned int i; // [esp+8h] [ebp-4h]
  unsigned int j; // [esp+8h] [ebp-4h]

  for ( i = 0; i < 0x10 && (*(_DWORD *)&byte_A03A1[6 * i] || *(_WORD *)&byte_A03A1[6 * i + 4]); ++i )
    ;
  if ( i >= 0x10 )
    return 11;
  if ( (_BYTE)dword_A01C4 )
    sub_66DF5();
  v7 = i;
  v4 = 6 * i;
  *(_WORD *)&byte_A03A1[v4 + 4] = a3;
  *(_DWORD *)&byte_A03A1[v4] = a2;
  dword_A0401[i] = a1;
  if ( (unsigned int)&unk_1234DC / a1 < dword_A039D )
    sub_5DE63((unsigned int)&unk_1234DC / a1);
  for ( j = 0; j < 0x10; ++j )
  {
    if ( *(_DWORD *)&byte_A03A1[6 * j] || *(_WORD *)&byte_A03A1[6 * j + 4] )
    {
      if ( dword_A0401[j] == 65280 )
      {
        if ( dword_A039D == 0xFFFF )
          dword_A0441[j] = (int)sub_10000;
        else
          dword_A0441[j] = (unsigned int)&unk_123333 / ((unsigned int)&unk_1234DC / dword_A039D);
      }
      else
      {
        dword_A0441[j] = (dword_A0401[j] << 16) / ((unsigned int)&unk_1234DC / dword_A039D);
      }
      dword_A0481[j] = 0;
    }
  }
  if ( (_BYTE)dword_A01C4 )
    sub_66E21();
  __writegsdword(a4, v7);
  return 0;
}
// 10000: using guessed type void sub_10000();
// A01C4: using guessed type int dword_A01C4;
// A039D: using guessed type int dword_A039D;
// A0401: using guessed type int dword_A0401[15];
// A0441: using guessed type int dword_A0441[15];
// A0481: using guessed type int dword_A0481[];

//----- (0005DB1D) --------------------------------------------------------
int sub_5DB1D(unsigned int a1, unsigned int a2)
{
  unsigned int i; // [esp+4h] [ebp-4h]

  if ( a1 >= 0x10 )
    return 10;
  if ( !*(_DWORD *)&byte_A03A1[6 * a1] && !*(_WORD *)&byte_A03A1[6 * a1 + 4] )
    return 10;
  if ( (_BYTE)dword_A01C4 )
    sub_66DF5();
  dword_A0401[a1] = a2;
  if ( (unsigned int)&unk_1234DC / a2 < dword_A039D )
    sub_5DE63((unsigned int)&unk_1234DC / a2);
  for ( i = 0; i < 0x10; ++i )
  {
    if ( *(_DWORD *)&byte_A03A1[6 * i] || *(_WORD *)&byte_A03A1[6 * i + 4] )
    {
      if ( dword_A0401[i] == 65280 )
      {
        if ( dword_A039D == 0xFFFF )
          dword_A0441[i] = (int)sub_10000;
        else
          dword_A0441[i] = (unsigned int)&unk_123333 / ((unsigned int)&unk_1234DC / dword_A039D);
      }
      else
      {
        dword_A0441[i] = (dword_A0401[i] << 16) / ((unsigned int)&unk_1234DC / dword_A039D);
      }
      dword_A0481[i] = 0;
    }
  }
  if ( (_BYTE)dword_A01C4 )
    sub_66E21();
  return 0;
}
// 10000: using guessed type void sub_10000();
// A01C4: using guessed type int dword_A01C4;
// A039D: using guessed type int dword_A039D;
// A0401: using guessed type int dword_A0401[15];
// A0441: using guessed type int dword_A0441[15];
// A0481: using guessed type int dword_A0481[];

//----- (0005DC91) --------------------------------------------------------
int sub_5DC91(int a1)
{
  int v1; // eax
  unsigned int v3; // [esp+4h] [ebp-8h]
  unsigned int i; // [esp+8h] [ebp-4h]
  unsigned int j; // [esp+8h] [ebp-4h]

  v3 = 0;
  v1 = 6 * a1;
  *(_WORD *)&byte_A03A1[v1 + 4] = 0;
  *(_DWORD *)&byte_A03A1[v1] = 0;
  for ( i = 0; i < 0x10; ++i )
  {
    if ( (*(_DWORD *)&byte_A03A1[6 * i] || *(_WORD *)&byte_A03A1[6 * i + 4])
      && dword_A0401[i] > v3
      && dword_A0401[i] != 65280 )
    {
      v3 = dword_A0401[i];
    }
  }
  if ( v3 )
    sub_5DE63((unsigned int)&unk_1234DC / v3);
  else
    sub_5DE63(0xFFFF);
  if ( (_BYTE)dword_A01C4 )
    sub_66DF5();
  for ( j = 0; j < 0x10; ++j )
  {
    if ( *(_DWORD *)&byte_A03A1[6 * j] || *(_WORD *)&byte_A03A1[6 * j + 4] )
    {
      if ( dword_A0401[j] == 65280 )
      {
        if ( dword_A039D == 0xFFFF )
          dword_A0441[j] = (int)sub_10000;
        else
          dword_A0441[j] = (unsigned int)&unk_123333 / ((unsigned int)&unk_1234DC / dword_A039D);
      }
      else
      {
        dword_A0441[j] = (dword_A0401[j] << 16) / ((unsigned int)&unk_1234DC / dword_A039D);
      }
      dword_A0481[j] = 0;
    }
  }
  if ( (_BYTE)dword_A01C4 )
    sub_66E21();
  return 0;
}
// 10000: using guessed type void sub_10000();
// A01C4: using guessed type int dword_A01C4;
// A039D: using guessed type int dword_A039D;
// A0401: using guessed type int dword_A0401[15];
// A0441: using guessed type int dword_A0441[15];
// A0481: using guessed type int dword_A0481[];

//----- (0005DE40) --------------------------------------------------------
int sub_5DE40(int a1)
{
  return dword_A0401[a1];
}
// A0401: using guessed type int dword_A0401[15];

//----- (0005DE63) --------------------------------------------------------
int sub_5DE63(int a1)
{
  dword_A039D = a1;
  sub_66D24(a1);
  return 0;
}
// A039D: using guessed type int dword_A039D;

//----- (0005DE91) --------------------------------------------------------
int sub_5DE91(int a1, int a2, int a3)
{
  void *retaddr[2]; // [esp+10h] [ebp+10h]

  for ( dword_12F040 = 0; (unsigned int)dword_12F040 < 0x10; ++dword_12F040 )
  {
    a1 = 6 * dword_12F040;
    if ( *(_DWORD *)&byte_A03A1[6 * dword_12F040] || *(_WORD *)&byte_A03A1[6 * dword_12F040 + 4] )
    {
      a2 = dword_A0441[dword_12F040];
      dword_A0481[dword_12F040] += a2;
      a1 = 4 * dword_12F040;
      if ( (dword_A0481[dword_12F040] & 0x10000) != 0 )
      {
        HIWORD(dword_A0481[dword_12F040]) = 0;
        if ( byte_A04C1[dword_12F040] != -1 )
          byte_A04D1 = byte_A04C1[dword_12F040];
        //fix a1 = MK_FP(*(_WORD *)&byte_A03A1[6 * dword_12F040 + 4], *(_DWORD *)&byte_A03A1[6 * dword_12F040])();
      }
    }
  }
  return 0; //fix  MK_FP(retaddr[0], retaddr[0])(a1, a2, a3);
}
// A0441: using guessed type int dword_A0441[15];
// A0481: using guessed type int dword_A0481[];
// A04D1: using guessed type char byte_A04D1;
// 12F040: using guessed type int dword_12F040;

//----- (0005DF4B) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int sub_5DF4B(int a1, int a2, int a3)
{
  int v3; // eax
  void *retaddr[2]; // [esp+10h] [ebp+10h]

  v3 = sub_66EA2();
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(v3, a2, a3);
}
// 5DF60: positive sp value 4 has been found

//----- (0005DF61) --------------------------------------------------------
void sub_5DF61()
{
  ;
}

//----- (0005DF72) --------------------------------------------------------
void sub_5DF72()
{
  ;
}

//----- (0005DF83) --------------------------------------------------------
int sub_5DF83(int a1, unsigned int a2, unsigned __int16 a3, int a4, int a5)
{
  unsigned __int8 v6; // [esp+0h] [ebp-38h]
  unsigned __int8 v7; // [esp+4h] [ebp-34h]
  int v9; // [esp+14h] [ebp-24h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  unsigned int k; // [esp+1Ch] [ebp-1Ch]
  unsigned int n; // [esp+1Ch] [ebp-1Ch]
  unsigned int ii; // [esp+1Ch] [ebp-1Ch]
  unsigned int j; // [esp+20h] [ebp-18h]
  unsigned int m; // [esp+20h] [ebp-18h]
  unsigned __int8 v16; // [esp+24h] [ebp-14h]
  unsigned __int8 v17; // [esp+28h] [ebp-10h]
  unsigned __int8 v18; // [esp+2Ch] [ebp-Ch]
  unsigned __int8 i; // [esp+30h] [ebp-8h]
  unsigned __int8 v20; // [esp+34h] [ebp-4h]

  v17 = 0;
  v16 = -1;
  v9 = -1;
  if ( dword_9EBC9 )
  {
    v18 = __readgsbyte(a2);
    v20 = v18 & 0xF;
    for ( i = byte_9DF8F[128 * a4 + 16 * a1 + (v18 & 0xF)]; ; i = 9 )
    {
LABEL_9:
      if ( i != 0xFF )
      {
        __writegsbyte(a2, v18 & 0xF0 | i);
        goto LABEL_66;
      }
      if ( v20 != 9 )
        break;
      byte_9DF8F[128 * a4 + 9 + 16 * a1] = 9;
    }
    for ( j = 0; j < 0x10; ++j )
    {
      while ( !byte_9EC5D[16 * a4 + j] && j < 0x10 )
        ++j;
      if ( j < 0x10 && byte_9E25F[16 * a4 + j] == -1 )
      {
        byte_9DF8F[128 * a4 + 16 * a1 + v20] = j;
        i = j;
        byte_9E25F[16 * a4 + j] = v20;
        byte_9E2AF[16 * a4 + j] = a1;
        byte_9E20F[16 * a4 + j] = __readgsbyte(*(_DWORD *)&byte_9C176[6 * a1] + 4 * v20 + 64);
        v10 = (unsigned __int8)byte_9E93F[128 * a4 + 16 * a1 + v20];
        if ( v10 == 255 )
        {
          for ( k = 0; k < 4; ++k )
          {
            if ( byte_9E2FF[320 * a4 + 20 * v20 + 5 * k] == -1 )
            {
              byte_9E2FF[320 * a4 + 20 * v20 + 5 * k] = 1;
              byte_9E93F[128 * a4 + 16 * a1 + v20] = k;
              goto LABEL_9;
            }
          }
        }
        else
        {
          byte_9ECAE[16 * a4 + (unsigned __int8)j] = 127;
          byte_9EBBF = j | 0xC0;
          byte_9EBC0 = 121;
          byte_9EBC1 = 0;
          //fix
          /*MK_FP(*(_WORD*)&byte_9C062[36 * a4 + 4], *(_DWORD*)&byte_9C062[36 * a4])(
            &byte_9EBBF,
            (unsigned __int16)__DS__,
            3,
            a4);*/
          if ( byte_9E302[320 * a4 + 20 * v20 + 5 * v10] != -1 )
          {
            byte_9EBBF = j | 0xC0;
            byte_9EBC0 = byte_9E302[320 * a4 + 20 * v20 + 5 * v10];
            //fix
            /*
            MK_FP(*(_WORD *)&byte_9C062[36 * a4 + 4], *(_DWORD *)&byte_9C062[36 * a4])(
              &byte_9EBBF,
              (unsigned __int16)__DS__,
              2,
              a4);*/
          }
          if ( byte_9E300[320 * a4 + 20 * v20 + 5 * v10] != -1 )
          {
            byte_9EBBF = j | 0xE0;
            byte_9EBC0 = 0;
            byte_9EBC1 = byte_9E300[320 * a4 + 20 * v20 + 5 * v10];
            //fix
            /*
            MK_FP(*(_WORD *)&byte_9C062[36 * a4 + 4], *(_DWORD *)&byte_9C062[36 * a4])(
              &byte_9EBBF,
              (unsigned __int16)__DS__,
              2,
              a4);*/
          }
          if ( byte_9E301[320 * a4 + 20 * v20 + 5 * v10] != -1 )
          {
            byte_9EBBF = j | 0xB0;
            byte_9EBC0 = 7;
            byte_9EBC1 = byte_9E301[320 * a4 + 20 * v20 + 5 * v10];
            //fix
            /*
            MK_FP(*(_WORD *)&byte_9C062[36 * a4 + 4], *(_DWORD *)&byte_9C062[36 * a4])(
              &byte_9EBBF,
              (unsigned __int16)__DS__,
              3,
              a4);*/
          }
          if ( byte_9E303[320 * a4 + 20 * v20 + 5 * v10] != -1 )
          {
            byte_9EBBF = j | 0xB0;
            byte_9EBC0 = 64;
            byte_9EBC1 = byte_9E303[320 * a4 + 20 * v20 + 5 * v10];
            //fix
            /*
            MK_FP(*(_WORD *)&byte_9C062[36 * a4 + 4], *(_DWORD *)&byte_9C062[36 * a4])(
              &byte_9EBBF,
              (unsigned __int16)__DS__,
              3,
              a4);*/
          }
        }
        goto LABEL_9;
      }
    }
    for ( m = 0; m < 0x10; ++m )
    {
      while ( !byte_9EC5D[16 * a4 + m] && m < 0x10 )
        ++m;
      if ( m < 0x10 && (unsigned __int8)byte_9E20F[16 * a4 + m] > v17 && byte_9E20F[16 * a4 + m] != -1 )
      {
        v17 = byte_9E20F[16 * a4 + m];
        v16 = m;
      }
    }
    if ( v16 == 0xFF )
      goto LABEL_66;
    if ( v17 > __readgsdword(*(_DWORD *)&byte_9C176[6 * a1] + 4 * v20 + 64) )
    {
      byte_9DF8F[128 * a4 + 16 * a1 + v20] = v16;
      byte_9DF8F[128 * a4 + 16 * (unsigned __int8)byte_9E2AF[16 * a4 + v16] + (unsigned __int8)byte_9E25F[16 * a4 + v16]] = -1;
      byte_9E25F[16 * a4 + v16] = v20;
      byte_9E2AF[16 * a4 + v16] = a1;
      i = v16;
      byte_9E20F[16 * a4 + v16] = __readgsbyte(*(_DWORD *)&byte_9C176[6 * a1] + 4 * v20 + 64);
      byte_9ECAE[16 * a4 + v16] = 127;
      byte_9EBBF = v16 | 0xB0;
      byte_9EBC0 = 123;
      byte_9EBC1 = 0;
      //fix
      /*
      MK_FP(*(_WORD *)&byte_9C062[36 * a4 + 4], *(_DWORD *)&byte_9C062[36 * a4])(
        &byte_9EBBF,
        (unsigned __int16)__DS__,
        3,
        a4);*/
      byte_9EBBF = v16 | 0xB0;
      byte_9EBC0 = 121;
      byte_9EBC1 = 0;
      //fix
      /*
      MK_FP(*(_WORD *)&byte_9C062[36 * a4 + 4], *(_DWORD *)&byte_9C062[36 * a4])(
        &byte_9EBBF,
        (unsigned __int16)__DS__,
        3,
        a4);*/
      if ( byte_9E93F[128 * a4 + 16 * a1 + v20] == -1 )
      {
        for ( n = 0; n < 4; ++n )
        {
          if ( byte_9E2FF[320 * a4 + 20 * v20 + 5 * n] == -1 )
          {
            byte_9E2FF[320 * a4 + 20 * v20 + 5 * n] = 1;
            byte_9E93F[128 * a4 + 16 * a1 + v20] = n;
            goto LABEL_9;
          }
        }
      }
      goto LABEL_9;
    }
    if ( byte_9E93F[128 * a4 + 16 * a1 + v20] == -1 )
    {
      for ( ii = 0; ii < 4; ++ii )
      {
        if ( byte_9E2FF[320 * a4 + 20 * v20 + 5 * ii] == -1 )
        {
          byte_9E2FF[320 * a4 + 20 * v20 + 5 * ii] = 1;
          byte_9E93F[128 * a4 + 16 * a1 + v20] = ii;
          break;
        }
      }
    }
LABEL_66:
    if ( v20 == 9 )
    {
      if ( v18 == 0xB9 && __readgsbyte(a2 + 1) == 7 )
        v9 = __readgsbyte(a2 + 2);
      byte_9ECB7[16 * a4] = v9;
    }
    else
    {
      v6 = v18 & 0xF0;
      if ( (v18 & 0xF0u) < 0xC0 )
      {
        if ( v6 == 0xB0 )
        {
          v7 = __readgsbyte(a2 + 1);
          if ( v7 >= 7u )
          {
            if ( v7 <= 7u )
            {
              byte_9E301[320 * a4 + 20 * v20 + 5 * (unsigned __int8)byte_9E93F[128 * a4 + 16 * a1 + v20]] = __readgsbyte(a2 + 2);
              v9 = __readgsbyte(a2 + 2);
              byte_9ECAE[16 * a4 + i] = v9;
            }
            else if ( v7 == 64 )
            {
              byte_9E303[320 * a4 + 20 * v20 + 5 * (unsigned __int8)byte_9E93F[128 * a4 + 16 * a1 + v20]] = __readgsbyte(a2 + 2);
            }
          }
        }
      }
      else if ( v6 <= 0xC0u )
      {
        byte_9E302[320 * a4 + 20 * v20 + 5 * (unsigned __int8)byte_9E93F[128 * a4 + 16 * a1 + v20]] = __readgsbyte(a2 + 1);
      }
      else if ( v6 == 0xE0 )
      {
        byte_9E300[320 * a4 + 20 * v20 + 5 * (unsigned __int8)byte_9E93F[128 * a4 + 16 * a1 + v20]] = __readgsbyte(a2 + 2);
      }
    }
    if ( i == 0xFF )
    {
      return -1;
    }
    else
    {
      if ( v9 != -1 )
        __writegsbyte(a2 + 2, (v9 * (unsigned int)(unsigned __int8)byte_9ECAD) >> 7);
      //fix MK_FP(*(_WORD *)&byte_9C062[36 * a4 + 4], *(_DWORD *)&byte_9C062[36 * a4])(a2, a3, a5, a4);
      __writegsbyte(a2, v18);
      if ( v9 != -1 )
        __writegsbyte(a2 + 2, v9);
      return 0;
    }
  }
  else
  {
    if ( (__readgsbyte(a2) & 0xF0) == 0xB0 )
    {
      if ( __readgsbyte(a2 + 1) == 7 )
      {
        byte_9EBBF = __readgsbyte(a2);
        byte_9EBC0 = 7;
        byte_9EBC1 = (__readgsbyte(a2 + 2) * (unsigned int)(unsigned __int8)byte_9ECAD) >> 7;
      }
      //fix
      /*
      MK_FP(*(_WORD *)&byte_9C062[36 * a4 + 4], *(_DWORD *)&byte_9C062[36 * a4])(
        &byte_9EBBF,
        (unsigned __int16)__DS__,
        a5,
        a4);*/
    }
    else
    {
        //fix MK_FP(*(_WORD *)&byte_9C062[36 * a4 + 4], *(_DWORD *)&byte_9C062[36 * a4])(a2, a3, a5, a4);
    }
    return 1;
  }
}
// 9EBBF: using guessed type char byte_9EBBF;
// 9EBC0: using guessed type char byte_9EBC0;
// 9EBC1: using guessed type char byte_9EBC1;
// 9EBC9: using guessed type int dword_9EBC9;
// 9ECAD: using guessed type char byte_9ECAD;
// 5DF83: using guessed type unsigned int arg_4;

//----- (0005E9C1) --------------------------------------------------------
int sub_5E9C1(int a1)
{
  unsigned int i; // [esp+8h] [ebp-14h]
  unsigned int v3; // [esp+Ch] [ebp-10h]
  unsigned __int8 v4; // [esp+10h] [ebp-Ch]
  unsigned __int8 v5; // [esp+14h] [ebp-8h]
  unsigned __int8 v6; // [esp+18h] [ebp-4h]

  for ( i = 0; i < dword_9C042[a1]; ++i )
  {
    v3 = __readgsdword(*(int *)((char *)&dword_9BFF2 + 6 * a1) + 4 * i);
    if ( v3 != -1 && v3 != 255 )
    {
      v5 = __readgsbyte(*(int *)((char *)&dword_9D98F[48 * a1] + 6 * i) + 8);
      if ( dword_9EBC9 )
      {
        v4 = byte_9DF8F[128 * v3 + 16 * a1 + v5];
        byte_9DF8F[128 * v3 + 16 * a1 + v5] = -1;
        v6 = byte_9E93F[128 * v3 + 16 * a1 + v5];
        byte_9E25F[16 * v3 + v4] = -1;
        byte_9E2AF[16 * v3 + v4] = -1;
        byte_9EBBF = v4 | 0xB0;
        byte_9EBC0 = 123;
        byte_9EBC1 = 0;
        //
        /*
        MK_FP(*(_WORD *)&byte_9C062[36 * v3 + 4], *(_DWORD *)&byte_9C062[36 * v3])(
          &byte_9EBBF,
          (unsigned __int16)__DS__,
          3,
          v3);*/
        byte_9EBBF = v4 | 0xB0;
        byte_9EBC0 = 121;
        byte_9EBC1 = 0;
        //fix
        /*
        MK_FP(*(_WORD *)&byte_9C062[36 * v3 + 4], *(_DWORD *)&byte_9C062[36 * v3])(
          &byte_9EBBF,
          (unsigned __int16)__DS__,
          3,
          v3);*/
        byte_9EBBF = v4 | 0xE0;
        byte_9EBC0 = 64;
        byte_9EBC1 = 64;
        //fix
        /*
        MK_FP(*(_WORD *)&byte_9C062[36 * v3 + 4], *(_DWORD *)&byte_9C062[36 * v3])(
          &byte_9EBBF,
          (unsigned __int16)__DS__,
          3,
          v3);*/
        byte_9EBBF = v4 | 0xB0;
        byte_9EBC0 = 7;
        byte_9EBC1 = 0;
        //fix
        /*
        MK_FP(*(_WORD *)&byte_9C062[36 * v3 + 4], *(_DWORD *)&byte_9C062[36 * v3])(
          &byte_9EBBF,
          (unsigned __int16)__DS__,
          3,
          v3);*/
        if ( v6 != 0xFF )
        {
          byte_9E302[320 * v3 + 20 * v5 + 5 * v6] = -1;
          byte_9E300[320 * v3 + 20 * v5 + 5 * v6] = -1;
          byte_9E301[320 * v3 + 20 * v5 + 5 * v6] = -1;
          byte_9E303[320 * v3 + 20 * v5 + 5 * v6] = -1;
          byte_9E2FF[320 * v3 + 20 * v5 + 5 * v6] = -1;
          byte_9E93F[128 * v3 + 16 * a1 + v5] = -1;
        }
      }
      else
      {
        byte_9EBBF = v5 | 0xB0;
        byte_9EBC0 = 123;
        byte_9EBC1 = 0;
        //fix
        /*
        MK_FP(*(_WORD *)&byte_9C062[36 * v3 + 4], *(_DWORD *)&byte_9C062[36 * v3])(
          &byte_9EBBF,
          (unsigned __int16)__DS__,
          3,
          v3);*/
        byte_9EBBF = v5 | 0xB0;
        byte_9EBC0 = 121;
        byte_9EBC1 = 0;
        //fix
        /*
        MK_FP(*(_WORD *)&byte_9C062[36 * v3 + 4], *(_DWORD *)&byte_9C062[36 * v3])(
          &byte_9EBBF,
          (unsigned __int16)__DS__,
          3,
          v3);*/
        byte_9EBBF = v5 | 0xE0;
        byte_9EBC0 = 64;
        byte_9EBC1 = 64;
        //fix
        /*
        MK_FP(*(_WORD *)&byte_9C062[36 * v3 + 4], *(_DWORD *)&byte_9C062[36 * v3])(
          &byte_9EBBF,
          (unsigned __int16)__DS__,
          3,
          v3);*/
        byte_9EBBF = v5 | 0xB0;
        byte_9EBC0 = 7;
        byte_9EBC1 = 0;
        //fix
        /*
        MK_FP(*(_WORD *)&byte_9C062[36 * v3 + 4], *(_DWORD *)&byte_9C062[36 * v3])(
          &byte_9EBBF,
          (unsigned __int16)__DS__,
          3,
          v3);*/
      }
    }
  }
  return 1;
}
// 9BFF2: using guessed type int dword_9BFF2;
// 9C042: using guessed type int dword_9C042[8];
// 9D98F: using guessed type int dword_9D98F[];
// 9EBBF: using guessed type char byte_9EBBF;
// 9EBC0: using guessed type char byte_9EBC0;
// 9EBC1: using guessed type char byte_9EBC1;
// 9EBC9: using guessed type int dword_9EBC9;

//----- (0005EDA0) --------------------------------------------------------
int sub_5EDA0(int a1, int a2, unsigned __int16 a3, int a4)
{
  //fix MK_FP(*(_WORD *)&byte_9C062[36 * a1 + 4], *(_DWORD *)&byte_9C062[36 * a1])(a2, a3, a4, a1);
  return 0;
}

//----- (0005EDD6) --------------------------------------------------------
int sub_5EDD6(int a1)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = dword_9EBC9;
  dword_9EBC9 = a1;
  return v2;
}
// 9EBC9: using guessed type int dword_9EBC9;

//----- (0005EE00) --------------------------------------------------------
void sub_5EE00()
{
  ;
}

//----- (0005EE11) --------------------------------------------------------
void sub_5EE11()
{
  ;
}

//----- (0005EE22) --------------------------------------------------------
int sub_5EE22(unsigned int a1, int a2, int a3, __int16 a4, unsigned int a5)
{
  unsigned __int64 v5; // rax
  int v6; // ebx
  int v7; // ebx
  unsigned int v8; // ebx
  unsigned __int64 v9; // rax
  int v10; // ebx
  unsigned __int64 v11; // rax
  int v12; // ebx
  int v13; // ebx
  int v14; // eax
  int v16; // [esp+8h] [ebp-34h]
  __int16 v17; // [esp+Ch] [ebp-30h]
  int v18; // [esp+10h] [ebp-2Ch]
  int i; // [esp+18h] [ebp-24h]
  int v20; // [esp+1Ch] [ebp-20h]
  unsigned int n; // [esp+20h] [ebp-1Ch]
  unsigned int v22; // [esp+24h] [ebp-18h]
  unsigned int j; // [esp+28h] [ebp-14h]
  unsigned int ii; // [esp+28h] [ebp-14h]
  int v26; // [esp+34h] [ebp-8h]
  unsigned int k; // [esp+38h] [ebp-4h]
  unsigned int m; // [esp+38h] [ebp-4h]

  v26 = 0;
  for ( i = 0; byte_9ECFF[i]; ++i )
  {
    if ( byte_9ECFF[i] != __readgsbyte(__readgsdword(a1) + i) )
      return 14;
  }
  for ( j = 0; j < 8; ++j )
  {
    if ( !*(_DWORD *)&byte_9C176[6 * j] && !*(_WORD *)&byte_9C176[6 * j + 4] )
    {
      v22 = j;
      break;
    }
  }
  if ( j == 8 )
    return 11;
  v5 = sub_66EF6(__readgsdword(a1), __readgsword(a1 + 4));
  v6 = v5;
  LODWORD(v5) = 6 * v22;
  *(_WORD *)&byte_9C176[v5 + 4] = WORD2(v5);
  *(_DWORD *)&byte_9C176[v5] = v6;
  v17 = *(_WORD *)&byte_9C176[6 * v22 + 4];
  v16 = *(_DWORD *)&byte_9C176[6 * v22] + 776;
  v7 = 3 * v22;
  word_9BFF6[v7] = a4;
  *(int *)((char *)&dword_9BFF2 + v7 * 2) = a3;
  dword_9C022[v22] = __readgsdword(*(_DWORD *)&byte_9C176[6 * v22] + 48);
  dword_9C042[v22] = dword_9C022[v22];
  LODWORD(v5) = *(_DWORD *)&byte_9C176[6 * v22];
  v8 = __readgsdword(a1 + 8);
  __writegsword(v5 + 772, __readgsword(a1 + 12));
  __writegsdword(v5 + 768, v8);
  for ( k = 0; k < dword_9C022[v22]; ++k )
  {
    dword_9BBF2[32 * v22 + k] = 0;
    v9 = sub_66EF6(v26 + v16, v17);
    v10 = v9;
    LODWORD(v9) = 6 * k + 192 * v22;
    *(__int16 *)((char *)&word_9D993 + v9) = WORD2(v9);
    *(int *)((char *)dword_9D98F + v9) = v10;
    v11 = sub_66EF6(v16 + v26 + 12, v17);
    v12 = v11;
    LODWORD(v11) = 192 * v22 + 6 * k;
    *(_WORD *)&byte_9B1F2[v11 + 4] = WORD2(v11);
    *(_DWORD *)&byte_9B1F2[v11] = v12;
    v13 = v11;
    v18 = sub_5F7C7(
            *(_DWORD *)&byte_9B1F2[v11],
            *(unsigned __int16 *)&byte_9B1F2[v11 + 4],
            (unsigned int)&dword_9B7F2[32 * v22 + k])
        + *(_DWORD *)&byte_9B1F2[v13];
    *(_WORD *)&byte_9B1F2[v13 + 4] = *(_WORD *)&byte_9B1F2[v13 + 4];
    *(_DWORD *)&byte_9B1F2[v13] = v18;
    v26 += __readgsdword(sub_66EF6(v26 + v16, v17) + 4);
  }
  for ( m = 0; m < dword_9C042[v22]; ++m )
  {
    if ( __readgsdword(*(int *)((char *)&dword_9BFF2 + 6 * v22) + 4 * m) == 255 )
    {
      v20 = 0;
      for ( n = 0; __readgsdword(*(_DWORD *)&byte_9C176[6 * v22] + 20 * m + 4 * n + 128) && !v20 && n < 5; ++n )
      {
        for ( ii = 0; ii < 5; ++ii )
        {
          if ( __readgsdword(*(_DWORD *)&byte_9C176[6 * v22] + 20 * m + 4 * n + 128) == 40960 )
          {
            if ( dword_9B1B6[ii] == 40960 || dword_9B1B6[ii] == 40961 || dword_9B1B6[ii] == 40968 )
            {
LABEL_38:
              __writegsdword(*(int *)((char *)&dword_9BFF2 + 6 * v22) + 4 * m, ii);
              v20 = 1;
              break;
            }
          }
          else if ( dword_9B1B6[ii] == __readgsdword(*(_DWORD *)&byte_9C176[6 * v22] + 20 * m + 4 * n + 128) )
          {
            goto LABEL_38;
          }
        }
      }
      if ( __readgsdword(*(_DWORD *)&byte_9C176[6 * v22] + 20 * m + 128) )
      {
        if ( !v20 )
        {
          v14 = 6 * m + 192 * v22;
          *(_WORD *)&byte_9B1F2[v14 + 4] = 0;
          *(_DWORD *)&byte_9B1F2[v14] = 0;
          __writegsdword(*(int *)((char *)&dword_9BFF2 + 6 * v22) + 4 * m, 0xFFu);
          --dword_9C022[v22];
        }
      }
      else
      {
        __writegsdword(*(int *)((char *)&dword_9BFF2 + 6 * v22) + 4 * m, 0);
      }
    }
  }
  __writegsdword(a5, v22);
  return 0;
}
// 5EEE0: variable 'v22' is possibly undefined
// 9B1B6: using guessed type int dword_9B1B6[6];
// 9B7F2: using guessed type int dword_9B7F2[256];
// 9BBF2: using guessed type int dword_9BBF2[256];
// 9BFF2: using guessed type int dword_9BFF2;
// 9BFF6: using guessed type __int16 word_9BFF6[];
// 9C022: using guessed type int dword_9C022[8];
// 9C042: using guessed type int dword_9C042[8];
// 9D98F: using guessed type int dword_9D98F[];
// 9D993: using guessed type __int16 word_9D993;
// 5EE22: using guessed type unsigned int arg_0;

//----- (0005F355) --------------------------------------------------------
int sub_5F355(unsigned int a1)
{
  int v1; // eax

  if ( a1 >= 8 )
    return 10;
  v1 = 6 * a1;
  *(_WORD *)&byte_9C176[v1 + 4] = 0;
  *(_DWORD *)&byte_9C176[v1] = 0;
  return 0;
}

//----- (0005F398) --------------------------------------------------------
int sub_5F398(int a1)
{
  int v3; // [esp+4h] [ebp-4h]

  //fix
  v3 = 0;
  //fix

  //fix
  /*
  v3 = sub_5D97B(
         __readgsdword(*(_DWORD *)&byte_9C176[6 * a1] + 56),
         (int)sub_66F3C,
         __CS__,
         (unsigned int)&dword_9C1A6[a1]);*/
  if ( v3 )
    return v3;
  byte_A04C1[dword_9C1A6[a1]] = a1;
  dword_9C136[a1] = 1;
  return 0;
}
// 9C136: using guessed type int dword_9C136[8];
// 9C1A6: using guessed type int dword_9C1A6[8];

//----- (0005F420) --------------------------------------------------------
int sub_5F420(unsigned int a1)
{
  int v1; // edx
  int v2; // eax
  int v4; // [esp+0h] [ebp-14h] BYREF
  __int16 v5; // [esp+4h] [ebp-10h]
  unsigned int v6; // [esp+8h] [ebp-Ch]
  unsigned __int16 v7; // [esp+Ch] [ebp-8h]

  if ( a1 >= 8 )
    return 10;
  if ( dword_9C1A6[a1] != -1 )
    sub_5DC91(dword_9C1A6[a1]);
  byte_A04C1[dword_9C1A6[a1]] = -1;
  dword_9C1A6[a1] = -1;
  if ( dword_9C136[a1] )
  {
    v5 = *(_WORD *)&byte_9C176[6 * a1 + 4];
    v4 = *(_DWORD *)&byte_9C176[6 * a1];
    v1 = *(_DWORD *)&byte_9C176[6 * a1];
    v7 = __readgsword(v1 + 772);
    v6 = __readgsdword(v1 + 768);
    sub_5E9C1(a1);
    dword_9C136[a1] = 0;
    v2 = 6 * a1;
    *(_WORD *)&byte_9C176[v2 + 4] = 0;
    *(_DWORD *)&byte_9C176[v2] = 0;
    sub_5F529(a1, (unsigned int)&v4);
  }
  return 0;
}
// 9C136: using guessed type int dword_9C136[8];
// 9C1A6: using guessed type int dword_9C1A6[8];

//----- (0005F529) --------------------------------------------------------
int sub_5F529(int a1, unsigned int a2)
{
  unsigned __int64 v2; // rax
  int v3; // ebx
  unsigned int v4; // ebx
  unsigned __int64 v5; // rax
  int v6; // ebx
  unsigned __int64 v7; // rax
  int v8; // ebx
  int v9; // ebx
  int v10; // eax
  int v12; // [esp+8h] [ebp-20h]
  int v13; // [esp+10h] [ebp-18h]
  __int16 v14; // [esp+14h] [ebp-14h]
  int v15; // [esp+20h] [ebp-8h]
  unsigned int i; // [esp+24h] [ebp-4h]
  unsigned int j; // [esp+24h] [ebp-4h]

  v15 = 0;
  v2 = sub_66EF6(__readgsdword(a2), __readgsword(a2 + 4));
  v3 = v2;
  LODWORD(v2) = 6 * a1;
  *(_WORD *)&byte_9C176[v2 + 4] = WORD2(v2);
  *(_DWORD *)&byte_9C176[v2] = v3;
  v14 = *(_WORD *)&byte_9C176[6 * a1 + 4];
  v13 = *(_DWORD *)&byte_9C176[6 * a1] + 776;
  dword_9C022[a1] = __readgsdword(*(_DWORD *)&byte_9C176[6 * a1] + 48);
  dword_9C042[a1] = dword_9C022[a1];
  LODWORD(v2) = *(_DWORD *)&byte_9C176[6 * a1];
  v4 = __readgsdword(a2 + 8);
  __writegsword(v2 + 772, __readgsword(a2 + 12));
  __writegsdword(v2 + 768, v4);
  for ( i = 0; i < dword_9C022[a1]; ++i )
  {
    dword_9BBF2[32 * a1 + i] = 0;
    v5 = sub_66EF6(v15 + v13, v14);
    v6 = v5;
    LODWORD(v5) = 6 * i + 192 * a1;
    *(__int16 *)((char *)&word_9D993 + v5) = WORD2(v5);
    *(int *)((char *)dword_9D98F + v5) = v6;
    v7 = sub_66EF6(v13 + v15 + 12, v14);
    v8 = v7;
    LODWORD(v7) = 192 * a1 + 6 * i;
    *(_WORD *)&byte_9B1F2[v7 + 4] = WORD2(v7);
    *(_DWORD *)&byte_9B1F2[v7] = v8;
    v9 = v7;
    v12 = sub_5F7C7(
            *(_DWORD *)&byte_9B1F2[v7],
            *(unsigned __int16 *)&byte_9B1F2[v7 + 4],
            (unsigned int)&dword_9B7F2[32 * a1 + i])
        + *(_DWORD *)&byte_9B1F2[v9];
    *(_WORD *)&byte_9B1F2[v9 + 4] = *(_WORD *)&byte_9B1F2[v9 + 4];
    *(_DWORD *)&byte_9B1F2[v9] = v12;
    v15 += __readgsdword(sub_66EF6(v15 + v13, v14) + 4);
  }
  for ( j = 0; j < dword_9C042[a1]; ++j )
  {
    if ( __readgsdword(*(int *)((char *)&dword_9BFF2 + 6 * a1) + 4 * j) == 255 )
    {
      v10 = 192 * a1 + 6 * j;
      *(_WORD *)&byte_9B1F2[v10 + 4] = 0;
      *(_DWORD *)&byte_9B1F2[v10] = 0;
      --dword_9C022[a1];
    }
  }
  return 0;
}
// 9B7F2: using guessed type int dword_9B7F2[256];
// 9BBF2: using guessed type int dword_9BBF2[256];
// 9BFF2: using guessed type int dword_9BFF2;
// 9C022: using guessed type int dword_9C022[8];
// 9C042: using guessed type int dword_9C042[8];
// 9D98F: using guessed type int dword_9D98F[];
// 9D993: using guessed type __int16 word_9D993;

//----- (0005F7C7) --------------------------------------------------------
int sub_5F7C7(unsigned int a1, int a2, unsigned int a3)
{
  unsigned int v3; // eax
  int v5; // [esp+4h] [ebp-14h]
  unsigned int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  int v8; // [esp+10h] [ebp-8h]
  char v9; // [esp+14h] [ebp-4h]

  v8 = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  do
  {
    ++v5;
    v3 = a1++;
    v9 = __readgsbyte(v3);
    if ( v9 < 0 )
      v8 = 1;
    v6 |= (v9 & 0x7F) << v7;
    v7 += 7;
  }
  while ( !v8 );
  __writegsdword(a3, v6);
  return v5;
}

//----- (0005F83E) --------------------------------------------------------
int sub_5F83E(char a1)
{
  int v2; // [esp+8h] [ebp-Ch]
  unsigned int i; // [esp+Ch] [ebp-8h]
  char v4; // [esp+10h] [ebp-4h]

  v2 = 0;
  byte_9ECAD = a1;
  while ( dword_9B1B6[v2] )
  {
    for ( i = 0; i < 0x10; ++i )
    {
      if ( byte_9EC5D[16 * v2 + i] || i == 9 )
      {
        v4 = ((unsigned __int8)byte_9ECAE[16 * v2 + i] * (unsigned int)(unsigned __int8)byte_9ECAD) >> 7;
        byte_9EBBF = i | 0xB0;
        byte_9EBC0 = 7;
        byte_9EBC1 = v4;
        //fix
        /*
        MK_FP(*(_WORD *)&byte_9C062[36 * v2 + 4], *(_DWORD *)&byte_9C062[36 * v2])(
          &byte_9EBBF,
          (unsigned __int16)__DS__,
          3,
          v2);*/
      }
    }
    ++v2;
  }
  return 0;
}
// 9B1B6: using guessed type int dword_9B1B6[6];
// 9EBBF: using guessed type char byte_9EBBF;
// 9EBC0: using guessed type char byte_9EBC0;
// 9EBC1: using guessed type char byte_9EBC1;
// 9ECAD: using guessed type char byte_9ECAD;

//----- (0005F913) --------------------------------------------------------
void sub_5F913()
{
  ;
}

//----- (0005F924) --------------------------------------------------------
void sub_5F924()
{
  ;
}

//----- (0005F935) --------------------------------------------------------
__int16 sub_5F935()
{
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  return sub_674CD();
}

//----- (0005FD67) --------------------------------------------------------
__int16 sub_5FD67()
{
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  return sub_674FA();
}

//----- (00060199) --------------------------------------------------------
int sub_60199(int a1, unsigned __int16 a2)
{
  sub_5F935();
  //fix
  /*
  if ( a1 || a2 )
    fstrcpy(&unk_9ED08, (unsigned __int16)__DS__, a1, a2);
  else
    byte_A04D2 = 0;*/
  //fix
  /*
  word_131526 = __CS__;
  dword_131522 = (int)sub_679AE;
  word_13152C = __CS__;
  dword_131528 = (int)sub_679DE;
  word_131532 = __CS__;
  dword_13152E = (int)sub_679F7;
  word_131538 = __CS__;
  dword_131534 = (int)sub_67A10;
  word_13153E = __CS__;
  dword_13153A = (int)sub_67A29;
  word_1314CC = __CS__;
  dword_1314C8 = (int)sub_68A14;
  word_1314D2 = __CS__;
  dword_1314CE = (int)sub_68BDA;
  word_1314D8 = __CS__;
  dword_1314D4 = (int)sub_68C4B;
  word_1314DE = __CS__;
  dword_1314DA = (int)sub_68C69;
  word_1314E4 = __CS__;
  dword_1314E0 = (int)sub_68C82;
  word_131508 = __CS__;
  dword_131504 = (int)sub_67A96;
  word_13150E = __CS__;
  dword_13150A = (int)sub_67D9D;
  word_131514 = __CS__;
  dword_131510 = (int)sub_67F1C;
  word_13151A = __CS__;
  dword_131516 = (int)sub_67F9A;
  word_131520 = __CS__;
  dword_13151C = (int)sub_67FB3;
  word_1314EA = __CS__;
  dword_1314E6 = (int)sub_69EED;
  word_1314F0 = __CS__;
  dword_1314EC = (int)sub_69F1C;
  word_1314F6 = __CS__;
  dword_1314F2 = (int)sub_69F57;
  word_1314FC = __CS__;
  dword_1314F8 = (int)sub_69F75;
  word_131502 = __CS__;
  dword_1314FE = (int)sub_69F93;
  dword_9C22A = 1;*/
  return 0;
}
// 6A67A: using guessed type _DWORD fstrcpy(_DWORD, _DWORD, _DWORD, _DWORD);
// 9C22A: using guessed type int dword_9C22A;
// A04D2: using guessed type char byte_A04D2;
// 1314C8: using guessed type int dword_1314C8;
// 1314CC: using guessed type __int16 word_1314CC;
// 1314CE: using guessed type int dword_1314CE;
// 1314D2: using guessed type __int16 word_1314D2;
// 1314D4: using guessed type int dword_1314D4;
// 1314D8: using guessed type __int16 word_1314D8;
// 1314DA: using guessed type int dword_1314DA;
// 1314DE: using guessed type __int16 word_1314DE;
// 1314E0: using guessed type int dword_1314E0;
// 1314E4: using guessed type __int16 word_1314E4;
// 1314E6: using guessed type int dword_1314E6;
// 1314EA: using guessed type __int16 word_1314EA;
// 1314EC: using guessed type int dword_1314EC;
// 1314F0: using guessed type __int16 word_1314F0;
// 1314F2: using guessed type int dword_1314F2;
// 1314F6: using guessed type __int16 word_1314F6;
// 1314F8: using guessed type int dword_1314F8;
// 1314FC: using guessed type __int16 word_1314FC;
// 1314FE: using guessed type int dword_1314FE;
// 131502: using guessed type __int16 word_131502;
// 131504: using guessed type int dword_131504;
// 131508: using guessed type __int16 word_131508;
// 13150A: using guessed type int dword_13150A;
// 13150E: using guessed type __int16 word_13150E;
// 131510: using guessed type int dword_131510;
// 131514: using guessed type __int16 word_131514;
// 131516: using guessed type int dword_131516;
// 13151A: using guessed type __int16 word_13151A;
// 13151C: using guessed type int dword_13151C;
// 131520: using guessed type __int16 word_131520;
// 131522: using guessed type int dword_131522;
// 131526: using guessed type __int16 word_131526;
// 131528: using guessed type int dword_131528;
// 13152C: using guessed type __int16 word_13152C;
// 13152E: using guessed type int dword_13152E;
// 131532: using guessed type __int16 word_131532;
// 131534: using guessed type int dword_131534;
// 131538: using guessed type __int16 word_131538;
// 13153A: using guessed type int dword_13153A;
// 13153E: using guessed type __int16 word_13153E;

//----- (00060335) --------------------------------------------------------
int sub_60335()
{
  sub_5FD67();
  dword_9C22A = 0;
  return 0;
}
// 9C22A: using guessed type int dword_9C22A;

//----- (0006035F) --------------------------------------------------------
int sub_6035F(unsigned int a1, unsigned int a2, int a3, int a4, int a5, unsigned int a6)
{
  int v6; // ecx
  unsigned int v7; // edx
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // eax
  int v12; // ecx
  int v13; // eax
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int v17; // eax
  int v18; // ecx
  int v19; // eax
  unsigned __int16 v20; // ax
  int v21; // edx
  int v22; // edx
  unsigned int v24; // [esp+Ch] [ebp-3Ch] BYREF
  int v25; // [esp+10h] [ebp-38h]
  int *v26; // [esp+14h] [ebp-34h]
  __int16 v27; // [esp+18h] [ebp-30h]
  int v28; // [esp+1Ch] [ebp-2Ch]
  void (*v29)(_DWORD); // [esp+24h] [ebp-24h] BYREF
  int v30; // [esp+28h] [ebp-20h]
  int v31; // [esp+2Ch] [ebp-1Ch]
  unsigned int i; // [esp+34h] [ebp-14h]
  unsigned int v33; // [esp+40h] [ebp-8h]
  unsigned int v34; // [esp+44h] [ebp-4h]

  //fix
  v6 = 0;
  v10 = 0;
  v13 = 0;
  v16 = 0;
  v19 = 0;
  v25 = 0;
  //fix

  v34 = __readgsdword(a4 + 24);
  v33 = __readgsdword(a4 + 28);
  v31 = 6;
  for ( i = 0; i < 5; ++i )
  {
    if ( !dword_9B1B6[i] )
    {
      v31 = i;
      break;
    }
  }
  if ( v31 == 6 )
    return 11;
  LOWORD(v7) = 4 * v31;
  dword_9B1B6[v31] = a1;
  for ( i = 0; i < 0x10; ++i )
  {
    v7 = i + 16 * a1;
    LOBYTE(v7) = byte_90000[v7 - 594995];
    byte_9EC5D[16 * v31 + i] = v7;
  }
  switch ( dword_9B1B6[v31] )
  {
    case 40962:
      for ( i = 0; i < 6; ++i )
      {
        v11 = 36 * v31 + 6 * i;
        v12 = *(int *)((char *)&dword_1314E6 + 6 * i);
        *(_WORD *)&byte_9C062[v11 + 4] = word_1314EA[3 * i];
        *(_DWORD *)&byte_9C062[v11] = v12;
      }
      //fix
      /*
      v13 = MK_FP(*(_WORD *)&byte_9C068[36 * v31 + 4], *(_DWORD *)&byte_9C068[36 * v31])(
              __readgsdword(a4 + 16),
              __readgsword(a4 + 20),
              v31,
              __readgsdword(a2));*/
      v28 = v13;
      if ( !v13 )
        goto LABEL_47;
      v30 = v28;
      break;
    case 40963:
      v27 = v7;
      v26 = sub_6798D();
      for ( i = 0; i < 6; ++i )
      {
        v14 = 36 * v31 + 6 * i;
        v15 = *(int *)((char *)&dword_131522 + 6 * i);
        *(_WORD *)&byte_9C062[v14 + 4] = word_131526[3 * i];
        *(_DWORD *)&byte_9C062[v14] = v15;
      }
      //fix
      /*
      v16 = MK_FP(*(_WORD *)&byte_9C068[36 * v31 + 4], *(_DWORD *)&byte_9C068[36 * v31])(
              __readgsdword(a4 + 16),
              __readgsword(a4 + 20),
              v31,
              dword_9EF0C);*/
      v28 = v16;
      if ( !v16 )
        goto LABEL_47;
      v30 = v28;
      break;
    case 40965:
      v27 = v7;
      v26 = sub_67A75();
      for ( i = 0; i < 6; ++i )
      {
        v8 = 36 * v31 + 6 * i;
        v9 = *(int *)((char *)&dword_131504 + 6 * i);
        *(_WORD *)&byte_9C062[v8 + 4] = word_131508[3 * i];
        *(_DWORD *)&byte_9C062[v8] = v9;
      }
      //fix
      /*
      v10 = MK_FP(*(_WORD *)&byte_9C068[36 * v31 + 4], *(_DWORD *)&byte_9C068[36 * v31])(
              __readgsdword(a4 + 16),
              __readgsword(a4 + 20),
              v31,
              dword_9EF0C);*/
      v28 = v10;
      if ( !v10 )
        goto LABEL_47;
      v30 = v28;
      break;
    case 40968:
      v27 = v7;
      v26 = sub_689F3();
      for ( i = 0; i < 6; ++i )
      {
        v17 = 36 * v31 + 6 * i;
        v18 = *(int *)((char *)&dword_1314C8 + 6 * i);
        *(_WORD *)&byte_9C062[v17 + 4] = word_1314CC[3 * i];
        *(_DWORD *)&byte_9C062[v17] = v18;
      }
      //fix
      /*
      v19 = MK_FP(*(_WORD *)&byte_9C068[36 * v31 + 4], *(_DWORD *)&byte_9C068[36 * v31])(
              __readgsdword(a4 + 16),
              __readgsword(a4 + 20),
              v31,
              __readgsdword(a2));*/
      v28 = v19;
      if ( !v19 )
        goto LABEL_47;
      v30 = v28;
      break;
    default:
      word_9EF0A = 0;
      dword_9EF06 = 0;
      v20 = __readgsword(a4 + 8);
      if ( !__readgsdword(a4 + 4) && v20 == word_9EF0A )
      {
        v28 = sub_68622((__int16)&v24, v6, a1, v31, (int *)&v29, (unsigned int)&v24);
        if ( v28 )
          return v28;
        __writegsword(a4 + 8, v25);
        __writegsdword(a4 + 4, v24);
        __writegsdword(a4 + 12, (unsigned int)v29);
        v22 = 3 * v31;
        word_9B160[v22] = v25;
        *(int *)((char *)&dword_9B15C + v22 * 2) = v24;
        dword_9B17A[v31] = (int)v29;
      }
      else
      {
        LOWORD(v25) = __readgsword(a4 + 8);
        v24 = __readgsdword(a4 + 4);
        v29 = (void (*)(_DWORD))__readgsdword(a4 + 12);
        v21 = 3 * v31;
        word_9B160[v21] = v25;
        *(int *)((char *)&dword_9B15C + v21 * 2) = v24;
        dword_9B17A[v31] = (int)v29;
      }
      sub_67486(v31);
      //fix
      /*sub_6A737(v29, v24, (unsigned __int16)v25, (int)&byte_9C062[36 * v31], __DS__);
      MK_FP(*(_WORD *)&byte_9C068[36 * v31 + 4], *(_DWORD *)&byte_9C068[36 * v31])(
        dword_9EF06,
        (unsigned __int16)word_9EF0A,
        dword_9EF0C,
        __readgsdword(a2));*/
LABEL_47:
      dword_9B18E[v31] = 1;
      __writegsdword(a6, v31);
      v30 = 0;
      break;
  }
  return v30;
}
// 60715: variable 'v6' is possibly undefined
// 9B15C: using guessed type int dword_9B15C;
// 9B160: using guessed type __int16 word_9B160[];
// 9B17A: using guessed type int dword_9B17A[5];
// 9B18E: using guessed type int dword_9B18E[5];
// 9B1B6: using guessed type int dword_9B1B6[6];
// 9EF06: using guessed type int dword_9EF06;
// 9EF0A: using guessed type __int16 word_9EF0A;
// 9EF0C: using guessed type int dword_9EF0C;
// 1314C8: using guessed type int dword_1314C8;
// 1314CC: using guessed type __int16 word_1314CC[];
// 1314E6: using guessed type int dword_1314E6;
// 1314EA: using guessed type __int16 word_1314EA[];
// 131504: using guessed type int dword_131504;
// 131508: using guessed type __int16 word_131508[];
// 131522: using guessed type int dword_131522;
// 131526: using guessed type __int16 word_131526[];
// 6035F: using guessed type int arg_C;
// 6035F: using guessed type unsigned int arg_4;

//----- (0006080C) --------------------------------------------------------
int sub_6080C(unsigned int a1, int a2)
{
  int v2; // eax
  unsigned int v4; // [esp+0h] [ebp-10h]

  if ( dword_9B18E[a1] )
  {
      //fix
      /*
    MK_FP(*(_WORD *)&byte_9C06E[36 * a1 + 4], *(_DWORD *)&byte_9C06E[36 * a1])(
      dword_9EF06,
      (unsigned __int16)word_9EF0A,
      dword_9EF0C,
      dword_9EF0C);*/
    if ( a2 )
    {
      v4 = dword_9B1B6[a1];
      if ( v4 < 0xA005 )
      {
        if ( v4 < 0xA002 || v4 > 0xA003 )
          goto LABEL_13;
      }
      else if ( v4 > 0xA005 && v4 != 40968 )
      {
LABEL_13:
        sub_68813(a1);
        goto LABEL_14;
      }
      //fix
      /*
      MK_FP(*(_WORD *)&byte_9C06E[36 * a1 + 4], *(_DWORD *)&byte_9C06E[36 * a1])(
        dword_9EF06,
        (unsigned __int16)word_9EF0A,
        a1,
        dword_9EF0C);*/
    }
LABEL_14:
    v2 = 3 * a1;
    word_9B160[v2] = 0;
    *(int *)((char *)&dword_9B15C + v2 * 2) = 0;
    dword_9B1B6[a1] = 0;
    dword_9B18E[a1] = 0;
    return 0;
  }
  return 1;
}
// 9B15C: using guessed type int dword_9B15C;
// 9B160: using guessed type __int16 word_9B160[];
// 9B18E: using guessed type int dword_9B18E[5];
// 9B1B6: using guessed type int dword_9B1B6[6];
// 9EF06: using guessed type int dword_9EF06;
// 9EF0A: using guessed type __int16 word_9EF0A;
// 9EF0C: using guessed type int dword_9EF0C;

//----- (0006091D) --------------------------------------------------------
int sub_6091D(int a1)
{
  unsigned int i; // [esp+8h] [ebp-4h]

  for ( i = 0; i < 0x10; ++i )
  {
    byte_9EBBF = i | 0xB0;
    byte_9EBC0 = 121;
    byte_9EBC1 = 0;
    //
    /*
    MK_FP(*(_WORD *)&byte_9C062[36 * a1 + 4], *(_DWORD *)&byte_9C062[36 * a1])(
      &byte_9EBBF,
      (unsigned __int16)__DS__,
      3,
      a1);*/
    byte_9EBBF = i | 0xB0;
    byte_9EBC0 = 123;
    byte_9EBC1 = 0;
    //fix
    /*
    MK_FP(*(_WORD *)&byte_9C062[36 * a1 + 4], *(_DWORD *)&byte_9C062[36 * a1])(
      &byte_9EBBF,
      (unsigned __int16)__DS__,
      3,
      a1);*/
  }
  //fix
  /*
  MK_FP(*(_WORD *)&byte_9C074[36 * a1 + 4], *(_DWORD *)&byte_9C074[36 * a1])(
    dword_9EF06,
    (unsigned __int16)word_9EF0A,
    a1,
    dword_9EF0C);*/
  return 0;
}
// 9EBBF: using guessed type char byte_9EBBF;
// 9EBC0: using guessed type char byte_9EBC0;
// 9EBC1: using guessed type char byte_9EBC1;
// 9EF06: using guessed type int dword_9EF06;
// 9EF0A: using guessed type __int16 word_9EF0A;
// 9EF0C: using guessed type int dword_9EF0C;

//----- (000609F4) --------------------------------------------------------
void sub_609F4()
{
  ;
}

//----- (00060BDC) --------------------------------------------------------
unsigned __int64 sub_60BDC(int a1)
{
  int v2; // [esp+0h] [ebp-1Ch]
  __int16 v3; // [esp+4h] [ebp-18h]
  unsigned int v4; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]
  int v7; // [esp+18h] [ebp-4h]

  v5 = 0;
  v3 = 0;
  v2 = 0;
  v6 = sub_63910(a1);
  if ( v6 > 0 )
  {
    v7 = sub_5CDE0(a1, 514);
    if ( v7 != -1 )
    {
      v5 = sub_42540(v6);
      if ( v5 )
      {
        if ( sub_5CBD0(v7, v5, v6) != v6 )
          v5 = 0;
      }
    }
    sub_5CE50(v7);
  }
  if ( v5 )
  {
    //fix v3 = __DS__;
    v2 = v5;
  }
  LOWORD(v4) = v3;
  return __PAIR64__(v4, v2);
}
// 60C8B: variable 'v4' is possibly undefined

//----- (00060CE0) --------------------------------------------------------
int sub_60CE0(__int16 a1, __int16 a2, int a3)
{
  int v4; // [esp+4h] [ebp-4h]

  //fix
  v4 = 0;
  //fix;

  sub_60D65(*(_WORD *)(a3 + 4), a2, a1, *(char **)a3, 0, 0);
  return v4;
}
// 60D15: variable 'v4' is possibly undefined
// 12EFF4: using guessed type int dword_12EFF4;

//----- (00060D18) --------------------------------------------------------
int sub_60D18(__int16 a1, __int16 a2, int a3)
{
  int v4; // [esp+4h] [ebp-4h]

  //fix
  v4 = 0;
  //fix;

  sub_60D65(*(_WORD *)(a3 + 4), a2, a1, *(char **)a3, 0, 0);
  return v4;
}
// 60D4D: variable 'v4' is possibly undefined
// 12EFF4: using guessed type int dword_12EFF4;

//----- (00060D50) --------------------------------------------------------
void sub_60D50fix(__int16 a1, int a2, int a3, char *a4, unsigned __int8 a5, char a6)
{
  sub_60D65(a1, a2, a3, a4, a5, a6);
}

//----- (00060D65) --------------------------------------------------------
void sub_60D65fix(__int16 a1, int a2, int a3, char *a4, unsigned __int8 a5, char a6)
{
  int v6; // edi
  _BYTE *v7; // edi
  int v8; // ecx
  int v9; // eax
  _BYTE *v10; // ebx
  char v11; // al
  char v12; // al
  char v13; // al
  _BYTE *v14; // edi
  int v15; // ecx
  int v16; // eax
  _BYTE *v17; // ebx
  char v18; // al
  char v19; // al
  char v20; // al
  char *v21; // edi
  unsigned int v22; // ecx
  int v23; // eax
  char *v24; // ebx
  char *v25; // edi
  char v26; // al
  char *v27; // esi
  char *v28; // edi
  unsigned int v29; // ecx
  int v30; // eax
  char *v31; // ebx
  char *v32; // edi
  char v33; // al
  char *v34; // esi
  int v35; // ebp
  _BYTE *v36; // edi
  int v37; // ecx
  _BYTE *v38; // ebx
  char v39; // al
  int v40; // eax
  _BYTE *v41; // edi
  int v42; // ecx
  unsigned __int8 i; // dl
  char v44; // al
  char v45; // al
  char v46; // cc
  char v47; // dl
  char v48; // al
  char *v49; // edi
  char v50; // al
  char v51; // dl
  char v52; // al
  char v53; // dl
  unsigned int v54; // ebx
  const void *v55; // esi
  char *v56; // edi
  unsigned int v57; // ecx
  int v58; // eax
  char *v59; // ebx
  char *v60; // edi
  char *v61; // edi
  unsigned int v62; // ecx
  int v63; // eax
  char *v64; // ebx
  char *v65; // edi
  char v66; // al
  char *v67; // esi
  int v68; // edi
  int v69; // ebx
  _BYTE *v70; // edi
  _BYTE *v71; // edx
  int v72; // ecx
  char v73; // al
  char v74; // al
  char v75; // al
  char v76; // al
  int v77; // ebx
  _BYTE *v78; // edi
  int v79; // ecx
  int v80; // eax
  _BYTE *v81; // ebx
  char v82; // al
  int v83; // ebx
  _BYTE *v84; // edi
  int v85; // ecx
  int v86; // eax
  _BYTE *v87; // ebx
  char v88; // al
  _BYTE *v89; // edi
  int v90; // ecx
  int v91; // ebx
  int v92; // eax
  _BYTE *v93; // ebx
  char v94; // al
  unsigned int v95; // ebx
  _BYTE *v96; // edi
  _BYTE *v97; // edx
  int v98; // ecx
  char v99; // al
  char v100; // al
  char v101; // al
  char v102; // al
  _BYTE *v103; // edi
  int v104; // ecx
  int v105; // ebx
  _BYTE *v106; // ebx
  int v107; // eax
  char v108; // al
  _BYTE *v109; // edi
  int v110; // ecx
  int v111; // ebx
  _BYTE *v112; // ebx
  int v113; // eax
  char v114; // al
  unsigned int v115; // ebx
  _BYTE *v116; // edi
  _BYTE *v117; // edx
  int v118; // ecx
  char v119; // al
  char v120; // al
  char v121; // al
  char v122; // al
  int v123; // eax
  int v124; // edi
  int v125; // eax
  int v126; // eax
  char v127; // al
  int v128; // eax
  char *v129; // [esp-4h] [ebp-Ch]
  unsigned __int8 v130; // [esp+2h] [ebp-6h]
  unsigned __int8 v131; // [esp+2h] [ebp-6h]
  unsigned __int8 v132; // [esp+2h] [ebp-6h]
  unsigned __int8 v133; // [esp+2h] [ebp-6h]
  unsigned __int8 v134; // [esp+2h] [ebp-6h]
  unsigned __int8 v135; // [esp+2h] [ebp-6h]
  unsigned __int8 v136; // [esp+2h] [ebp-6h]
  unsigned __int8 v137; // [esp+2h] [ebp-6h]
  char v138; // [esp+3h] [ebp-5h]
  char v139; // [esp+3h] [ebp-5h]
  _BYTE *v140; // [esp+4h] [ebp-4h]
  _BYTE *v141; // [esp+4h] [ebp-4h]

  //fix
  v46 = 0;
  //fix

  if ( !HIBYTE(a1) )
    return;
  v6 = dword_12EFF4 + dword_12F008 + dword_12EFF0 * dword_12F018;
  if ( (word_12F02E & 1) != 0 )
  {
    LOBYTE(a1) = (unsigned __int8)a1 >> 1;
    HIBYTE(a1) >>= 1;
    a3 >>= 1;
    a2 >>= 1;
  }
  if ( a2 < 0 )
  {
    if ( (word_9ADFC & 2) != 0 )
    {
      v126 = a2 + HIBYTE(a1);
      //fix v46 = (v126 + 1 < 0) ^ __OFADD__(1, v126) | (v126 == -1);
      v127 = v126 + 1;
      if ( v46 )
        return;
      a2 = -1;
      HIBYTE(a1) = v127;
    }
    else
    {
      v128 = a2 + HIBYTE(a1);
      //fix
      /*if ((v128 < 0) ^ __OFADD__(a2, HIBYTE(a1)) | (v128 == 0))
        return;*/
      HIBYTE(a1) = v128;
      BYTE1(v128) = 0;
      do
      {
        while ( 1 )
        {
          LOBYTE(v128) = *a4++;
          if ( !(_BYTE)v128 )
            break;
          if ( (v128 & 0x80u) == 0 )
            a4 += v128;
        }
        ++a2;
      }
      while ( a2 );
    }
  }
  else if ( a2 + HIBYTE(a1) >= dword_12F028 )
  {
    if ( (word_9ADFC & 2) != 0 )
    {
      if ( a2 + 1 >= dword_12F028 )
        return;
      v123 = HIBYTE(a1) + a2 + 1 - dword_12F028;
      HIBYTE(a1) = dword_12F028 - (a2 + 1);
      v124 = v123;
      v125 = 0;
      do
      {
        while ( 1 )
        {
          LOBYTE(v125) = *a4++;
          if ( !(_BYTE)v125 )
            break;
          if ( (v125 & 0x80u) == 0 )
            a4 += v125;
        }
        --v124;
      }
      while ( v124 );
      v6 = dword_12EFF4;
    }
    else
    {
      if ( dword_12F028 <= a2 )
        return;
      HIBYTE(a1) = dword_12F028 - a2;
    }
  }
  if ( a3 >= 0 )
  {
    if ( a3 + (unsigned __int8)a1 >= dword_12F000 )
    {
      if ( word_9ADFC )
      {
        if ( (word_9ADFC & 1) != 0 )
        {
          if ( (word_9ADFC & 2) != 0 )
          {
            if ( dword_12F024 - a3 >= 0 )
            {
              v77 = (unsigned __int8)a1 + a3;
              v78 = (_BYTE *)(dword_12EFF0 * (HIBYTE(a1) + a2) + v77 + v6);
              v79 = 0;
              LOBYTE(a1) = dword_12F024 - v77 - 2;
              v131 = a1;
              v80 = -1;
              v81 = v78;
              do
              {
                while ( 1 )
                {
                  while ( 1 )
                  {
                    LOBYTE(v80) = *a4++;
                    if ( (v80 & 0x80u) == 0 )
                      break;
                    v78 += v80;
                    LOBYTE(a1) = a1 - v80;
                  }
                  if ( !(_BYTE)v80 )
                    break;
                  LOBYTE(v79) = v80;
                  do
                  {
                    v82 = *a4++;
                    LOBYTE(a1) = a1 + 1;
                    if ( (a1 & 0x80u) == 0 )
                      *v78 = v82;
                    --v78;
                    --v79;
                  }
                  while ( v79 );
                }
                v81 -= dword_12EFF0;
                v78 = v81;
                a1 = __PAIR16__(HIBYTE(a1), v131) - 256;
              }
              while ( HIBYTE(a1) );
            }
          }
          else if ( dword_12F024 - a3 >= 0 )
          {
            v83 = (unsigned __int8)a1 + a3;
            v84 = (_BYTE *)(dword_12EFF0 * a2 + v83 + v6);
            v85 = 0;
            LOBYTE(a1) = dword_12F024 - v83 - 2;
            v132 = a1;
            v86 = -1;
            v87 = v84;
            do
            {
              while ( 1 )
              {
                while ( 1 )
                {
                  LOBYTE(v86) = *a4++;
                  if ( (v86 & 0x80u) == 0 )
                    break;
                  v84 += v86;
                  LOBYTE(a1) = a1 - v86;
                }
                if ( !(_BYTE)v86 )
                  break;
                LOBYTE(v85) = v86;
                do
                {
                  v88 = *a4++;
                  LOBYTE(a1) = a1 + 1;
                  if ( (a1 & 0x80u) == 0 )
                    *v84 = v88;
                  --v84;
                  --v85;
                }
                while ( v85 );
              }
              v87 += dword_12EFF0;
              v84 = v87;
              a1 = __PAIR16__(HIBYTE(a1), v132) - 256;
            }
            while ( HIBYTE(a1) );
          }
        }
        else if ( (word_9ADFC & 2) != 0 )
        {
          v89 = (_BYTE *)(dword_12EFF0 * (HIBYTE(a1) + a2) + a3 + v6);
          v90 = 0;
          v91 = dword_12F024 - a3;
          if ( v91 >= 0 )
          {
            LOBYTE(a1) = v91;
            v133 = v91;
            v92 = -1;
            v93 = v89;
            do
            {
              while ( 1 )
              {
                while ( 1 )
                {
                  LOBYTE(v92) = *a4++;
                  if ( (v92 & 0x80u) == 0 )
                    break;
                  v89 -= v92;
                  LOBYTE(a1) = v92 + a1;
                }
                if ( !(_BYTE)v92 )
                  break;
                LOBYTE(v90) = v92;
                do
                {
                  v94 = *a4++;
                  LOBYTE(a1) = a1 - 1;
                  if ( (a1 & 0x80u) == 0 )
                    *v89++ = v94;
                  --v90;
                }
                while ( v90 );
              }
              v93 -= dword_12EFF0;
              v89 = v93;
              a1 = __PAIR16__(HIBYTE(a1), v133) - 256;
            }
            while ( HIBYTE(a1) );
          }
        }
      }
      else
      {
        v68 = a3 + v6;
        v69 = dword_12F024 - a3;
        if ( v69 >= 0 )
        {
          v70 = (_BYTE *)(dword_12EFF0 * a2 + v68);
          BYTE1(v69) = HIBYTE(a1);
          v130 = v69;
          v71 = v70;
          v72 = 0;
          do
          {
            while ( 1 )
            {
              while ( 1 )
              {
                v73 = *a4++;
                if ( v73 >= 0 )
                  break;
                //fix v46 = ((char)(v73 + v69) < 0) ^ __OFADD__(v73, (_BYTE)v69) | (v73 + (_BYTE)v69 == 0);
                LOBYTE(v69) = v73 + v69;
                if ( !v46 )
                {
                  v70 -= v73;
                  v75 = *a4++;
                  LOBYTE(v72) = v75;
                  do
                  {
                    v76 = *a4++;
                    LOBYTE(v69) = v69 - 1;
                    if ( (v69 & 0x80u) == 0 )
                      *v70++ = v76;
                    --v72;
                  }
                  while ( v72 );
                }
              }
              if ( !v73 )
                break;
              LOBYTE(v72) = v73;
              do
              {
                v74 = *a4++;
                LOBYTE(v69) = v69 - 1;
                if ( (v69 & 0x80u) == 0 )
                  *v70++ = v74;
                --v72;
              }
              while ( v72 );
            }
            v71 += dword_12EFF0;
            v70 = v71;
            LOWORD(v69) = __PAIR16__(BYTE1(v69), v130) - 256;
          }
          while ( BYTE1(v69) );
        }
      }
    }
    else if ( (word_9ADFC & 1) != 0 )
    {
      if ( (word_9ADFC & 2) != 0 )
      {
        v7 = (_BYTE *)(dword_12EFF0 * (HIBYTE(a1) + a2) + (unsigned __int8)a1 + a3 + v6);
        v8 = 0;
        v9 = -1;
        v10 = v7;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              LOBYTE(v9) = *a4++;
              if ( (v9 & 0x80u) == 0 )
                break;
              v7 += v9;
              v12 = *a4++;
              LOBYTE(v8) = v12;
              do
              {
                v13 = *a4++;
                *v7-- = v13;
                --v8;
              }
              while ( v8 );
            }
            if ( !(_BYTE)v9 )
              break;
            LOBYTE(v8) = v9;
            do
            {
              v11 = *a4++;
              *v7-- = v11;
              --v8;
            }
            while ( v8 );
          }
          v10 -= dword_12EFF0;
          v7 = v10;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
      else
      {
        v14 = (_BYTE *)(dword_12EFF0 * a2 + (unsigned __int8)a1 + a3 + v6);
        v15 = 0;
        v16 = -1;
        v17 = v14;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              LOBYTE(v16) = *a4++;
              if ( (v16 & 0x80u) == 0 )
                break;
              v14 += v16;
              v19 = *a4++;
              LOBYTE(v15) = v19;
              do
              {
                v20 = *a4++;
                *v14-- = v20;
                --v15;
              }
              while ( v15 );
            }
            if ( !(_BYTE)v16 )
              break;
            LOBYTE(v15) = v16;
            do
            {
              v18 = *a4++;
              *v14-- = v18;
              --v15;
            }
            while ( v15 );
          }
          v17 += dword_12EFF0;
          v14 = v17;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
    }
    else if ( word_9ADFC )
    {
      if ( (word_9ADFC & 2) != 0 )
      {
        v28 = (char *)(dword_12EFF0 * (HIBYTE(a1) + a2) + a3 + v6);
        v29 = 0;
        v30 = -1;
        v31 = v28;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              LOBYTE(v30) = *a4++;
              if ( (v30 & 0x80u) == 0 )
                break;
              v32 = &v28[-v30];
              v33 = *a4;
              v34 = a4 + 1;
              LOBYTE(v29) = v33;
              qmemcpy(v32, v34, v29);
              a4 = &v34[v29];
              v28 = &v32[v29];
              v29 = 0;
            }
            if ( !(_BYTE)v30 )
              break;
            LOBYTE(v29) = v30;
            qmemcpy(v28, a4, v29);
            a4 += v29;
            v28 += v29;
            v29 = 0;
          }
          v31 -= dword_12EFF0;
          v28 = v31;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
      else if ( (word_9ADFC & 4) != 0 )
      {
        v35 = dword_9AFA0;
        v36 = (_BYTE *)(dword_12EFF0 * a2 + a3 + v6);
        v37 = 0;
        v38 = v36;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              v39 = *a4++;
              if ( v39 >= 0 )
                break;
              v36 -= v39;
            }
            if ( !v39 )
              break;
            LOBYTE(v37) = v39;
            v40 = (unsigned __int8)v39;
            do
            {
              LOBYTE(v40) = *a4++;
              BYTE1(v40) = *v36;
              *v36++ = *(_BYTE *)(v40 + v35);
              --v37;
            }
            while ( v37 );
          }
          v38 += dword_12EFF0;
          v36 = v38;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
      else if ( (word_9ADFC & 8) != 0 )
      {
        v41 = (_BYTE *)(dword_12EFF0 * a2 + a3 + v6);
        v42 = 0;
        v140 = v41;
        v138 = HIBYTE(a1);
        for ( i = a5; ; i = a5 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              v44 = *a4++;
              if ( v44 >= 0 )
                break;
              v42 = (unsigned __int8)-v44;
              do
              {
                v46 = (char)i-- < 1;
                if ( v46 )
                {
                  i = a5;
                  ++v41;
                }
                --v42;
              }
              while ( v42 );
            }
            if ( !v44 )
              break;
            LOBYTE(v42) = v44;
            do
            {
              v45 = *a4++;
              v46 = (char)i-- < 1;
              if ( v46 )
              {
                i = a5;
                *v41++ = v45;
              }
              --v42;
            }
            while ( v42 );
          }
          if ( !--v138 )
            break;
          v47 = a6;
          while ( --v47 >= 0 )
          {
            while ( 1 )
            {
              do
                v48 = *a4++;
              while ( v48 < 0 );
              if ( !v48 )
                break;
              a4 += (unsigned __int8)v48;
            }
          }
          v140 += dword_12EFF0;
          v41 = v140;
        }
      }
      else if ( (word_9ADFC & 0x20) != 0 )
      {
        v49 = (char *)(dword_12EFF0 * a2 + a3 + v6);
        v141 = (uint8*)v49;
        v139 = HIBYTE(a1);
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              v50 = *a4++;
              if ( v50 >= 0 )
                break;
              v49 += (unsigned __int16)(a5 * (unsigned __int8)-v50);
            }
            if ( !v50 )
              break;
            v51 = v50;
            do
            {
              v52 = *a4++;
              memset(v49, v52, a5);
              v49 += a5;
              v46 = v51-- <= 1;
            }
            while ( !v46 );
          }
          v53 = a6 - 1;
          if ( a6 > 1 )
          {
            v129 = a4;
            v54 = (unsigned int)((char*)v49 - (char*)v141);
            do
            {
              v55 = v141;
              v141 += dword_12EFF0;
              qmemcpy(v141, v55, v54);
              v46 = v53-- <= 1;
            }
            while ( !v46 );
            a4 = v129;
          }
          v141 += dword_12EFF0;
          v49 = (char*)v141;
          --v139;
        }
        while ( v139 );
      }
      else if ( (word_9ADFC & 0x40) != 0 )
      {
        v56 = (char *)(dword_12EFF0 * a2 + a3 + v6);
        v57 = 0;
        v58 = -1;
        v59 = v56;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              LOBYTE(v58) = *a4++;
              if ( (v58 & 0x80u) == 0 )
                break;
              v60 = &v56[-v58];
              LOBYTE(v57) = *a4;
              a4 += v57 + 1;
              memset(v60, a5, v57);
              v56 = &v60[v57];
              v57 = 0;
            }
            if ( !(_BYTE)v58 )
              break;
            LOBYTE(v57) = v58;
            a4 += v57;
            memset(v56, a5, v57);
            v56 += v57;
            v57 = 0;
          }
          v59 += dword_12EFF0;
          v56 = v59;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
      else
      {
        v61 = (char *)(dword_12EFF0 * a2 + a3 + v6);
        v62 = 0;
        v63 = -1;
        v64 = v61;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              LOBYTE(v63) = *a4++;
              if ( (v63 & 0x80u) == 0 )
                break;
              v65 = &v61[-v63];
              v66 = *a4;
              v67 = a4 + 1;
              LOBYTE(v62) = v66;
              qmemcpy(v65, v67, v62);
              a4 = &v67[v62];
              v61 = &v65[v62];
              v62 = 0;
            }
            if ( !(_BYTE)v63 )
              break;
            LOBYTE(v62) = v63;
            qmemcpy(v61, a4, v62);
            a4 += v62;
            v61 += v62;
            v62 = 0;
          }
          v64 += dword_12EFF0;
          v61 = v64;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
    }
    else
    {
      v21 = (char *)(dword_12EFF0 * a2 + a3 + v6);
      v22 = 0;
      v23 = -1;
      v24 = v21;
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            LOBYTE(v23) = *a4++;
            if ( (v23 & 0x80u) == 0 )
              break;
            v25 = &v21[-v23];
            v26 = *a4;
            v27 = a4 + 1;
            LOBYTE(v22) = v26;
            qmemcpy(v25, v27, v22);
            a4 = &v27[v22];
            v21 = &v25[v22];
            v22 = 0;
          }
          if ( !(_BYTE)v23 )
            break;
          LOBYTE(v22) = v23;
          qmemcpy(v21, a4, v22);
          a4 += v22;
          v21 += v22;
          v22 = 0;
        }
        v24 += dword_12EFF0;
        v21 = v24;
        --HIBYTE(a1);
      }
      while ( HIBYTE(a1) );
    }
    return;
  }
  if ( !word_9ADFC )
  {
    v95 = -a3;
    if ( (unsigned __int8)a1 <= v95 )
      return;
    v96 = (_BYTE *)(dword_12EFF0 * a2 + v6);
    BYTE1(v95) = HIBYTE(a1);
    v97 = v96;
    v134 = v95;
    v98 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v99 = *a4++;
          if ( v99 < 0 )
            break;
          if ( v99 )
          {
            LOBYTE(v98) = v99;
            do
            {
              v100 = *a4++;
              LOBYTE(v95) = v95 - 1;
              if ( (v95 & 0x80u) != 0 )
                *v96++ = v100;
              --v98;
            }
            while ( v98 );
          }
          else
          {
            v97 += dword_12EFF0;
            v96 = v97;
            LOWORD(v95) = __PAIR16__(BYTE1(v95), v134) - 256;
            if ( !BYTE1(v95) )
              return;
          }
        }
        if ( (char)v95 > 0 )
          break;
LABEL_179:
        v96 -= v99;
        v101 = *a4++;
        LOBYTE(v98) = v101;
        do
        {
          v102 = *a4++;
          LOBYTE(v95) = v95 - 1;
          if ( (v95 & 0x80u) != 0 )
            *v96++ = v102;
          --v98;
        }
        while ( v98 );
      }
      LOBYTE(v95) = v99 + v95;
      if ( (v95 & 0x80u) != 0 )
      {
        v99 = v95;
        goto LABEL_179;
      }
    }
  }
  if ( (word_9ADFC & 1) == 0 )
  {
    if ( (word_9ADFC & 2) == 0 )
      return;
    v115 = -a3;
    if ( (unsigned __int8)a1 <= v115 )
      return;
    v116 = (_BYTE *)(dword_12EFF0 * (HIBYTE(a1) + a2) + v6);
    BYTE1(v115) = HIBYTE(a1);
    v117 = v116;
    v137 = v115;
    v118 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v119 = *a4++;
          if ( v119 < 0 )
            break;
          if ( v119 )
          {
            LOBYTE(v118) = v119;
            do
            {
              v120 = *a4++;
              LOBYTE(v115) = v115 - 1;
              if ( (v115 & 0x80u) != 0 )
                *v116++ = v120;
              --v118;
            }
            while ( v118 );
          }
          else
          {
            v117 -= dword_12EFF0;
            v116 = v117;
            LOWORD(v115) = __PAIR16__(BYTE1(v115), v137) - 256;
            if ( !BYTE1(v115) )
              return;
          }
        }
        if ( (char)v115 > 0 )
          break;
LABEL_225:
        v116 -= v119;
        v121 = *a4++;
        LOBYTE(v118) = v121;
        do
        {
          v122 = *a4++;
          LOBYTE(v115) = v115 - 1;
          if ( (v115 & 0x80u) != 0 )
            *v116++ = v122;
          --v118;
        }
        while ( v118 );
      }
      LOBYTE(v115) = v119 + v115;
      if ( (v115 & 0x80u) != 0 )
      {
        v119 = v115;
        goto LABEL_225;
      }
    }
  }
  if ( (word_9ADFC & 2) != 0 )
  {
    v103 = (_BYTE *)(dword_12EFF0 * (HIBYTE(a1) + a2) + (unsigned __int8)a1 + a3 + v6);
    v104 = 0;
    v105 = (unsigned __int8)a1 + a3 + 1;
    if ( v105 >= 0 )
    {
      LOBYTE(a1) = v105;
      v135 = v105;
      v106 = v103;
      v107 = -1;
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            LOBYTE(v107) = *a4++;
            if ( (v107 & 0x80u) == 0 )
              break;
            v103 += v107;
            LOBYTE(a1) = v107 + a1;
          }
          if ( !(_BYTE)v107 )
            break;
          LOBYTE(v104) = v107;
          do
          {
            v108 = *a4++;
            LOBYTE(a1) = a1 - 1;
            if ( (a1 & 0x80u) == 0 )
              *v103 = v108;
            --v103;
            --v104;
          }
          while ( v104 );
        }
        v106 -= dword_12EFF0;
        v103 = v106;
        a1 = __PAIR16__(HIBYTE(a1), v135) - 256;
      }
      while ( HIBYTE(a1) );
    }
  }
  else
  {
    v109 = (_BYTE *)(dword_12EFF0 * a2 + (unsigned __int8)a1 + a3 + v6);
    v110 = 0;
    v111 = (unsigned __int8)a1 + a3 + 1;
    if ( v111 >= 0 )
    {
      LOBYTE(a1) = v111;
      v136 = v111;
      v112 = v109;
      v113 = -1;
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            LOBYTE(v113) = *a4++;
            if ( (v113 & 0x80u) == 0 )
              break;
            v109 += v113;
            LOBYTE(a1) = v113 + a1;
          }
          if ( !(_BYTE)v113 )
            break;
          LOBYTE(v110) = v113;
          do
          {
            v114 = *a4++;
            LOBYTE(a1) = a1 - 1;
            if ( (a1 & 0x80u) == 0 )
              *v109 = v114;
            --v109;
            --v110;
          }
          while ( v110 );
        }
        v112 += dword_12EFF0;
        v109 = v112;
        a1 = __PAIR16__(HIBYTE(a1), v136) - 256;
      }
      while ( HIBYTE(a1) );
    }
  }
}
// 9ADFC: using guessed type __int16 word_9ADFC;
// 9AFA0: using guessed type int dword_9AFA0;
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F000: using guessed type int dword_12F000;
// 12F008: using guessed type int dword_12F008;
// 12F018: using guessed type int dword_12F018;
// 12F024: using guessed type int dword_12F024;
// 12F028: using guessed type int dword_12F028;
// 12F02E: using guessed type __int16 word_12F02E;

//----- (00061594) --------------------------------------------------------
int sub_61594(unsigned __int16 a1, unsigned __int16 a2, __int16 a3)
{
  int v3; // eax
  int v5; // [esp+4h] [ebp-4h]

  //fix
  v5 = 0;
  //fix

  if ( a1 < 0x280u && a2 < 0x190u )
  {
    v3 = (int)a2 >> 1;
    LOWORD(v3) = 320 * v3;
    *(_BYTE *)(dword_12EFF4 + v3 + ((int)a1 >> 1)) = a3;
  }
  return v5;
}
// 615CE: variable 'v5' is possibly undefined
// 12EFF4: using guessed type int dword_12EFF4;

//----- (000615D4) --------------------------------------------------------
int sub_615D4(unsigned __int16 a1, unsigned __int16 a2, __int16 a3)
{
  int v4; // [esp+4h] [ebp-4h]

  //fix
  v4 = 0;
  //fix;

  if ( a1 < 0x280u && a2 < 0x1E0u )
    *(_BYTE *)(dword_12EFF4 + 640 * a2 + a1) = a3;
  return v4;
}
// 6160B: variable 'v4' is possibly undefined
// 12EFF4: using guessed type int dword_12EFF4;

//----- (00061610) --------------------------------------------------------
int sub_61610(int a1)
{
  int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( !*(_DWORD *)(a1 + 28) )
      break;
    sub_634A0(a1);
    a1 += 44;
  }
  return result;
}

//----- (00061640) --------------------------------------------------------
void sub_61640(
        unsigned __int16 a1,
        unsigned __int16 a2,
        unsigned __int16 a3,
        unsigned __int16 a4,
        unsigned __int16 a5)
{
  _BYTE *v5; // edi
  __int16 v6; // dx
  int v7; // ebx
  int v8; // esi
  int v9; // ecx
  int v10; // [esp+0h] [ebp-4h]
  unsigned __int16 v11; // [esp+14h] [ebp+10h]

  v5 = (_BYTE *)(320 * (a2 >> 1) + dword_12EFF4 + (a1 >> 1));
  v6 = a4 >> 1;
  v11 = a3 >> 1;
  v10 = (unsigned __int16)(320 - v11);
  if ( (word_9ADFC & 4) != 0 )
  {
    v7 = a5;
    v8 = dword_9AFA0;
    do
    {
      v9 = v11;
      do
      {
        BYTE1(v7) = *v5;
        *v5++ = *(_BYTE *)(v7 + v8);
        --v9;
      }
      while ( v9 );
      v5 += v10;
      --v6;
    }
    while ( v6 );
  }
  else
  {
    do
    {
      memset(v5, a5, v11);
      v5 += v10 + v11;
      --v6;
    }
    while ( v6 );
  }
}
// 9ADFC: using guessed type __int16 word_9ADFC;
// 9AFA0: using guessed type int dword_9AFA0;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (000616C0) --------------------------------------------------------
void sub_616C0(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, unsigned __int16 a5)
{
  _BYTE *v5; // edi
  int v7; // ebx
  int v8; // esi
  int v9; // ecx
  int v10; // [esp+0h] [ebp-4h]

  v5 = (_BYTE *)(640 * a2 + dword_12EFF4 + a1);
  v10 = (unsigned __int16)(640 - a3);
  if ( (word_9ADFC & 4) != 0 )
  {
    v7 = a5;
    v8 = dword_9AFA0;
    do
    {
      v9 = a3;
      do
      {
        BYTE1(v7) = *v5;
        *v5++ = *(_BYTE *)(v7 + v8);
        --v9;
      }
      while ( v9 );
      v5 += v10;
      --a4;
    }
    while ( a4 );
  }
  else
  {
    do
    {
      memset(v5, a5, a3);
      v5 += v10 + a3;
      --a4;
    }
    while ( a4 );
  }
}
// 9ADFC: using guessed type __int16 word_9ADFC;
// 9AFA0: using guessed type int dword_9AFA0;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (00061740) --------------------------------------------------------
int sub_61740(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5)
{
  __int16 v6; // [esp+1Ch] [ebp+1Ch]
  __int16 v7; // [esp+20h] [ebp+20h]

  v6 = a3 - 1;
  v7 = a4 - 1;
  sub_6B260(a1, a2, v6 + a1, a2, a5, 0);
  sub_6B260(v6 + a1, a2, v6 + a1, v7 + a2 + 1, a5, 0);
  sub_6B260(a1, v7 + a2, v6 + a1 + 1, v7 + a2, a5, 0);
  return sub_6B260(a1, a2, a1, v7 + a2, a5, 0);
}

//----- (00061810) --------------------------------------------------------
int sub_61810(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5)
{
  __int16 v6; // [esp+1Ch] [ebp+1Ch]
  __int16 v7; // [esp+20h] [ebp+20h]

  v6 = a3 - 1;
  v7 = a4 - 1;
  sub_6B378(a1, a2, v6 + a1, a2, a5, 0);
  sub_6B378(v6 + a1, a2, v6 + a1, v7 + a2 + 1, a5, 0);
  sub_6B378(a1, v7 + a2, v6 + a1 + 1, v7 + a2, a5, 0);
  return sub_6B378(a1, a2, a1, v7 + a2, a5, 0);
}

//----- (000618E0) --------------------------------------------------------
int sub_618E0(__int16 a1)
{
  int result; // eax
  int v2[13]; // [esp+0h] [ebp-78h] BYREF
  char v3[28]; // [esp+34h] [ebp-44h] BYREF
  int v4[7]; // [esp+50h] [ebp-28h] BYREF
  char v5[12]; // [esp+6Ch] [ebp-Ch] BYREF

  memset(v2, 0, 50);
  HIWORD(v2[8]) = (unsigned int)dword_12F080 >> 4;
  LOWORD(v2[9]) = HIWORD(v2[8]);
  v2[0] = 0;
  v2[7] = 20225;
  v2[6] = a1;
  memset(v4, 0, sizeof(v4));
  memset(v3, 0, sizeof(v3));
  memset(v5, 0, sizeof(v5));
  segread((uint32)v5);
  v4[0] = 768;
  v4[1] = 16;
  v4[5] = (int)v2;
  int386x(49, (uint32)v4, (uint32)v3, (uint32)v5);
  HIWORD(result) = HIWORD(dword_12F080);
  LOWORD(result) = *(unsigned __int8 *)(dword_12F080 + 4);
  word_12F084 = (unsigned __int8)result + (*(unsigned __int8 *)(dword_12F080 + 5) << 8);
  return result;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 636BC: using guessed type _DWORD segread(_DWORD);
// 636E6: using guessed type _DWORD int386x(_DWORD, _DWORD, _DWORD, _DWORD);
// 12F080: using guessed type int dword_12F080;
// 12F084: using guessed type __int16 word_12F084;

//----- (000619B8) --------------------------------------------------------
int sub_619B8(__int16 a1)
{
  char v2[28]; // [esp+0h] [ebp-38h] BYREF
  _WORD v3[14]; // [esp+1Ch] [ebp-1Ch] BYREF

  memset(v3, 0, sizeof(v3));
  memset(v2, 0, sizeof(v2));
  v3[0] = 20226;
  v3[2] = a1;
  int386(16, (uint32)v3, (uint32)v2);
  return sub_618E0(a1);
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 62F78: using guessed type _DWORD int386(_DWORD, _DWORD, _DWORD);

//----- (00061A1C) --------------------------------------------------------
int sub_61A1C(__int16 a1)
{
  int result; // eax

  word_9AFA4 = a1;
  if ( (unsigned __int16)a1 >= 6u )
  {
    __outbyte(0x3C8u, 0);
    __outbyte(0x3C9u, 0x3Fu);
    __outbyte(0x3C9u, 0);
    __outbyte(0x3C9u, 0);
  }
  //fix __asm { int     10h; - VIDEO - VESA SuperVGA BIOS -  VESA SuperVGA BIOS - CPU VIDEO MEMORY CONTROL }
  result = 20229;
  //fix __asm { int     10h; - VIDEO - VESA SuperVGA BIOS -  VESA SuperVGA BIOS - CPU VIDEO MEMORY CONTROL }
  return result;
}
// 9AFA4: using guessed type __int16 word_9AFA4;
// 12F080: using guessed type int dword_12F080;

//----- (00061AB0) --------------------------------------------------------
int sub_61AB0()
{
  int v1[13]; // [esp+0h] [ebp-7Ch] BYREF
  int v2[7]; // [esp+34h] [ebp-48h] BYREF
  char v3[28]; // [esp+50h] [ebp-2Ch] BYREF
  char v4[12]; // [esp+6Ch] [ebp-10h] BYREF

  memset(v1, 0, 50);
  HIWORD(v1[8]) = (unsigned int)dword_12F080 >> 4;
  LOWORD(v1[9]) = HIWORD(v1[8]);
  v1[0] = 0;
  v1[7] = 20224;
  v1[4] = 257;
  memset(v2, 0, sizeof(v2));
  memset(v3, 0, sizeof(v3));
  memset(v4, 0, sizeof(v4));
  segread((uint32)v4);
  v2[0] = 768;
  v2[1] = 16;
  v2[5] = (int)v1;
  int386x(49, (uint32)v2, (uint32)v3, (uint32)v4);
  return strncmp((char*)dword_12F080, aVesa, 4);
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 636BC: using guessed type _DWORD segread(_DWORD);
// 636E6: using guessed type _DWORD int386x(_DWORD, _DWORD, _DWORD, _DWORD);
// 65E6F: using guessed type _DWORD strncmp(_DWORD, _DWORD, _DWORD);
// 12F080: using guessed type int dword_12F080;

//----- (00061B90) --------------------------------------------------------
int sub_61B90(unsigned __int8 *a1)
{
  char v2[28]; // [esp+0h] [ebp-38h] BYREF
  int v3[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  v3[0] = 3840;
  int386(16, (uint32)v3, (uint32)v2);
  if ( !word_12F02C )
    word_12F02C = (unsigned __int8)v2[0];
  v3[0] = 19;
  dword_12EFF0 = 320;
  dword_12EFF8 = 200;
  int386(16, (uint32)v3, (uint32)v2);
  sub_319A0(a1);
  sub_5C468();
  return sub_65EB0(0, 0, 320, 200);
}
// 62F78: using guessed type _DWORD int386(_DWORD, _DWORD, _DWORD);
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF8: using guessed type int dword_12EFF8;
// 12F02C: using guessed type __int16 word_12F02C;

//----- (00061C30) --------------------------------------------------------
int sub_61C30(unsigned __int8 *a1)
{
  char v2[28]; // [esp+0h] [ebp-38h] BYREF
  int v3[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  v3[0] = 3840;
  int386(16, (uint32)v3, (uint32)v2);
  if ( !word_12F02C )
    word_12F02C = (unsigned __int8)v2[0];
  dword_12EFF0 = 640;
  dword_12EFF8 = 480;
  sub_619B8(257);
  sub_319A0(a1);
  sub_5C468();
  return sub_65EB0(0, 0, 640, 480);
}
// 62F78: using guessed type _DWORD int386(_DWORD, _DWORD, _DWORD);
// 12EFF0: using guessed type int dword_12EFF0;
// 12EFF8: using guessed type int dword_12EFF8;
// 12F02C: using guessed type __int16 word_12F02C;
// 61C30: using guessed type int var_1C[7];
// 61C30: using guessed type char var_38[28];

//----- (00061CC0) --------------------------------------------------------
__int16 sub_61CC0(unsigned __int8 *a1, unsigned __int8 a2, char a3)
{
  int v3; // eax
  int v4; // eax
  unsigned __int8 v6[768]; // [esp+0h] [ebp-30Ch] BYREF
  int i; // [esp+300h] [ebp-Ch]
  int v8; // [esp+308h] [ebp-4h]

  if ( a3 )
  {
    if ( byte_9AFA8 )
    {
      if ( a2 == ++word_12F690 )
        byte_9AFA8 = 0;
    }
    else
    {
      word_12F690 = 0;
      byte_9AFA8 = 1;
      sub_6B47C((unsigned __int8 *)byte_12F090);
      if ( !a1 )
        memset(&unk_12F390, 0, 768);
    }
    if ( !a1 )
      a1 = (unsigned __int8 *)&unk_12F390;
    for ( i = 0; (__int16)i < 768; ++i )
    {
      v4 = (__int16)i;
      LOWORD(v4) = (unsigned __int8)byte_12F090[(__int16)i];
      v8 = a1[(__int16)i] - v4;
      v6[(__int16)i] = byte_12F090[(__int16)i] + (__int16)v8 * ((int)unk_12F68E >> 16) / a2;
    }
    sub_5CC54();
    sub_319A0(v6);
  }
  else
  {
    sub_6B47C((unsigned __int8 *)byte_12F090);
    if ( !a1 )
    {
      a1 = (unsigned __int8 *)&unk_12F390;
      memset(&unk_12F390, 0, 768);
    }
    for ( word_12F690 = 0; a2 >= word_12F690; ++word_12F690 )
    {
      for ( i = 0; (__int16)i < 768; ++i )
      {
        v3 = (__int16)i;
        LOWORD(v3) = (unsigned __int8)byte_12F090[(__int16)i];
        v8 = a1[(__int16)i] - v3;
        v6[(__int16)i] = byte_12F090[(__int16)i] + (__int16)v8 * ((int)unk_12F68E >> 16) / a2;
      }
      sub_5CC54();
      sub_319A0(v6);
    }
    byte_9AFA8 = 0;
  }
  return word_12F690;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 9AFA8: using guessed type char byte_9AFA8;
// 12F690: using guessed type __int16 word_12F690;
// 61CC0: using guessed type unsigned __int8 var_30C[768];

//----- (00061EC8) --------------------------------------------------------
void sub_61EC8()
{
  byte_9AFA8 = 0;
}
// 9AFA8: using guessed type char byte_9AFA8;

//----- (00061F90) --------------------------------------------------------
void sub_61F90()
{
  if ( byte_939E4 )
  {
    sub_5D010();
    while ( sub_559A0() )
      ;
    sub_661A4(dword_CC140, 0);
    sub_5DC91(dword_CC148);
    if ( !byte_939CC )
      sub_5D948();
    sub_64F78(dword_CC140, 1, 1);
    sub_6481C();
    sub_61610((int)aDataSnds00Dat);
  }
}
// 939CC: using guessed type char byte_939CC;
// 939E4: using guessed type char byte_939E4;
// CC140: using guessed type int dword_CC140;
// CC148: using guessed type int dword_CC148;

//----- (00062020) --------------------------------------------------------
int sub_62020()
{
  int result; // eax

  //fix
  result = 0;
  //fix

  if ( byte_939CC )
  {
    if ( word_939D2 )
    {
      sub_5F420(dword_CBFD8);
      sub_5F355(dword_CBFD8);
      sub_6091D(dword_CBFDC);
    }
    if ( byte_9AF9C )
      sub_6091D(dword_12F074);
    sub_6080C(dword_CBFDC, 1);
    if ( byte_9AF9C )
      sub_6080C(dword_12F074, 1);
    sub_5D948();
    sub_60335();
    if ( byte_CBFEF )
    {
      sub_62128(dword_CBFE8);
      sub_62128(dword_CBFE2);
    }
    if ( byte_9AF9C )
      sub_62128(dword_12F07A);
    return sub_61610((int)aDataMusic00Dat);
  }
  return result;
}
// 939CC: using guessed type char byte_939CC;
// 939D2: using guessed type __int16 word_939D2;
// 9AF9C: using guessed type char byte_9AF9C;
// CBFD8: using guessed type int dword_CBFD8;
// CBFDC: using guessed type int dword_CBFDC;
// CBFE2: using guessed type int dword_CBFE2;
// CBFE8: using guessed type int dword_CBFE8;
// CBFEF: using guessed type char byte_CBFEF;
// 12F074: using guessed type int dword_12F074;
// 12F07A: using guessed type int dword_12F07A;

//----- (00062128) --------------------------------------------------------
int *sub_62128(int a1)
{
  return sub_426E0(a1);
}

//----- (00062B30) --------------------------------------------------------
int sub_62B30(int a1, int a2, char a3)
{
  return lseek(a1, a2, a3);
}
// 6B992: using guessed type _DWORD lseek(_DWORD, _DWORD, char);

//----- (00062B60) --------------------------------------------------------
int sub_62B60(int a1, char *a2)
{
  unsigned int i; // ecx
  int *v3; // esi
  int v4; // eax
  int v5; // eax
  _WORD *v6; // esi
  unsigned int v7; // edx
  char *v8; // ebx
  _DWORD *v9; // esi
  char *v10; // edi
  _DWORD *v11; // esi
  _WORD *v12; // edi
  _BYTE *v13; // esi
  _BYTE *v14; // edi
  char *v15; // edi
  int v16; // eax
  __int16 v17; // bx
  __int16 v18; // ax
  __int16 v19; // dx
  __int16 v20; // ax
  unsigned __int16 v22; // [esp-1Ah] [ebp-1Eh]

  if ( *(_WORD *)a1 != 20050 )
    return 0;
  v3 = (int *)(a1 + 4);
  if ( *(_WORD *)(a1 + 2) != 323 )
    return 0;
  LOBYTE(v4) = sub_62CF4(v3);
  dword_9B140 = v4;
  LOBYTE(v5) = sub_62CF4(v3);
  dword_9B144 = v5;
  byte_9B150 = *(_BYTE *)(a1 + 9);
  v6 = (_WORD *)(a1 + 10);
  v7 = v5 + 18 + a1;
  if ( v7 > (unsigned int)a2 )
  {
    v8 = &a2[dword_9B140 + *(unsigned __int8 *)(a1 + 16)];
    if ( (unsigned int)v8 > v7 )
    {
      v9 = (_DWORD *)(v7 - 4);
      v10 = v8 - 4;
      for ( i = (unsigned int)dword_9B144 >> 2; i; --i )
      {
        *(_DWORD *)v10 = *v9--;
        v10 -= 4;
      }
      v11 = v9 + 1;
      v12 = (uint16*)(v10 + 4);
      LOWORD(i) = dword_9B144 & 3;
      if ( (dword_9B144 & 3) != 0 )
      {
        v13 = (uint8*)((char *)v11 - 1);
        v14 = (uint8*)((char *)v12 - 1);
        while ( i )
        {
          *v14-- = *v13--;
          --i;
        }
        v12 = (uint16*)(v14 + 1);
      }
      v6 = v12;
    }
  }
  v15 = a2;
  byte_9B151 = 0;
  word_9B14C = *v6;
  sub_62D40(2u, (int)v6);
  do
  {
    sub_62DC3((int)v6);
    sub_62DC3((int)v6);
    sub_62DC3((int)v6);
    word_9B14A = sub_62D40(0x10u, (int)v6);
    while ( 1 )
    {
      sub_62CFD(word_9AFC0, (int)v6);
      if ( (_WORD)i )
      {
        qmemcpy(v15, v6, i);
        v6 = (_WORD *)((char *)v6 + i);
        v15 += i;
        i = (unsigned __int8)byte_9B151;
        v17 = *v6;
        v18 = __ROL2__(*v6, byte_9B151);
        v19 = (1 << byte_9B151) - 1;
        word_9B14C &= v19;
        v20 = v18 & v19 | (v6[1] << byte_9B151);
        word_9B14C |= v17 << byte_9B151;
        word_9B14E = v20;
      }
      if ( !--word_9B14A )
        break;
      sub_62CFD(word_9B040, (int)v6);
      v22 = i;
      sub_62CFD(word_9B0C0, (int)v6);
      LOWORD(i) = i + 2;
      v16 = v22;
      LOWORD(v16) = v22 + 1;
      qmemcpy(v15, &v15[-v16], i);
      v15 += i;
      i = 0;
    }
    --byte_9B150;
  }
  while ( byte_9B150 );
  return dword_9B140;
}
// 62B8D: variable 'v4' is possibly undefined
// 62B97: variable 'v5' is possibly undefined
// 62C4F: variable 'i' is possibly undefined
// 9AFC0: using guessed type __int16 word_9AFC0[64];
// 9B040: using guessed type __int16 word_9B040[64];
// 9B0C0: using guessed type __int16 word_9B0C0[64];
// 9B140: using guessed type int dword_9B140;
// 9B144: using guessed type int dword_9B144;
// 9B14A: using guessed type __int16 word_9B14A;
// 9B14C: using guessed type __int16 word_9B14C;
// 9B14E: using guessed type __int16 word_9B14E;
// 9B150: using guessed type char byte_9B150;
// 9B151: using guessed type char byte_9B151;

//----- (00062CF4) --------------------------------------------------------
char sub_62CF4fix(int *a1)
{
  int v1; // eax

  v1 = *a1;
  BYTE1(v1) = *a1;
  LOBYTE(v1) = BYTE1(*a1);
  return (unsigned __int16)__ROL4__(v1, 16) >> 8;
}

//----- (00062CFD) --------------------------------------------------------
__int16 sub_62CFDfix(__int16 *a1, int a2)
{
  __int16 *v3; // esi
  __int16 v5; // ax
  __int16 *v6; // esi
  __int16 v7; // bx
  __int16 v8; // ax
  __int16 v9; // cx
  __int16 result; // ax

  v3 = a1;
  do
  {
    v5 = *v3;
    v6 = v3 + 1;
    v7 = word_9B14C & v5;
    v8 = *v6;
    v3 = v6 + 1;
  }
  while ( v8 != v7 );
  v9 = v3[30];
  result = sub_62D40(HIBYTE(v9), a2);
  if ( (unsigned __int8)v9 >= 2u )
    return (1 << (v9 - 1)) | sub_62D40(v9 - 1, a2);
  return result;
}
// 9B14C: using guessed type __int16 word_9B14C;

//----- (00062D40) --------------------------------------------------------
__int16 sub_62D40fix(unsigned __int8 a1, int a2)
{
  unsigned __int16 v3; // ax
  unsigned __int16 v4; // bx
  char v5; // ch
  __int16 v7; // [esp-4h] [ebp-4h]

  v3 = word_9B14E;
  v4 = word_9B14C;
  v7 = word_9B14C & ((1 << a1) - 1);
  v5 = byte_9B151 - a1;
  if ( (unsigned __int8)byte_9B151 < a1 )
  {
    v4 = __ROR2__(word_9B14E & ((1 << byte_9B151) - 1), byte_9B151) | ((unsigned __int16)word_9B14C >> byte_9B151);
    v3 = *(_WORD *)(a2 + 2);
    a1 -= byte_9B151;
    v5 = 16 - a1;
  }
  word_9B14E = v3 >> a1;
  word_9B14C = __ROR2__(v3 & ((1 << a1) - 1), a1) | (v4 >> a1);
  byte_9B151 = v5;
  return v7;
}
// 9B14C: using guessed type __int16 word_9B14C;
// 9B14E: using guessed type __int16 word_9B14E;
// 9B151: using guessed type char byte_9B151;

//----- (00062DC3) --------------------------------------------------------
char sub_62DC3fix(int a1)
{
  _BYTE *v1; // edi
  unsigned __int16 v2; // ax
  int v3; // ecx
  int v4; // ecx
  _BYTE *v5; // esi
  _WORD *v6; // edi
  unsigned __int16 v7; // bx
  unsigned __int16 v8; // dx
  _WORD *v9; // edi
  unsigned __int16 v10; // bx
  char v11; // cf
  __int16 v13; // t2
  __int16 v14; // ax
  __int16 v16; // [esp-24h] [ebp-28h] BYREF
  unsigned __int16 v17; // [esp-22h] [ebp-26h]
  unsigned __int16 v18; // [esp-20h] [ebp-24h]
  _BYTE *v19; // [esp-1Eh] [ebp-22h]
  __int16 v20; // [esp-1Ah] [ebp-1Eh]
  int v21; // [esp-18h] [ebp-1Ch]
  _DWORD v22[6]; // [esp-14h] [ebp-18h] BYREF

  v1 = (uint8*)v22;
  v2 = sub_62D40(5u, a1);
  v3 = v2;
  if ( v2 )
  {
    v21 = v2;
    do
    {
      v2 = sub_62D40(4u, a1);
      *v1++ = v2;
      --v3;
    }
    while ( v3 );
    v4 = v21;
    v21 = a1;
    v5 = (uint8*)v22;
    v6 = (_WORD *)v22[4];
    LOBYTE(v2) = 1;
    v7 = 0;
    v8 = 0x8000;
    do
    {
      v20 = v4;
      v19 = v5;
      do
      {
        if ( (_BYTE)v2 == *v5 )
        {
          v18 = v2;
          v17 = v7;
          v16 = v4;
          *v6 = (1 << v2) - 1;
          v9 = v6 + 1;
          v10 = v7 >> (16 - v2);
          LOBYTE(v4) = v2;
          //fix _AX = 0;
          v11 = 0;
          do
          {
            v13 = v11 << 15;
            v11 = v10 & 1;
            v10 = (v10 >> 1) | v13;
            __asm { rcl     ax, 1 }
            --v4;
          }
          while ( v4 );
          //fix *v9 = _AX;
          v6 = v9 + 1;
          LOBYTE(v14) = v5 - (_BYTE *)&v16 - 16;
          HIBYTE(v14) = *v5;
          v6[30] = v14;
          LOWORD(v4) = v16;
          v2 = v18;
          v7 = v8 + v17;
        }
        ++v5;
        --v4;
      }
      while ( v4 );
      v5 = v19;
      LOWORD(v4) = v20;
      v8 >>= 1;
      LOBYTE(v2) = v2 + 1;
    }
    while ( (_BYTE)v2 != 17 );
  }
  return v2;
}

//----- (00062E60) --------------------------------------------------------
int sub_62E60(int a1, int a2, int a3)
{
  int v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]

  v5 = sub_5CDE0(a1, 546);
  if ( v5 == -1 )
    return -1;
  v6 = sub_62ED0(v5, a2, a3);
  sub_5CE50(v5);
  return v6;
}

//----- (00062ED0) --------------------------------------------------------
int sub_62ED0(int a1, int a2, int a3)
{
  return write(a1, a2, a3);
}
// 6C8EC: using guessed type _DWORD write(_DWORD, _DWORD, _DWORD);

//----- (00062FA8) --------------------------------------------------------
void sub_62FA8(const void *a1, void *a2, unsigned __int16 a3)
{
  qmemcpy(a2, a1, 320 * a3);
}

//----- (00062FC4) --------------------------------------------------------
void sub_62FC4(const void *a1, void *a2, unsigned __int16 a3)
{
  qmemcpy(a2, a1, 640 * a3);
}

//----- (00062FF0) --------------------------------------------------------
int sub_62FF0(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (00063010) --------------------------------------------------------
void sub_63010()
{
  int v0; // [esp+0h] [ebp-14h]
  int n; // [esp+4h] [ebp-10h]
  signed int k; // [esp+8h] [ebp-Ch]
  int m; // [esp+8h] [ebp-Ch]
  int ii; // [esp+8h] [ebp-Ch]
  int jj; // [esp+8h] [ebp-Ch]
  int kk; // [esp+8h] [ebp-Ch]
  int i; // [esp+Ch] [ebp-8h]
  int j; // [esp+Ch] [ebp-8h]
  int v9; // [esp+Ch] [ebp-8h]
  unsigned int v10; // [esp+10h] [ebp-4h]

  if ( !dword_12F6A8[0] )
  {
    v0 = sub_6342C(0xFA00u);
    for ( i = 0; i < 256; ++i )
      memset(&dword_12F6A0[3 * i], 0, 12);
    for ( j = 0; j < 256; ++j )
      memset((char *)&dword_1302A0 + 18 * j, 0, 18);
    v9 = 0;
    for ( k = (signed int)&unk_A0000; k >= 1024; k -= 1024 )
    {
      v10 = sub_6342C(k);
      if ( v10 )
      {
        dword_12F6A8[3 * v9] = k;
        dword_12F6A0[3 * v9] = 16 * (unsigned __int16)v10;
        dword_12F6A4[3 * v9] = HIWORD(v10);
        k += 1024;
        ++v9;
      }
    }
    for ( m = 0x1000000; m >= 4096; m -= 4096 )
    {
      dword_12F6A0[3 * v9] = (int)malloc(m);
      if ( dword_12F6A0[3 * v9] )
      {
        for ( n = 4096; n > 0; n -= 16 )
        {
          if ( expand(dword_12F6A0[3 * v9], n + m) )
          {
            dword_12F6A8[3 * v9] = n + m;
            dword_12F6A4[3 * v9] = 0;
            break;
          }
        }
        m += 4096;
        ++v9;
      }
    }
    for ( ii = 4096; ii >= 16; ii -= 16 )
    {
      dword_12F6A0[3 * v9] = (int)malloc(ii);
      if ( dword_12F6A0[3 * v9] )
      {
        dword_12F6A8[3 * v9] = ii;
        dword_12F6A4[3 * v9] = 0;
        ii += 4096;
        ++v9;
      }
    }
    qsort(dword_12F6A0, v9, 12, (_CoreCrtNonSecureSearchSortCompareFunction)sub_62FF0);
    for ( jj = 0; jj < 256; ++jj )
      *(int *)((char *)&dword_1302A4 + 18 * jj) = 0;
    for ( kk = 0; kk < v9; ++kk )
    {
      *(int *)((char *)&dword_1302A0 + 18 * kk) = dword_12F6A0[3 * kk];
      *(int *)((char *)&dword_1302A4 + 18 * kk) = dword_12F6A8[3 * kk];
      if ( kk )
        *(int *)((char *)&dword_1302AC + 18 * kk) = (int)&dword_1302A0 + 18 * kk - 18;
      else
        dword_1302AC = 0;
      *(int *)((char *)&dword_1302A8 + 18 * kk) = (int)&dword_1302A0 + 18 * kk + 18;
      byte_1302B0[18 * kk] = 0;
      byte_1302B1[18 * kk] = kk;
    }
    *(int *)((char *)&dword_1302A8 + 18 * v9 - 18) = 0;
    sub_6D35C(HIWORD(v0));
  }
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);
// 6CB61: using guessed type _DWORD malloc(_DWORD);
// 6CC5D: using guessed type _DWORD expand(_DWORD, _DWORD);
// 6CF2D: using guessed type _DWORD qsort(_DWORD, _DWORD, _DWORD, _DWORD);
// 12F6A0: using guessed type int dword_12F6A0[];
// 12F6A4: using guessed type int dword_12F6A4[];
// 12F6A8: using guessed type int dword_12F6A8[];
// 1302A0: using guessed type int dword_1302A0;
// 1302A4: using guessed type int dword_1302A4;
// 1302A8: using guessed type int dword_1302A8;
// 1302AC: using guessed type int dword_1302AC;

//----- (00063338) --------------------------------------------------------
int *sub_63338()
{
  int *result; // eax
  int *i; // [esp+0h] [ebp-4h]

  //fix
  result = 0;
  //fix

  dword_1314A0 = 0;
  dword_1314A4 = 0;
  dword_1314A8 = 0;
  dword_1314AC = 0;
  dword_1314B0 = -1;
  for ( i = &dword_1302A0; i; i = result )
  {
    if ( *((_BYTE *)i + 16) )
    {
      dword_1314A8 += i[1];
      dword_1314A0 += i[1];
    }
    else
    {
      dword_1314A4 += i[1];
      if ( i[1] > (unsigned int)dword_1314AC )
        dword_1314AC = i[1];
      if ( i[1] < (unsigned int)dword_1314B0 )
        dword_1314B0 = i[1];
      dword_1314A0 += i[1];
    }
    result = (int *)i[2];
  }
  LOBYTE(dword_1314A0) = dword_1314A0 & 0xFC;
  LOBYTE(dword_1314A4) = dword_1314A4 & 0xFC;
  LOBYTE(dword_1314A8) = dword_1314A8 & 0xFC;
  LOBYTE(dword_1314AC) = dword_1314AC & 0xFC;
  LOBYTE(dword_1314B0) = dword_1314B0 & 0xFC;
  return result;
}
// 1302A0: using guessed type int dword_1302A0;
// 1314A0: using guessed type int dword_1314A0;
// 1314A4: using guessed type int dword_1314A4;
// 1314A8: using guessed type int dword_1314A8;
// 1314AC: using guessed type int dword_1314AC;
// 1314B0: using guessed type int dword_1314B0;

//----- (0006342C) --------------------------------------------------------
int sub_6342C(unsigned int a1)
{
  int v2[7]; // [esp+0h] [ebp-40h] BYREF
  int v3[7]; // [esp+1Ch] [ebp-24h] BYREF
  int v4; // [esp+38h] [ebp-8h]

  v4 = 0;
  if ( a1 < (unsigned int)&unk_A0000 )
  {
    v2[0] = 256;
    v2[1] = (a1 + 15) >> 4;
    int386(49, (uint32)v2, (uint32)v3);
    if ( !v3[6] )
      return (v3[3] << 16) | v3[0];
  }
  return v4;
}
// 62F78: using guessed type _DWORD int386(_DWORD, _DWORD, _DWORD);

//----- (000634A0) --------------------------------------------------------
_DWORD *sub_634A0(int a1)
{
  _DWORD *result; // eax

  result = *(_DWORD **)(a1 + 28);
  if ( *result )
  {
    sub_426E0(**(_DWORD **)(a1 + 28));
    result = *(_DWORD **)(a1 + 28);
    *result = 0;
  }
  return result;
}

//----- (000634E0) --------------------------------------------------------
int sub_634E0(int a1)
{
  int v1; // eax
  int *v2; // edx
  int v3; // eax
  int *v4; // edx
  int (*v6)(int); // [esp+0h] [ebp-8h]

  sub_63010();
  if ( (*(_BYTE *)(a1 + 40) & 1) != 0 )
    v6 = sub_425C0;
  else
    v6 = sub_42540;
  sub_634A0(a1);
  if ( *(_BYTE *)a1 == 42 )
  {
    v1 = v6(*(_DWORD *)(a1 + 36));
    v2 = *(int **)(a1 + 28);
    *v2 = v1;
    if ( !*v2 )
      return 0;
  }
  else
  {
    *(_DWORD *)(a1 + 36) = sub_63910(a1);
    if ( *(int *)(a1 + 36) <= 0 )
      return 0;
    v3 = v6(*(_DWORD *)(a1 + 36));
    v4 = *(int **)(a1 + 28);
    *v4 = v3;
    if ( !*v4 )
      return -1;
    if ( sub_3EEA0((const char *)a1, **(char ***)(a1 + 28)) != *(_DWORD *)(a1 + 36) )
    {
      **(_DWORD **)(a1 + 28) = 0;
      **(_DWORD **)(a1 + 32) = 0;
      *(_DWORD *)(a1 + 36) = 0;
      return 0;
    }
  }
  if ( *(_DWORD *)(a1 + 32) )
    **(_DWORD **)(a1 + 32) = *(_DWORD *)(a1 + 36) + **(_DWORD **)(a1 + 28);
  return 1;
}

//----- (0006377B) --------------------------------------------------------
void sub_6377B()
{
  ;
}

//----- (0006378C) --------------------------------------------------------
char *sub_6378C(int a1)
{
  return off_9EF10[a1];
}
// 9EF10: using guessed type char *off_9EF10[20];

//----- (000637AF) --------------------------------------------------------
void sub_637AF()
{
  ;
}

//----- (000637C0) --------------------------------------------------------
void sub_637C0()
{
  ;
}

//----- (000637D1) --------------------------------------------------------
int sub_637D1(int a1, int a2, unsigned __int16 a3, int a4)
{
  //fix MK_FP(byte_9C07A[9 * a1 + 1], byte_9C07A[9 * a1])(a2, a3, a1, a4);
  return 0;
}
// 9C07A: using guessed type _DWORD byte_9C07A[39];

//----- (000638E0) --------------------------------------------------------
int sub_638E0(int a1, int a2, int a3)
{
  void *retaddr[2]; // [esp+10h] [ebp+10h]

  byte_9ECFE = 1;
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(a1, a2, a3);
}
// 9ECFE: using guessed type char byte_9ECFE;

//----- (000638F8) --------------------------------------------------------
void sub_638F8()
{
  ;
}

//----- (00063910) --------------------------------------------------------
int sub_63910(int a1)
{
  char v2[8]; // [esp+0h] [ebp-1Ch] BYREF
  char v3[8]; // [esp+8h] [ebp-14h] BYREF
  int v5; // [esp+14h] [ebp-8h]
  int v6; // [esp+18h] [ebp-4h]

  v5 = -1;
  qmemcpy(v3, "RNC", 3);
  v3[3] = 1;
  v3[4] = 0;
  v6 = sub_5CDE0(a1, 512);
  if ( v6 <= 0 )
    return -1;
  sub_5CBD0(v6, (int)v2, 8);
  if ( !strncmp(v2, v3, 4) )
  {
    v5 = (unsigned __int8)v2[4] << 8;
    v5 += (unsigned __int8)v2[5];
    v5 <<= 8;
    v5 += (unsigned __int8)v2[6];
    v5 <<= 8;
    v5 += (unsigned __int8)v2[7];
  }
  else
  {
    v5 = filelength(v6);
  }
  sub_5CE50(v6);
  return v5;
}
// 62AE2: using guessed type _DWORD filelength(_DWORD);
// 65E6F: using guessed type _DWORD strncmp(_DWORD, _DWORD, _DWORD);

//----- (00063A8C) --------------------------------------------------------
void sub_63A8C()
{
  ;
}

//----- (00063A9D) --------------------------------------------------------
int sub_63A9D(__int16 a1, int a2, int a3, __int16 a4)
{
  int v4; // eax

  if ( dword_9EF60 )
    return 3;
  if ( a3 || a4 )
  {
    strcpy(&unk_A05D1, (char*)a3);
    strcat(&unk_A05D1, aHmidet386);
  }
  else
  {
    strcpy(&unk_A05D1, aHmidet386);
  }
  dword_131574 = open((uint32)&unk_A05D1, 512);
  if ( dword_131574 == -1 )
    return 15;
  read(dword_131574, (uint32)&unk_131588, 44);
  dword_131578 = (int)malloc(4096);
  if ( dword_131578 )
  {
    dword_131580 = sub_67557(a1, a2, dword_131578);
    v4 = sub_67582();
    word_1315B8 = a1;
    dword_1315B4 = v4;
    sub_674CD();
    lseek(dword_131574, 0, 0);
    dword_9EF64 = 0;
    dword_9EF60 = 1;
    return 0;
  }
  else
  {
    close(dword_131574);
    return 5;
  }
}
// 6691E: using guessed type _DWORD close(_DWORD);
// 6692C: using guessed type _DWORD read(_DWORD, _DWORD, _DWORD);
// 6B992: using guessed type _DWORD lseek(_DWORD, _DWORD, char);
// 6CB61: using guessed type _DWORD malloc(_DWORD);
// 6DD0E: using guessed type _DWORD strcpy(_DWORD, _DWORD);
// 6DD33: using guessed type _DWORD strcat(_DWORD, _DWORD);
// 9EF60: using guessed type int dword_9EF60;
// 9EF64: using guessed type int dword_9EF64;
// 131574: using guessed type int dword_131574;
// 131578: using guessed type int dword_131578;
// 131580: using guessed type int dword_131580;
// 1315B4: using guessed type int dword_1315B4;
// 1315B8: using guessed type __int16 word_1315B8;

//----- (00063C06) --------------------------------------------------------
int sub_63C06()
{
  dword_9EF60 = 0;
  close(dword_131574);
  sub_674FA();
  free((void*)dword_131578);
  return 0;
}
// 6691E: using guessed type _DWORD close(_DWORD);
// 6BA12: using guessed type _DWORD free(_DWORD);
// 9EF60: using guessed type int dword_9EF60;
// 131574: using guessed type int dword_131574;
// 131578: using guessed type int dword_131578;

//----- (00063C5A) --------------------------------------------------------
int sub_63C5A(const void *a1, unsigned int a2, char *a3, __int16 a4, unsigned int a5)
{
  int v7; // [esp+4h] [ebp-18h]
  int v8; // [esp+Ch] [ebp-10h]
  int v9; // [esp+10h] [ebp-Ch]
  unsigned int v10; // [esp+14h] [ebp-8h]

  v10 = 0;
  if ( !a3 && !a4 )
    return 2;
  if ( a2 < 0xE000 || a2 > 0xE200 )
    return 6;
  v9 = 0;
  lseek(dword_131574, 0, 0);
  read(dword_131574, (uint32)&unk_131588, 44);
  while ( v10 <= dword_1315A8 && !v9 )
  {
    v7 = lseek(dword_131574, 0, 1);
    read(dword_131574, (uint32)&unk_131540, 48);
    if ( dword_131568 == a2 && byte_13156D < 0 )
    {
      v9 = 1;
      read(dword_131574, dword_131578, dword_131564);
      dword_131584 = dword_131578;
    }
    else
    {
      lseek(dword_131574, dword_131564, 1);
    }
    ++v10;
  }
  if ( v9 != 1 )
    return 7;
  v8 = sub_67710((int (*)(_DWORD))dword_131584);
  if ( !v8 )
    return 8;
  sub_6765C(a1, (int (*)(_DWORD))dword_131584, dword_1315B4, word_1315B8, a3, a4);
  __writegsdword(a5, v8);
  dword_131570 = v7;
  return 0;
}
// 63DE1: variable 'v7' is possibly undefined
// 6692C: using guessed type _DWORD read(_DWORD, _DWORD, _DWORD);
// 6B992: using guessed type _DWORD lseek(_DWORD, _DWORD, char);
// 131564: using guessed type int dword_131564;
// 131568: using guessed type int dword_131568;
// 13156D: using guessed type char byte_13156D;
// 131570: using guessed type int dword_131570;
// 131574: using guessed type int dword_131574;
// 131578: using guessed type int dword_131578;
// 131584: using guessed type int dword_131584;
// 1315A8: using guessed type int dword_1315A8;
// 1315B4: using guessed type int dword_1315B4;
// 1315B8: using guessed type __int16 word_1315B8;

//----- (00064248) --------------------------------------------------------
int sub_64248(unsigned int a1, __int16 a2)
{
  if ( !a1 && !a2 )
    return 2;
  lseek(dword_131574, dword_131570, 0);
  read(dword_131574, (uint32)&unk_131540, 48);
  read(dword_131574, dword_131578, dword_131564);
  sub_67710((int (*)(_DWORD))dword_131584);
  sub_6773B((int (*)(_DWORD))dword_131584);
  __writegsdword(a1, dword_A06DC);
  __writegsdword(a1 + 8, dword_A06E0);
  __writegsdword(a1 + 4, dword_A06E4);
  return 0;
}
// 6692C: using guessed type _DWORD read(_DWORD, _DWORD, _DWORD);
// 6B992: using guessed type _DWORD lseek(_DWORD, _DWORD, char);
// A06DC: using guessed type int dword_A06DC;
// A06E0: using guessed type int dword_A06E0;
// A06E4: using guessed type int dword_A06E4;
// 131564: using guessed type int dword_131564;
// 131570: using guessed type int dword_131570;
// 131574: using guessed type int dword_131574;
// 131578: using guessed type int dword_131578;
// 131584: using guessed type int dword_131584;
// 1315B4: using guessed type int dword_1315B4;
// 1315B8: using guessed type __int16 word_1315B8;

//----- (00064414) --------------------------------------------------------
void sub_64414()
{
  ;
}

//----- (00064425) --------------------------------------------------------
void sub_64425()
{
  ;
}

//----- (00064436) --------------------------------------------------------
__int16 sub_64436()
{
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  sub_674CD();
  return sub_674CD();
}

//----- (000645FB) --------------------------------------------------------
__int16 sub_645FB()
{
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  sub_674FA();
  return sub_674FA();
}

//----- (000647C0) --------------------------------------------------------
int sub_647C0(int a1, unsigned __int16 a2)
{
  sub_64436();
  dword_9EF80 = 1;
  //fix
  /*
  if ( a1 || a2 )
    fstrcpy(&byte_A04D2, (unsigned __int16)__DS__, a1, a2);
  else
    byte_A04D2 = 0;*/
  return 0;
}
// 6A67A: using guessed type _DWORD fstrcpy(_DWORD, _DWORD, _DWORD, _DWORD);
// 9EF80: using guessed type int dword_9EF80;
// A04D2: using guessed type char byte_A04D2;

//----- (0006481C) --------------------------------------------------------
int sub_6481C()
{
  sub_645FB();
  dword_9EF80 = 0;
  return 0;
}
// 9EF80: using guessed type int dword_9EF80;

//----- (00064846) --------------------------------------------------------
int sub_64846(
        int a1,
        int a2,
        unsigned int a3,
        unsigned int a4,
        int a5,
        unsigned int a6,
        int a7,
        unsigned int a8)
{
  int v8; // edx
  int v9; // edx
  __int16 v10; // dx
  int v11; // edx
  int v12; // edx
  int v13; // edx
  int v14; // eax
  int v15; // ebx
  int v16; // eax
  int v17; // ebx
  int v18; // eax
  unsigned int v19; // ebx
  int v20; // eax
  int v21; // ebx
  int v22; // eax
  int v23; // ebx
  int v24; // eax
  int v25; // ebx
  int v26; // eax
  int v27; // ebx
  int v29; // [esp+8h] [ebp-64h]
  unsigned __int16 v30; // [esp+Ch] [ebp-60h]
  int v31; // [esp+10h] [ebp-5Ch] BYREF
  int v32; // [esp+14h] [ebp-58h]
  int v33; // [esp+18h] [ebp-54h]
  __int16 v34; // [esp+1Ch] [ebp-50h]
  unsigned int v35; // [esp+20h] [ebp-4Ch] BYREF
  int v36; // [esp+24h] [ebp-48h]
  unsigned int v38; // [esp+2Ch] [ebp-40h]
  unsigned int j; // [esp+30h] [ebp-3Ch]
  int v40; // [esp+34h] [ebp-38h] BYREF
  int (*v41)(_DWORD); // [esp+38h] [ebp-34h] BYREF
  int v42; // [esp+3Ch] [ebp-30h]
  int v43; // [esp+40h] [ebp-2Ch]
  unsigned int i; // [esp+44h] [ebp-28h]
  void (*v45[5])(_DWORD); // [esp+48h] [ebp-24h] BYREF
  unsigned int v46; // [esp+5Ch] [ebp-10h]
  int v47; // [esp+60h] [ebp-Ch]
  void (*v48)(_DWORD); // [esp+64h] [ebp-8h]
  unsigned int v49; // [esp+68h] [ebp-4h]

  //fix
  v36 = 0;
  //fix

  v49 = __readgsdword(a6);
  v48 = (void (*)(_DWORD))__readgsdword(a6 + 16);
  v30 = __readgsword(a6 + 8);
  v29 = __readgsdword(a6 + 4);
  v46 = __readgsdword(a6 + 12);
  v45[4] = v48;
  v45[3] = (void (*)(_DWORD))__readgsdword(a6 + 20);
  v45[2] = (void (*)(_DWORD))__readgsdword(a6 + 24);
  v43 = 6;
  for ( i = 0; i < 5; ++i )
  {
    if ( !dword_A0338[i] )
    {
      v43 = i;
      break;
    }
  }
  if ( v43 == 6 )
    return 11;
  dword_A0338[v43] = a3;
  if ( __readgsdword(a6 + 36) || __readgsword(a6 + 40) )
  {
    LOWORD(v36) = __readgsword(a6 + 40);
    v35 = __readgsdword(a6 + 36);
    v41 = (int (*)(_DWORD))__readgsdword(a6 + 44);
    v8 = 3 * v43;
    word_A01D0[v8] = v36;
    *(int *)((char *)&dword_A01CC + v8 * 2) = v35;
    dword_A01EA[v43] = (int)v41;
  }
  else
  {
    v42 = sub_6DE34((__int16)&v35, a1, a3, v43, (int *)&v41, (unsigned int)&v35);
    if ( v42 )
      return v42;
    __writegsword(a6 + 40, v36);
    __writegsdword(a6 + 36, v35);
    __writegsdword(a6 + 44, (unsigned int)v41);
    v9 = 3 * v43;
    word_A01D0[v9] = v36;
    *(int *)((char *)&dword_A01CC + v9 * 2) = v35;
    dword_A01EA[v43] = (int)v41;
  }
  //fix v42 = sub_6DD7D(v43, (int)&byte_A0350[6 * v43], __DS__);
  if ( !v42 )
  {
    if ( (unsigned int)dword_A0338[v43] >= 0xE106 )
    {
      v18 = 3 * v43;
      word_A02DE[v18] = 0;
      *(int *)((char *)&dword_A02DA + v18 * 2) = 0;
    }
    else
    {
      v10 = 4 * v43;
      dword_A0280[v43] = v49;
      if ( v46 )
      {
        dword_9EF6C[v43] = 1;
        v34 = 0;
        v33 = 0;
        a1 = sub_650FF(v10, a1, v49, (uint32*)&v40);
        v30 = v10;
        v29 = a1;
        if ( !a1 && v10 == v34 )
        {
          sub_6E030(v43);
          dword_A0338[v43] = 0;
          return 5;
        }
        v11 = 3 * v43;
        word_A0298[v11] = v30;
        *(int *)((char *)&dword_A0294 + v11 * 2) = a1;
        if ( __readgsdword(*(_DWORD *)&byte_A0350[6 * v43] + 36) == 8 )
        {
          if ( (__readgsbyte(*(_DWORD *)&byte_A0350[6 * v43] + 61) & 0x80u) == 0 )
          {
            for ( j = 0; j < v49; ++j )
              __writegsbyte(j + a1, 0x80u);
          }
          else
          {
            for ( j = 0; j < v49; ++j )
              __writegsbyte(j + a1, 0);
          }
        }
        else
        {
          for ( j = 0; j < v49; ++j )
            __writegsbyte(j + a1, 0);
        }
      }
      else
      {
        v12 = 3 * v43;
        word_A0298[v12] = v30;
        *(int *)((char *)&dword_A0294 + v12 * 2) = v29;
        dword_9EF6C[v43] = 0;
      }
      __writegsword(a6 + 8, v30);
      __writegsdword(a6 + 4, v29);
      if ( __readgsdword(a6 + 48) || __readgsword(a6 + 52) )
      {
        LOWORD(v32) = __readgsword(a6 + 52);
        v31 = __readgsdword(a6 + 48);
      }
      else if ( __readgsdword(a6 + 60) )
      {
        v42 = sub_6E09A(a6, a1, __readgsdword(a6 + 60), (int *)v45, (unsigned int)&v31);
        if ( v42 )
          return v42;
      }
      else
      {
        v42 = sub_6E09A(
                (__int16)&v31,
                a1,
                __readgsdword(*(_DWORD *)&byte_A0350[6 * v43] + 104),
                (int *)v45,
                (unsigned int)&v31);
        if ( v42 )
          return v42;
      }
      __writegsword(a6 + 52, v32);
      __writegsdword(a6 + 48, v31);
      v13 = 3 * v43;
      word_A0202[v13] = v32;
      *(int *)((char *)&dword_A01FE + v13 * 2) = v31;
      dword_A021C[v43] = (int)v45[0];
      dword_A0244[v43] = 1;
      v47 = __readgsdword(a4 + 8);
      v47 = dword_A0374[v47];
      sub_677E3(a2, v45[0], v31, (unsigned __int16)v32, v29, v30, v49, v47, v43, (int)&dword_1315BC);
      v14 = 3 * v43;
      v15 = dword_1315BC;
      word_A02DE[v14] = word_1315C0;
      *(int *)((char *)&dword_A02DA + v14 * 2) = v15;
      v16 = 3 * v43;
      v17 = dword_1315C4;
      word_A031A[v16] = word_1315C8;
      *(int *)((char *)&dword_A0316 + v16 * 2) = v17;
      sub_67527((int)&byte_131724[192 * v43], dword_1315CC, word_1315D0);
    }
    v19 = *(int *)((char *)&dword_A02DA + 6 * v43);
    __writegsword(a6 + 32, word_A02DE[3 * v43]);
    __writegsdword(a6 + 28, v19);
    sub_6790D();
    dword_A02B2[v43] = v40;
    v45[1] = (void (*)(_DWORD))__readgsdword(a4);
    v38 = __readgsdword(a4 + 4);
    v47 = __readgsdword(a4 + 8);
    byte_A0394[v43] = v47;
    sub_67845(v41);
    sub_678DE(v41);
    sub_678AF(v41);
    v40 = dword_A02B2[v43];
    sub_6787E(v41);
    dword_A0230[v43] = 1;
    dword_A0258[v43] = 1;
    dword_1315E4[16 * v43] = __readgsdword(a6);
    v20 = v43 << 6;
    v21 = __readgsdword(a6 + 4);
    *(__int16 *)((char *)&word_1315EC + v20) = __readgsword(a6 + 8);
    *(int *)((char *)&dword_1315E8 + v20) = v21;
    dword_1315F0[16 * v43] = __readgsdword(a6 + 12);
    dword_1315F4[16 * v43] = __readgsdword(a6 + 16);
    dword_1315F8[16 * v43] = a3;
    dword_1315FC[16 * v43] = __readgsdword(a6 + 24);
    v22 = v43 << 6;
    v23 = __readgsdword(a6 + 28);
    *(__int16 *)((char *)&word_131604 + v22) = __readgsword(a6 + 32);
    *(int *)((char *)&dword_131600 + v22) = v23;
    v24 = v43 << 6;
    v25 = __readgsdword(a6 + 36);
    *(__int16 *)((char *)&word_13160C + v24) = __readgsword(a6 + 40);
    *(int *)((char *)&dword_131608 + v24) = v25;
    v26 = v43 << 6;
    v27 = __readgsdword(a6 + 48);
    *(__int16 *)((char *)&word_131618 + v26) = __readgsword(a6 + 52);
    *(int *)((char *)&dword_131614 + v26) = v27;
    dword_131620[16 * v43] = __readgsdword(a6 + 60);
    __writegsdword(a8, v43);
    return 0;
  }
  return v42;
}
// 9EF6C: using guessed type int dword_9EF6C[];
// A01CC: using guessed type int dword_A01CC;
// A01D0: using guessed type __int16 word_A01D0[13];
// A01EA: using guessed type int dword_A01EA[5];
// A01FE: using guessed type int dword_A01FE;
// A0202: using guessed type __int16 word_A0202[13];
// A021C: using guessed type int dword_A021C[5];
// A0230: using guessed type int dword_A0230[5];
// A0244: using guessed type int dword_A0244[5];
// A0258: using guessed type int dword_A0258[5];
// A0280: using guessed type int dword_A0280[5];
// A0294: using guessed type int dword_A0294;
// A0298: using guessed type __int16 word_A0298[];
// A02B2: using guessed type int dword_A02B2[5];
// A02DA: using guessed type int dword_A02DA;
// A02DE: using guessed type __int16 word_A02DE[28];
// A0316: using guessed type int dword_A0316;
// A031A: using guessed type __int16 word_A031A[];
// A0338: using guessed type int dword_A0338[6];
// A0374: using guessed type int dword_A0374[8];
// 1315BC: using guessed type int dword_1315BC;
// 1315C0: using guessed type __int16 word_1315C0;
// 1315C4: using guessed type int dword_1315C4;
// 1315C8: using guessed type __int16 word_1315C8;
// 1315CC: using guessed type int dword_1315CC;
// 1315D0: using guessed type __int16 word_1315D0;
// 1315E4: using guessed type int dword_1315E4[];
// 1315E8: using guessed type int dword_1315E8;
// 1315EC: using guessed type __int16 word_1315EC;
// 1315F0: using guessed type int dword_1315F0[];
// 1315F4: using guessed type int dword_1315F4[];
// 1315F8: using guessed type int dword_1315F8[];
// 1315FC: using guessed type int dword_1315FC[];
// 131600: using guessed type int dword_131600;
// 131604: using guessed type __int16 word_131604;
// 131608: using guessed type int dword_131608;
// 13160C: using guessed type __int16 word_13160C;
// 131614: using guessed type int dword_131614;
// 131618: using guessed type __int16 word_131618;
// 131620: using guessed type int dword_131620[65];
// 64846: using guessed type unsigned int arg_C;
// 64846: using guessed type unsigned int arg_4;

//----- (00064F78) --------------------------------------------------------
int sub_64F78(unsigned int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int (*v8)(_DWORD); // [esp+14h] [ebp-4h]

  if ( !dword_A0230[a1] )
    return 1;
  dword_A0258[a1] = 0;
  if ( (unsigned int)dword_A02C6[a1] < 0xE106 && dword_9EF6C[a1] && a2 )
    dword_9EF6C[a1] = 0;
  v8 = (int (*)(_DWORD))dword_A01EA[a1];
  sub_676E5(v8);
  sub_677B8(v8);
  sub_67944();
  if ( a3 )
  {
    sub_6E030(a1);
    sub_6E23C(*(int *)((char *)&dword_A01FE + 6 * a1), word_A0202[3 * a1]);
  }
  v3 = 3 * a1;
  word_A01D0[v3] = 0;
  *(int *)((char *)&dword_A01CC + v3 * 2) = 0;
  v4 = 3 * a1;
  word_A02DE[v4] = 0;
  *(int *)((char *)&dword_A02DA + v4 * 2) = 0;
  v5 = 3 * a1;
  word_A0202[v5] = 0;
  *(int *)((char *)&dword_A01FE + v5 * 2) = 0;
  dword_A0338[a1] = 0;
  dword_A0230[a1] = 0;
  return 0;
}
// 9EF6C: using guessed type int dword_9EF6C[];
// A01CC: using guessed type int dword_A01CC;
// A01D0: using guessed type __int16 word_A01D0[];
// A01EA: using guessed type int dword_A01EA[5];
// A01FE: using guessed type int dword_A01FE;
// A0202: using guessed type __int16 word_A0202[13];
// A0230: using guessed type int dword_A0230[5];
// A0258: using guessed type int dword_A0258[5];
// A02C6: using guessed type int dword_A02C6[5];
// A02DA: using guessed type int dword_A02DA;
// A02DE: using guessed type __int16 word_A02DE[];
// A0338: using guessed type int dword_A0338[6];

//----- (000650FF) --------------------------------------------------------
int sub_650FF(__int16 a1, int a2, unsigned int a3, _DWORD *a4)
{
  int v5; // [esp+14h] [ebp-4h] BYREF

  do
  {
    sub_675C8((a3 >> 4) + 4, (uint32*)&v5);
    v5 = sub_67557(a1, a2, v5);
    *a4 = v5;
    a1 = v5;
  }
  while ( (unsigned __int16)v5 > 0xFFFF - a3 );
  return sub_67582();
}

//----- (000651D6) --------------------------------------------------------
void sub_651D6()
{
  ;
}

//----- (000651E7) --------------------------------------------------------
void sub_651E7()
{
  ;
}

//----- (000651F8) --------------------------------------------------------
bool sub_651F8(int a1, int a2)
{
  unsigned int i; // [esp+8h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    if ( i >= 0x20 )
      return 1;
    if ( (__int16)__readgsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 52) == a2 )
      break;
  }
  return ((__readgsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 48) >> 8) & 0x80u) == 0;
}

//----- (0006533A) --------------------------------------------------------
void sub_6533A()
{
  ;
}

//----- (0006534B) --------------------------------------------------------
void sub_6534B()
{
  ;
}

//----- (0006535C) --------------------------------------------------------
int sub_6535C(int a1, unsigned int a2)
{
  unsigned int v2; // edx
  unsigned int v3; // ebx
  int v4; // edx
  unsigned int v5; // ebx
  unsigned int v6; // ebx
  int v7; // edx
  unsigned __int16 v8; // bx
  int v9; // eax
  unsigned int v10; // ebx
  unsigned int i; // [esp+20h] [ebp-4h]

  if ( (unsigned int)dword_A02C6[a1] >= 0xE106 )
    return 0;
  for ( i = 0; ; ++i )
  {
    if ( i >= 0x20 )
      return -1;
    if ( ((__readgsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 48) >> 8) & 0x80u) == 0 )
      break;
  }
  v2 = *(_DWORD *)&byte_131724[192 * a1 + 6 * i];
  v3 = __readgsdword(a2);
  __writegsword(v2 + 4, __readgsword(a2 + 4));
  __writegsdword(v2, v3);
  v4 = *(_DWORD *)&byte_131724[192 * a1 + 6 * i];
  v5 = __readgsdword(a2);
  __writegsword(v4 + 12, __readgsword(a2 + 4));
  __writegsdword(v4 + 8, v5);
  v6 = __readgsdword(a2 + 36) + __readgsdword(a2);
  v7 = *(_DWORD *)&byte_131724[192 * a1 + 6 * i];
  __writegsword(v7 + 20, __readgsword(a2 + 4));
  __writegsdword(v7 + 16, v6);
  if ( (__readgsbyte(a2 + 28) & 0x40) != 0 )
  {
    __writegsdword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 24, __readgsdword(a2 + 36));
    __writegsdword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 28, __readgsdword(a2 + 36));
    __writegsdword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 32, __readgsdword(a2 + 40));
    __writegsdword(
      *(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 44,
      __readgsdword(a2 + 32) - (__readgsdword(a2 + 40) + __readgsdword(a2 + 36)));
  }
  else
  {
    __writegsdword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 24, __readgsdword(a2 + 8));
    __writegsdword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 28, __readgsdword(a2 + 8));
  }
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 50, __readgsword(a2 + 16));
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 52, __readgsword(a2 + 18));
  v8 = __readgsword(a2 + 28);
  HIBYTE(v8) |= 0xA0u;
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 48, v8);
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 54, __readgsword(a2 + 14));
  v9 = *(_DWORD *)&byte_131724[192 * a1 + 6 * i];
  v10 = __readgsdword(a2 + 20);
  __writegsword(v9 + 64, __readgsword(a2 + 24));
  __writegsdword(v9 + 60, v10);
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 56, __readgsword(a2 + 12));
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 74, __readgsword(a2 + 26));
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 58, 0);
  __writegsdword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 68, __readgsdword(a2 + 44));
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 72, 0);
  __writegsdword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 76, 0);
  __writegsdword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 80, __readgsdword(a2 + 8));
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 84, __readgsword(a2 + 50));
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 86, __readgsword(a2 + 52));
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 88, __readgsword(a2 + 54));
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 90, __readgsword(a2 + 56));
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 92, __readgsword(a2 + 58));
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 94, __readgsword(a2 + 60));
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 96, __readgsword(a2 + 62));
  __writegsdword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 100, 0);
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 104, 0);
  return i;
}
// A02C6: using guessed type int dword_A02C6[5];

//----- (00065965) --------------------------------------------------------
int sub_65965(int a1, int a2)
{
  unsigned int i; // [esp+4h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    if ( i >= 0x20 )
      return 10;
    if ( (__int16)__readgsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 52) == a2 )
      break;
  }
  __writegsbyte(
    *(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 49,
    __readgsbyte(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 49) & 0x7F);
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 52, 0);
  return 0;
}

//----- (00065D57) --------------------------------------------------------
void sub_65D57()
{
  ;
}

//----- (00065D70) --------------------------------------------------------
unsigned int sub_65D70(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unsigned int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( a1 >= a2 )
      break;
    if ( *(_DWORD *)a1 < a3 )
    {
      *(_BYTE *)(a1 + 4) *= 2;
      *(_BYTE *)(a1 + 5) *= 2;
      *(_DWORD *)a1 += a3;
    }
    a1 += 6;
  }
  return result;
}

//----- (00065DC0) --------------------------------------------------------
unsigned int *sub_65DC0(unsigned int *a1, unsigned int a2, unsigned int a3)
{
  unsigned int *result; // eax

  while ( 1 )
  {
    result = a1;
    if ( (unsigned int)a1 >= a2 )
      break;
    if ( *a1 < a3 )
      *a1 += a3;
    a1 = (unsigned int *)((char *)a1 + 6);
  }
  return result;
}

//----- (00065E00) --------------------------------------------------------
void sub_65E00()
{
  if ( byte_939CC && byte_939CD && word_939D2 && sub_5D7F0(dword_CBFD8) )
  {
    sub_5F529(dword_CBFD8, (unsigned int)&dword_12F030);
    sub_5F398(dword_CBFD8);
  }
}
// 939CC: using guessed type char byte_939CC;
// 939CD: using guessed type char byte_939CD;
// 939D2: using guessed type __int16 word_939D2;
// CBFD8: using guessed type int dword_CBFD8;
// 12F030: using guessed type int dword_12F030;

//----- (00065EB0) --------------------------------------------------------
int sub_65EB0(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  int result; // eax

  dword_12F008 = a1;
  dword_12F018 = a2;
  dword_12F000 = a3;
  dword_12F028 = a4;
  dword_12F024 = a3 + a1;
  result = a4;
  dword_12F010 = a4 + a2;
  return result;
}
// 12F000: using guessed type int dword_12F000;
// 12F008: using guessed type int dword_12F008;
// 12F010: using guessed type int dword_12F010;
// 12F018: using guessed type int dword_12F018;
// 12F024: using guessed type int dword_12F024;
// 12F028: using guessed type int dword_12F028;

//----- (00065F10) --------------------------------------------------------
void sub_65F10(__int16 a1, __int16 a2)
{
  int v2; // edx
  __int16 *v3; // [esp+0h] [ebp-Ch]
  __int16 i; // [esp+4h] [ebp-8h]
  __int16 j; // [esp+4h] [ebp-8h]
  char v6; // [esp+8h] [ebp-4h]

  if ( byte_939E4 && byte_939E5 && a2 <= (int)(unsigned __int16)word_CC1C6 )
  {
    v3 = word_CBFF0;
    for ( i = 0; i < 32; ++i )
    {
      if ( *v3 == a1 && v3[1] == a2 && !sub_651F8(dword_CC140, i) )
      {
        sub_65965(dword_CC140, i);
        break;
      }
      v3 += 2;
    }
    v6 = 0;
    for ( j = 0; j < 32; ++j )
    {
      if ( sub_651F8(dword_CC140, j) )
      {
        v6 = 1;
        break;
      }
    }
    if ( v6 )
    {
      word_CBFF0[2 * j] = a1;
      word_CBFF2[2 * j] = a2;
      word_93A02 = j;
      word_93A0C = 256;
      word_93A00 = 0x7FFF;
      word_CC070[j] = 0x7FFF;
      dword_939F8 = *(_DWORD *)(32 * a2 + dword_CC154 + 26) - 16;
      v2 = *(_DWORD *)(32 * a2 + dword_CC154 + 18);
      //fix word_939F4 = __DS__;
      dword_939F0 = v2;
      dword_CC144 = sub_6535C(dword_CC140, (unsigned int)&dword_939F0);
    }
  }
}
// 939E4: using guessed type char byte_939E4;
// 939E5: using guessed type char byte_939E5;
// 939F0: using guessed type int dword_939F0;
// 939F4: using guessed type __int16 word_939F4;
// 939F8: using guessed type int dword_939F8;
// 93A00: using guessed type __int16 word_93A00;
// 93A02: using guessed type __int16 word_93A02;
// 93A0C: using guessed type __int16 word_93A0C;
// CBFF0: using guessed type __int16 word_CBFF0[];
// CBFF2: using guessed type __int16 word_CBFF2[63];
// CC070: using guessed type __int16 word_CC070[];
// CC140: using guessed type int dword_CC140;
// CC144: using guessed type int dword_CC144;
// CC154: using guessed type int dword_CC154;
// CC1C6: using guessed type __int16 word_CC1C6;

//----- (00066107) --------------------------------------------------------
void sub_66107()
{
  ;
}

//----- (00066118) --------------------------------------------------------
int sub_66118(int a1, int a2, unsigned __int16 a3)
{
  unsigned int i; // [esp+4h] [ebp-4h]

  if ( !dword_A0258[a1] )
    return -1;
  for ( i = 0; ; ++i )
  {
    if ( i >= 0x20 )
      return 10;
    if ( (__int16)__readgsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 52) == a2 )
      break;
  }
  __writegsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 50, a3);
  return 0;
}
// A0258: using guessed type int dword_A0258[5];

//----- (000661A4) --------------------------------------------------------
int sub_661A4(int a1, int a2)
{
  unsigned int i; // [esp+8h] [ebp-4h]

  if ( !dword_A0258[a1] )
    return -1;
  for ( i = 0; i < 0x20; ++i )
    __writegsword(
      *(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 50,
      (__int16)__readgsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 50) * a2 / 0x7FFFu);
  return 0;
}
// A0258: using guessed type int dword_A0258[5];

//----- (0006623A) --------------------------------------------------------
void sub_6623A()
{
  ;
}

//----- (00066250) --------------------------------------------------------
void sub_66250(__int16 a1, __int16 a2, unsigned __int16 a3)
{
  __int16 *v3; // [esp+0h] [ebp-8h]
  __int16 i; // [esp+4h] [ebp-4h]

  if ( byte_939E4 )
  {
    v3 = word_CBFF0;
    for ( i = 0; i < 32; ++i )
    {
      if ( *v3 == a1 && v3[1] == a2 && !sub_651F8(dword_CC140, i) && a3 < 0x81u )
      {
        sub_66118(dword_CC140, i, (a3 << 8) - 1);
        word_CC070[i] = (a3 << 8) - 1;
        return;
      }
      v3 += 2;
    }
  }
}
// 939E4: using guessed type char byte_939E4;
// CBFF0: using guessed type __int16 word_CBFF0[];
// CC070: using guessed type __int16 word_CC070[];
// CC140: using guessed type int dword_CC140;

//----- (00066313) --------------------------------------------------------
void sub_66313()
{
  ;
}

//----- (00066324) --------------------------------------------------------
int sub_66324(int a1)
{
  int v2; // [esp+4h] [ebp-8h]
  unsigned int i; // [esp+8h] [ebp-4h]

  v2 = 0;
  for ( i = 0; i < 0x20; ++i )
  {
    if ( ((__readgsword(*(_DWORD *)&byte_131724[192 * a1 + 6 * i] + 48) >> 8) & 0x80u) != 0 )
      ++v2;
  }
  return v2;
}

//----- (0006637C) --------------------------------------------------------
void sub_6637C()
{
  ;
}

//----- (00066390) --------------------------------------------------------
unsigned int sub_66390(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unsigned int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( a1 >= a2 )
      break;
    if ( *(_DWORD *)a1 >= a3 )
    {
      *(_BYTE *)(a1 + 4) = (int)*(unsigned __int8 *)(a1 + 4) >> 1;
      *(_BYTE *)(a1 + 5) = (int)*(unsigned __int8 *)(a1 + 5) >> 1;
      *(_DWORD *)a1 -= a3;
    }
    a1 += 6;
  }
  return result;
}

//----- (00066410) --------------------------------------------------------
unsigned int *sub_66410(unsigned int *a1, unsigned int a2, unsigned int a3)
{
  unsigned int *result; // eax

  while ( 1 )
  {
    result = a1;
    if ( (unsigned int)a1 >= a2 )
      break;
    if ( *a1 >= a3 )
      *a1 -= a3;
    a1 = (unsigned int *)((char *)a1 + 6);
  }
  return result;
}

//----- (000664AB) --------------------------------------------------------
int sub_664AB(unsigned __int8 *a1, unsigned __int8 **a2, int a3, int a4)
{
  int v4; // edi
  unsigned __int8 *i; // ebx
  unsigned __int8 v6; // al
  unsigned __int8 v8; // cl
  unsigned int v9; // esi
  int v10; // eax
  unsigned int v11; // edx
  unsigned __int8 *v12; // [esp+0h] [ebp-1Ch]
  char v13; // [esp+4h] [ebp-18h]
  unsigned __int8 v14; // [esp+8h] [ebp-14h]

  v4 = a3;
  if ( a2 )
    *a2 = a1;
  for ( i = a1; (IsTable[(unsigned __int8)(*i + 1)] & 2) != 0; ++i )
    ;
  v14 = *i;
  if ( *i == 43 || *i == 45 )
    ++i;
  if ( !a3 )
  {
    if ( *i == 48 && ((v6 = i[1], v6 == 120) || v6 == 88) )
    {
      v4 = 16;
    }
    else if ( *i == 48 )
    {
      v4 = 8;
    }
    else
    {
      v4 = 10;
    }
  }
  if ( v4 >= 2 && v4 <= 36 )
  {
    if ( v4 == 16 && *i == 48 )
    {
      v8 = i[1];
      if ( v8 == 120 || v8 == 88 )
        i += 2;
    }
    v12 = i;
    v9 = 0;
    v13 = 0;
    while ( 1 )
    {
      v10 = sub_66612(*i);
      if ( v10 >= v4 )
        break;
      v11 = v9;
      v9 = v10 + v4 * v9;
      if ( v9 < v11 )
        v13 = 1;
      ++i;
    }
    if ( i == v12 )
      i = a1;
    if ( a2 )
      *a2 = i;
    if ( a4 == 1 && v9 >= 0x80000000 && (v9 != 0x80000000 || v14 != 45) )
      v13 = 1;
    if ( v13 )
    {
      _set_errno(14);
      if ( a4 )
      {
        if ( v14 == 45 )
          return 0x80000000;
        else
          return 0x7FFFFFFF;
      }
      else
      {
        return -1;
      }
    }
    else
    {
        if (v14 == 45)
            return 0;//fix -v9;
      return v9;
    }
  }
  else
  {
    _set_errno(13);
    return 0;
  }
}
// 66C8B: using guessed type _DWORD _set_errno(_DWORD);

//----- (0006660D) --------------------------------------------------------
int sub_6660D(unsigned __int8 *a1, unsigned __int8 **a2, int a3)
{
  return sub_664AB(a1, a2, a3, 1);
}

//----- (00066612) --------------------------------------------------------
int sub_66612(unsigned __int8 a1)
{
  unsigned __int8 v2; // al

  if ( a1 >= 0x30u && a1 <= 0x39u )
    return a1 - 48;
  v2 = tolower(a1);
  if ( v2 >= 0x61u && v2 <= 0x69u )
    return v2 - 87;
  if ( v2 >= 0x6Au && v2 <= 0x72u || v2 >= 0x73u && v2 <= 0x7Au )
    return v2 - 87;
  return 37;
}
// 6B5A3: using guessed type _DWORD tolower(_DWORD);

//----- (0006666C) --------------------------------------------------------
__int16 sub_6666C(__int16 result)
{
  _BOOL1 v1; // zf

  //fix __asm { int     16h; KEYBOARD - GET ENHANCED SHIFT FLAGS (AT model 339,XT2,XT286,PS) }
  byte_12EF71 = (result & 3) != 0;
  if ( (result & 4) != 0 )
    byte_12EF71 |= 2u;
  v1 = (result & 8) == 0;
  if ( (result & 8) != 0 )
  {
    v1 = 0;
    byte_12EF71 |= 4u;
  }
  byte_12EF70 = 0;
  //fix __asm { int     16h; KEYBOARD - CHECK ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS) }
  if ( !v1 )
  {
      //fix __asm { int     16h; KEYBOARD - GET ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS) }
    byte_12EF70 = 16;
  }
  return result;
}
// 12EF70: using guessed type char byte_12EF70;
// 12EF71: using guessed type char byte_12EF71;

//----- (00066CAD) --------------------------------------------------------
void sub_66CAD()
{
  //fix ((void (*)(_DWORD))_GETDS)((unsigned __int16)__DS__);
}
// 66CAD: using guessed type void sub_66CAD();

//----- (00066D24) --------------------------------------------------------
unsigned __int8 sub_66D24(__int16 a1)
{
  unsigned __int8 v1; // al
  unsigned __int8 v2; // ah
  unsigned __int8 v3; // al
  unsigned __int8 result; // al

  if ( dword_A01C4 )
  {
    v1 = __inbyte(0x21u);
    __outbyte(0x21u, v1 | 1);
    __outbyte(0x43u, 0x36u);
    v2 = HIBYTE(a1);
    __outbyte(0x40u, a1);
    __outbyte(0x40u, v2);
    v3 = __inbyte(0x21u);
    result = v3 & 0xFE;
    __outbyte(0x21u, result);
  }
  return result;
}
// A01C4: using guessed type int dword_A01C4;

//----- (00066D6A) --------------------------------------------------------
unsigned __int8 sub_66D6A(int a1, __int16 a2, int a3, __int16 a4)
{
  unsigned __int8 v4; // al
  unsigned __int8 v5; // ah
  unsigned __int8 v6; // al
  unsigned __int8 result; // al

  *(_DWORD *)byte_9F1A8 = a3;
  *(_WORD *)&byte_9F1A8[4] = a4;
  //fix word_9F1B0 = __DS__;
  //fix word_9F1B6 = __DS__;
  if ( dword_A01C4 )
  {
    v4 = __inbyte(0x21u);
    __outbyte(0x21u, v4 | 1);
    //fix __asm { int     21h; DOS - 2+ - GET INTERRUPT VECTOR }
    dword_9F19C = a1;
    LOWORD(dword_9F1A0) = a4;
    //fix __asm { int     21h; DOS - SET INTERRUPT VECTOR }
    __outbyte(0x43u, 0x36u);
    v5 = HIBYTE(a2);
    __outbyte(0x40u, a2);
    __outbyte(0x40u, v5);
    v6 = __inbyte(0x21u);
    result = v6 & 0xFE;
    __outbyte(0x21u, result);
  }
  return result;
}
// 9F19C: using guessed type int dword_9F19C;
// 9F1A0: using guessed type int dword_9F1A0;
// 9F1B0: using guessed type __int16 word_9F1B0;
// 9F1B6: using guessed type __int16 word_9F1B6;
// A01C4: using guessed type int dword_A01C4;

//----- (00066DF5) --------------------------------------------------------
unsigned __int8 sub_66DF5()
{
  unsigned __int8 v0; // al
  unsigned __int8 result; // al

  if ( dword_A01C4 )
  {
    v0 = __inbyte(0x21u);
    result = v0 | 1;
    __outbyte(0x21u, result);
  }
  return result;
}
// A01C4: using guessed type int dword_A01C4;

//----- (00066E21) --------------------------------------------------------
unsigned __int8 sub_66E21()
{
  unsigned __int8 v0; // al
  unsigned __int8 result; // al

  if ( dword_A01C4 )
  {
    v0 = __inbyte(0x21u);
    result = v0 & 0xFE;
    __outbyte(0x21u, result);
  }
  return result;
}
// A01C4: using guessed type int dword_A01C4;

//----- (00066E4D) --------------------------------------------------------
unsigned __int8 sub_66E4D()
{
  unsigned __int8 v0; // al
  unsigned __int8 v1; // al
  unsigned __int8 result; // al

  if ( dword_A01C4 )
  {
    v0 = __inbyte(0x21u);
    __outbyte(0x21u, v0 | 1);
    //fix __asm { int     31h; DPMI Services   ax=func xxxxh }
    __outbyte(0x40u, 0);
    __outbyte(0x40u, 0);
    v1 = __inbyte(0x21u);
    result = v1 & 0xFE;
    __outbyte(0x21u, result);
  }
  return result;
}
// 9F19C: using guessed type int dword_9F19C;
// A01C4: using guessed type int dword_A01C4;

//----- (00066EA2) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int sub_66EA2()
{
  int result; // eax
  int v1; // [esp-8h] [ebp-8h]
  int v2; // [esp-4h] [ebp-4h]
  void *retaddr[2]; // [esp+0h] [ebp+0h] BYREF

  //fix
  result = 0;
  //fix

  if ( dword_A01C4 )
  {
    word_A01C2 = 0;
    return 0;//fix
    /*MK_FP(retaddr[0], retaddr[0])(
             _InterlockedExchange((volatile __int32 *)&retaddr[1], dword_9F1A0),
             v2,
             v1,
             _InterlockedExchange((volatile __int32 *)retaddr, dword_9F19C));*/
  }
  return result;
}
// 66EE2: positive sp value 28 has been found
// 66EE2: variable 'v2' is possibly undefined
// 66EE2: variable 'v1' is possibly undefined
// 9F19C: using guessed type int dword_9F19C;
// 9F1A0: using guessed type int dword_9F1A0;
// A01C2: using guessed type __int16 word_A01C2;
// A01C4: using guessed type int dword_A01C4;

//----- (00066EE5) --------------------------------------------------------
void sub_66EE5()
{
  ;
}

//----- (00066EF6) --------------------------------------------------------
unsigned __int64 sub_66EF6(unsigned int a1, __int16 a2)
{
  unsigned int v3; // [esp+4h] [ebp-4h]

  LOWORD(v3) = a2;
  return __PAIR64__(v3, a1);
}
// 66F12: variable 'v3' is possibly undefined

//----- (00066F1A) --------------------------------------------------------
void sub_66F1A()
{
  ;
}

//----- (00066F2B) --------------------------------------------------------
void sub_66F2B()
{
  ;
}

//----- (00066F3C) --------------------------------------------------------
int sub_66F3C()
{
  int v0; // eax
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // edx
  int v6; // edx
  int v7; // eax
  int v8; // eax
  int v9; // edx
  int v10; // eax
  int v11; // edx
  unsigned __int8 v13; // [esp+0h] [ebp-34h]
  int v14; // [esp+4h] [ebp-30h] BYREF
  __int16 v15; // [esp+8h] [ebp-2Ch]
  int v16; // [esp+Ch] [ebp-28h]
  __int16 v17; // [esp+10h] [ebp-24h]
  _DWORD v18[2]; // [esp+14h] [ebp-20h]
  int v19; // [esp+1Ch] [ebp-18h]
  int v20; // [esp+20h] [ebp-14h]
  int v21; // [esp+24h] [ebp-10h]
  unsigned __int8 i; // [esp+30h] [ebp-4h]
  void *retaddr[2]; // [esp+44h] [ebp+10h]

  if (!dword_9C136[(unsigned __int8)byte_A04D1] || dword_9C116[(unsigned __int8)byte_A04D1])
      return 0;// MK_FP(retaddr[0], retaddr[0])();
  for ( i = 0; ; ++i )
  {
      if (i >= (unsigned int)dword_9C042[(unsigned __int8)byte_A04D1])
          return 0;// MK_FP(retaddr[0], retaddr[0])();
    v0 = ((unsigned __int8)byte_A04D1 << 7) + 4 * i;
    ++*(int *)((char *)dword_9BBF2 + v0);
    v1 = 192 * (unsigned __int8)byte_A04D1 + 6 * i;
    if ( (*(_DWORD *)&byte_9B1F2[v1] || *(_WORD *)&byte_9B1F2[v1 + 4])
      && dword_9B7F2[32 * (unsigned __int8)byte_A04D1 + i] <= (unsigned int)dword_9BBF2[32 * (unsigned __int8)byte_A04D1
                                                                                      + i] )
    {
      break;
    }
LABEL_31:
    ;
  }
  while ( 1 )
  {
    if ( __readgsbyte(*(_DWORD *)&byte_9B1F2[192 * (unsigned __int8)byte_A04D1 + 6 * i]) >= 0xF0u )
      v2 = (unsigned __int8)byte_9C166[__readgsbyte(*(_DWORD *)&byte_9B1F2[192 * (unsigned __int8)byte_A04D1 + 6 * i]) & 0xF];
    else
      v2 = (unsigned __int8)byte_9C156[(int)__readgsbyte(*(_DWORD *)&byte_9B1F2[192 * (unsigned __int8)byte_A04D1
                                                                              + 6 * i]) >> 4];
    v21 = v2;
    if ( __readgsbyte(*(_DWORD *)&byte_9B1F2[192 * (unsigned __int8)byte_A04D1 + 6 * i]) != 0xFF )
    {
      v7 = 192 * (unsigned __int8)byte_A04D1 + 6 * i;
      sub_5DF83(
        (unsigned __int8)byte_A04D1,
        *(_DWORD *)&byte_9B1F2[v7],
        *(_WORD *)&byte_9B1F2[v7 + 4],
        __readgsdword(*(int *)((char *)&dword_9BFF2 + 6 * (unsigned __int8)byte_A04D1) + 4 * i),
        v21);
      goto LABEL_28;
    }
    v13 = __readgsbyte(*(_DWORD *)&byte_9B1F2[192 * (unsigned __int8)byte_A04D1 + 6 * i] + 1);
    if ( v13 < 0x2Fu )
      goto LABEL_28;
    if ( v13 > 0x2Fu )
    {
      if ( v13 == 81 )
        v21 = 5;
      goto LABEL_28;
    }
    v3 = 192 * (unsigned __int8)byte_A04D1 + 6 * i;
    *(_WORD *)&byte_9B1F2[v3 + 4] = 0;
    *(_DWORD *)&byte_9B1F2[v3] = 0;
    v4 = (unsigned __int8)byte_A04D1;
    if ( !--dword_9C022[v4] )
      break;
    v21 = 3;
LABEL_28:
    dword_9BBF2[32 * (unsigned __int8)byte_A04D1 + i] = 0;
    v8 = 192 * (unsigned __int8)byte_A04D1 + 6 * i;
    if ( *(_DWORD *)&byte_9B1F2[v8] || *(_WORD *)&byte_9B1F2[v8 + 4] )
    {
      v9 = 192 * (unsigned __int8)byte_A04D1 + 6 * i;
      LOWORD(v20) = *(_WORD *)&byte_9B1F2[v9 + 4];
      v19 = v21 + *(_DWORD *)&byte_9B1F2[v9];
      *(_WORD *)&byte_9B1F2[v9 + 4] = v20;
      *(_DWORD *)&byte_9B1F2[v9] = v19;
      v10 = 192 * (unsigned __int8)byte_A04D1 + 6 * i;
      v21 = sub_5F7C7(
              *(_DWORD *)&byte_9B1F2[v10],
              *(unsigned __int16 *)&byte_9B1F2[v10 + 4],
              (unsigned int)&dword_9B7F2[32 * (unsigned __int8)byte_A04D1 + i]);
      v11 = 6 * i + 192 * (unsigned __int8)byte_A04D1;
      LOWORD(v20) = *(_WORD *)&byte_9B1F2[v11 + 4];
      v19 = v21 + *(_DWORD *)&byte_9B1F2[v11];
      *(_WORD *)&byte_9B1F2[v11 + 4] = v20;
      *(_DWORD *)&byte_9B1F2[v11] = v19;
      if ( !dword_9B7F2[32 * (unsigned __int8)byte_A04D1 + i] )
        continue;
    }
    goto LABEL_31;
  }
  dword_9C136[(unsigned __int8)byte_A04D1] = 0;
  sub_5E9C1((unsigned __int8)byte_A04D1);
  if ( dword_9C1A6[(unsigned __int8)byte_A04D1] != -1 )
    sub_5DC91(dword_9C1A6[(unsigned __int8)byte_A04D1]);
  byte_A04C1[dword_9C1A6[(unsigned __int8)byte_A04D1]] = -1;
  dword_9C1A6[(unsigned __int8)byte_A04D1] = -1;
  v5 = *(_DWORD *)&byte_9C176[6 * (unsigned __int8)byte_A04D1];
  LOWORD(v18[1]) = __readgsword(v5 + 772);
  v18[0] = __readgsdword(v5 + 768);
  v6 = 6 * (unsigned __int8)byte_A04D1;
  v15 = *(_WORD *)&byte_9C176[v6 + 4];
  v14 = *(_DWORD *)&byte_9C176[v6];
  v17 = v18[1];
  v16 = v18[0];
  *(_WORD *)&byte_9C176[v6 + 4] = 0;
  *(_DWORD *)&byte_9C176[v6] = 0;
  sub_5F529((unsigned __int8)byte_A04D1, (unsigned int)&v14);
  if (v18[0] || LOWORD(v18[1]))
      ;//fix MK_FP(v18[1], v18[0])((unsigned __int8)byte_A04D1);
  return 0;//fix MK_FP(retaddr[0], retaddr[0])();
}
// 9B7F2: using guessed type int dword_9B7F2[256];
// 9BBF2: using guessed type int dword_9BBF2[256];
// 9BFF2: using guessed type int dword_9BFF2;
// 9C022: using guessed type int dword_9C022[8];
// 9C042: using guessed type int dword_9C042[8];
// 9C116: using guessed type int dword_9C116[8];
// 9C136: using guessed type int dword_9C136[8];
// 9C1A6: using guessed type int dword_9C1A6[8];
// A04D1: using guessed type char byte_A04D1;

//----- (00067464) --------------------------------------------------------
void sub_67464()
{
  ;
}

//----- (00067475) --------------------------------------------------------
void sub_67475()
{
  ;
}

//----- (00067486) --------------------------------------------------------
bool sub_67486(int a1)
{
  return dword_9B18E[a1] == 0;
}
// 9B18E: using guessed type int dword_9B18E[5];

//----- (000674B9) --------------------------------------------------------
void sub_674B9()
{
  ;
}

//----- (000674CD) --------------------------------------------------------
__int16 sub_674CD()
{
  __int16 result; // ax

  result = 1536;
  //fix __asm { int     31h; DPMI Services   ax=func xxxxh }
  return result;
}

//----- (000674FA) --------------------------------------------------------
__int16 sub_674FA()
{
  __int16 result; // ax

  result = 1536;
  //fix __asm { int     31h; DPMI Services   ax=func xxxxh }
  return result;
}

//----- (00067527) --------------------------------------------------------
void sub_67527(int a1, int a2, __int16 a3)
{
  int v5; // ecx

  v5 = 32;
  do
  {
    *(_DWORD *)a1 = a2;
    *(_WORD *)(a1 + 4) = a3;
    a2 += 108;
    a1 += 6;
    --v5;
  }
  while ( v5 );
}

//----- (00067557) --------------------------------------------------------
int sub_67557(__int16 a1, int a2, int a3)
{
  int v3; // ecx

  //fix __asm { int     31h; DPMI Services   ax=func xxxxh }
  v3 = a2 << 16;
  LOWORD(v3) = a1;
  return v3 + a3;
}

//----- (00067582) --------------------------------------------------------
int sub_67582()
{
  __asm
  {
      //fix int     31h; DPMI Services   ax=func xxxxh
    //fix int     31h; DPMI Services   ax=func xxxxh
    //fix int     31h; DPMI Services   ax=func xxxxh
  }
  return 0;
}

//----- (000675C8) --------------------------------------------------------
__int16 sub_675C8(int a1, _DWORD *a2)
{
  __int16 result; // ax

  //fix __asm { int     31h; DPMI Services   ax=func xxxxh }
  *a2 = 4096;
  //fix __asm { int     31h; DPMI Services   ax=func xxxxh }
  result = 1536;
  //fix __asm { int     31h; DPMI Services   ax=func xxxxh }
  return result;
}

//----- (0006765C) --------------------------------------------------------
int sub_6765C(
        const void *a1,
        int (*a2)(_DWORD),
        char a3,
        __int16 a4,
        char *a5,
        __int16 a6)
{
  int result; // eax

  result = a2((uint32)a2);
  qmemcpy(a5, a1, 0x6Au);
  //fix *MK_FP(a6, a5 + 52) = a4;
  //fix *MK_FP(a6, a5 + 60) = a4;
  //fix *MK_FP(a6, a5 + 68) = a4;
  //fix *MK_FP(a6, a5 + 76) = a4;
  return result;
}

//----- (000676B0) --------------------------------------------------------
int sub_676B0(int a1, int (*a2)(_DWORD), char a3, __int16 a4, int a5, __int16 a6)
{
  int result; // eax

  result = a2((uint32)a2);
  //fix *MK_FP(a6, a5) = a1;
  //fix *MK_FP(a6, a5 + 4) = a4;
  return result;
}

//----- (000676E5) --------------------------------------------------------
int sub_676E5(int (*a1)(_DWORD))
{
  return a1((uint32)a1);
}

//----- (00067710) --------------------------------------------------------
int sub_67710(int (*a1)(_DWORD))
{
  return a1((uint32)a1);
}

//----- (0006773B) --------------------------------------------------------
__int16 sub_6773B(int (*a1)(_DWORD))
{
  __int16 v1; // cx
  __int16 result; // ax

  //fix
  v1 = 0;
  //fix

  LOWORD(dword_A06DC) = a1((uint32)a1);
  LOWORD(dword_A06E4) = SHIBYTE(v1);
  result = (char)v1;
  LOWORD(dword_A06E0) = (char)v1;
  return result;
}
// 67765: variable 'v1' is possibly undefined
// A06DC: using guessed type int dword_A06DC;
// A06E0: using guessed type int dword_A06E0;
// A06E4: using guessed type int dword_A06E4;

//----- (00067780) --------------------------------------------------------
int sub_67780(int (*a1)(_DWORD))
{
  return a1((uint32)a1);
}

//----- (000677B8) --------------------------------------------------------
int sub_677B8(int (*a1)(_DWORD))
{
  return a1((uint32)a1);
}

//----- (000677E3) --------------------------------------------------------
__int16 sub_677E3fix(
        int a1,
        void (*a2)(_DWORD),
        char a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10)
{
  __int16 result; // ax

  //fix
  result = 0;
  //fix

  a2((uint32)a2);
  _disable();
  //fix
  /*
  *(_DWORD *)a10 = (char *)a2 + a5;
  *(_DWORD *)(a10 + 8) = (char *)a2 + a7;
  *(_DWORD *)(a10 + 16) = (char *)a2 + a1;
  *(_WORD *)(a10 + 4) = __CS__;
  result = __DS__;
  *(_WORD *)(a10 + 12) = __DS__;
  *(_WORD *)(a10 + 20) = __DS__;
  */
  _enable();
  return result;
}
// 677E3: using guessed type _DWORD arg_C;

//----- (00067845) --------------------------------------------------------
int sub_67845(int (*a1)(_DWORD))
{
  return a1((uint32)a1);
}

//----- (0006787E) --------------------------------------------------------
int sub_6787E(int (*a1)(_DWORD))
{
  return a1((uint32)a1);
}

//----- (000678AF) --------------------------------------------------------
int sub_678AF(int (*a1)(_DWORD))
{
  return a1((uint32)a1);
}

//----- (000678DE) --------------------------------------------------------
int sub_678DE(int (*a1)(_DWORD))
{
  return a1((uint32)a1);
}

//----- (0006790D) --------------------------------------------------------
__int16 sub_6790D()
{
  __int16 result; // ax

  result = 5632;
  //fix __asm { int     2Fh; - Multiplex - MS WINDOWS - ENHANCED WINDOWS INSTALLATION CHECK }
  return result;
}

//----- (00067944) --------------------------------------------------------
__int16 sub_67944()
{
  __int16 result; // ax

  result = 5632;
  //fix __asm { int     2Fh; - Multiplex - MS WINDOWS - ENHANCED WINDOWS INSTALLATION CHECK }
  return result;
}

//----- (0006797C) --------------------------------------------------------
void sub_6797C()
{
  ;
}

//----- (0006798D) --------------------------------------------------------
int *sub_6798D()
{
  return &dword_131522;
}
// 131522: using guessed type int dword_131522;

//----- (000679AE) --------------------------------------------------------
int sub_679AE(int a1, unsigned __int16 a2, int a3, int a4)
{
  void *retaddr[2]; // [esp+10h] [ebp+Ch]

  //fix MK_FP(*((_WORD *)&byte_9C22E + 2), byte_9C22E)(a1, a2, a3, a4);
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}
// 9C22E: using guessed type int (*byte_9C22E)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000679DE) --------------------------------------------------------
int sub_679DE()
{
  void *retaddr[2]; // [esp+10h] [ebp+Ch]

  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}

//----- (000679F7) --------------------------------------------------------
int sub_679F7()
{
  void *retaddr[2]; // [esp+10h] [ebp+Ch]

  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}

//----- (00067A10) --------------------------------------------------------
int sub_67A10()
{
  void *retaddr[2]; // [esp+10h] [ebp+Ch]

  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}

//----- (00067A29) --------------------------------------------------------
int sub_67A29(int (*a1)(_DWORD, _DWORD, _DWORD, _DWORD), __int16 a2)
{
  void *retaddr[2]; // [esp+10h] [ebp+Ch]

  *((_WORD *)&byte_9C22E + 2) = a2;
  byte_9C22E = a1;
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}
// 9C22E: using guessed type int (*byte_9C22E)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00067A53) --------------------------------------------------------
void sub_67A53()
{
  ;
}

//----- (00067A64) --------------------------------------------------------
void sub_67A64()
{
  ;
}

//----- (00067A75) --------------------------------------------------------
int *sub_67A75()
{
  return &dword_131504;
}
// 131504: using guessed type int dword_131504;

//----- (00067A96) --------------------------------------------------------
int sub_67A96(unsigned int a1, int a2, int a3, int a4)
{
  int v4; // eax
  char *v5; // eoff
  int v7; // [esp+Ch] [ebp-4h]
  int v8; // [esp+Ch] [ebp-4h]
  int v9; // [esp+Ch] [ebp-4h]
  int v10; // [esp+Ch] [ebp-4h]
  void *retaddr[2]; // [esp+1Ch] [ebp+Ch]

  if ( (__readgsbyte(a1) & 0xF0) == 0xB0 && __readgsbyte(a1 + 1) == 123 )
  {
    while ( dword_9C9F0[a4] )
    {
      v7 = sub_682CB(a4);
      sub_65965(dword_9D922[a4], v7 + 1);
    }
  }
  if ( (__readgsbyte(a1) & 0xF0) == 0x90 && *(_DWORD *)&byte_9CA04[768 * a4 + 6 * __readgsbyte(a1 + 1)] )
  {
    if ( __readgsbyte(a1 + 2) )
    {
      if ( __readgsword(*(_DWORD *)&byte_9CA04[768 * a4 + 6 * __readgsbyte(a1 + 1)] + 26) != 0x8000 )
      {
        v8 = sub_68491(a4, __readgsbyte(a1 + 1));
        if ( v8 != -1 )
          sub_65965(dword_9D922[a4], v8 + 1);
      }
      if ( dword_9C9F0[a4] >= (unsigned int)dword_9C9DC[a4] )
      {
        v9 = sub_682CB(a4);
        sub_65965(dword_9D922[a4], v9 + 1);
      }
      v4 = 768 * a4 + 6 * __readgsbyte(a1 + 1);
      __writegsword(
        *(_DWORD *)&byte_9CA04[v4] + 18,
        sub_68207(a4, *(_DWORD *)&byte_9CA04[v4], *(_WORD *)&byte_9CA04[v4 + 4]) + 1);
      if ( dword_9D972[a4] )
      {
        __writegsword(
          *(_DWORD *)&byte_9CA04[768 * a4 + 6 * __readgsbyte(a1 + 1)] + 16,
          ((unsigned __int8)byte_9ECAD * (unsigned int)__readgsbyte(a1 + 2)) >> 7);
        v5 = &byte_9CA04[768 * a4 + 6 * __readgsbyte(a1 + 1)];
        __writegsword(*(_DWORD *)v5 + 16, __readgsword(*(_DWORD *)v5 + 16) << 8);
      }
      sub_6535C(dword_9D922[a4], *(_DWORD *)&byte_9CA04[768 * a4 + 6 * __readgsbyte(a1 + 1)]);
      __writegsword(*(_DWORD *)&byte_9CA04[768 * a4 + 6 * __readgsbyte(a1 + 1)] + 18, __readgsbyte(a1 + 1));
    }
    else if ( __readgsword(*(_DWORD *)&byte_9CA04[768 * a4 + 6 * __readgsbyte(a1 + 1)] + 26) != 0x8000 )
    {
      v10 = sub_68491(a4, __readgsbyte(a1 + 1));
      if ( v10 != -1 )
        sub_65965(dword_9D922[a4], v10 + 1);
    }
  }
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}
// 9C9DC: using guessed type int dword_9C9DC[5];
// 9C9F0: using guessed type int dword_9C9F0[5];
// 9D922: using guessed type int dword_9D922[5];
// 9D972: using guessed type int dword_9D972[5];
// 9ECAD: using guessed type char byte_9ECAD;
// 67A96: using guessed type unsigned int arg_0;

//----- (00067D9D) --------------------------------------------------------
int sub_67D9D(int a1, int a2, unsigned int a3, int a4, int a5)
{
  unsigned int v6; // eax
  int v7; // [esp+14h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-8h] BYREF
  unsigned int i; // [esp+20h] [ebp-4h]
  void *retaddr[2]; // [esp+30h] [ebp+Ch]

  for ( i = 0; i < 5; ++i )
  {
    if ( dword_1315F8[16 * i] == __readgsdword(a3) )
    {
      dword_9D922[a5] = i;
      break;
    }
  }
  if ( i == 5 )
  {
    dword_9D95E[a5] = 1;
    v7 = sub_64846(
           a1,
           a2,
           __readgsdword(a3),
           __readgsdword(a3 + 28),
           __readgsword(a3 + 32),
           __readgsdword(a3 + 20),
           __readgsword(a3 + 24),
           (unsigned int)&v8);
    if (v7)
        0;//fix return MK_FP(retaddr[0], retaddr[0])(v7);
    dword_9D922[a5] = v8;
    v6 = __readgsdword(a3 + 20);
    v7 = sub_5D97B(__readgsdword(a3 + 4), __readgsdword(v6 + 28), __readgsword(v6 + 32), (unsigned int)&dword_9D94A[a5]);
    if (v7)
        return 0;//fix MK_FP(retaddr[0], retaddr[0])(v7);
    dword_9D936[a5] = 1;
  }
  else
  {
    dword_9D95E[a5] = 0;
  }
  dword_9D972[a5] = __readgsdword(a3 + 16);
  sub_68180(a5, __readgsdword(a3 + 12));
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}
// 9D922: using guessed type int dword_9D922[5];
// 9D936: using guessed type int dword_9D936[5];
// 9D94A: using guessed type int dword_9D94A[5];
// 9D95E: using guessed type int dword_9D95E[5];
// 9D972: using guessed type int dword_9D972[5];
// 1315F8: using guessed type int dword_1315F8[];

//----- (00067F1C) --------------------------------------------------------
int sub_67F1C(int a1, int a2, int a3)
{
  void *retaddr[2]; // [esp+10h] [ebp+Ch]

  if ( dword_9D936[a3] )
  {
    dword_9D936[a3] = 0;
    if ( dword_9D95E[a3] )
    {
      sub_64F78(dword_9D922[a3], 1, 1);
      sub_5DC91(dword_9D94A[a3]);
    }
  }
  sub_681F6();
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}
// 9D922: using guessed type int dword_9D922[5];
// 9D936: using guessed type int dword_9D936[5];
// 9D94A: using guessed type int dword_9D94A[5];
// 9D95E: using guessed type int dword_9D95E[5];

//----- (00067F9A) --------------------------------------------------------
int sub_67F9A()
{
  void *retaddr[2]; // [esp+10h] [ebp+Ch]

  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}

//----- (00067FB3) --------------------------------------------------------
int sub_67FB3(int a1, __int16 a2, int a3, int a4)
{
  int v4; // edx
  int v5; // eax
  unsigned __int64 v7; // rax
  int v8; // ebx
  unsigned __int64 v9; // rax
  unsigned int v10; // ebx
  unsigned int i; // [esp+4h] [ebp-Ch]
  int v12; // [esp+8h] [ebp-8h]
  int j; // [esp+Ch] [ebp-4h]
  unsigned int v14; // [esp+Ch] [ebp-4h]
  void *retaddr[2]; // [esp+1Ch] [ebp+Ch]

  v4 = 6 * a4;
  *(_WORD *)&byte_9D904[v4 + 4] = a2;
  *(_DWORD *)&byte_9D904[v4] = a1;
  for ( i = 0; i < 0x80; ++i )
  {
    v5 = 768 * a4 + 6 * i;
    *(_WORD *)&byte_9CA04[v5 + 4] = 0;
    *(_DWORD *)&byte_9CA04[v5] = 0;
  }
  for ( j = 0; byte_9D986[j]; ++j )
  {
      if (byte_9D986[j] != __readgsbyte(j + a1))
          return 0;//fix MK_FP(retaddr[0], retaddr[0])(14);
  }
  v14 = 40;
  do
  {
    v12 = (__int16)__readgsword(sub_66EF6(v14 + a1, a2) + 18);
    v7 = sub_66EF6(v14 + a1, a2);
    v8 = v7;
    LODWORD(v7) = 6 * v12 + 768 * a4;
    *(_WORD *)&byte_9CA04[v7 + 4] = WORD2(v7);
    *(_DWORD *)&byte_9CA04[v7] = v8;
    v9 = sub_66EF6(v14 + a1 + 84, a2);
    v10 = v9;
    LODWORD(v9) = *(_DWORD *)&byte_9CA04[768 * a4 + 6 * v12];
    __writegsword(v9 + 4, WORD2(v9));
    __writegsdword(v9, v10);
    LODWORD(v9) = *(_DWORD *)&byte_9CA04[768 * a4 + 6 * v12];
    //fix __writegsword(v9 + 24, __CS__);
    __writegsdword(v9 + 20, (unsigned int)sub_6813F);
    v14 += __readgsdword(*(_DWORD *)&byte_9CA04[768 * a4 + 6 * v12] + 8) + 84;
  }
  while ( v14 < __readgsdword(*(_DWORD *)&byte_9D904[6 * a4] + 36) );
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}

//----- (0006813F) --------------------------------------------------------
int sub_6813F(int a1, int a2, int a3)
{
  int v3; // eax
  void *retaddr[2]; // [esp+Ch] [ebp+Ch]

  v3 = sub_68365(a1, a3 - 1);
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(v3);
}

//----- (0006815E) --------------------------------------------------------
void sub_6815E()
{
  ;
}

//----- (0006816F) --------------------------------------------------------
void sub_6816F()
{
  ;
}

//----- (00068180) --------------------------------------------------------
int sub_68180(int a1, int a2)
{
  int v2; // eax
  int result; // eax
  unsigned int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 0x20; ++i )
  {
    v2 = 384 * a1 + 12 * i;
    *(__int16 *)((char *)&word_9C23C + v2) = 0;
    *(int *)((char *)&dword_9C238 + v2) = 0;
  }
  dword_9C9B4[a1] = 31;
  dword_9C9C8[a1] = 0;
  result = a2;
  dword_9C9DC[a1] = a2;
  return result;
}
// 9C238: using guessed type int dword_9C238;
// 9C23C: using guessed type __int16 word_9C23C;
// 9C9B4: using guessed type int dword_9C9B4[5];
// 9C9C8: using guessed type int dword_9C9C8[5];
// 9C9DC: using guessed type int dword_9C9DC[5];

//----- (000681F6) --------------------------------------------------------
void sub_681F6()
{
  ;
}

//----- (00068207) --------------------------------------------------------
int sub_68207(int a1, int a2, __int16 a3)
{
  int v3; // edx
  int v6; // [esp+4h] [ebp-4h]

  if ( dword_9C9F0[a1] >= (unsigned int)dword_9C9DC[a1] )
    return -1;
  if ( dword_9C9B4[a1] == 31 )
    dword_9C9B4[a1] = 0;
  else
    ++dword_9C9B4[a1];
  v6 = dword_9C9B4[a1];
  dword_9C234[96 * a1 + 3 * v6] = (__int16)__readgsword(a2 + 18);
  v3 = 384 * a1 + 12 * v6;
  *(__int16 *)((char *)&word_9C23C + v3) = a3;
  *(int *)((char *)&dword_9C238 + v3) = a2;
  ++dword_9C9F0[a1];
  return v6;
}
// 9C234: using guessed type int dword_9C234[];
// 9C238: using guessed type int dword_9C238;
// 9C23C: using guessed type __int16 word_9C23C;
// 9C9B4: using guessed type int dword_9C9B4[5];
// 9C9DC: using guessed type int dword_9C9DC[5];
// 9C9F0: using guessed type int dword_9C9F0[5];

//----- (000682CB) --------------------------------------------------------
int sub_682CB(int a1)
{
  int v1; // eax
  int v4; // [esp+4h] [ebp-4h]

  if ( !dword_9C9F0[a1] )
    return -1;
  v4 = dword_9C9C8[a1];
  v1 = 384 * a1 + 12 * v4;
  *(__int16 *)((char *)&word_9C23C + v1) = 0;
  *(int *)((char *)&dword_9C238 + v1) = 0;
  if ( dword_9C9C8[a1] == 31 )
    dword_9C9C8[a1] = 0;
  else
    ++dword_9C9C8[a1];
  --dword_9C9F0[a1];
  return v4;
}
// 9C238: using guessed type int dword_9C238;
// 9C23C: using guessed type __int16 word_9C23C;
// 9C9C8: using guessed type int dword_9C9C8[5];
// 9C9F0: using guessed type int dword_9C9F0[5];

//----- (00068365) --------------------------------------------------------
int sub_68365(int a1, int a2)
{
  int v2; // edx
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  int v8; // [esp+4h] [ebp-4h]

  if ( !dword_9C9F0[a1] )
    return -1;
  while ( a2 != dword_9C9C8[a1] )
  {
    if ( a2 )
      v8 = a2 - 1;
    else
      v8 = 31;
    v2 = 384 * a1 + 12 * v8;
    v3 = 384 * a1 + 12 * a2;
    v4 = *(int *)((char *)&dword_9C238 + v2);
    *(__int16 *)((char *)&word_9C23C + v3) = *(__int16 *)((char *)&word_9C23C + v2);
    *(int *)((char *)&dword_9C238 + v3) = v4;
    *(int *)((char *)dword_9C234 + v3) = *(int *)((char *)dword_9C234 + v2);
    if ( a2 )
      --a2;
    else
      a2 = 31;
  }
  v5 = 384 * a1 + 12 * a2;
  *(__int16 *)((char *)&word_9C23C + v5) = 0;
  *(int *)((char *)&dword_9C238 + v5) = 0;
  if ( (unsigned int)dword_9C9C8[a1] >= 0x1F )
    dword_9C9C8[a1] = 0;
  else
    ++dword_9C9C8[a1];
  --dword_9C9F0[a1];
  return 0;
}
// 9C234: using guessed type int dword_9C234[];
// 9C238: using guessed type int dword_9C238;
// 9C23C: using guessed type __int16 word_9C23C;
// 9C9C8: using guessed type int dword_9C9C8[5];
// 9C9F0: using guessed type int dword_9C9F0[5];

//----- (00068491) --------------------------------------------------------
int sub_68491(int a1, int a2)
{
  int v2; // edx
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  unsigned int v8; // [esp+4h] [ebp-Ch]
  int v9; // [esp+8h] [ebp-8h]
  unsigned int i; // [esp+Ch] [ebp-4h]

  if ( !dword_9C9F0[a1] )
    return -1;
  for ( i = 0; i < 0x21 && dword_9C234[96 * a1 + 3 * i] != a2; ++i )
    ;
  if ( i == 32 )
    return -1;
  v8 = i;
  while ( i != dword_9C9C8[a1] )
  {
    if ( i )
      v9 = i - 1;
    else
      v9 = 31;
    v2 = 384 * a1 + 12 * v9;
    v3 = 384 * a1 + 12 * i;
    v4 = *(int *)((char *)&dword_9C238 + v2);
    *(__int16 *)((char *)&word_9C23C + v3) = *(__int16 *)((char *)&word_9C23C + v2);
    *(int *)((char *)&dword_9C238 + v3) = v4;
    *(int *)((char *)dword_9C234 + v3) = *(int *)((char *)dword_9C234 + v2);
    if ( i )
      --i;
    else
      i = 31;
  }
  v5 = 384 * a1 + 12 * i;
  *(__int16 *)((char *)&word_9C23C + v5) = 0;
  *(int *)((char *)&dword_9C238 + v5) = 0;
  if ( (unsigned int)dword_9C9C8[a1] >= 0x1F )
    dword_9C9C8[a1] = 0;
  else
    ++dword_9C9C8[a1];
  --dword_9C9F0[a1];
  return v8;
}
// 9C234: using guessed type int dword_9C234[];
// 9C238: using guessed type int dword_9C238;
// 9C23C: using guessed type __int16 word_9C23C;
// 9C9C8: using guessed type int dword_9C9C8[5];
// 9C9F0: using guessed type int dword_9C9F0[5];

//----- (00068600) --------------------------------------------------------
void sub_68600()
{
  ;
}

//----- (00068611) --------------------------------------------------------
void sub_68611()
{
  ;
}

//----- (00068622) --------------------------------------------------------
int sub_68622(
        __int16 a1,
        int a2,
        unsigned int a3,
        unsigned int a4,
        int *a5,
        unsigned int a6)
{
  int v7; // [esp+0h] [ebp-30h]
  unsigned __int16 v8; // [esp+4h] [ebp-2Ch]
  int v10; // [esp+14h] [ebp-1Ch]
  unsigned int v11; // [esp+18h] [ebp-18h]
  int v12; // [esp+1Ch] [ebp-14h]
  int v13; // [esp+28h] [ebp-8h]
  int v14; // [esp+2Ch] [ebp-4h]

  v12 = 0;
  v11 = 0;
  if ( a4 > 5 )
    return 10;
  if ( dword_9B18E[a4] )
    return 9;
  if ( a3 < 0xA000 || a3 > 0xA200 )
    return 6;
  strcpy(&unk_9EE07, &unk_9ED08);
  strcat(&unk_9EE07, aHmimdrv386);
  v14 = open((uint32)&unk_9EE07, 512);
  if ( v14 != -1 )
  {
    read(v14, (uint32)&unk_9C1D2, 44);
    while ( 1 )
    {
      if ( v11 > dword_9C1F2 || v12 )
      {
        close(v14);
        dword_9B1A2[a4] = dword_9C226;
        dword_9B18E[a4] = 1;
        __writegsword(a6 + 4, v8);
        __writegsdword(a6, v7);
        return 0;
      }
      read(v14, (uint32)&unk_9C1FE, 44);
      v13 = dword_9C222;
      if ( dword_9C226 == a3 )
      {
        v12 = 1;
        v10 = (int)malloc(dword_9C222);
        if ( !v10 )
          return 5;
        sub_67557(a1, a2, v10);
        v8 = a1;
        v7 = sub_67582();
        read(v14, v10, v13);
        sub_674CD();
        a2 = (int)a5;
        *a5 = v10;
      }
      else
      {
        lseek(v14, dword_9C222, 1);
      }
      ++v11;
    }
  }
  return 15;
}
// 687F5: variable 'v8' is possibly undefined
// 68801: variable 'v7' is possibly undefined
// 6691E: using guessed type _DWORD close(_DWORD);
// 6692C: using guessed type _DWORD read(_DWORD, _DWORD, _DWORD);
// 6B992: using guessed type _DWORD lseek(_DWORD, _DWORD, char);
// 6CB61: using guessed type _DWORD malloc(_DWORD);
// 6DD0E: using guessed type _DWORD strcpy(_DWORD, _DWORD);
// 6DD33: using guessed type _DWORD strcat(_DWORD, _DWORD);
// 9B18E: using guessed type int dword_9B18E[5];
// 9B1A2: using guessed type int dword_9B1A2[5];
// 9C1F2: using guessed type int dword_9C1F2;
// 9C222: using guessed type int dword_9C222;
// 9C226: using guessed type int dword_9C226;

//----- (00068813) --------------------------------------------------------
int sub_68813(unsigned int a1)
{
  if ( a1 > 5 )
    return 10;
  if ( !dword_9B18E[a1] )
    return 10;
  dword_9B18E[a1] = 0;
  return 0;
}
// 9B18E: using guessed type int dword_9B18E[5];

//----- (0006887D) --------------------------------------------------------
void sub_6887D()
{
  ;
}

//----- (0006888E) --------------------------------------------------------
void sub_6888E()
{
  ;
}

//----- (000688F5) --------------------------------------------------------
void sub_688F5()
{
  ;
}

//----- (00068906) --------------------------------------------------------
void sub_68906()
{
  ;
}

//----- (000689D1) --------------------------------------------------------
void sub_689D1()
{
  ;
}

//----- (000689E2) --------------------------------------------------------
void sub_689E2()
{
  ;
}

//----- (000689F3) --------------------------------------------------------
int *sub_689F3()
{
  return &dword_1314C8;
}
// 1314C8: using guessed type int dword_1314C8;

//----- (00068A14) --------------------------------------------------------
int sub_68A14(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // eax
  unsigned __int8 v6; // [esp+0h] [ebp-8h]
  void *retaddr[2]; // [esp+14h] [ebp+Ch]

  v6 = __readgsbyte(a4) & 0xF0;
  if ( v6 >= 0xB0u )
  {
    if ( v6 <= 0xB0u )
    {
      sub_6FA53(__readgsbyte(a4 + 2), __readgsbyte(a4 + 1), __readgsbyte(a4) & 0xF);
    }
    else if ( v6 < 0xD0u )
    {
      if ( v6 == 0xC0 )
        sub_6FC44(__readgsbyte(a4 + 1), __readgsbyte(a4) & 0xF);
    }
    else if ( v6 <= 0xD0u )
    {
      sub_6FDA4(__readgsbyte(a4 + 2), __readgsbyte(a4 + 1), __readgsbyte(a4) & 0xF);
    }
    else if ( v6 == 0xE0 )
    {
      sub_6FDEC(__readgsbyte(a4 + 2), __readgsbyte(a4 + 1), __readgsbyte(a4) & 0xF);
    }
    return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
  }
  if ( v6 < 0x90u )
  {
      if (v6 != 0x80)
          return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
LABEL_14:
    sub_6F3B3(__readgsbyte(a4 + 2), __readgsbyte(a4 + 1), __readgsbyte(a4) & 0xF);
    return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
  }
  if ( v6 <= 0x90u )
  {
    if ( __readgsbyte(a4 + 2) )
    {
      v4 = __readgsbyte(a4 + 2);
      sub_6F4CB(v4, a1, a3, a2, (unsigned __int8)v4, __readgsbyte(a4 + 1), __readgsbyte(a4) & 0xF);
      return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
    }
    goto LABEL_14;
  }
  if ( v6 == 0xA0 )
    sub_6FDAC(__readgsbyte(a4 + 1), __readgsbyte(a4) & 0xF);
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}

//----- (00068BDA) --------------------------------------------------------
int sub_68BDA(int a1, int a2, int a3, __int16 a4)
{
  void *retaddr[2]; // [esp+10h] [ebp+Ch]

  sub_70044(a4);
  sub_70AA0();
  dword_A1F24 = (int)&unk_A1F48;
  dword_A1F28 = (int)&off_A2150;
  dword_A1F2C = (int)&unk_A22BC;
  dword_A1F30 = (int)&off_A282F;
  dword_A1F34 = (int)&off_A2995;
  dword_A1F38 = (int)&unk_A2F5F;
  dword_A1F3C = (int)&unk_A59DD;
  sub_6E5B2();
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}
// A1F24: using guessed type int dword_A1F24;
// A1F28: using guessed type int dword_A1F28;
// A1F2C: using guessed type int dword_A1F2C;
// A1F30: using guessed type int dword_A1F30;
// A1F34: using guessed type int dword_A1F34;
// A1F38: using guessed type int dword_A1F38;
// A1F3C: using guessed type int dword_A1F3C;
// A2150: using guessed type void *off_A2150;
// A282F: using guessed type char *off_A282F;
// A2995: using guessed type void *off_A2995;

//----- (00068C4B) --------------------------------------------------------
int sub_68C4B()
{
  void *retaddr[2]; // [esp+10h] [ebp+Ch]

  sub_70B3E();
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}

//----- (00068C69) --------------------------------------------------------
int sub_68C69()
{
  void *retaddr[2]; // [esp+10h] [ebp+Ch]

  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}

//----- (00068C82) --------------------------------------------------------
int sub_68C82()
{
  void *retaddr[2]; // [esp+10h] [ebp+Ch]

  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}

//----- (00068C9B) --------------------------------------------------------
void sub_68C9B()
{
  ;
}

//----- (00068CAC) --------------------------------------------------------
void sub_68CAC()
{
  ;
}

//----- (00068CBD) --------------------------------------------------------
char sub_68CBD(int a1, int a2, unsigned int a3)
{
  int v3; // eax
  __int16 v4; // ax
  unsigned int i; // [esp+0h] [ebp-4h]

  LOBYTE(v3) = a3;
  if ( __readgsbyte(a3) < 0x10u )
  {
    LOBYTE(v3) = a3;
    if ( __readgsbyte(a3) != 9 )
    {
      dword_A082C[__readgsbyte(a3)] = __readgsbyte(a3 + 1);
      v3 = 4 * __readgsbyte(a3);
      *(int *)((char *)dword_A086C + v3) = 1;
      for ( i = 0; i < 9; ++i )
      {
        LOBYTE(v3) = i;
        if ( byte_A0764[i] )
        {
          LOBYTE(v3) = __readgsbyte(a3);
          if ( (unsigned __int8)v3 == dword_A0808[i] )
          {
            v4 = sub_68D7F(__readgsbyte(a3 + 1), (unsigned __int8)byte_A0764[i], i);
            LOBYTE(v3) = sub_6A085(i, v4);
          }
        }
      }
    }
  }
  return v3;
}
// A0808: using guessed type int dword_A0808[9];
// A082C: using guessed type int dword_A082C[16];
// A086C: using guessed type int dword_A086C[16];

//----- (00068D7F) --------------------------------------------------------
unsigned int sub_68D7F(unsigned int a1, int a2, int a3)
{
  unsigned int i; // [esp+4h] [ebp-18h]
  int v5; // [esp+14h] [ebp-8h]
  unsigned int v7; // [esp+18h] [ebp-4h]
  unsigned int v8; // [esp+18h] [ebp-4h]
  unsigned int v9; // [esp+34h] [ebp+18h]

  v9 = a2 - 12;
  for ( i = v9; i >= 0xC; i -= 12 )
    ;
  v5 = dword_A0A68[v9];
  if ( a1 >= 0x40 )
  {
    v8 = dword_A0A68[dword_A08AC[dword_A0808[a3]] + v9] - v5;
    if ( v8 > 0x2CF )
    {
      v5 = dword_A0C04[11 - i] | ((dword_A0A68[v9] & 0x1C00) + 1024);
      v8 = dword_A0A68[dword_A08AC[dword_A0808[a3]] + v9] - v5;
    }
    return ((1000 * (a1 - 64)) >> 6) * v8 / 0x3E8 + v5;
  }
  else
  {
    v7 = v5 - dword_A0A68[v9 - dword_A08AC[dword_A0808[a3]]];
    if ( v7 > 0x2CF )
      v7 = ((v5 & 0x3FF) - LOWORD(dword_A0C00[dword_A08AC[dword_A0808[a3]]])) & 0x3FF;
    return v5 - ((1000 * (63 - a1)) >> 6) * v7 / 0x3E8;
  }
}
// A0808: using guessed type int dword_A0808[9];
// A08AC: using guessed type int dword_A08AC[16];
// A0A68: using guessed type int dword_A0A68[102];
// A0C00: using guessed type int dword_A0C00[];
// A0C04: using guessed type int dword_A0C04[36];

//----- (00068F15) --------------------------------------------------------
void sub_68F15()
{
  ;
}

//----- (00068F26) --------------------------------------------------------
void sub_68F26()
{
  ;
}

//----- (00068F37) --------------------------------------------------------
char sub_68F37(int a1, int a2, unsigned int a3)
{
  int v3; // eax

  LOBYTE(v3) = __readgsbyte(a3 + 1);
  if ( (unsigned __int8)v3 < 0x66u )
  {
    if ( (unsigned __int8)v3 >= 7u )
    {
      if ( (unsigned __int8)v3 <= 7u )
      {
        LOBYTE(v3) = sub_70B8B(__readgsbyte(a3), __readgsbyte(a3 + 2));
      }
      else if ( (_BYTE)v3 == 64 )
      {
        dword_A0994[__readgsbyte(a3)] = __readgsbyte(a3 + 2);
        LOBYTE(v3) = a3;
        if ( !__readgsbyte(a3 + 2) )
        {
          while ( dword_A09F0 )
          {
            LOBYTE(v3) = sub_6956E(0, 0, (unsigned int)&byte_A09F4[3 * dword_A09F0]);
            --dword_A09F0;
          }
        }
      }
    }
  }
  else if ( (unsigned __int8)v3 <= 0x66u )
  {
    v3 = 4 * __readgsbyte(a3);
    *(int *)((char *)dword_A08AC + v3) = __readgsbyte(a3 + 2);
  }
  else if ( (unsigned __int8)v3 >= 0x79u )
  {
    if ( (unsigned __int8)v3 <= 0x79u )
    {
      LOBYTE(v3) = sub_69716(__readgsbyte(a3));
    }
    else if ( (_BYTE)v3 == 123 )
    {
      LOBYTE(v3) = sub_6966D(__readgsbyte(a3));
    }
  }
  return v3;
}
// A08AC: using guessed type int dword_A08AC[16];
// A0994: using guessed type int dword_A0994[18];
// A09F0: using guessed type int dword_A09F0;

//----- (0006905C) --------------------------------------------------------
void sub_6905C()
{
  ;
}

//----- (0006906D) --------------------------------------------------------
void sub_6906D()
{
  ;
}

//----- (0006907E) --------------------------------------------------------
void sub_6907E(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  __int16 v3; // ax
  unsigned int j; // [esp+0h] [ebp-14h]
  unsigned int i; // [esp+0h] [ebp-14h]
  unsigned int v6; // [esp+4h] [ebp-10h]
  unsigned __int8 v7; // [esp+10h] [ebp-4h]
  unsigned __int8 v8; // [esp+10h] [ebp-4h]

  if ( a3 < 0x10u )
  {
    if ( a3 == 9 )
    {
      v8 = sub_70D55(9u);
      sub_6A297(v8);
      dword_A0808[v8] = 9;
      for ( i = 0; i < 5; ++i )
      {
        sub_6A640(byte_A0776[2 * v8] + 0x80, byte_A0724[(unsigned __int8)byte_A0776[2 * v8]] | 0xF);
        sub_6A640(byte_A0775[2 * v8] + 0x80, byte_A0724[(unsigned __int8)byte_A0775[2 * v8]] | 0xF);
      }
      sub_6A405(dword_A07B6 + 30 * a1, (unsigned __int16)word_A07BA, v8);
      dword_A0930[v8] = a2;
      sub_6A640(
        byte_A0776[2 * v8] + 64,
        byte_A0704[(unsigned __int8)byte_A0776[2 * v8]] & 0xC0 | ((0x2000
                                                                 - (64
                                                                  - (byte_A0704[(unsigned __int8)byte_A0776[2 * v8]] & 0x3F))
                                                                 * 2
                                                                 * (64
                                                                  - (unsigned int)(unsigned __int8)byte_A0A24[(int)(unsigned __int8)(((dword_A08F0[9] << 7) / 127 * dword_A0930[v8]) >> 7) >> 1])) >> 7));
      sub_6A1D5(v8, dword_A0A38[__readgsbyte(dword_A07B0 + 12 * a1 + 2)]);
      byte_A0764[v8] = a1;
    }
    else
    {
      v7 = sub_70D55(a3);
      sub_6A297(v7);
      dword_A0808[v7] = a3;
      for ( j = 0; j < 5; ++j )
      {
        sub_6A640(byte_A0776[2 * v7] + 0x80, byte_A0724[(unsigned __int8)byte_A0776[2 * v7]] | 0xF);
        sub_6A640(byte_A0775[2 * v7] + 0x80, byte_A0724[(unsigned __int8)byte_A0775[2 * v7]] | 0xF);
      }
      sub_6A405(dword_A07A0 + 30 * dword_A07C8[a3], (unsigned __int16)word_A07A4, v7);
      dword_A0930[v7] = a2;
      v6 = (0x2000
          - (64 - (byte_A0704[(unsigned __int8)byte_A0776[2 * v7]] & 0x3F))
          * 2
          * (64
           - (unsigned int)(unsigned __int8)byte_A0A24[(int)(unsigned __int8)(((dword_A08F0[a3] << 7)
                                                                             / 127
                                                                             * dword_A0930[v7]) >> 7) >> 1])) >> 7;
      if ( !__readgsbyte(dword_A07A0 + 30 * dword_A07C8[a3] + 14) )
        sub_6A640(byte_A0775[2 * v7] + 64, byte_A0704[(unsigned __int8)byte_A0775[2 * v7]] & 0xC0 | v6);
      sub_6A640(byte_A0776[2 * v7] + 64, byte_A0704[(unsigned __int8)byte_A0776[2 * v7]] & 0xC0 | v6);
      sub_6A1D5(v7, dword_A0A38[a1]);
      byte_A0764[v7] = a1;
      if ( dword_A07C4 )
      {
        if ( dword_A086C[a3] )
        {
          v3 = sub_68D7F(dword_A082C[a3], a1, v7);
          sub_6A085(v7, v3);
        }
      }
    }
  }
}
// A07A0: using guessed type int dword_A07A0;
// A07A4: using guessed type __int16 word_A07A4;
// A07B0: using guessed type int dword_A07B0;
// A07B6: using guessed type int dword_A07B6;
// A07BA: using guessed type __int16 word_A07BA;
// A07C4: using guessed type int dword_A07C4;
// A07C8: using guessed type int dword_A07C8[16];
// A0808: using guessed type int dword_A0808[9];
// A082C: using guessed type int dword_A082C[16];
// A086C: using guessed type int dword_A086C[16];
// A08F0: using guessed type int dword_A08F0[16];
// A0930: using guessed type int dword_A0930[9];
// A0A38: using guessed type int dword_A0A38[12];

//----- (0006954C) --------------------------------------------------------
void sub_6954C()
{
  ;
}

//----- (0006955D) --------------------------------------------------------
void sub_6955D()
{
  ;
}

//----- (0006956E) --------------------------------------------------------
char sub_6956E(int a1, int a2, unsigned int a3)
{
  int v3; // eax
  unsigned int i; // [esp+4h] [ebp-8h]

  LOBYTE(v3) = a3;
  if ( __readgsbyte(a3 + 2) < 0x10u )
  {
    v3 = 4 * __readgsbyte(a3 + 2);
    if ( *(int *)((char *)dword_A0994 + v3) && (unsigned int)dword_A09F0 < 0x10 )
    {
      byte_A09F4[3 * dword_A09F0] = __readgsbyte(a3);
      byte_A09F5[3 * dword_A09F0] = __readgsbyte(a3 + 1);
      LOBYTE(v3) = __readgsbyte(a3 + 2);
      byte_A09F6[3 * dword_A09F0++] = v3;
    }
    else
    {
      for ( i = 0; i < 9; ++i )
      {
        LOBYTE(v3) = a3;
        if ( byte_A0764[i] == __readgsbyte(a3) )
        {
          LOBYTE(v3) = __readgsbyte(a3 + 2);
          if ( (unsigned __int8)v3 == dword_A0808[i] )
          {
            sub_6A297(i);
            LOBYTE(v3) = i;
            byte_A0764[i] = 0;
          }
        }
      }
    }
  }
  return v3;
}
// A0808: using guessed type int dword_A0808[9];
// A0994: using guessed type int dword_A0994[18];
// A09F0: using guessed type int dword_A09F0;

//----- (0006966D) --------------------------------------------------------
int sub_6966D(unsigned int a1)
{
  int result; // eax
  unsigned int i; // [esp+0h] [ebp-4h]

  if ( a1 < 0x10 )
  {
    dword_A08F0[a1] = 127;
    dword_A0930[a1] = 127;
    dword_A0954[a1] = 0;
    result = 4 * a1;
    dword_A0994[a1] = 0;
    for ( i = 0; i < 9; ++i )
    {
      result = dword_A0808[i];
      if ( result == a1 )
      {
        sub_6A297(i);
        result = i;
        byte_A0764[i] = 0;
      }
    }
  }
  return result;
}
// 69683: conditional instruction was optimized away because %arg_0.4>=10u
// A0808: using guessed type int dword_A0808[9];
// A08F0: using guessed type int dword_A08F0[16];
// A0930: using guessed type int dword_A0930[9];
// A0954: using guessed type int dword_A0954[16];
// A0994: using guessed type int dword_A0994[18];

//----- (00069716) --------------------------------------------------------
int sub_69716(unsigned int a1)
{
  int result; // eax

  if ( a1 < 0x10 )
  {
    dword_A08F0[a1] = 127;
    dword_A0930[a1] = 127;
    dword_A0954[a1] = 0;
    dword_A0994[a1] = 0;
    dword_A082C[a1] = 64;
    result = 4 * a1;
    dword_A08AC[a1] = 2;
  }
  return result;
}
// 6972C: conditional instruction was optimized away because %arg_0.4>=10u
// A082C: using guessed type int dword_A082C[16];
// A08AC: using guessed type int dword_A08AC[16];
// A08F0: using guessed type int dword_A08F0[16];
// A0930: using guessed type int dword_A0930[9];
// A0954: using guessed type int dword_A0954[16];
// A0994: using guessed type int dword_A0994[18];

//----- (0006979E) --------------------------------------------------------
void sub_6979E()
{
  ;
}

//----- (000697AF) --------------------------------------------------------
void sub_697AF()
{
  ;
}

//----- (000697C0) --------------------------------------------------------
void sub_697C0(int a1, int a2, unsigned int a3)
{
  unsigned __int8 v3; // [esp+0h] [ebp-4h]

  v3 = __readgsbyte(a3) & 0xF0;
  if ( v3 < 0xB0u )
  {
    if ( v3 >= 0x80u )
    {
      if ( v3 > 0x80u )
      {
        if ( v3 != 0x90 )
          return;
        if ( __readgsbyte(a3 + 2) )
        {
          sub_6907E(__readgsbyte(a3 + 1), __readgsbyte(a3 + 2), __readgsbyte(a3) & 0xF);
          return;
        }
      }
      byte_A09E0 = __readgsbyte(a3) & 0xF;
      byte_A09DE = __readgsbyte(a3 + 1);
      byte_A09DF = __readgsbyte(a3 + 2);
      sub_6956E(0, 0, (unsigned int)&byte_A09DE);
    }
  }
  else if ( v3 <= 0xB0u )
  {
    byte_A09E3 = __readgsbyte(a3) & 0xF;
    byte_A09E4 = __readgsbyte(a3 + 1);
    byte_A09E5 = __readgsbyte(a3 + 2);
    sub_68F37(0, 0, (unsigned int)&byte_A09E3);
  }
  else if ( v3 >= 0xC0u )
  {
    if ( v3 <= 0xC0u )
    {
      byte_A09E1 = __readgsbyte(a3 + 1);
      byte_A09E2 = __readgsbyte(a3) & 0xF;
      sub_70E1C(0, 0, (unsigned int)&byte_A09E1);
    }
    else if ( v3 == 0xE0 )
    {
      byte_A09E6 = __readgsbyte(a3) & 0xF;
      byte_A09E7 = __readgsbyte(a3 + 2);
      sub_68CBD(0, 0, (unsigned int)&byte_A09E6);
    }
  }
}
// A09DE: using guessed type char byte_A09DE;
// A09DF: using guessed type char byte_A09DF;
// A09E0: using guessed type char byte_A09E0;
// A09E1: using guessed type char byte_A09E1;
// A09E2: using guessed type char byte_A09E2;
// A09E3: using guessed type char byte_A09E3;
// A09E4: using guessed type char byte_A09E4;
// A09E5: using guessed type char byte_A09E5;
// A09E6: using guessed type char byte_A09E6;
// A09E7: using guessed type char byte_A09E7;

//----- (0006999B) --------------------------------------------------------
void sub_6999B()
{
  ;
}

//----- (000699AC) --------------------------------------------------------
void sub_699AC()
{
  ;
}

//----- (000699BD) --------------------------------------------------------
char sub_699BD()
{
  char result; // al
  unsigned int i; // [esp+0h] [ebp-4h]
  unsigned int j; // [esp+0h] [ebp-4h]

  result = sub_6A317();
  dword_A08EC = 0;
  for ( i = 0; i < 9; ++i )
  {
    byte_A0764[i] = 0;
    dword_A0808[i] = 0;
    result = 4 * i;
    dword_A0930[i] = 127;
  }
  for ( j = 0; j < 0x10; ++j )
  {
    dword_A082C[j] = 64;
    dword_A07C8[j] = 0;
    dword_A086C[j] = 0;
    dword_A08F0[j] = 127;
    result = 4 * j;
    dword_A0954[j] = 0;
  }
  return result;
}
// A07C8: using guessed type int dword_A07C8[16];
// A0808: using guessed type int dword_A0808[9];
// A082C: using guessed type int dword_A082C[16];
// A086C: using guessed type int dword_A086C[16];
// A08EC: using guessed type int dword_A08EC;
// A08F0: using guessed type int dword_A08F0[16];
// A0930: using guessed type int dword_A0930[9];
// A0954: using guessed type int dword_A0954[16];

//----- (00069A83) --------------------------------------------------------
void sub_69A83()
{
  ;
}

//----- (00069A94) --------------------------------------------------------
void sub_69A94()
{
  ;
}

//----- (00069AA5) --------------------------------------------------------
int sub_69AA5(int a1, int a2, int a3, __int16 a4)
{
  unsigned int v4; // edx
  unsigned int v5; // edx
  int result; // eax
  unsigned int v7; // edx
  unsigned int v8; // edx
  unsigned __int8 i; // [esp+4h] [ebp-4h]

  sub_69BFE(a3);
  if ( dword_A08EC )
  {
    dword_A08EC = 0;
    word_A07AE = a4;
    dword_A07AA = a3;
    v7 = __readgsdword(*(_DWORD *)byte_A0794 + 12);
    word_A07B4 = a4;
    dword_A07B0 = v7 + a3;
    v8 = __readgsdword(*(_DWORD *)byte_A0794 + 16);
    word_A07BA = a4;
    result = v8 + a3;
    dword_A07B6 = v8 + a3;
    dword_A07BC = 1;
  }
  else
  {
    dword_A08EC = 1;
    *(_WORD *)&byte_A0794[4] = a4;
    *(_DWORD *)byte_A0794 = a3;
    dword_A078C = (__int16)__readgsword(a3 + 8);
    v4 = __readgsdword(a3 + 12);
    word_A079E = a4;
    dword_A079A = v4 + a3;
    v5 = __readgsdword(a3 + 16);
    word_A07A4 = a4;
    result = v5 + a3;
    dword_A07A0 = v5 + a3;
    dword_A07A6 = 1;
    for ( i = 0; i < 9u; ++i )
    {
      byte_A09EE = 0;
      byte_A09EF = i;
      //fix word_A09EC = __DS__;
      dword_A09E8 = (int)&byte_A09EE;
      result = sub_70E1C(i, 1000, (unsigned int)&byte_A09EE);
    }
  }
  return result;
}
// A078C: using guessed type int dword_A078C;
// A079A: using guessed type int dword_A079A;
// A079E: using guessed type __int16 word_A079E;
// A07A0: using guessed type int dword_A07A0;
// A07A4: using guessed type __int16 word_A07A4;
// A07A6: using guessed type int dword_A07A6;
// A07AA: using guessed type int dword_A07AA;
// A07AE: using guessed type __int16 word_A07AE;
// A07B0: using guessed type int dword_A07B0;
// A07B4: using guessed type __int16 word_A07B4;
// A07B6: using guessed type int dword_A07B6;
// A07BA: using guessed type __int16 word_A07BA;
// A07BC: using guessed type int dword_A07BC;
// A08EC: using guessed type int dword_A08EC;
// A09E8: using guessed type int dword_A09E8;
// A09EC: using guessed type __int16 word_A09EC;
// A09EE: using guessed type char byte_A09EE;
// A09EF: using guessed type char byte_A09EF;

//----- (00069BFE) --------------------------------------------------------
int sub_69BFE(int a1)
{
  int result; // eax
  int v2; // [esp+0h] [ebp-10h]
  unsigned __int16 i; // [esp+Ch] [ebp-4h]

  v2 = __readgsdword(a1 + 16) + a1;
  for ( i = 0; ; ++i )
  {
    result = (__int16)__readgsword(a1 + 8) - 2;
    if ( i >= result )
      break;
    __writegsbyte(
      v2 + 11,
      (32 * __readgsbyte(v2 + 7)) | (__readgsbyte(v2 + 12) << 6) | (__readgsbyte(v2 + 11) << 7) | (16
                                                                                                 * __readgsbyte(v2 + 13)) | __readgsbyte(v2 + 3));
    __writegsbyte(v2 + 2, __readgsbyte(v2 + 10) | (__readgsbyte(v2 + 2) << 6));
    __writegsbyte(v2 + 5, __readgsbyte(v2 + 8) | (16 * __readgsbyte(v2 + 5)));
    __writegsbyte(v2 + 6, __readgsbyte(v2 + 9) | (16 * __readgsbyte(v2 + 6)));
    __writegsbyte(v2 + 14, __readgsbyte(v2 + 14) | (2 * __readgsbyte(v2 + 4)));
    __writegsbyte(
      v2 + 24,
      __readgsbyte(v2 + 16) | (16 * __readgsbyte(v2 + 26)) | (32 * __readgsbyte(v2 + 20)) | (__readgsbyte(v2 + 25) << 6) | (__readgsbyte(v2 + 24) << 7));
    __writegsbyte(v2 + 15, __readgsbyte(v2 + 23) | (__readgsbyte(v2 + 15) << 6));
    __writegsbyte(v2 + 18, __readgsbyte(v2 + 21) | (16 * __readgsbyte(v2 + 18)));
    __writegsbyte(v2 + 19, __readgsbyte(v2 + 22) | (16 * __readgsbyte(v2 + 19)));
    v2 += 30;
  }
  return result;
}

//----- (00069DFE) --------------------------------------------------------
void sub_69DFE()
{
  ;
}

//----- (00069E0F) --------------------------------------------------------
void sub_69E0F()
{
  ;
}

//----- (00069E20) --------------------------------------------------------
char sub_69E20()
{
  char result; // al

  dword_A06E8 = dword_A06F0;
  sub_69FE4((unsigned int)&dword_A06E8);
  sub_6A317();
  result = sub_6A60E();
  dword_A0788 = 0;
  return result;
}
// A06E8: using guessed type int dword_A06E8;
// A06F0: using guessed type int dword_A06F0;
// A0788: using guessed type int dword_A0788;

//----- (00069E63) --------------------------------------------------------
void sub_69E63()
{
  ;
}

//----- (00069E74) --------------------------------------------------------
void sub_69E74()
{
  ;
}

//----- (00069E85) --------------------------------------------------------
char sub_69E85(int a1, int a2, unsigned int a3)
{
  char result; // al

  dword_A06EC = __readgsdword(a3);
  sub_69FE4((unsigned int)&dword_A06EC);
  result = sub_6A11B();
  dword_A0788 = 1;
  return result;
}
// A06EC: using guessed type int dword_A06EC;
// A0788: using guessed type int dword_A0788;

//----- (00069ECB) --------------------------------------------------------
void sub_69ECB()
{
  ;
}

//----- (00069EDC) --------------------------------------------------------
void sub_69EDC()
{
  ;
}

//----- (00069EED) --------------------------------------------------------
int sub_69EED(unsigned int a1, __int16 a2, int a3, int a4)
{
  void *retaddr[2]; // [esp+10h] [ebp+Ch]

  sub_697C0(a4, a3, a1);
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}

//----- (00069F1C) --------------------------------------------------------
int sub_69F1C(int a1, int a2, int a3, int a4)
{
  void *retaddr[2]; // [esp+10h] [ebp+Ch]

  dword_131AEC = a4;
  sub_69E85(a4, a4, (unsigned int)&dword_131AEC);
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}
// 131AEC: using guessed type int dword_131AEC;

//----- (00069F57) --------------------------------------------------------
int sub_69F57()
{
  void *retaddr[2]; // [esp+10h] [ebp+Ch]

  sub_69E20();
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}

//----- (00069F75) --------------------------------------------------------
int sub_69F75()
{
  void *retaddr[2]; // [esp+10h] [ebp+Ch]

  sub_699BD();
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}

//----- (00069F93) --------------------------------------------------------
int sub_69F93(int a1, __int16 a2, int a3, int a4)
{
  void *retaddr[2]; // [esp+10h] [ebp+Ch]

  sub_69AA5(a4, a4, a1, a2);
  return 0;//fix MK_FP(retaddr[0], retaddr[0])(0);
}

//----- (00069FC2) --------------------------------------------------------
void sub_69FC2()
{
  ;
}

//----- (00069FD3) --------------------------------------------------------
void sub_69FD3()
{
  ;
}

//----- (00069FE4) --------------------------------------------------------
char sub_69FE4(unsigned int a1)
{
  if ( __readgsdword(a1) != 904 && __readgsdword(a1) != 896 )
    return 1;
  dword_A076F = __readgsdword(a1);
  dword_A06F0 = __readgsdword(a1);
  sub_6A640(1u, 0x20u);
  byte_A0758 = 0;
  sub_6A11B();
  byte_A0773 = 1;
  return 0;
}
// A06F0: using guessed type int dword_A06F0;
// A0758: using guessed type char byte_A0758;
// A076F: using guessed type int dword_A076F;
// A0773: using guessed type char byte_A0773;

//----- (0006A063) --------------------------------------------------------
void sub_6A063()
{
  ;
}

//----- (0006A074) --------------------------------------------------------
void sub_6A074()
{
  ;
}

//----- (0006A085) --------------------------------------------------------
char sub_6A085(unsigned __int8 a1, __int16 a2)
{
  byte_A0734[a1] = a2;
  byte_A073D[a1] = HIBYTE(a2) | 0x20;
  sub_6A640(a1 - 96, byte_A0734[a1]);
  sub_6A640(a1 - 80, byte_A073D[a1]);
  return 0;
}

//----- (0006A0F9) --------------------------------------------------------
void sub_6A0F9()
{
  ;
}

//----- (0006A10A) --------------------------------------------------------
void sub_6A10A()
{
  ;
}

//----- (0006A11B) --------------------------------------------------------
char sub_6A11B()
{
  unsigned int i; // [esp+0h] [ebp-8h]
  unsigned int j; // [esp+0h] [ebp-8h]

  for ( i = 0; i < 9; ++i )
  {
    byte_A073D[i] = 0;
    sub_6A640(i - 80, byte_A073D[i]);
  }
  for ( j = 0; j < 0xB; ++j )
    byte_A0759[j] = 0;
  byte_A0774 = 0;
  byte_A0758 &= 0xC0u;
  sub_6A640(0xBDu, byte_A0758);
  return 0;
}
// A0758: using guessed type char byte_A0758;
// A0774: using guessed type char byte_A0774;

//----- (0006A1B3) --------------------------------------------------------
void sub_6A1B3()
{
  ;
}

//----- (0006A1C4) --------------------------------------------------------
void sub_6A1C4()
{
  ;
}

//----- (0006A1D5) --------------------------------------------------------
char sub_6A1D5(unsigned __int8 a1, __int16 a2)
{
  byte_A0734[a1] = a2;
  byte_A073D[a1] = HIBYTE(a2) | 0x20;
  sub_6A640(a1 - 96, byte_A0734[a1]);
  sub_6A640(a1 - 80, byte_A073D[a1] & 0xDF);
  sub_6A640(a1 - 80, byte_A073D[a1]);
  byte_A0764[a1] = 1;
  return 0;
}

//----- (0006A275) --------------------------------------------------------
void sub_6A275()
{
  ;
}

//----- (0006A286) --------------------------------------------------------
void sub_6A286()
{
  ;
}

//----- (0006A297) --------------------------------------------------------
char sub_6A297(unsigned __int8 a1)
{
  if ( !byte_A0764[a1] )
    return 6;
  byte_A073D[a1] &= ~0x20u;
  sub_6A640(a1 - 80, byte_A073D[a1]);
  byte_A0764[a1] = 0;
  return 0;
}

//----- (0006A2F5) --------------------------------------------------------
void sub_6A2F5()
{
  ;
}

//----- (0006A306) --------------------------------------------------------
void sub_6A306()
{
  ;
}

//----- (0006A317) --------------------------------------------------------
char sub_6A317()
{
  unsigned __int8 i; // [esp+4h] [ebp-4h]
  unsigned __int8 j; // [esp+4h] [ebp-4h]
  unsigned __int8 k; // [esp+4h] [ebp-4h]

  if ( !byte_A0773 )
    return 2;
  byte_A0758 = 0;
  sub_6A640(0xBDu, 0);
  for ( i = 0; i < 9u; ++i )
    sub_6A640(i - 80, byte_A073D[i] & 0xDF);
  for ( j = 0; j < 9u; ++j )
    sub_6A640(byte_A0776[2 * j] + 64, 0xFFu);
  for ( k = 0; k < 0xBu; ++k )
    byte_A0759[k] = 0;
  return 0;
}
// A0758: using guessed type char byte_A0758;
// A0773: using guessed type char byte_A0773;

//----- (0006A3E3) --------------------------------------------------------
void sub_6A3E3()
{
  ;
}

//----- (0006A3F4) --------------------------------------------------------
void sub_6A3F4()
{
  ;
}

//----- (0006A405) --------------------------------------------------------
char sub_6A405(int a1, int a2, unsigned __int8 a3)
{
  unsigned __int8 v4; // [esp+0h] [ebp-38h]
  unsigned __int8 v5; // [esp+4h] [ebp-34h]
  unsigned __int8 v6; // [esp+8h] [ebp-30h]
  unsigned __int8 v7; // [esp+Ch] [ebp-2Ch]
  unsigned __int8 v8; // [esp+10h] [ebp-28h]
  unsigned __int8 v9; // [esp+14h] [ebp-24h]
  unsigned __int8 v10; // [esp+18h] [ebp-20h]
  unsigned __int8 v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+20h] [ebp-18h]
  unsigned __int8 v14; // [esp+24h] [ebp-14h]
  unsigned __int8 v15; // [esp+28h] [ebp-10h]
  unsigned __int8 v16; // [esp+2Ch] [ebp-Ch]

  v12 = (unsigned __int8)byte_A0775[2 * a3];
  v15 = __readgsbyte(a1 + 11);
  v16 = __readgsbyte(a1 + 2);
  v5 = __readgsbyte(a1 + 5);
  v14 = __readgsbyte(a1 + 6);
  v4 = __readgsbyte(a1 + 14);
  v11 = __readgsbyte(a1 + 28);
  v10 = __readgsbyte(a1 + 24);
  v9 = __readgsbyte(a1 + 15);
  v8 = __readgsbyte(a1 + 18);
  v7 = __readgsbyte(a1 + 19);
  v6 = __readgsbyte(a1 + 29);
  byte_A0724[(unsigned __int8)byte_A0776[2 * a3]] = v7;
  byte_A0724[(unsigned __int8)byte_A0775[2 * a3]] = v14;
  sub_6A640(v12 + 32, v15);
  sub_6A640(v12 + 64, v16);
  byte_A0704[v12] = v16;
  sub_6A640(v12 + 96, v5);
  sub_6A640(v12 + 0x80, v14);
  sub_6A640(a3 - 64, v4);
  sub_6A640(v12 - 32, v11);
  v13 = (unsigned __int8)byte_A0776[2 * a3];
  sub_6A640(v13 + 32, v10);
  byte_A0704[v13] = v9;
  sub_6A640(v13 + 96, v8);
  sub_6A640(v13 + 0x80, v7);
  sub_6A640(v13 - 32, v6);
  byte_A0759[a3] = 1;
  return 0;
}
// 6A405: using guessed type _DWORD arg_0;

//----- (0006A5EC) --------------------------------------------------------
void sub_6A5EC()
{
  ;
}

//----- (0006A5FD) --------------------------------------------------------
void sub_6A5FD()
{
  ;
}

//----- (0006A60E) --------------------------------------------------------
char sub_6A60E()
{
  byte_A0773 = 0;
  return 0;
}
// A0773: using guessed type char byte_A0773;

//----- (0006A62D) --------------------------------------------------------
void sub_6A62D()
{
  ;
}

//----- (0006A640) --------------------------------------------------------
unsigned __int8 sub_6A640(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int16 v2; // dx

  v2 = dword_A06F0;
  __outbyte(dword_A06F0, a1);
  __inbyte(++v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __outbyte(v2--, a2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  __inbyte(v2);
  return __inbyte(v2);
}
// A06F0: using guessed type int dword_A06F0;

//----- (0006A737) --------------------------------------------------------
__int16 sub_6A737(void (*a1)(_DWORD), unsigned int a2, int a3, int a4, __int16 a5)
{
  int v7; // ecx
  int v8; // edi
  __int16 result; // ax

  //fix
  result = 0;
  //fix

  a1((uint32)a1);
  v7 = 5;
  do
  {
    //fix *MK_FP(a5, a4) = (char *)a1 + __readfsdword(a2);
    v8 = a4 + 4;
    //fix result = __CS__;
    //fix *MK_FP(a5, v8) = __CS__;
    a4 = v8 + 2;
    a2 += 8;
    --v7;
  }
  while ( v7 );
  return result;
}
// 6A737: using guessed type unsigned int arg_4;

//----- (0006B260) --------------------------------------------------------
int sub_6B260(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5, __int16 a6)
{
  __int16 v6; // bx
  __int16 v7; // cx
  __int16 v8; // dx
  _BYTE *v10; // edi
  int v11; // eax
  unsigned int v12; // ecx
  int v13; // ecx
  int v14; // esi
  int v15; // esi
  int v16; // [esp+4h] [ebp-4h]

  //fix
  v16 = 0;
  //fix

  v6 = 2 * dword_12F024;
  v7 = 2 * dword_12F018;
  v8 = 2 * dword_12F010;
  if ( a1 < (__int16)(2 * dword_12F008) )
    a1 = 2 * dword_12F008;
  if ( a3 < (__int16)(2 * dword_12F008) )
    return v16;
  if ( a1 >= v6 )
    return v16;
  if ( a3 >= v6 )
    a3 = 2 * dword_12F024;
  if ( a2 < v7 )
    a2 = 2 * dword_12F018;
  if ( a4 < v7 )
    return v16;
  if ( a2 >= v8 )
    return v16;
  if ( a4 >= v8 )
    a4 = 2 * dword_12F010;
  v10 = (_BYTE *)(320 * ((unsigned __int16)a2 >> 1) + dword_12EFF4 + ((unsigned __int16)a1 >> 1));
  v11 = a5;
  v12 = (unsigned __int16)a3;
  if ( a3 == a1 )
  {
    v13 = (unsigned __int16)a4;
    LOWORD(v13) = (unsigned __int16)(a4 - a2) >> 1;
    if ( (a6 & 4) != 0 )
    {
      v14 = dword_9AFA0;
      do
      {
        BYTE1(v11) = *v10;
        *v10 = *(_BYTE *)(v11 + v14);
        v10 += 320;
        --v13;
      }
      while ( v13 );
    }
    else
    {
      do
      {
        *v10 = a5;
        v10 += 320;
        --v13;
      }
      while ( v13 );
    }
  }
  else
  {
    LOWORD(v12) = (unsigned __int16)(a3 - a1) >> 1;
    if ( (a6 & 4) != 0 )
    {
      v15 = dword_9AFA0;
      do
      {
        BYTE1(v11) = *v10;
        *v10++ = *(_BYTE *)(v11 + v15);
        --v12;
      }
      while ( v12 );
    }
    else
    {
      memset(v10, a5, v12);
    }
  }
  return v16;
}
// 6B2A5: variable 'v16' is possibly undefined
// 9AFA0: using guessed type int dword_9AFA0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F008: using guessed type int dword_12F008;
// 12F010: using guessed type int dword_12F010;
// 12F018: using guessed type int dword_12F018;
// 12F024: using guessed type int dword_12F024;

//----- (0006B378) --------------------------------------------------------
int sub_6B378(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5, __int16 a6)
{
  _BYTE *v7; // edi
  int v8; // eax
  unsigned int v9; // ecx
  int v10; // ecx
  int v11; // esi
  int v12; // esi
  int v13; // [esp+4h] [ebp-4h]

  //fix
  v13 = 0;
  //fix

  if ( a1 < (__int16)dword_12F008 )
    a1 = dword_12F008;
  if ( a3 < (__int16)dword_12F008 )
    return v13;
  if ( a1 >= (__int16)dword_12F024 )
    return v13;
  if ( a3 >= (__int16)dword_12F024 )
    a3 = dword_12F024;
  if ( a2 < (__int16)dword_12F018 )
    a2 = dword_12F018;
  if ( a4 < (__int16)dword_12F018 )
    return v13;
  if ( a2 >= (__int16)dword_12F010 )
    return v13;
  if ( a4 >= (__int16)dword_12F010 )
    a4 = dword_12F010;
  v7 = (_BYTE *)(640 * (unsigned __int16)a2 + dword_12EFF4 + (unsigned __int16)a1);
  v8 = a5;
  v9 = (unsigned __int16)a3;
  LOWORD(v9) = a3 - a1;
  if ( a3 == a1 )
  {
    v10 = (unsigned __int16)a4;
    LOWORD(v10) = a4 - a2;
    if ( (a6 & 4) != 0 )
    {
      v11 = dword_9AFA0;
      do
      {
        BYTE1(v8) = *v7;
        *v7 = *(_BYTE *)(v8 + v11);
        v7 += 640;
        --v10;
      }
      while ( v10 );
    }
    else
    {
      do
      {
        *v7 = a5;
        v7 += 640;
        --v10;
      }
      while ( v10 );
    }
  }
  else if ( (a6 & 4) != 0 )
  {
    v12 = dword_9AFA0;
    do
    {
      BYTE1(v8) = *v7;
      *v7++ = *(_BYTE *)(v8 + v12);
      --v9;
    }
    while ( v9 );
  }
  else
  {
    memset(v7, a5, v9);
  }
  return v13;
}
// 6B3B1: variable 'v13' is possibly undefined
// 9AFA0: using guessed type int dword_9AFA0;
// 12EFF4: using guessed type int dword_12EFF4;
// 12F008: using guessed type int dword_12F008;
// 12F010: using guessed type int dword_12F010;
// 12F018: using guessed type int dword_12F018;
// 12F024: using guessed type int dword_12F024;

//----- (0006B47C) --------------------------------------------------------
int sub_6B47C(unsigned __int8 *a1)
{
  int v3; // [esp+4h] [ebp-4h]

  //fix
  v3 = 0;
  //fix

  __outbyte(0x3C7u, 0);
  __inbytestring(0x3C9u, (int)a1, 0x300u);
  return v3;
}
// 6B49D: variable 'v3' is possibly undefined

//----- (0006B87A) --------------------------------------------------------
int sub_6B87A()
{
  return dword_A0CA4;
}
// A0CA4: using guessed type int dword_A0CA4;

//----- (0006BCA3) --------------------------------------------------------
int sub_6BCA3(int a1, unsigned __int8 *a2, int *a3)
{
  int *v3; // edi
  int v4; // ebp
  unsigned __int8 *v5; // ebx
  unsigned __int8 *v6; // ecx
  int v7; // ebx
  int v8; // eax
  unsigned __int8 *v9; // eax
  unsigned int v10; // ebx
  int v11; // eax
  int v13; // [esp-4h] [ebp-18h]
  int v14; // [esp+0h] [ebp-14h]

  v3 = a3;
  v4 = 0;
  v14 = 0;
  *(_BYTE *)(a1 + 16) &= ~2u;
  while ( 1 )
  {
    v5 = a2;
    v6 = ++a2;
    v7 = *v5;
    if ( !v7 )
      break;
    if ( (IsTable[(unsigned __int8)(v7 + 1)] & 2) != 0 )
    {
      v4 += sub_6BF98(a1);
    }
    else if ( v7 == 37 )
    {
      v9 = sub_6BEBB(v6, a1);
      a2 = v9;
      v10 = *v9;
      if ( *v9 )
        a2 = v9 + 1;
      if ( v10 < 0x65 )
      {
        if ( v10 < 0x58 )
        {
          if ( v10 < 0x45 )
          {
            if ( v10 == 37 )
            {
              v8 = (*(int (**)(int))a1)(a1);
              if ( v8 != 37 )
              {
LABEL_7:
                if ( (*(_BYTE *)(a1 + 16) & 2) == 0 )
                  (*(void (**)(int, int))(a1 + 4))(v8, a1);
                break;
              }
            }
          }
          else if ( v10 <= 0x45 || v10 == 71 )
          {
LABEL_45:
            sub_6C32A(a1, v3);
            goto LABEL_50;
          }
        }
        else
        {
          if ( v10 <= 0x58 )
          {
LABEL_44:
            sub_6C66D(a1, v3, 16, 1);
            goto LABEL_50;
          }
          if ( v10 >= 0x63 )
          {
            if ( v10 <= 0x63 )
            {
              v11 = sub_6BFCF((_WORD *)a1, a1, v3);
              goto LABEL_50;
            }
            v13 = 1;
LABEL_40:
            sub_6C66D(a1, v3, 10, v13);
            goto LABEL_50;
          }
          if ( v10 == 91 )
          {
            sub_6C224((_BYTE *)a1, a1, v3, &a2);
            goto LABEL_50;
          }
        }
      }
      else
      {
        if ( v10 <= 0x67 )
          goto LABEL_45;
        if ( v10 < 0x70 )
        {
          if ( v10 < 0x6E )
          {
            if ( v10 == 105 )
            {
              sub_6C66D(a1, v3, 0, 1);
              goto LABEL_50;
            }
          }
          else
          {
            if ( v10 > 0x6E )
            {
              sub_6C66D(a1, v3, 8, 1);
LABEL_50:
              if ( v11 <= 0 )
                break;
              v4 += v11;
              if ( (*(_BYTE *)(a1 + 16) & 1) != 0 )
                ++v14;
              goto LABEL_55;
            }
            sub_6C175(a1, v3, v4);
          }
        }
        else
        {
          if ( v10 <= 0x70 )
            goto LABEL_44;
          if ( v10 < 0x75 )
          {
            if ( v10 == 115 )
            {
              sub_6C05C((_BYTE *)a1, a1, v3);
              goto LABEL_50;
            }
          }
          else
          {
            if ( v10 <= 0x75 )
            {
              v13 = 0;
              goto LABEL_40;
            }
            if ( v10 == 120 )
              goto LABEL_44;
          }
        }
      }
    }
    else
    {
      v8 = (*(int (**)(int))a1)(a1);
      if ( v8 != v7 )
        goto LABEL_7;
      ++v4;
    }
LABEL_55:
    if ( (*(_BYTE *)(a1 + 16) & 2) != 0 )
    {
      if ( *a2 == 37 )
      {
        ++a2;
        a2 = sub_6BEBB(a2, a1);
        if ( *a2 == 110 )
          sub_6C175(a1, v3, v4);
      }
      break;
    }
  }
  if ( v14 || (*(_BYTE *)(a1 + 16) & 2) == 0 )
    return v14;
  else
    return -1;
}
// 6BE39: variable 'v11' is possibly undefined

//----- (0006BEBB) --------------------------------------------------------
unsigned __int8 *sub_6BEBB(unsigned __int8 *a1, int a2)
{
  unsigned __int8 *result; // eax
  char v3; // dl
  int v4; // edx
  unsigned __int8 v5; // cl
  int v6; // [esp+0h] [ebp-Ch]

  result = a1;
  v3 = *(_BYTE *)(a2 + 16) | 1;
  *(_DWORD *)(a2 + 12) = -1;
  *(_BYTE *)(a2 + 16) = v3;
  *(_BYTE *)(a2 + 16) = v3 & 3;
  if ( *a1 == 42 )
  {
    result = a1 + 1;
    *(_BYTE *)(a2 + 16) &= ~1u;
  }
  v6 = *result;
  if ( (IsTable[(unsigned __int8)(v6 + 1)] & 0x20) != 0 )
  {
    v4 = 0;
    do
    {
      ++result;
      v4 = v6 - 48 + 10 * v4;
      v6 = *result;
    }
    while ( (IsTable[(unsigned __int8)(v6 + 1)] & 0x20) != 0 );
    *(_DWORD *)(a2 + 12) = v4;
  }
  if ( *result == 78 )
  {
    *(_BYTE *)(a2 + 16) |= 8u;
  }
  else
  {
    if ( *result != 70 )
      goto LABEL_12;
    *(_BYTE *)(a2 + 16) |= 4u;
  }
  ++result;
LABEL_12:
  v5 = *result;
  if ( *result < 0x68u )
  {
    if ( v5 == 76 )
    {
      ++result;
      *(_BYTE *)(a2 + 16) |= 0x40u;
    }
  }
  else if ( *result <= 0x68u )
  {
    ++result;
    *(_BYTE *)(a2 + 16) |= 0x10u;
  }
  else if ( v5 >= 0x6Cu && (v5 <= 0x6Cu || v5 == 119) )
  {
    ++result;
    *(_BYTE *)(a2 + 16) |= 0x20u;
  }
  return result;
}

//----- (0006BF98) --------------------------------------------------------
int sub_6BF98(int a1)
{
  int i; // esi
  int v2; // eax

  for ( i = 0; ; ++i )
  {
    v2 = (*(int (**)(int))a1)(a1);
    if ( (IsTable[(unsigned __int8)(v2 + 1)] & 2) == 0 )
      break;
  }
  if ( (*(_BYTE *)(a1 + 16) & 2) == 0 )
    (*(void (**)(int, int))(a1 + 4))(v2, a1);
  return i;
}

//----- (0006BFCF) --------------------------------------------------------
int sub_6BFCF(_WORD *a1, int a2, int *a3)
{
  char v3; // dl
  int v4; // esi
  int v5; // eoff
  int v6; // ecx
  int v7; // edx
  int v8; // edi
  int v9; // ebp
  __int16 v10; // ax
  char v11; // ch

  v3 = *(_BYTE *)(a2 + 16);
  if ( (v3 & 1) != 0 )
  {
    if ( (v3 & 4) != 0 )
    {
      v4 = *a3 + 8;
      *a3 = v4;
      v5 = v4 - 8;
      a1 = *(_WORD **)(v4 - 8);
      //fix __ES__ = *(_WORD *)(v5 + 4);
    }
    else if ( (v3 & 8) != 0 )
    {
      v6 = *a3 + 4;
      *a3 = v6;
      //fix __ES__ = __DS__;
      a1 = *(_WORD **)(v6 - 4);
    }
    else
    {
      v7 = *a3 + 4;
      *a3 = v7;
      //fix __ES__ = __DS__;
      a1 = *(_WORD **)(v7 - 4);
    }
  }
  v8 = *(_DWORD *)(a2 + 12);
  v9 = 0;
  if ( v8 == -1 )
    v8 = 1;
  while ( v8 > 0 )
  {
    v10 = (*(int (**)(int))a2)(a2);
    v11 = *(_BYTE *)(a2 + 16);
    if ( (v11 & 2) != 0 )
      break;
    ++v9;
    --v8;
    if ( (v11 & 1) != 0 )
    {
      if ( (v11 & 0x20) != 0 )
      {
        *a1++ = v10;
      }
      else
      {
        *(_BYTE *)a1 = v10;
        a1 = (_WORD *)((char *)a1 + 1);
      }
    }
  }
  return v9;
}

//----- (0006C05C) --------------------------------------------------------
void sub_6C05Cfix(_BYTE *a1, int a2, int *a3)
{
  char v3; // dh
  int v4; // esi
  int v5; // eoff
  int v6; // ecx
  int v7; // edx
  int i; // edi
  int v9; // eax
  int v10; // [esp+0h] [ebp-1Ch]
  unsigned __int8 v11; // [esp+4h] [ebp-18h]

  if ( (*(_BYTE *)(a2 + 16) & 0x20) != 0 )
    v11 = 2;
  else
    v11 = 1;
  v3 = *(_BYTE *)(a2 + 16);
  if ( (v3 & 1) != 0 )
  {
    if ( (v3 & 4) != 0 )
    {
      v4 = *a3 + 8;
      *a3 = v4;
      v5 = v4 - 8;
      a1 = *(_BYTE **)(v4 - 8);
      //fix __ES__ = *(_WORD *)(v5 + 4);
    }
    else if ( (v3 & 8) != 0 )
    {
      v6 = *a3 + 4;
      *a3 = v6;
      //fix __ES__ = __DS__;
      a1 = *(_BYTE **)(v6 - 4);
    }
    else
    {
      v7 = *a3 + 4;
      *a3 = v7;
      //fix __ES__ = __DS__;
      a1 = *(_BYTE **)(v7 - 4);
    }
  }
  for ( i = 0; ; ++i )
  {
    v10 = (*(int (**)(int))a2)(a2);
    if ( (IsTable[(unsigned __int8)(v10 + 1)] & 2) == 0 )
      break;
  }
  if ( (*(_BYTE *)(a2 + 16) & 2) != 0 )
  {
    i = 0;
  }
  else
  {
    v9 = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 12) = v9 - 1;
    if ( v9 )
    {
      while ( 1 )
      {
        ++i;
        if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
        {
          if ( v11 == 1 )
            *a1 = v10;
          else
            *(_WORD *)a1 = v10;
          a1 += v11;
        }
        v10 = sub_6C8C5(a2);
        if ( v10 == -1 )
          break;
        if ( (IsTable[(unsigned __int8)(v10 + 1)] & 2) != 0 )
          goto LABEL_23;
      }
    }
    else
    {
LABEL_23:
      (*(void (**)(int, int))(a2 + 4))(v10, a2);
    }
  }
  if ( (*(_BYTE *)(a2 + 16) & 1) != 0 && i > 0 )
  {
    if ( v11 == 1 )
      *a1 = 0;
    else
      *(_WORD *)a1 = 0;
  }
  JUMPOUT(0x6C056);
}
// 6C170: control flows out of bounds to 6C056

//----- (0006C175) --------------------------------------------------------
int *sub_6C175(int a1, int *a2, int a3)
{
  int *result; // eax
  char v4; // bl
  int v5; // esi
  int v6; // ecx
  int v7; // ebx

  result = a2;
  v4 = *(_BYTE *)(a1 + 16);
  if ( (v4 & 1) != 0 )
  {
    if ( (v4 & 4) != 0 )
    {
      v5 = *a2 + 8;
      *a2 = v5;
      result = *(int **)(v5 - 8);
      //fix __ES__ = *(_WORD *)(v5 - 8 + 4);
    }
    else if ( (v4 & 8) != 0 )
    {
      v6 = *a2 + 4;
      *a2 = v6;
      //fix __ES__ = __DS__;
      result = *(int **)(v6 - 4);
    }
    else
    {
      v7 = *a2 + 4;
      *a2 = v7;
      //fix __ES__ = __DS__;
      result = *(int **)(v7 - 4);
    }
    if ( (*(_BYTE *)(a1 + 16) & 0x10) != 0 )
      *(_WORD *)result = a3;
    else
      *result = a3;
  }
  return result;
}

//----- (0006C1E0) --------------------------------------------------------
_BYTE *sub_6C1E0(_BYTE *a1, int a2)
{
  int v2; // eax
  _BYTE *v3; // ebx

  memset((void*)a2, 0, 32);
  v2 = (unsigned __int8)*a1;
  v3 = a1 + 1;
  if ( *a1 )
  {
    do
    {
      *(_BYTE *)((v2 >> 3) + a2) |= byte_AC16C[v2 & 7];
      v2 = (unsigned __int8)*v3;
      if ( !*v3 )
        break;
      ++v3;
    }
    while ( v2 != 93 );
  }
  return v3;
}
// 5CC30: using guessed type _DWORD memset(_DWORD, _DWORD, _DWORD);

//----- (0006C224) --------------------------------------------------------
void sub_6C224fix(_BYTE *a1, int a2, int *a3, _BYTE **a4)
{
  _BYTE *v4; // eax
  _BOOL1 v5; // zf
  char v6; // cl
  int v7; // ebp
  int v8; // esi
  int v9; // ecx
  int v10; // edi
  int i; // ebp
  int v12; // eax
  char v13; // dl
  char v14[32]; // [esp+0h] [ebp-40h] BYREF
  int v15; // [esp+20h] [ebp-20h]
  bool v16; // [esp+24h] [ebp-1Ch]
  int v17; // [esp+28h] [ebp-18h]

  v4 = *a4;
  v5 = **a4 != 94;
  v16 = **a4 == 94;
  if ( !v5 )
    *a4 = v4 + 1;
  *a4 = sub_6C1E0(*a4, (int)v14);
  v6 = *(_BYTE *)(a2 + 16);
  if ( (v6 & 1) != 0 )
  {
    if ( (v6 & 4) != 0 )
    {
      v7 = *a3 + 8;
      *a3 = v7;
      a1 = *(_BYTE **)(v7 - 8);
      //fix __ES__ = *(_WORD *)(v7 - 8 + 4);
    }
    else if ( (v6 & 8) != 0 )
    {
      v8 = *a3 + 4;
      *a3 = v8;
      //fix __ES__ = __DS__;
      a1 = *(_BYTE **)(v8 - 4);
    }
    else
    {
      v9 = *a3 + 4;
      *a3 = v9;
      //fix __ES__ = __DS__;
      a1 = *(_BYTE **)(v9 - 4);
    }
  }
  v10 = *(_DWORD *)(a2 + 12);
  for ( i = 0; ; ++i )
  {
    if ( !v10 )
      goto LABEL_16;
    v12 = (*(int (**)(int))a2)(a2);
    v13 = *(_BYTE *)(a2 + 16);
    v17 = v12;
    if ( (v13 & 2) != 0 )
      goto LABEL_16;
    v15 = (unsigned __int8)v14[v12 >> 3];
    if ( ((unsigned __int8)(v15 & byte_AC16C[v12 & 7]) == 0) != v16 )
      break;
    --v10;
    if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
      *a1++ = v17;
  }
  (*(void (**)(int, int))(a2 + 4))(v12, a2);
LABEL_16:
  if ( (*(_BYTE *)(a2 + 16) & 1) != 0 && i > 0 )
    *a1 = 0;
  JUMPOUT(0x6C056);
}
// 6C325: control flows out of bounds to 6C056
// 6C224: using guessed type char var_40[32];

//----- (0006C32A) --------------------------------------------------------
void sub_6C32A(int a1, int *a2)
{
  char *v2; // ebx
  int v3; // edi
  int i; // ebp
  int v5; // eax
  int v6; // ecx
  char *v7; // ecx
  char v8; // al
  int v9; // eax
  char v10; // ah
  int v11; // ecx
  int *v12; // ebx
  int v13; // ebx
  int v14; // edx
  char v15; // dh
  int v16; // eax
  char v17; // [esp+0h] [ebp-80h] BYREF
  _BYTE v18[3]; // [esp+1h] [ebp-7Fh] BYREF
  int v19[2]; // [esp+50h] [ebp-30h] BYREF
  int v20; // [esp+58h] [ebp-28h]
  unsigned int j; // [esp+5Ch] [ebp-24h]
  int v22; // [esp+60h] [ebp-20h]
  int v23; // [esp+64h] [ebp-1Ch]
  int v24; // [esp+68h] [ebp-18h]

  v2 = &v17;
  v3 = 0;
  for ( i = 0; ; ++i )
  {
    v5 = (*(int (**)(int))a1)(a1);
    v22 = v5;
    if ( (IsTable[(unsigned __int8)(v5 + 1)] & 2) == 0 )
      break;
  }
  if ( (*(_BYTE *)(a1 + 16) & 2) != 0 )
    goto LABEL_42;
  v6 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v6 - 1;
  if ( v6 )
  {
    if ( v5 == 43 || v5 == 45 )
    {
      v17 = v22;
      v2 = (char*)v18;
      v22 = sub_6C8C5(a1);
      if ( v22 == -1 )
        goto LABEL_42;
    }
    if ( (IsTable[(unsigned __int8)(v22 + 1)] & 0x20) != 0 || v22 == 46 )
    {
      v20 = 0;
      v23 = 0;
      if ( (IsTable[(unsigned __int8)(v22 + 1)] & 0x20) != 0 )
      {
        v23 = 1;
        while ( 1 )
        {
          *v2++ = v22;
          if ( (*(_BYTE *)(a1 + 16) & 0x10) != 0 )
            HIWORD(v20) = v22 + 10 * HIWORD(v20) - 48;
          ++v3;
          v22 = sub_6C8C5(a1);
          if ( v22 == -1 )
            break;
          if ( (IsTable[(unsigned __int8)(v22 + 1)] & 0x20) == 0 )
            goto LABEL_17;
        }
LABEL_42:
        if ( v3 > 0 && (*(_BYTE *)(a1 + 16) & 1) != 0 )
        {
          *v2 = 0;
          if ( (*(_BYTE *)(a1 + 16) & 0x10) != 0 )
          {
            if ( v17 == 45 )
              v20 = -v20;
          }
          else
          {
            off_A6368((uint32)&v17, (uint32)v19);
          }
          v10 = *(_BYTE *)(a1 + 16);
          if ( (v10 & 4) != 0 )
          {
            v11 = *a2 + 8;
            *a2 = v11;
            v12 = *(int **)(v11 - 8);
            //fix __ES__ = *(_WORD *)(v11 - 8 + 4);
          }
          else if ( (v10 & 8) != 0 )
          {
            v13 = *a2 + 4;
            *a2 = v13;
            //fix __ES__ = __DS__;
            v12 = *(int **)(v13 - 4);
          }
          else
          {
            v14 = *a2 + 4;
            *a2 = v14;
            //fix __ES__ = __DS__;
            v12 = *(int **)(v14 - 4);
          }
          v15 = *(_BYTE *)(a1 + 16);
          if ( (v15 & 0x10) != 0 )
          {
            v16 = v20;
          }
          else
          {
            if ( (v15 & 0x20) != 0 || (v15 & 0x40) != 0 )
            {
              *v12 = v19[0];
              v12[1] = v19[1];
              goto LABEL_60;
            }
            v16 = _FDFS();
          }
          *v12 = v16;
        }
LABEL_60:
        JUMPOUT(0x6C056);
      }
LABEL_17:
      if ( v22 == 46 )
      {
        *v2++ = 46;
        v22 = sub_6C8C5(a1);
        if ( v22 == -1 )
          goto LABEL_42;
        if ( !v23 && (IsTable[(unsigned __int8)(v22 + 1)] & 0x20) == 0 )
          goto LABEL_41;
        ++v3;
        do
        {
          if ( (IsTable[(unsigned __int8)(v22 + 1)] & 0x20) == 0 )
            break;
          ++v3;
          *v2++ = v22;
          v22 = sub_6C8C5(a1);
        }
        while ( v22 != -1 );
        if ( (*(_BYTE *)(a1 + 16) & 0x10) != 0 )
        {
          v7 = v2;
          for ( j = 0; ; j /= 0xAu )
          {
            v8 = *--v7;
            if ( *v7 == 46 )
              break;
            v24 = 10;
            BYTE2(j) = v8 - 48;
          }
          LOWORD(v20) = j;
        }
        if ( v22 == -1 )
          goto LABEL_42;
      }
      if ( (*(_BYTE *)(a1 + 16) & 0x10) == 0 && (v22 == 101 || v22 == 69) )
      {
        ++v3;
        *v2 = v22;
        v9 = sub_6C8C5(a1);
        ++v2;
        v22 = v9;
        if ( v9 == -1 )
          goto LABEL_42;
        if ( v9 == 43 || v9 == 45 )
        {
          ++v3;
          *v2++ = v22;
          v22 = sub_6C8C5(a1);
          if ( v22 == -1 )
            goto LABEL_42;
        }
        if ( (IsTable[(unsigned __int8)(v22 + 1)] & 0x20) != 0 )
        {
          while ( 1 )
          {
            ++v3;
            *v2++ = v22;
            v22 = sub_6C8C5(a1);
            if ( v22 == -1 )
              goto LABEL_42;
            if ( (IsTable[(unsigned __int8)(v22 + 1)] & 0x20) == 0 )
              goto LABEL_41;
          }
        }
        v3 = 0;
      }
    }
  }
LABEL_41:
  (*(void (**)(int, int))(a1 + 4))(v22, a1);
  goto LABEL_42;
}
// 6C668: control flows out of bounds to 6C056
// 713FA: using guessed type int _FDFS(void);
// A6368: using guessed type int (*off_A6368)(_DWORD, _DWORD);

//----- (0006C66D) --------------------------------------------------------
void sub_6C66D(int a1, int *a2, int a3, int a4)
{
  int v4; // ebp
  int v5; // edi
  int v6; // esi
  int v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  char v15; // ah
  int v16; // edx
  _WORD *v17; // eax
  int v18; // ebp
  int v19; // ecx
  int v20; // [esp+0h] [ebp-20h]
  int v21; // [esp+4h] [ebp-1Ch]
  int i; // [esp+8h] [ebp-18h]

  v4 = a3;
  v5 = 0;
  v6 = 0;
  for ( i = 0; ; ++i )
  {
    v7 = (*(int (**)(int))a1)(a1);
    v21 = v7;
    if ( (IsTable[(unsigned __int8)(v7 + 1)] & 2) == 0 )
      break;
  }
  if ( (*(_BYTE *)(a1 + 16) & 2) != 0 )
    goto LABEL_34;
  v8 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v8 - 1;
  if ( v8 )
  {
    v20 = 43;
    if ( a4 && (v7 == 43 || v7 == 45) )
    {
      v20 = v7;
      v21 = sub_6C8C5(a1);
      if ( v21 == -1 )
        goto LABEL_34;
    }
    if ( !a3 )
    {
      if ( v21 != 48 )
      {
        v4 = 10;
        goto LABEL_26;
      }
      v9 = sub_6C8C5(a1);
      v6 = 1;
      v21 = v9;
      if ( v9 != -1 )
      {
        if ( v9 != 120 && v9 != 88 )
        {
          v4 = 8;
          goto LABEL_26;
        }
        v6 = 0;
        v21 = sub_6C8C5(a1);
        if ( v21 != -1 )
        {
          v4 = 16;
          goto LABEL_26;
        }
      }
      goto LABEL_34;
    }
    if ( a3 != 16 || v21 != 48 )
      goto LABEL_26;
    v10 = sub_6C8C5(a1);
    v6 = 1;
    v21 = v10;
    if ( v10 == -1 )
    {
LABEL_34:
      if ( v20 == 45 )
        v5 = -v5;
      if ( v6 > 0 )
      {
        v15 = *(_BYTE *)(a1 + 16);
        if ( (v15 & 1) != 0 )
        {
          if ( (v15 & 4) != 0 )
          {
            v16 = *a2 + 8;
            *a2 = v16;
            v17 = *(_WORD **)(v16 - 8);
            //fix __ES__ = *(_WORD *)(v16 - 8 + 4);
          }
          else if ( (v15 & 8) != 0 )
          {
            v18 = *a2 + 4;
            *a2 = v18;
            //fix __ES__ = __DS__;
            v17 = *(_WORD **)(v18 - 4);
          }
          else
          {
            v19 = *a2 + 4;
            *a2 = v19;
            //fix __ES__ = __DS__;
            v17 = *(_WORD **)(v19 - 4);
          }
          if ( (*(_BYTE *)(a1 + 16) & 0x10) != 0 )
            *v17 = v5;
          else
            *(_DWORD *)v17 = v5;
        }
      }
      JUMPOUT(0x6C056);
    }
    if ( v10 == 120 || v10 == 88 )
    {
      v11 = sub_6C8C5(a1);
      v6 = 0;
      goto LABEL_25;
    }
LABEL_26:
    while ( 1 )
    {
      v12 = sub_6C896(v21);
      if ( v12 >= v4 )
        break;
      v5 = v12 + v4 * v5;
      v11 = sub_6C8C5(a1);
      ++v6;
LABEL_25:
      v21 = v11;
      if ( v11 == -1 )
        goto LABEL_34;
    }
    if ( v21 == 58 && *(char *)(a1 + 16) < 0 )
    {
      while ( 1 )
      {
        v13 = sub_6C8C5(a1);
        ++v6;
        v21 = v13;
        if ( v13 == -1 )
          goto LABEL_34;
        v14 = sub_6C896(v13);
        if ( v14 >= v4 )
          break;
        v5 = v14 + v4 * v5;
      }
    }
  }
  (*(void (**)(int, int))(a1 + 4))(v21, a1);
  goto LABEL_34;
}
// 6C891: control flows out of bounds to 6C056
// 6C822: variable 'v20' is possibly undefined

//----- (0006C896) --------------------------------------------------------
int sub_6C896(int a1)
{
  int v2; // eax

  if ( a1 >= 48 && a1 <= 57 )
    return a1 - 48;
  v2 = tolower(a1);
  if ( v2 < 97 || v2 > 102 )
    return 16;
  else
    return v2 - 87;
}
// 6B5A3: using guessed type _DWORD tolower(_DWORD);

//----- (0006C8C5) --------------------------------------------------------
int sub_6C8C5(int a1)
{
  int v1; // eax
  int result; // eax

  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( !v1 )
    return -1;
  result = (*(int (**)(int))a1)(a1);
  if ( (*(_BYTE *)(a1 + 16) & 2) != 0 )
    return -1;
  return result;
}

//----- (0006D35C) --------------------------------------------------------
int sub_6D35C(unsigned __int16 a1)
{
  int result; // eax
  char v2[28]; // [esp+0h] [ebp-38h] BYREF
  int v3[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  //fix
  result = 0;
  //fix

  if ( a1 )
  {
    v3[0] = 257;
    v3[3] = a1;
    return int386(49, (uint32)v3, (uint32)v2);
  }
  return result;
}
// 62F78: using guessed type _DWORD int386(_DWORD, _DWORD, _DWORD);
// 6D35C: using guessed type char var_38[28];

//----- (0006D5EC) --------------------------------------------------------
int sub_6D5EC(int a1, int a2)
{
  return *(_DWORD *)a2;
}

//----- (0006DD6C) --------------------------------------------------------
void sub_6DD6C()
{
  ;
}

//----- (0006DD7D) --------------------------------------------------------
int sub_6DD7D(int a1, int a2, __int16 a3)
{
  if ( !*(int *)((char *)&dword_A01CC + 6 * a1) && !word_A01D0[3 * a1] )
    return 1;
  if ( !a2 && !a3 )
    return 2;
  sub_676B0(
    6 * a1,
    (int (*)(_DWORD))dword_A01EA[a1],
    *(int *)((char *)&dword_A01CC + 6 * a1),
    word_A01D0[3 * a1],
    a2,
    a3);
  return 0;
}
// A01CC: using guessed type int dword_A01CC;
// A01D0: using guessed type __int16 word_A01D0[13];
// A01EA: using guessed type int dword_A01EA[5];

//----- (0006DE12) --------------------------------------------------------
void sub_6DE12()
{
  ;
}

//----- (0006DE23) --------------------------------------------------------
void sub_6DE23()
{
  ;
}

//----- (0006DE34) --------------------------------------------------------
int sub_6DE34(
        __int16 a1,
        int a2,
        unsigned int a3,
        unsigned int a4,
        int *a5,
        unsigned int a6)
{
  int v7; // [esp+0h] [ebp-30h]
  unsigned __int16 v8; // [esp+4h] [ebp-2Ch]
  int v10; // [esp+10h] [ebp-20h]
  unsigned int v11; // [esp+18h] [ebp-18h]
  int v12; // [esp+1Ch] [ebp-14h]
  int v13; // [esp+28h] [ebp-8h]
  int v14; // [esp+2Ch] [ebp-4h]

  v12 = 0;
  v11 = 0;
  if ( a4 > 5 )
    return 10;
  if ( dword_A0230[a4] )
    return 9;
  if ( a3 < 0xE000 || a3 > 0xE200 )
    return 6;
  strcpy(&unk_A05D1, &byte_A04D2);
  strcat(&unk_A05D1, aHmidrv386);
  v14 = open((uint32)&unk_A05D1, 512);
  if ( v14 != -1 )
  {
    read(v14, (uint32)&unk_131BB0, 44);
    while ( 1 )
    {
      if ( v11 > dword_131BD0 || v12 )
      {
        close(v14);
        dword_A02C6[a4] = dword_131BA8;
        dword_A0230[a4] = 1;
        __writegsword(a6 + 4, v8);
        __writegsdword(a6, v7);
        return 0;
      }
      read(v14, (uint32)&unk_131B80, 48);
      v13 = dword_131BA4;
      if ( dword_131BA8 == a3 && byte_131BAD < 0 )
      {
        v12 = 1;
        v10 = (int)malloc(dword_131BA4);
        if ( !v10 )
          return 5;
        sub_674CD();
        sub_67557(a1, a2, v10);
        v8 = a1;
        v7 = sub_67582();
        read(v14, v10, v13);
        a2 = (int)a5;
        *a5 = v10;
      }
      else
      {
        lseek(v14, dword_131BA4, 1);
      }
      ++v11;
    }
  }
  return 15;
}
// 6E012: variable 'v8' is possibly undefined
// 6E01E: variable 'v7' is possibly undefined
// 6691E: using guessed type _DWORD close(_DWORD);
// 6692C: using guessed type _DWORD read(_DWORD, _DWORD, _DWORD);
// 6B992: using guessed type _DWORD lseek(_DWORD, _DWORD, char);
// 6CB61: using guessed type _DWORD malloc(_DWORD);
// 6DD0E: using guessed type _DWORD strcpy(_DWORD, _DWORD);
// 6DD33: using guessed type _DWORD strcat(_DWORD, _DWORD);
// A0230: using guessed type int dword_A0230[5];
// A02C6: using guessed type int dword_A02C6[5];
// A04D2: using guessed type char byte_A04D2;
// 131BA4: using guessed type int dword_131BA4;
// 131BA8: using guessed type int dword_131BA8;
// 131BAD: using guessed type char byte_131BAD;
// 131BD0: using guessed type int dword_131BD0;

//----- (0006E030) --------------------------------------------------------
int sub_6E030(unsigned int a1)
{
  if ( a1 > 5 )
    return 10;
  if ( !dword_A0230[a1] )
    return 10;
  dword_A0230[a1] = 0;
  return 0;
}
// A0230: using guessed type int dword_A0230[5];

//----- (0006E09A) --------------------------------------------------------
int sub_6E09A(__int16 a1, int a2, unsigned int a3, int *a4, unsigned int a5)
{
  int v6; // [esp+0h] [ebp-30h]
  unsigned __int16 v7; // [esp+4h] [ebp-2Ch]
  int v9; // [esp+10h] [ebp-20h]
  unsigned int v10; // [esp+18h] [ebp-18h]
  int v11; // [esp+1Ch] [ebp-14h]
  int v12; // [esp+28h] [ebp-8h]
  int v13; // [esp+2Ch] [ebp-4h]

  v11 = 0;
  v10 = 0;
  if ( a3 < 0x1000 || a3 > 0x1023 )
    return 6;
  strcpy(&unk_A05D1, &byte_A04D2);
  strcat(&unk_A05D1, aHmidrv386);
  v13 = open((uint32)&unk_A05D1, 512);
  if ( v13 != -1 )
  {
    read(v13, (uint32)&unk_131BB0, 44);
    while ( 1 )
    {
      if ( v10 > dword_131BD0 || v11 )
      {
        close(v13);
        __writegsword(a5 + 4, v7);
        __writegsdword(a5, v6);
        return 0;
      }
      read(v13, (uint32)&unk_131B80, 48);
      v12 = dword_131BA4;
      if ( dword_131BA8 == a3 )
      {
        v11 = 1;
        v9 = (int)malloc(dword_131BA4);
        if ( !v9 )
          return 5;
        sub_674CD();
        sub_67557(a1, a2, v9);
        v7 = a1;
        v6 = sub_67582();
        read(v13, v9, v12);
        a2 = (int)a4;
        *a4 = v9;
      }
      else
      {
        lseek(v13, dword_131BA4, 1);
      }
      ++v10;
    }
  }
  return 15;
}
// 6E21E: variable 'v7' is possibly undefined
// 6E22A: variable 'v6' is possibly undefined
// 6691E: using guessed type _DWORD close(_DWORD);
// 6692C: using guessed type _DWORD read(_DWORD, _DWORD, _DWORD);
// 6B992: using guessed type _DWORD lseek(_DWORD, _DWORD, char);
// 6CB61: using guessed type _DWORD malloc(_DWORD);
// 6DD0E: using guessed type _DWORD strcpy(_DWORD, _DWORD);
// 6DD33: using guessed type _DWORD strcat(_DWORD, _DWORD);
// A04D2: using guessed type char byte_A04D2;
// 131BA4: using guessed type int dword_131BA4;
// 131BA8: using guessed type int dword_131BA8;
// 131BD0: using guessed type int dword_131BD0;

//----- (0006E23C) --------------------------------------------------------
int sub_6E23C(int a1, __int16 a2)
{
  if ( a1 || a2 )
    return 0;
  else
    return 2;
}

//----- (0006E295) --------------------------------------------------------
void sub_6E295()
{
  ;
}

//----- (0006E2A6) --------------------------------------------------------
void sub_6E2A6()
{
  ;
}

//----- (0006E33D) --------------------------------------------------------
void sub_6E33D()
{
  ;
}

//----- (0006E34E) --------------------------------------------------------
void sub_6E34E()
{
  ;
}

//----- (0006E3B9) --------------------------------------------------------
void sub_6E3B9()
{
  ;
}

//----- (0006E5A0) --------------------------------------------------------
void *sub_6E5A0()
{
  return &unk_131BE0;
}

//----- (0006E5A6) --------------------------------------------------------
void *sub_6E5A6()
{
  return &unk_131BDC;
}

//----- (0006E5B2) --------------------------------------------------------
int sub_6E5B2()
{
  unsigned __int16 i; // si
  int v1; // eax

  if ( dword_A1F24 )
    dword_A1734[0] = (int)&dword_A1F24;
  for ( i = 0; i < 0x10u; ++i )
  {
    v1 = 15 * i;
    byte_A1B39[v1 * 2] = 0x80;
    byte_A1B36[v1 * 2] = 0;
    byte_A1B3A[v1 * 2] = 127;
    byte_A1B3B[v1 * 2] = 100;
    word_A1B3C[v1] = 0;
    word_A1B3E[v1] = 0;
    word_A1B40[v1] = 512;
    word_A1B4C[v1] = -1;
    word_A1B4E[v1] = -1;
    word_A1B4A[v1] = 0;
    word_A1B42[v1] = 0;
    word_A1B44[v1] = 0;
    word_A1B46[v1] = 0;
    word_A1B48[v1] = -1;
    sub_6FC44(0, i);
  }
  return 0;
}
// A1734: using guessed type int dword_A1734[64];
// A1B3C: using guessed type __int16 word_A1B3C[];
// A1B3E: using guessed type __int16 word_A1B3E[];
// A1B40: using guessed type __int16 word_A1B40[];
// A1B42: using guessed type __int16 word_A1B42[];
// A1B44: using guessed type __int16 word_A1B44[];
// A1B46: using guessed type __int16 word_A1B46[];
// A1B48: using guessed type __int16 word_A1B48[];
// A1B4A: using guessed type __int16 word_A1B4A[];
// A1B4C: using guessed type __int16 word_A1B4C[];
// A1B4E: using guessed type __int16 word_A1B4E[];
// A1F24: using guessed type int dword_A1F24;

//----- (0006E65B) --------------------------------------------------------
unsigned int __stdcall sub_6E65B(unsigned __int16 a1, unsigned __int16 a2)
{
  unsigned int v2; // kr00_4
  int v3; // ebx
  unsigned int result; // eax

  v2 = __readeflags();
  if ( (v2 & 0x200) != 0 )
    _disable();
  v3 = a2;
  __outword(word_A160A + 2050, ((int)a2 >> 7) & 0xE0 | a2 & 0x1F);
  __outword((a2 & 0xC00) + ((v3 >> 8) & 2 | word_A160A), a1);
  result = v2;
  if ( (v2 & 0x200) != 0 )
    _enable();
  return result;
}
// A160A: using guessed type __int16 word_A160A;

//----- (0006E6BF) --------------------------------------------------------
int __stdcall sub_6E6BF(unsigned __int16 a1)
{
  unsigned int v1; // kr00_4
  int v2; // ebx
  int result; // eax

  v1 = __readeflags();
  if ( (v1 & 0x200) != 0 )
    _disable();
  v2 = a1;
  __outword(word_A160A + 2050, ((int)a1 >> 7) & 0xE0 | a1 & 0x1F);
  LOWORD(result) = __inword((word_A160A | (v2 >> 8) & 2) + (a1 & 0xC00));
  if ( (v1 & 0x200) != 0 )
    _enable();
  return (unsigned __int16)result;
}
// A160A: using guessed type __int16 word_A160A;

//----- (0006E727) --------------------------------------------------------
void __stdcall sub_6E727(unsigned __int16 a1, unsigned __int16 a2)
{
  unsigned int v2; // kr00_4
  int v3; // ebx

  v2 = __readeflags();
  if ( (v2 & 0x200) != 0 )
    _disable();
  v3 = a2;
  __outword(word_A160A + 2050, a2 & 0x1F | ((int)a2 >> 7) & 0xE0);
  __outword((a2 & 0xC00) + ((v3 >> 8) & 2 | word_A160A), a1);
  JUMPOUT(0x6E6B2);
}
// 6E79B: control flows out of bounds to 6E6B2
// A160A: using guessed type __int16 word_A160A;

//----- (0006E7A0) --------------------------------------------------------
int __stdcall sub_6E7A0(unsigned __int16 a1)
{
  unsigned int v1; // kr00_4
  int v2; // ebx
  int v3; // ecx
  __int16 v4; // si
  unsigned __int16 v5; // ax
  int v6; // ebx
  unsigned __int16 v7; // ax
  int v8; // ebx

  v1 = __readeflags();
  if ( (v1 & 0x200) != 0 )
    _disable();
  v2 = a1;
  __outword(word_A160A + 2050, ((int)a1 >> 7) & 0xE0 | a1 & 0x1F);
  v3 = (v2 >> 8) & 2;
  v4 = a1 & 0xC00;
  v5 = __inword((a1 & 0xC00) + (v3 | word_A160A));
  v6 = v5;
  v7 = __inword(v4 + (v3 | word_A160A) + 2);
  v8 = (v7 << 16) | v6;
  if ( (v1 & 0x200) != 0 )
    _enable();
  return v8;
}
// A160A: using guessed type __int16 word_A160A;

//----- (0006E822) --------------------------------------------------------
void __stdcall sub_6E822(int a1, __int16 a2, __int16 a3)
{
  unsigned int v3; // kr00_4
  unsigned __int16 j; // di
  unsigned int v5; // esi
  unsigned int v6; // eax
  unsigned __int16 v7; // ax
  unsigned int v8; // esi
  unsigned int v9; // [esp+4h] [ebp-14h]
  unsigned int v10; // [esp+8h] [ebp-10h]
  __int16 v11; // [esp+Ch] [ebp-Ch]
  unsigned __int16 i; // [esp+10h] [ebp-8h]
  unsigned __int16 v13; // [esp+14h] [ebp-4h]

  v3 = __readeflags();
  if ( (v3 & 0x200) != 0 )
    _disable();
  v10 = -1;
  v13 = word_A1608 - 1;
  for ( i = 0; i < 3u; ++i )
  {
    for ( j = i; j < (unsigned __int16)word_A1608; j += 3 )
    {
      v11 = word_A18B4[10 * j];
      if ( (unsigned __int16)v11 < 0xFF00u )
      {
        v9 = sub_6E7A0(j | 0x7000) & 0xFFFFFF;
        v5 = sub_6E7A0(j | 0x6000) & 0xFFFFFF;
        if ( v5 + 10 > v9 )
        {
          v6 = sub_6E7A0(j | 0x400) & 0xFFFFFF;
          if ( v6 >= v5 && v6 <= v9 )
          {
            v13 = j;
            goto LABEL_22;
          }
        }
      }
      if ( v11 == -1 || (unsigned __int16)v11 < 0x1000u )
      {
        v7 = (unsigned int)sub_6E7A0(j | 0x3000) >> 16;
        v8 = v7;
        if ( v11 != -1 )
          v8 = v7 + 1280;
        if ( (((unsigned __int16)sub_6E6BF(j | 0x5400) >> 8) & 0x80u) == 0 )
          v8 += 2688;
        if ( v8 < v10 )
        {
          v10 = v8;
          v13 = j;
        }
      }
    }
  }
LABEL_22:
  word_A18B4[10 * v13] = a2 | (a3 << 8);
  sub_6E65B(0x807Fu, v13 | 0x5400);
  if ( (v3 & 0x200) != 0 )
    _enable();
  JUMPOUT(0x6F3AD);
}
// 6E971: control flows out of bounds to 6F3AD
// A1608: using guessed type __int16 word_A1608;
// A18B4: using guessed type __int16 word_A18B4[];

//----- (0006E976) --------------------------------------------------------
int __stdcall sub_6E976(unsigned __int16 a1, unsigned __int16 a2)
{
  if ( (unsigned __int8)a1 > a2 || (unsigned __int16)((int)a1 >> 8) < a2 )
    JUMPOUT(0x6F84A);
  return 1;
}
// 6E98B: control flows out of bounds to 6F84A

//----- (0006E9A4) --------------------------------------------------------
int __stdcall sub_6E9A4(int a1, unsigned __int16 a2, unsigned __int16 a3)
{
  int result; // eax

  if ( a2 <= 3u )
  {
    result = (int)&unk_A1D34 + 124 * a3 + 4 * a2;
    *(_DWORD *)result += a1;
  }
  else if ( a2 == 4 )
  {
    result = 124 * a3;
    *(__int16 *)((char *)&word_A1D44 + result) += a1;
  }
  else
  {
    result = (int)&unk_A1D34 + 124 * a3 + 2 * a2 + 8;
    *(_WORD *)result = a1;
  }
  return result;
}
// A1D44: using guessed type __int16 word_A1D44;

//----- (0006EA0F) --------------------------------------------------------
int __stdcall sub_6EA0F(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4)
{
  int v5; // esi
  int v6; // esi
  int v7; // esi
  int v8; // eax
  __int16 v9; // di
  unsigned __int16 v10; // ax
  unsigned __int16 *v11; // esi
  int v12; // esi
  unsigned __int16 v13; // dx
  int v14; // esi
  int v15; // eax
  unsigned __int16 v16; // ax
  __int16 k; // di
  int v18; // edx
  int v19; // [esp+4h] [ebp-38h]
  unsigned __int16 v20; // [esp+8h] [ebp-34h]
  unsigned __int16 v21; // [esp+Ch] [ebp-30h]
  int v22; // [esp+10h] [ebp-2Ch]
  unsigned __int16 v23; // [esp+18h] [ebp-24h]
  int v24; // [esp+1Ch] [ebp-20h]
  unsigned __int16 v25; // [esp+20h] [ebp-1Ch]
  unsigned __int16 i; // [esp+24h] [ebp-18h]
  unsigned __int16 j; // [esp+28h] [ebp-14h]
  unsigned __int16 v28; // [esp+2Ch] [ebp-10h]
  int v29; // [esp+30h] [ebp-Ch]
  signed __int16 v30; // [esp+34h] [ebp-8h]
  int v31; // [esp+38h] [ebp-4h]

  if ( !dword_A1734[a4] )
    return 0;
  v29 = 0;
  v31 = 0;
  v5 = 4 * a3 + *(_DWORD *)dword_A1734[a4];
  v21 = *(_WORD *)(v5 + 6);
  v25 = *(_WORD *)(v5 + 2);
LABEL_35:
  if ( v25 < v21 )
  {
    v19 = 0;
    v22 = v31;
    v6 = *(_DWORD *)(dword_A1734[a4] + 4);
    v23 = *(_WORD *)(v6 + 2 * v25 + 2);
    for ( i = *(_WORD *)(v6 + 2 * v25); ; ++i )
    {
      if ( i >= v23 )
        goto LABEL_34;
      v7 = 3 * i;
      v8 = *(_DWORD *)(dword_A1734[a4] + 8);
      v9 = *(unsigned __int8 *)(v7 + v8);
      v10 = *(_WORD *)(v7 + v8 + 1);
      v30 = v10;
      if ( v9 == 43 && !sub_6E976(v10, a2) )
        goto LABEL_34;
      if ( v9 == 44 && !sub_6E976(v30, a1) )
        goto LABEL_34;
      word_A1834[2 * (__int16)v31] = v9;
      word_A1836[2 * (__int16)v31++] = v30;
LABEL_10:
      if ( v19 )
      {
LABEL_34:
        ++v25;
        goto LABEL_35;
      }
      if ( v9 == 41 )
      {
        v11 = (unsigned __int16 *)(*(_DWORD *)(dword_A1734[a4] + 12) + 2 * v30);
        v20 = v11[1];
        v28 = *v11;
        while ( 2 )
        {
          if ( v28 < v20 )
          {
            v24 = v31;
            v12 = *(_DWORD *)(dword_A1734[a4] + 16);
            v13 = *(_WORD *)(v12 + 2 * v28 + 2);
            for ( j = *(_WORD *)(v12 + 2 * v28); ; ++j )
            {
              if ( j >= v13 )
                goto LABEL_29;
              v14 = 3 * j;
              v15 = *(_DWORD *)(dword_A1734[a4] + 20);
              v9 = *(unsigned __int8 *)(v14 + v15);
              v16 = *(_WORD *)(v14 + v15 + 1);
              v30 = v16;
              if ( v9 == 41 )
                goto LABEL_10;
              if ( v9 == 53 )
                break;
              if ( v9 == 43 && !sub_6E976(v16, a2) || v9 == 44 && !sub_6E976(v30, a1) )
                goto LABEL_29;
              word_A1834[2 * (__int16)v31] = v9;
              word_A1836[2 * (__int16)v31++] = v30;
            }
            v19 = 1;
            qmemcpy((char *)&unk_A1D34 + 124 * (__int16)v29, &unk_A0E84, 0x7Cu);
            sub_6E9A4(a2, 0x2Eu, v29);
            sub_6E9A4(a1, 0x2Fu, v29);
            for ( k = 0; k < (__int16)v31; ++k )
              sub_6E9A4(word_A1836[2 * k], word_A1834[2 * k], v29);
            v18 = 16 * v30;
            sub_6E9A4(*(_DWORD *)(v18 + *(_DWORD *)(dword_A1734[a4] + 24)), 0, v29);
            sub_6E9A4(*(_DWORD *)(v18 + *(_DWORD *)(dword_A1734[a4] + 24) + 4), 1u, v29);
            sub_6E9A4(*(_DWORD *)(v18 + *(_DWORD *)(dword_A1734[a4] + 24) + 8), 2u, v29);
            sub_6E9A4(*(_DWORD *)(v18 + *(_DWORD *)(dword_A1734[a4] + 24) + 12), 3u, v29);
            if ( dword_A1728 )
              dword_A1728((unsigned __int16)v29 | 0x8000);
            if ( (_WORD)++v29 != 4 )
            {
              v31 = v24;
LABEL_29:
              ++v28;
              continue;
            }
            return v29;
          }
          break;
        }
        v31 = v22;
      }
    }
  }
  return v29;
}
// A1728: using guessed type int (__stdcall *dword_A1728)(_DWORD);
// A1734: using guessed type int dword_A1734[64];
// A1834: using guessed type __int16 word_A1834[];
// A1836: using guessed type __int16 word_A1836[63];

//----- (0006ED47) --------------------------------------------------------
int __stdcall sub_6ED47(unsigned __int16 a1)
{
  int i; // edx

  for ( i = 0; (__int16)i < 128; ++i )
  {
    if ( a1 > (unsigned __int16)word_A0F00[(__int16)i] )
      return i;
  }
  return 127;
}
// A0F00: using guessed type __int16 word_A0F00[128];

//----- (0006ED75) --------------------------------------------------------
int __stdcall sub_6ED75(__int16 a1)
{
  __int16 v1; // si
  int v2; // ebx

  v1 = a1;
  v2 = 0;
  if ( a1 < 0 )
  {
    while ( v1 < 0 )
    {
      --v2;
      v1 += 1200;
    }
  }
  else
  {
    v2 = a1 / 1200;
  }
  if ( (__int16)v2 > 1 )
    v2 = 1;
  return ((v2 + 14) << 12) | (((v1 % 1200) << 12) / 1200);
}

//----- (0006EDD0) --------------------------------------------------------
int sub_6EDD0(int a1, int a2, int a3, int a4, unsigned __int16 a5, int a6, int a7)
{
  __int16 *v7; // edi
  __int16 i; // si
  __int16 v10; // eax^2
  char v11; // al
  int v12; // eax
  int v13; // edx
  char *v14; // esi
  unsigned int v15; // eax
  __int16 v16; // ax
  int v17; // et2
  int v18; // eax
  int v19; // eax
  int v20; // ebx
  int v21; // edx
  int v22; // eax
  unsigned __int16 v23; // cx
  __int64 v24; // rax
  int v25; // ebx
  int v26; // eax
  __int16 v27; // ax
  unsigned __int16 v28; // ax
  _BYTE v29[4]; // [esp+4h] [ebp-3Ch]
  int v30; // [esp+8h] [ebp-38h]
  int v31; // [esp+Ch] [ebp-34h]
  int v32; // [esp+10h] [ebp-30h]
  int v33; // [esp+14h] [ebp-2Ch]
  int v34; // [esp+18h] [ebp-28h]
  int v35; // [esp+1Ch] [ebp-24h]
  int v36; // [esp+20h] [ebp-20h]
  int v37; // [esp+24h] [ebp-1Ch]
  int v38; // [esp+28h] [ebp-18h]
  int v39; // [esp+2Ch] [ebp-14h]
  int v40; // [esp+30h] [ebp-10h]
  int v41; // [esp+34h] [ebp-Ch]
  int v42; // [esp+38h] [ebp-8h]
  int v43; // [esp+3Ch] [ebp-4h]

  //fix
  v10 = 0;
  v11 = 0;
  //fix

  v7 = &word_A1B34[15 * (a7 & 0xF)];
  v36 = sub_6EA0F(a5, a6, *v7, v7[8]);
  if ( !(_WORD)v36 )
    return 1;
  for ( i = 0; i < (__int16)v36; ++i )
  {
    sub_6E822(0, 254, 255);
    HIWORD(a2) = v10;
    v29[i] = v11;
  }
  v38 = 0;
  v35 = a7 << 8;
  HIWORD(v12) = HIWORD(a7);
  LOWORD(v12) = a7 & 0xF;
  v37 = v12;
  while ( (__int16)v38 < (__int16)v36 )
  {
    LOWORD(a2) = (unsigned __int8)v29[(__int16)v38];
    v41 = a2;
    v13 = 20 * (unsigned __int16)a2;
    v33 = (int)word_A18B4 + v13;
    v14 = (char *)&unk_A1D34 + 124 * (__int16)v38;
    v15 = sub_6E65B(0xE000u, v41 | 0x800);
    if ( (_WORD)v37 == 9 )
    {
      if ( *((_WORD *)v14 + 30) == 127 )
        *((_WORD *)v14 + 29) = -18433;
      if ( *((_WORD *)v14 + 38) == 127 )
        *((_WORD *)v14 + 37) = -18433;
    }
    else if ( *((__int16 *)v14 + 38) < 125 )
    {
      v16 = *((_WORD *)v14 + 51);
      if ( (unsigned __int16)v16 < 0x46u )
        v16 = 70;
      v17 = (*((__int16 *)v14 + 12) * v16 + 64) % 127;
      v15 = (*((__int16 *)v14 + 12) * v16 + 64) / 127;
      HIWORD(v13) = HIWORD(v17);
      *((_WORD *)v14 + 12) = v15;
    }
    LOWORD(v15) = *((_WORD *)v14 + 55) + *((_WORD *)v14 + 50);
    v18 = 100 * v15;
    LOWORD(v13) = *((_WORD *)v14 + 56);
    v39 = v18 + v13;
    LOWORD(v18) = *((_WORD *)v14 + 59);
    v39 -= v18;
    if ( *((_WORD *)v14 + 60) == 1 )
    {
      HIWORD(v19) = HIWORD(v39);
      LOWORD(v19) = (__int16)v39 / 2;
      v39 = v19;
    }
    v31 = *((unsigned __int16 *)v14 + 40);
    if ( (_WORD)v37 != 9 )
    {
      *((_WORD *)v14 + 39) -= *((_WORD *)v14 + 43) * (*((_WORD *)v14 + 50) - 60);
      if ( *((__int16 *)v14 + 39) < 0 )
        *((_WORD *)v14 + 39) = 0;
      v31 -= *((__int16 *)v14 + 44) * (*((__int16 *)v14 + 50) - 60);
      if ( v31 < 0 )
        v31 = 0;
      if ( v31 > 0xFFFF )
        v31 = 0xFFFF;
    }
    *((_WORD *)v14 + 39) = 127 - *((__int16 *)v14 + 39) / 92;
    *((_WORD *)v14 + 40) = sub_6ED47(v31);
    v34 = *(_DWORD *)v14 - 46;
    if ( (v14[116] & 1) != 0 )
    {
      v32 = *((_DWORD *)v14 + 2);
      v30 = *((_DWORD *)v14 + 3) + 1;
      if ( *((_DWORD *)v14 + 1) - *((_DWORD *)v14 + 3) >= 10 )
      {
        *(_DWORD *)(v33 + 16) = *((_DWORD *)v14 + 1) + 1;
        goto LABEL_30;
      }
    }
    else
    {
      v32 = *((_DWORD *)v14 + 3) + 6;
      v30 = *((_DWORD *)v14 + 3) + 10;
    }
    *(_DWORD *)(v33 + 16) = 0;
LABEL_30:
    v20 = sub_6ED75(*((_WORD *)v14 + 8) + v39);
    v42 = v20;
    *(_WORD *)(v33 + 12) = v20;
    v21 = v33;
    *(_BYTE *)(v33 + 2) = *((_BYTE *)v7 + 18);
    *(_BYTE *)(v21 + 3) = *(_BYTE *)v7;
    *(_WORD *)(v21 + 6) = *((_WORD *)v14 + 52);
    *(_WORD *)(v21 + 4) = *((_WORD *)v14 + 51);
    *(_WORD *)(v21 + 14) = *((_WORD *)v14 + 9);
    *(_WORD *)(v21 + 8) = *((_WORD *)v14 + 42);
    *(_WORD *)(v21 + 10) = *((_WORD *)v14 + 34);
    if ( v7[7] )
    {
      v22 = v7[7] + (unsigned __int16)v20;
      if ( v22 <= 0xFFFF )
      {
        LOWORD(v22) = v7[7];
        v42 = v20 + v22;
      }
      else
      {
        v42 = 0xFFFF;
      }
    }
    v23 = (unsigned __int8)byte_A1000[(unsigned __int8)v14[102]];
    v43 = (unsigned __int8)byte_A1080[*((unsigned __int8 *)v7 + 7)];
    v24 = 3 * (127 - *((__int16 *)v14 + 52));
    v25 = (int)(v24 - (__CFSHL__(HIDWORD(v24), 3) + 8 * HIDWORD(v24))) >> 3;
    v40 = 8 * (unsigned __int16)(v25 + v23 + v43) / 3;
    if ( (unsigned __int16)v40 < 0xFFu && v23 < 0x32u && (unsigned __int16)v25 < 0x2Fu )
    {
      v43 = (unsigned __int8)byte_A1100[*((unsigned __int8 *)v7 + 6)];
      v40 = (unsigned __int16)v40 + (unsigned __int16)v43 * (255 - (unsigned __int16)v40) / 127;
    }
    else
    {
      v40 = 255;
    }
    sub_6E65B(0x80u, v41 | 0x5400);
    sub_6E727(0xFFFFu, v41 | 0x3000);
    sub_6E65B(*((_WORD *)v14 + 37), v41 | 0x4400);
    sub_6E65B((*((_WORD *)v14 + 38) | (*((_WORD *)v14 + 39) << 8)) & 0x7F7F, v41 | 0x4600);
    sub_6E65B(*((_WORD *)v14 + 29), v41 | 0x6400);
    sub_6E65B(*((_WORD *)v14 + 30) | (*((_WORD *)v14 + 31) << 8), v41 | 0x6600);
    sub_6E65B(*((_WORD *)v14 + 32) | (*((_WORD *)v14 + 33) << 8), v41 | 0x7400);
    sub_6E65B(v42, v41 | 0x800);
    sub_6E65B(v40 | (*((_WORD *)v14 + 12) << 8), v41 | 0x1800);
    sub_6E65B(*((_WORD *)v14 + 25), v41 | 0x5600);
    sub_6E65B(*((_WORD *)v14 + 27), v41 | 0x7600);
    sub_6E65B(*((_WORD *)v14 + 15) | (*((_WORD *)v14 + 11) << 8), v41 | 0x2800);
    v31 = v7[5] + v7[4] + *((__int16 *)v14 + 9);
    if ( v31 > 127 )
      v31 = 127;
    sub_6E65B(*((_WORD *)v14 + 14) | ((_WORD)v31 << 8), v41 | 0x3800);
    sub_6E65B(*((_WORD *)v14 + 26) | (*((_WORD *)v14 + 17) << 8), v41 | 0x4800);
    sub_6E65B(*((_WORD *)v14 + 28) | (*((_WORD *)v14 + 10) << 8), v41 | 0x5800);
    v26 = sub_6E7A0(v41 | 0x1000);
    BYTE1(v26) = 0;
    v31 = v26;
    v27 = *((_WORD *)v14 + 20) + *((unsigned __int8 *)v7 + 3);
    if ( (unsigned __int16)v27 > 0xFFu )
      v27 = 255;
    sub_6E727(v31 | (v27 << 8), v41 | 0x1000);
    v31 = *((unsigned __int8 *)v7 + 5) + 255 - 2 * *((__int16 *)v14 + 21) - 129;
    if ( v31 > 255 )
      v31 = 255;
    if ( v31 < 0 )
      v31 = 0;
    v32 |= v31 << 24;
    sub_6E727(v32, v41 | 0x6000);
    v28 = *((_WORD *)v14 + 19) + *((unsigned __int8 *)v7 + 4);
    if ( v28 > 0xFFu )
      v28 = 255;
    v30 |= v28 << 24;
    sub_6E727(v30, v41 | 0x7000);
    v34 |= *((__int16 *)v14 + 13) << 28;
    sub_6E727(v34, v41 | 0x400);
    sub_6E65B(*((_WORD *)v14 + 40) | (*((_WORD *)v14 + 41) << 8), v41 | 0x5400);
    HIWORD(a2) = HIWORD(a6) | HIWORD(v35);
    *(_WORD *)v33 = a6 | v35;
    ++v38;
  }
  return 0;
}
// 6EE29: variable 'v10' is possibly undefined
// 6EE2E: variable 'v11' is possibly undefined
// A18B4: using guessed type __int16 word_A18B4[];
// A1B34: using guessed type __int16 word_A1B34[];

//----- (0006F3B3) --------------------------------------------------------
void __stdcall sub_6F3B3(int a1, __int16 a2, unsigned __int16 a3)
{
  unsigned __int16 i; // di
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // ax
  unsigned __int16 v6; // ax

  for ( i = 0; i < (unsigned __int16)word_A1608; ++i )
  {
    if ( (int)(unsigned __int16)word_A18B4[10 * i] >> 8 != 255 )
    {
      v4 = word_A18B4[10 * i];
      HIBYTE(v4) &= 0xFu;
      if ( v4 == (unsigned __int16)((a3 << 8) | a2) )
      {
        if ( byte_A1B36[30 * a3] )
        {
          LOBYTE(word_A18B4[10 * i]) = -1;
        }
        else
        {
          word_A18B4[10 * i] = -1;
          v5 = word_A18BC[10 * i];
          HIBYTE(v5) |= 0x80u;
          sub_6E65B(v5, i | 0x5400);
          v6 = word_A18BE[10 * i];
          HIBYTE(v6) |= 0x80u;
          sub_6E65B(v6, i | 0x7400);
          if ( dword_A18C4[5 * i] )
          {
            sub_6E7A0(i | 0x7000);
            sub_6E727(LOWORD(dword_A18C4[5 * i]) + 4, i | 0x7000);
            sub_6E7A0(i | 0x6000);
            sub_6E727(dword_A18C4[5 * i], i | 0x6000);
          }
        }
      }
    }
  }
  JUMPOUT(0x6F3AB);
}
// 6F4C6: control flows out of bounds to 6F3AB
// A1608: using guessed type __int16 word_A1608;
// A18B4: using guessed type __int16 word_A18B4[];
// A18BC: using guessed type __int16 word_A18BC[];
// A18BE: using guessed type __int16 word_A18BE[];
// A18C4: using guessed type int dword_A18C4[156];

//----- (0006F4CB) --------------------------------------------------------
void sub_6F4CB(
        int a1,
        int a2,
        int a3,
        int a4,
        unsigned __int16 a5,
        unsigned __int16 a6,
        unsigned __int16 a7)
{
  if ( a5 )
    sub_6EDD0(a5, a2, a3, a4, a5, a6, a7);
  else
    sub_6F3B3(0, a6, a7);
}

//----- (0006F502) --------------------------------------------------------
void __stdcall sub_6F502(__int16 a1, unsigned __int16 a2)
{
  if ( word_A1B48[15 * a2] == -1 )
    word_A1B46[15 * a2] = a1;
  word_A1B48[15 * a2] = a1;
  JUMPOUT(0x6F84A);
}
// 6F531: control flows out of bounds to 6F84A
// A1B46: using guessed type __int16 word_A1B46[];
// A1B48: using guessed type __int16 word_A1B48[];

//----- (0006F536) --------------------------------------------------------
void __stdcall sub_6F536(__int16 a1, unsigned __int16 a2)
{
  byte_A1B37[30 * a2] = 2 * ((unsigned __int16)(45 * a1) / 0x64u);
  JUMPOUT(0x6F84A);
}
// 6F55A: control flows out of bounds to 6F84A

//----- (0006F55F) --------------------------------------------------------
void __stdcall sub_6F55F(__int16 a1, unsigned __int16 a2)
{
  byte_A1B38[30 * a2] = 2 * ((unsigned __int16)(45 * a1) / 0x64u);
  JUMPOUT(0x6F84A);
}
// 6F583: control flows out of bounds to 6F84A

//----- (0006F588) --------------------------------------------------------
void __stdcall sub_6F588(char a1, unsigned __int16 a2)
{
  byte_A1B39[30 * a2] = -1 - 2 * a1 - 1;
  JUMPOUT(0x6F84A);
}
// 6F5A3: control flows out of bounds to 6F84A

//----- (0006F5A8) --------------------------------------------------------
int __stdcall sub_6F5A8(unsigned __int8 a1, unsigned __int16 a2)
{
  unsigned __int16 i; // di
  __int64 v3; // rax
  int v4; // ecx
  int v5; // esi
  __int16 v6; // si
  int v7; // eax
  unsigned __int16 v9; // [esp+4h] [ebp-4h]

  byte_A1B3B[30 * a2] = a1;
  for ( i = 0; i < (unsigned __int16)word_A1608; ++i )
  {
    if ( (int)(unsigned __int16)word_A18B4[10 * i] >> 8 == a2 )
    {
      v9 = (unsigned __int8)byte_A1000[(unsigned __int8)byte_A18B8[20 * i]];
      v3 = 3 * (127 - (unsigned __int16)word_A18BA[10 * i]);
      v4 = (int)(v3 - (__CFSHL__(HIDWORD(v3), 3) + 8 * HIDWORD(v3))) >> 3;
      v5 = 8 * (unsigned __int16)(v4 + v9 + (unsigned __int8)byte_A1080[a1]) / 3;
      if ( (unsigned __int16)v5 < 0xFFu && v9 < 0x32u && (unsigned __int16)v4 < 0x2Fu )
        v6 = v5 + (255 - (unsigned __int16)v5) * (unsigned __int8)byte_A1100[(unsigned __int8)byte_A1B3A[30 * a2]] / 127;
      else
        v6 = 255;
      v7 = sub_6E6BF(i | 0x1800);
      LOBYTE(v7) = 0;
      sub_6E65B(v7 | v6, i | 0x1800);
    }
  }
  return 0;
}
// A1608: using guessed type __int16 word_A1608;
// A18B4: using guessed type __int16 word_A18B4[];
// A18BA: using guessed type __int16 word_A18BA[];

//----- (0006F6AF) --------------------------------------------------------
int __stdcall sub_6F6AF(char a1, unsigned __int16 a2)
{
  int v2; // eax

  v2 = 30 * a2;
  byte_A1B3A[v2] = a1;
  return sub_6F5A8(byte_A1B3B[v2], a2);
}

//----- (0006F6D8) --------------------------------------------------------
int __stdcall sub_6F6D8(unsigned __int16 a1, unsigned __int16 a2)
{
  unsigned __int16 i; // si
  unsigned __int16 v3; // bx
  unsigned __int16 v4; // ax

  if ( a1 >= 0x40u )
  {
    byte_A1B36[30 * a2] = 1;
  }
  else
  {
    byte_A1B36[30 * (a2 & 0xF)] = 0;
    for ( i = 0; i < (unsigned __int16)word_A1608; ++i )
    {
      v3 = word_A18B4[10 * i];
      if ( (unsigned __int8)v3 == 255 && (int)v3 >> 8 != 255 && (HIBYTE(v3) & 0xF) == a2 )
      {
        word_A18B4[10 * i] = -1;
        v4 = word_A18BC[10 * i];
        HIBYTE(v4) |= 0x80u;
        sub_6E65B(v4, i | 0x5400);
      }
    }
  }
  return 0;
}
// A1608: using guessed type __int16 word_A1608;
// A18B4: using guessed type __int16 word_A18B4[];
// A18BC: using guessed type __int16 word_A18BC[];

//----- (0006F77A) --------------------------------------------------------
void __stdcall sub_6F77A(unsigned __int16 a1, unsigned __int16 a2)
{
  int v2; // edx
  __int16 v3; // si
  unsigned __int8 v4; // al
  unsigned __int16 i; // [esp+0h] [ebp-4h]
  __int16 v6; // [esp+14h] [ebp+10h]

  v6 = a1 / 0x1Eu;
  word_A1B3C[15 * a2] = v6;
  for ( i = 0; i < (unsigned __int16)word_A1608; ++i )
  {
    v2 = (int)(unsigned __int16)word_A18B4[10 * i] >> 8;
    if ( (_WORD)v2 != 255 && (v2 & 0xF) == a2 )
    {
      v3 = word_A18C2[10 * i] + word_A1B3E[15 * a2] + v6;
      if ( v3 > 127 )
        v3 = 127;
      v4 = sub_6E6BF(i | 0x3800);
      sub_6E65B(v4 | (unsigned __int16)(v3 << 8), i | 0x3800);
    }
  }
  JUMPOUT(0x6F6A7);
}
// 6F81F: control flows out of bounds to 6F6A7
// A1608: using guessed type __int16 word_A1608;
// A18B4: using guessed type __int16 word_A18B4[];
// A18C2: using guessed type __int16 word_A18C2[];
// A1B3C: using guessed type __int16 word_A1B3C[];
// A1B3E: using guessed type __int16 word_A1B3E[];

//----- (0006F824) --------------------------------------------------------
int __stdcall sub_6F824(unsigned __int8 a1, unsigned __int16 a2)
{
  int v2; // eax

  v2 = 15 * a2;
  word_A1B4A[v2] = 256;
  LOBYTE(word_A1B4C[v2]) = 0;
  word_A1B4C[v2] |= a1;
  return 0;
}
// A1B4A: using guessed type __int16 word_A1B4A[];
// A1B4C: using guessed type __int16 word_A1B4C[];

//----- (0006F850) --------------------------------------------------------
void __stdcall sub_6F850(int a1, unsigned __int16 a2)
{
  int v2; // eax

  v2 = 15 * a2;
  word_A1B4A[v2] = 256;
  HIBYTE(word_A1B4C[v2]) = 0;
  JUMPOUT(0x6F843);
}
// 6F870: control flows out of bounds to 6F843
// A1B4A: using guessed type __int16 word_A1B4A[];
// A1B4C: using guessed type __int16 word_A1B4C[];

//----- (0006F872) --------------------------------------------------------
int __stdcall sub_6F872(__int16 a1, unsigned __int16 a2)
{
  __int16 v2; // bx

  v2 = word_A1B4A[15 * a2];
  if ( (unsigned __int16)v2 >= 0x100u )
  {
    if ( (unsigned __int16)v2 <= 0x100u )
    {
      if ( !word_A1B4C[15 * a2] )
      {
        HIBYTE(word_A1B40[15 * a2]) = 0;
        word_A1B40[15 * a2] |= a1 << 8;
        return 0;
      }
    }
    else if ( v2 == 512 && dword_A1728 )
    {
      HIBYTE(word_A1B50[15 * a2]) = 0;
      LOBYTE(word_A1B50[15 * a2]) &= ~0x80u;
      word_A1B50[15 * a2] |= a1 << 7;
      return dword_A1728(a2);
    }
  }
  return 1;
}
// A1728: using guessed type int (__stdcall *dword_A1728)(_DWORD);
// A1B40: using guessed type __int16 word_A1B40[];
// A1B4A: using guessed type __int16 word_A1B4A[];
// A1B4C: using guessed type __int16 word_A1B4C[];
// A1B50: using guessed type __int16 word_A1B50[];

//----- (0006F8F1) --------------------------------------------------------
int __stdcall sub_6F8F1(__int16 a1, unsigned __int16 a2)
{
  __int16 v2; // bx

  v2 = word_A1B4A[15 * a2];
  if ( (unsigned __int16)v2 >= 0x100u )
  {
    if ( (unsigned __int16)v2 <= 0x100u )
    {
      if ( !word_A1B4C[15 * a2] )
      {
        LOBYTE(word_A1B40[15 * a2]) = 0;
        word_A1B40[15 * a2] |= a1;
        return 0;
      }
    }
    else if ( v2 == 512 && dword_A1728 )
    {
      LOBYTE(word_A1B50[15 * a2]) &= 0x80u;
      word_A1B50[15 * a2] |= a1;
      return dword_A1728(a2);
    }
  }
  return 1;
}
// A1728: using guessed type int (__stdcall *dword_A1728)(_DWORD);
// A1B40: using guessed type __int16 word_A1B40[];
// A1B4A: using guessed type __int16 word_A1B4A[];
// A1B4C: using guessed type __int16 word_A1B4C[];
// A1B50: using guessed type __int16 word_A1B50[];

//----- (0006F963) --------------------------------------------------------
void __stdcall sub_6F963(int a1, __int16 a2)
{
  int v2; // edx
  int v3; // eax
  int savedregs; // [esp+0h] [ebp+0h]

  //fix
  savedregs = 0;
  //fix

  v2 = a2 & 0xF;
  v3 = 15 * v2;
  byte_A1B37[v3 * 2] = 0;
  byte_A1B38[v3 * 2] = 0;
  byte_A1B39[v3 * 2] = 0x80;
  byte_A1B3A[v3 * 2] = 127;
  byte_A1B3B[v3 * 2] = 100;
  word_A1B3C[v3] = 0;
  byte_A1B36[v3 * 2] = 0;
  word_A1B42[v3] = 0;
  word_A1B40[v3] = 512;
  word_A1B4C[v3] = -1;
  word_A1B4E[v3] = -1;
  word_A1B46[v3] = 0;
  word_A1B48[v3] = -1;
  if ( dword_A1730 )
    dword_A1730(0, v2, savedregs);
  JUMPOUT(0x6F84A);
}
// 6F9F4: control flows out of bounds to 6F84A
// 6F9EE: variable 'savedregs' is possibly undefined
// A1730: using guessed type int (__stdcall *dword_A1730)(_DWORD, _DWORD, _DWORD);
// A1B3C: using guessed type __int16 word_A1B3C[];
// A1B40: using guessed type __int16 word_A1B40[];
// A1B42: using guessed type __int16 word_A1B42[];
// A1B46: using guessed type __int16 word_A1B46[];
// A1B48: using guessed type __int16 word_A1B48[];
// A1B4C: using guessed type __int16 word_A1B4C[];
// A1B4E: using guessed type __int16 word_A1B4E[];

//----- (0006F9F9) --------------------------------------------------------
void __stdcall sub_6F9F9(int a1, __int16 a2)
{
  unsigned __int16 i; // si
  int v3; // edx

  for ( i = 0; i < (unsigned __int16)word_A1608; ++i )
  {
    v3 = (int)(unsigned __int16)word_A18B4[10 * i] >> 8;
    if ( (_WORD)v3 != 255 && (v3 & 0xF) == a2 )
    {
      word_A18B4[10 * i] = -1;
      sub_6E65B(0x807Fu, i | 0x5400);
    }
  }
  JUMPOUT(0x6F773);
}
// 6FA4E: control flows out of bounds to 6F773
// A1608: using guessed type __int16 word_A1608;
// A18B4: using guessed type __int16 word_A18B4[];

//----- (0006FA53) --------------------------------------------------------
int __stdcall sub_6FA53(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3)
{
  int savedregs; // [esp+0h] [ebp+0h]

  //fix
  savedregs = 0;
  //fix

  if ( a2 < 0x40u )
  {
    if ( a2 < 7u )
    {
      if ( a2 )
      {
        if ( a2 <= 1u )
        {
          sub_6F77A(a1, a3);
        }
        else
        {
          if ( a2 != 6 )
            return 1;
          sub_6F872(a1, a3);
        }
      }
      else
      {
        sub_6F502(a1, a3);
      }
    }
    else if ( a2 <= 7u )
    {
      sub_6F5A8(a1, a3);
    }
    else if ( a2 < 0xBu )
    {
      if ( a2 != 10 )
        return 1;
      sub_6F588(a1, a3);
    }
    else if ( a2 <= 0xBu )
    {
      sub_6F6AF(a1, a3);
    }
    else
    {
      if ( a2 != 38 )
        return 1;
      sub_6F8F1(a1, a3);
    }
    return 0;
  }
  if ( a2 <= 0x40u )
  {
    sub_6F6D8(a1, a3);
    return 0;
  }
  if ( a2 < 0x63u )
  {
    if ( a2 < 0x5Du )
    {
      if ( a2 != 91 )
        return 1;
      sub_6F536(a1, a3);
    }
    else
    {
      if ( a2 > 0x5Du )
      {
        if ( a2 == 98 && dword_A172C )
          return dword_A172C(a1, a3);
        return 1;
      }
      sub_6F55F(a1, a3);
    }
    return 0;
  }
  if ( a2 > 0x63u )
  {
    if ( a2 < 0x65u )
    {
      sub_6F824(a1, a3);
      return 0;
    }
    if ( a2 <= 0x65u )
    {
      sub_6F850(a1, a3);
      return 0;
    }
    if ( a2 >= 0x79u )
    {
      if ( a2 <= 0x79u )
      {
        sub_6F963(a1, a3);
      }
      else
      {
        if ( a2 != 123 )
          return 1;
        sub_6F9F9(a1, a3);
      }
      return 0;
    }
    return 1;
  }
  if ( !dword_A1730 )
    return 1;
  return dword_A1730(a1, a3, savedregs);
}
// 6FC3A: variable 'savedregs' is possibly undefined
// A172C: using guessed type int (__stdcall *dword_A172C)(_DWORD, _DWORD);
// A1730: using guessed type int (__stdcall *dword_A1730)(_DWORD, _DWORD, _DWORD);

//----- (0006FC44) --------------------------------------------------------
void __stdcall sub_6FC44(unsigned __int16 a1, __int16 a2)
{
  __int16 v2; // cx
  int v3; // eax
  unsigned __int16 i; // dx
  unsigned __int16 j; // si
  int v6; // ebx
  unsigned __int8 *v7; // eax
  _BOOL1 k; // zf
  unsigned __int16 m; // dx
  unsigned __int16 n; // si
  int v11; // eax
  unsigned __int8 *v12; // eax
  __int16 v13; // [esp+0h] [ebp-8h]
  unsigned __int16 v14; // [esp+4h] [ebp-4h]
  unsigned __int16 v15; // [esp+1Ch] [ebp+14h]

  v2 = 1;
  v15 = a2 & 0xF;
  if ( word_A1B48[15 * v15] != -1 )
    word_A1B46[15 * v15] = word_A1B48[15 * v15];
  v3 = 15 * v15;
  word_A1B44[v3] = 0;
  word_A1B34[v3] = 0;
  if ( v15 == 9 )
  {
    v14 = 0;
    for ( i = 0; i < 0x40u; ++i )
    {
      if ( dword_A1734[i] )
      {
        for ( j = 0; ; ++j )
        {
          v7 = (unsigned __int8 *)(4 * j + *(_DWORD *)dword_A1734[i]);
          if ( v7[1] == 0xFF )
            break;
          if ( v7[1] == 0x80 )
          {
            v6 = *v7;
            if ( v6 <= a1 && v6 >= v14 )
            {
              v2 = 0;
              v14 = *v7;
              word_A1B44[135] = i;
              word_A1B34[135] = j;
            }
          }
        }
      }
    }
    for ( k = v2 == 0; ; k = v13 == 0 )
    {
      if ( k )
        goto LABEL_29;
      v13 = 0;
LABEL_17:
      for ( m = 0; m < 0x40u; ++m )
      {
        if ( dword_A1734[m] )
        {
          for ( n = 0; ; ++n )
          {
            v12 = (unsigned __int8 *)(4 * n + *(_DWORD *)dword_A1734[m]);
            if ( v12[1] == 0xFF )
              goto LABEL_26;
            if ( v12[1] == v13 && *v12 == a1 )
              break;
          }
          v11 = 15 * v15;
          word_A1B44[v11] = m;
          word_A1B34[v11] = n;
LABEL_29:
          JUMPOUT(0x6F6A9);
        }
LABEL_26:
        ;
      }
    }
  }
  v13 = word_A1B46[15 * v15];
  goto LABEL_17;
}
// 6FD9F: control flows out of bounds to 6F6A9
// A1734: using guessed type int dword_A1734[64];
// A1B34: using guessed type __int16 word_A1B34[];
// A1B44: using guessed type __int16 word_A1B44[];
// A1B46: using guessed type __int16 word_A1B46[];
// A1B48: using guessed type __int16 word_A1B48[];

//----- (0006FDA4) --------------------------------------------------------
void __stdcall sub_6FDA4(int a1, int a2, int a3)
{
  JUMPOUT(0x6FB75);
}
// 6FDA7: control flows out of bounds to 6FB75

//----- (0006FDAC) --------------------------------------------------------
void __stdcall sub_6FDAC(unsigned __int16 a1, __int16 a2)
{
  int v2; // eax
  unsigned __int16 v3; // [esp+Ch] [ebp+Ch]

  v3 = a2 & 0xF;
  v2 = 15 * v3;
  word_A1B3E[v2] = a1 / 0x1Eu;
  sub_6F77A(30 * word_A1B3C[v2], v3);
}
// A1B3C: using guessed type __int16 word_A1B3C[];
// A1B3E: using guessed type __int16 word_A1B3E[];

//----- (0006FDEC) --------------------------------------------------------
int __stdcall sub_6FDEC(unsigned __int8 a1, unsigned __int8 a2, __int16 a3)
{
  unsigned __int8 v3; // al
  __int64 v4; // rax
  int v5; // edi
  unsigned __int16 i; // si
  int v7; // edx
  int v8; // eax

  v3 = HIBYTE(word_A1B40[15 * (a3 & 0xF)]);
  if ( !v3 )
    v3 = 2;
  v4 = (__int16)(a2 + (a1 << 7) - 0x2000) * (__int16)(341 * v3);
  v5 = (int)(v4 - (__CFSHL__(HIDWORD(v4), 13) + (HIDWORD(v4) << 13))) >> 13;
  word_A1B42[15 * (a3 & 0xF)] = v5;
  for ( i = 0; i < (unsigned __int16)word_A1608; ++i )
  {
    v7 = (int)(unsigned __int16)word_A18B4[10 * i] >> 8;
    if ( (_WORD)v7 != 255 && (v7 & 0xF) == a3 )
    {
      v8 = (__int16)v5 + (unsigned __int16)word_A18C0[10 * i];
      if ( v8 >= 0xFFFF )
        LOWORD(v8) = -1;
      sub_6E65B(v8, i | 0x800);
    }
  }
  return 0;
}
// A1608: using guessed type __int16 word_A1608;
// A18B4: using guessed type __int16 word_A18B4[];
// A18C0: using guessed type __int16 word_A18C0[];
// A1B40: using guessed type __int16 word_A1B40[];
// A1B42: using guessed type __int16 word_A1B42[];

//----- (0006FEBF) --------------------------------------------------------
int __stdcall sub_6FEBF(unsigned __int16 a1)
{
  int v2; // esi

  if ( a1 >= 8u )
    return 1;
  v2 = 7 * a1;
  sub_6E65B(word_A1180[v2], 0x3409u);
  sub_6E65B(word_A1182[v2], 0x340Cu);
  sub_6E65B(word_A1184[v2], 0x3603u);
  sub_6E727(*(int *)((char *)&dword_A1186 + v2 * 2), 0x1409u);
  sub_6E727(*(int *)((char *)&dword_A118A + v2 * 2), 0x140Au);
  sub_6E727(0x8000u, 0x140Du);
  sub_6E727(0, 0x140Eu);
  return 0;
}
// A1180: using guessed type __int16 word_A1180[];
// A1182: using guessed type __int16 word_A1182[];
// A1184: using guessed type __int16 word_A1184[];
// A1186: using guessed type int dword_A1186;
// A118A: using guessed type int dword_A118A;

//----- (0006FF53) --------------------------------------------------------
int __stdcall sub_6FF53(unsigned __int16 a1)
{
  __int16 i; // si
  __int16 v3[4]; // [esp+0h] [ebp-8h]

  if ( a1 >= 8u )
    return 1;
  v3[0] = 9216;
  v3[1] = 9728;
  v3[2] = 13312;
  v3[3] = 13824;
  for ( i = 0; i < 28; ++i )
    sub_6E65B(
      word_A120C[28 * a1 + i],
      v3[(int)(unsigned __int8)byte_A11F0[i] >> 5] | ((unsigned __int8)byte_A11F0[i] % 32));
  return 0;
}
// A120C: using guessed type __int16 word_A120C[224];

//----- (00070044) --------------------------------------------------------
char __stdcall sub_70044(__int16 a1)
{
  __int16 v1; // si
  __int16 v2; // ax

  v1 = word_A160A;
  word_A160A = a1;
  if ( (unsigned __int16)a1 < 0x300u || (LOBYTE(v2) = sub_7008A(), v2) )
  {
    HIBYTE(word_A160A) += 4;
    LOBYTE(v2) = sub_7008A();
    if ( v2 )
    {
      word_A160A = v1;
      LOBYTE(v2) = 1;
    }
  }
  return v2;
}
// 70066: variable 'v2' is possibly undefined
// A160A: using guessed type __int16 word_A160A;

//----- (0007008A) --------------------------------------------------------
_BOOL1 sub_7008A()
{
  return (unsigned __int16)sub_6E6BF(0x7800u) == 0xFFFF
      || (unsigned __int16)sub_6E6BF(0x141Du) == 0xFFFF
      || (unsigned __int16)sub_6E6BF(0x141Eu) == 0xFFFF
      || (unsigned __int16)sub_6E6BF(0x141Fu) == 0xFFFF
      || (sub_6E6BF(0x7800u) & 0xC) != 12
      || (sub_6E6BF(0x141Du) & 0x58) != 88
      || (sub_6E6BF(0x141Eu) & 3) != 3;
}

//----- (00070113) --------------------------------------------------------
unsigned int __stdcall sub_70113(__int16 a1)
{
  unsigned int v1; // esi
  __int16 v2; // di
  unsigned int result; // eax

  v1 = 0;
  v2 = sub_6E6BF(0x161Bu) + a1;
  do
  {
    result = sub_6E6BF(0x161Bu);
    if ( (_WORD)result == v2 )
      break;
    result = v1++;
  }
  while ( result < 0x7FFF );
  return result;
}

//----- (00070148) --------------------------------------------------------
unsigned int sub_70148()
{
  unsigned __int16 i; // si
  unsigned int result; // eax

  for ( i = 0; i < 0x20u; ++i )
  {
    sub_6E65B(0x80u, i | 0x5400);
    sub_6E65B(0, i | 0x6600);
    sub_6E65B(0, i | 0x7400);
    sub_6E65B(0, i | 0x800);
    sub_6E65B(0xFF00u, i | 0x1800);
    sub_6E65B(0, i | 0x2800);
    sub_6E65B(0, i | 0x3800);
    sub_6E65B(0x18u, i | 0x4800);
    sub_6E65B(0x18u, i | 0x5800);
    sub_6E65B(0, i | 0x6800);
    sub_6E65B(0, i | 0x7600);
    sub_6E65B(0, i | 0x5600);
    sub_6E65B(0, i | 0x4600);
    sub_6E65B(0, i | 0x4400);
    result = sub_6E65B(0, i | 0x6400);
  }
  return result;
}

//----- (0007024E) --------------------------------------------------------
void sub_7024E()
{
  unsigned __int16 i; // si

  sub_70113(2);
  for ( i = 0; i < 0x20u; ++i )
  {
    sub_6E727(0, i | 0x1000);
    sub_6E727(0xFFFFu, i | 0x3000);
    sub_6E727(0, i | 0x6000);
    sub_6E727(0, i | 0x7000);
    sub_6E727(0, i);
    sub_6E727(0xFFFFu, i | 0x2000);
    sub_6E727(0, i | 0x400);
    sub_6E727(0, i | 0x5000);
    sub_6E727(0, i | 0x4000);
  }
}

//----- (000702F6) --------------------------------------------------------
unsigned int sub_702F6()
{
  int v0; // esi
  unsigned __int16 i; // di
  unsigned __int16 j; // di
  unsigned __int16 k; // di
  unsigned __int16 m; // di
  int v5; // esi
  unsigned __int16 n; // di
  __int16 v7; // ax
  unsigned __int16 ii; // di
  __int16 v9; // ax
  unsigned __int16 jj; // di
  __int16 v11; // ax
  unsigned __int16 kk; // di
  __int16 v13; // ax
  unsigned __int16 mm; // si
  int v15; // esi
  unsigned __int16 nn; // di
  __int16 v17; // ax
  unsigned __int16 i1; // di
  __int16 v19; // ax
  unsigned __int16 i2; // di
  __int16 v21; // ax
  unsigned __int16 i3; // di
  __int16 v23; // ax
  int v24; // esi
  unsigned __int16 i4; // di
  unsigned __int16 i5; // di
  unsigned __int16 i6; // di
  unsigned __int16 i7; // di
  unsigned int result; // eax
  unsigned __int16 v30; // [esp-8h] [ebp-10h]
  unsigned __int16 v31; // [esp-8h] [ebp-10h]
  unsigned __int16 v32; // [esp-8h] [ebp-10h]
  unsigned __int16 v33; // [esp-8h] [ebp-10h]
  unsigned __int16 v34; // [esp-8h] [ebp-10h]
  unsigned __int16 v35; // [esp-8h] [ebp-10h]
  unsigned __int16 v36; // [esp-8h] [ebp-10h]
  unsigned __int16 v37; // [esp-8h] [ebp-10h]
  unsigned __int16 v38; // [esp-8h] [ebp-10h]
  unsigned __int16 v39; // [esp-8h] [ebp-10h]
  unsigned __int16 v40; // [esp-8h] [ebp-10h]
  unsigned __int16 v41; // [esp-8h] [ebp-10h]
  unsigned __int16 v42; // [esp-8h] [ebp-10h]
  unsigned __int16 v43; // [esp-8h] [ebp-10h]
  unsigned __int16 v44; // [esp-8h] [ebp-10h]
  unsigned __int16 v45; // [esp-8h] [ebp-10h]

  sub_6E65B(0, 0x1414u);
  sub_6E65B(0, 0x1415u);
  sub_6E65B(0, 0x1416u);
  sub_6E65B(0, 0x1415u);
  v0 = 0;
  for ( i = 0; i < 0x20u; ++i )
  {
    v30 = word_A1400[(unsigned __int16)v0++];
    sub_6E65B(v30, i | 0x2400);
  }
  for ( j = 0; j < 0x20u; ++j )
  {
    v31 = word_A1400[(unsigned __int16)v0++];
    sub_6E65B(v31, j | 0x2600);
  }
  for ( k = 0; k < 0x20u; ++k )
  {
    v32 = word_A1400[(unsigned __int16)v0++];
    sub_6E65B(v32, k | 0x3400);
  }
  for ( m = 0; m < 0x20u; ++m )
  {
    v33 = word_A1400[(unsigned __int16)v0++];
    sub_6E65B(v33, m | 0x3600);
  }
  sub_70113(1024);
  v5 = 0;
  for ( n = 0; n < 0x20u; ++n )
  {
    if ( n % 2 )
      v7 = 0x8000;
    else
      v7 = 0;
    v34 = v7 | word_A1400[(unsigned __int16)v5++];
    sub_6E65B(v34, n | 0x2400);
  }
  for ( ii = 0; ii < 0x20u; ++ii )
  {
    if ( ii % 2 )
      v9 = 0x8000;
    else
      v9 = 0;
    v35 = word_A1400[(unsigned __int16)v5++] | v9;
    sub_6E65B(v35, ii | 0x2600);
  }
  for ( jj = 0; jj < 0x20u; ++jj )
  {
    if ( jj % 2 )
      v11 = 0x8000;
    else
      v11 = 0;
    v36 = v11 | word_A1400[(unsigned __int16)v5++];
    sub_6E65B(v36, jj | 0x3400);
  }
  for ( kk = 0; kk < 0x20u; ++kk )
  {
    if ( kk % 2 )
      v13 = 0x8000;
    else
      v13 = 0;
    v37 = v13 | word_A1400[(unsigned __int16)v5++];
    sub_6E65B(v37, kk | 0x3600);
  }
  for ( mm = 0; mm < 0x14u; ++mm )
    sub_6E727(0, mm | 0x1400);
  v15 = 0;
  for ( nn = 0; nn < 0x20u; ++nn )
  {
    if ( nn % 2 )
      v17 = 0x8000;
    else
      v17 = 0;
    v38 = v17 | word_A1500[(unsigned __int16)v15++];
    sub_6E65B(v38, nn | 0x2400);
  }
  for ( i1 = 0; i1 < 0x20u; ++i1 )
  {
    if ( i1 % 2 )
      v19 = 0x8000;
    else
      v19 = 0;
    v39 = v19 | word_A1500[(unsigned __int16)v15++];
    sub_6E65B(v39, i1 | 0x2600);
  }
  for ( i2 = 0; i2 < 0x20u; ++i2 )
  {
    if ( i2 % 2 )
      v21 = 0x8000;
    else
      v21 = 0;
    v40 = word_A1500[(unsigned __int16)v15++] | v21;
    sub_6E65B(v40, i2 | 0x3400);
  }
  for ( i3 = 0; i3 < 0x20u; ++i3 )
  {
    if ( i3 % 2 )
      v23 = 0x8000;
    else
      v23 = 0;
    v41 = word_A1500[(unsigned __int16)v15++] | v23;
    sub_6E65B(v41, i3 | 0x3600);
  }
  sub_6E727(0, 0x1409u);
  sub_6E727(0x83u, 0x140Au);
  sub_6E727(0x8000u, 0x140Du);
  sub_6E727(0, 0x140Eu);
  v24 = 0;
  for ( i4 = 0; i4 < 0x20u; ++i4 )
  {
    v42 = word_A1500[(unsigned __int16)v24++];
    sub_6E65B(v42, i4 | 0x2400);
  }
  for ( i5 = 0; i5 < 0x20u; ++i5 )
  {
    v43 = word_A1500[(unsigned __int16)v24++];
    sub_6E65B(v43, i5 | 0x2600);
  }
  for ( i6 = 0; i6 < 0x20u; ++i6 )
  {
    v44 = word_A1500[(unsigned __int16)v24++];
    sub_6E65B(v44, i6 | 0x3400);
  }
  for ( i7 = 0; i7 < 0x20u; ++i7 )
  {
    v45 = word_A1500[(unsigned __int16)v24++];
    result = sub_6E65B(v45, i7 | 0x3600);
  }
  return result;
}
// A1400: using guessed type __int16 word_A1400[128];
// A1500: using guessed type __int16 word_A1500[128];

//----- (000706CC) --------------------------------------------------------
void sub_706CC()
{
  unsigned __int16 v0; // si
  unsigned int v1; // kr00_4
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // ax

  sub_6E65B(0x80u, 0x541Eu);
  sub_6E727(0xFFE0u, 0x601Eu);
  sub_6E727(0xFFE8u, 0x701Eu);
  sub_6E727(0, 0x101Eu);
  sub_6E727(0, 0x1Eu);
  sub_6E727(0xFFE3u, 0x41Eu);
  sub_6E65B(0x80u, 0x541Fu);
  sub_6E727(0xFFF0u, 0x601Fu);
  sub_6E727(0xFFF8u, 0x701Fu);
  sub_6E727(0xFFu, 0x101Fu);
  sub_6E727(0x8000u, 0x1Fu);
  sub_6E727(0xFFF3u, 0x41Fu);
  v0 = word_A160A + 2050;
  v1 = __readeflags();
  if ( (v1 & 0x200) != 0 )
    _disable();
  __outword(v0, 0x3Eu);
  __outword(word_A160A, 0);
  do
    v2 = __inword(v0);
  while ( (v2 & 0x1000) == 0 );
  do
    v3 = __inword(v0);
  while ( (v3 & 0x1000) != 0 );
  __outword(word_A160A + 2, 0x4828u);
  __outword(v0, 0x3Cu);
  __outword(word_A160A + 1024, 0);
  if ( (v1 & 0x200) != 0 )
    _enable();
  sub_6E727(0xFFFFu, 0x301Eu);
  sub_6E727(0xFFFFu, 0x301Fu);
}
// A160A: using guessed type __int16 word_A160A;

//----- (00070812) --------------------------------------------------------
void sub_70812()
{
  unsigned int v0; // esi
  unsigned __int16 i; // di
  unsigned __int16 j; // si

  v0 = 0x200000;
  sub_6E65B(0x20u, 0x141Eu);
  for ( i = 0; i < 0x1Eu; ++i )
  {
    sub_6E65B(0x80u, i | 0x5400);
    sub_6E727(0, i | 0x3000);
    sub_6E727(0, i | 0x2000);
    sub_6E727(0, i | 0x6000);
    sub_6E727(0, i | 0x7000);
    sub_6E727(0, i | 0x1000);
    sub_6E727(0, i);
    sub_6E727(0, i | 0x400);
  }
  sub_6E727(0, 0x1416u);
  sub_6E65B(0xFFFFu, 0x141Au);
  sub_6E65B(0xAAAAu, 0x141Au);
  sub_6E65B(0x5555u, 0x141Au);
  sub_6E65B(0xDDDDu, 0x141Au);
  sub_70113(2);
  sub_6E727(0, 0x1414u);
  sub_6E6BF(0x141Au);
  if ( (unsigned __int16)sub_6E6BF(0x141Au) == 0xFFFF
    && (unsigned __int16)sub_6E6BF(0x141Au) == 0xAAAA
    && (unsigned __int16)sub_6E6BF(0x141Au) == 21845
    && (unsigned __int16)sub_6E6BF(0x141Au) == 0xDDDD )
  {
    do
    {
      if ( v0 > 0xFF8000 )
        break;
      v0 += 0x8000;
      sub_6E727(v0, 0x1416u);
      sub_6E65B(0x1234u, 0x141Au);
      sub_6E65B(0x1234u, 0x141Au);
      sub_6E65B(0x1234u, 0x141Au);
      sub_6E65B(0x1234u, 0x141Au);
      sub_70113(2);
      sub_6E727(0, 0x1414u);
      sub_6E6BF(0x141Au);
      if ( (unsigned __int16)sub_6E6BF(0x141Au) == 4660 )
        break;
      sub_6E727(v0, 0x1414u);
      sub_6E6BF(0x141Au);
      if ( (unsigned __int16)sub_6E6BF(0x141Au) != 4660 )
        break;
    }
    while ( (unsigned __int16)sub_6E6BF(0x141Au) == 4660
         && (unsigned __int16)sub_6E6BF(0x141Au) == 4660
         && (unsigned __int16)sub_6E6BF(0x141Au) == 4660 );
  }
  dword_A160C = v0 - 0x200000;
  for ( j = 0; j < 0x1Eu; ++j )
    sub_6E727(0, j | 0x400);
}
// A160C: using guessed type int dword_A160C;

//----- (00070AA0) --------------------------------------------------------
int sub_70AA0()
{
  unsigned __int16 i; // dx
  int v1; // eax

  if ( (unsigned __int16)sub_6E6BF(0x7800u) == 12 )
  {
    sub_6E65B(0x59u, 0x141Du);
    sub_6E65B(0x20u, 0x141Eu);
    sub_6E65B(0, 0x141Fu);
    sub_70148();
    sub_7024E();
    sub_702F6();
    if ( (unsigned __int16)word_A1608 <= 0x1Eu )
      sub_706CC();
    sub_70812();
    sub_6E65B(4u, 0x141Fu);
    if ( (sub_6E6BF(0x141Eu) & 0x40) != 0 )
    {
      for ( i = 0; i < (unsigned __int16)word_A1608; ++i )
      {
        v1 = 10 * i;
        word_A18B4[v1] = -1;
        word_A18C2[v1] = 0;
      }
    }
  }
  return 0;
}
// A1608: using guessed type __int16 word_A1608;
// A18B4: using guessed type __int16 word_A18B4[];
// A18C2: using guessed type __int16 word_A18C2[];

//----- (00070B3E) --------------------------------------------------------
int sub_70B3E()
{
  __int16 i; // si

  for ( i = 32; i--; sub_6E65B(0x807Fu, i | 0x5400) )
    ;
  sub_70113(128);
  sub_706CC();
  return 0;
}

//----- (00070B8B) --------------------------------------------------------
char sub_70B8B(unsigned int a1, unsigned __int8 a2)
{
  int v2; // eax
  unsigned int v4; // [esp+4h] [ebp-Ch]
  unsigned int i; // [esp+8h] [ebp-8h]

  if ( a1 < 0x10 )
  {
    dword_A08F0[a1] = a2;
    LOBYTE(v2) = 4 * a1;
    dword_A0954[a1] = 1;
    for ( i = 0; i < 9; ++i )
    {
      LOBYTE(v2) = i;
      if ( byte_A0764[i] )
      {
        v2 = dword_A0808[i];
        if ( v2 == a1 )
        {
          v4 = (0x2000
              - (64 - (byte_A0704[(unsigned __int8)byte_A0776[2 * i]] & 0x3F))
              * ((2
                * (64
                 - (unsigned __int8)byte_A0A24[(int)(unsigned __int8)((dword_A0930[i] * ((a2 << 7) / 0x7Fu)) >> 7) >> 1])) & 0x3FFFFFFu)) >> 7;
          if ( !__readgsbyte(dword_A07A0 + 30 * dword_A07C8[dword_A0808[i]] + 14) )
            sub_6A640(byte_A0775[2 * i] + 64, byte_A0704[(unsigned __int8)byte_A0775[2 * i]] & 0xC0 | v4);
          LOBYTE(v2) = sub_6A640(byte_A0776[2 * i] + 64, byte_A0704[(unsigned __int8)byte_A0776[2 * i]] & 0xC0 | v4);
        }
      }
    }
  }
  return v2;
}
// 70D2E: variable 'v2' is possibly undefined
// A07A0: using guessed type int dword_A07A0;
// A07C8: using guessed type int dword_A07C8[16];
// A0808: using guessed type int dword_A0808[9];
// A08F0: using guessed type int dword_A08F0[16];
// A0930: using guessed type int dword_A0930[9];
// A0954: using guessed type int dword_A0954[16];

//----- (00070D55) --------------------------------------------------------
unsigned __int8 sub_70D55(unsigned __int8 a1)
{
  unsigned int k; // [esp+0h] [ebp-Ch]
  unsigned int i; // [esp+4h] [ebp-8h]
  unsigned int j; // [esp+4h] [ebp-8h]

  for ( i = 0; i < 9; ++i )
  {
    if ( !byte_A0764[i] )
      return i;
  }
  for ( j = 0; j < 0x10; ++j )
  {
    if ( !dword_A086C[j] )
    {
      for ( k = 0; k < 9; ++k )
      {
        if ( dword_A0808[k] == j )
          return k;
      }
    }
  }
  if ( a1 >= 9u )
    a1 -= 9;
  return a1;
}
// A0808: using guessed type int dword_A0808[9];
// A086C: using guessed type int dword_A086C[16];

//----- (00070E1C) --------------------------------------------------------
int sub_70E1C(int a1, int a2, unsigned int a3)
{
  int result; // eax

  result = __readgsbyte(a3 + 1);
  dword_A07C8[result] = __readgsbyte(a3);
  return result * 4;
}
// A07C8: using guessed type int dword_A07C8[];

//----- (00071012) --------------------------------------------------------
char *sub_71012()
{
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  return (char *)&retaddr - dword_A0CA8;
}
// 71014: returning address of temporary local variable '%" r"'
// A0CA8: using guessed type int dword_A0CA8;

//----- (0007101B) --------------------------------------------------------
void sub_7101B()
{
  dword_A8874 = 0x8000;
}
// A8874: using guessed type int dword_A8874;

//----- (00071524) --------------------------------------------------------
void sub_71524()
{
    //fix word_A636C = __SS__;
}
// A636C: using guessed type __int16 word_A636C;

//----- (00071B53) --------------------------------------------------------
int sub_71B53()
{
  return 0;
}

//----- (00071BC9) --------------------------------------------------------
void sub_71BC9(int a1, const void *a2, void *a3)
{
  if ( byte_A0CC6 == 9 )
  {
    //fix __asm { int     21h; DOS - GET DISK TRANSFER AREA ADDRESS }
    qmemcpy(a3, a2, 0x2Bu);
  }
}
// A0CC6: using guessed type char byte_A0CC6;

//----- (000724C0) --------------------------------------------------------
int sub_724C0(__int16 a1, __int16 a2)
{
  int v2; // ebx
  int v3; // edx
  int v4; // eax
  int v5; // esi
  int v6; // esi
  int v8; // esi
  int v9; // eax
  int v10; // esi
  int v11; // esi
  int v12; // edi

  v2 = HIBYTE(a1);
  BYTE1(v2) = HIBYTE(a2);
  v3 = (unsigned __int8)a2;
  if ( ((HIBYTE(a1) + HIBYTE(a2)) & 1) != 0 )
  {
    if ( __CFADD__((_BYTE)a2, (_BYTE)a1) )
    {
      BYTE1(v2) = HIBYTE(a2) + 1;
      v4 = (unsigned __int8)byte_DC1E0[v2];
      LOBYTE(v2) = v2 + 1;
      v8 = (unsigned __int8)byte_DC1E0[v2];
      LOBYTE(v3) = ~(_BYTE)a2;
      BYTE1(v2) = HIBYTE(a2);
      v6 = v3 * ((unsigned __int8)byte_DC1E0[v2] - v8) + (unsigned __int8)a1 * (v8 - v4);
    }
    else
    {
      v4 = (unsigned __int8)byte_DC1E0[v2];
      LOBYTE(v2) = v2 + 1;
      v5 = (unsigned __int8)a1 * ((unsigned __int8)byte_DC1E0[v2] - v4);
      LOBYTE(v2) = v2 - 1;
      BYTE1(v2) = HIBYTE(a2) + 1;
      v6 = (unsigned __int8)a2 * ((unsigned __int8)byte_DC1E0[v2] - v4) + v5;
    }
    return (v6 >> 3) + 32 * v4;
  }
  else
  {
    v9 = (unsigned __int8)byte_DC1E0[v2];
    if ( (unsigned __int8)a1 <= (unsigned __int8)a2 )
    {
      BYTE1(v2) = HIBYTE(a2) + 1;
      v12 = (unsigned __int8)byte_DC1E0[v2];
      LOBYTE(v2) = v2 + 1;
      v11 = (unsigned __int8)a2 * (v12 - v9) + (unsigned __int8)a1 * ((unsigned __int8)byte_DC1E0[v2] - v12);
    }
    else
    {
      LOBYTE(v2) = v2 + 1;
      v10 = (unsigned __int8)byte_DC1E0[v2];
      BYTE1(v2) = HIBYTE(a2) + 1;
      v11 = (unsigned __int8)a2 * ((unsigned __int8)byte_DC1E0[v2] - v10) + (unsigned __int8)a1 * (v10 - v9);
    }
    return (v11 >> 3) + 32 * v9;
  }
}

//----- (000725C8) --------------------------------------------------------
void sub_725C8(__int16 a1, unsigned __int16 a2, __int16 a3)
{
  int v3; // ebx
  __int16 v4; // cx
  char v6; // [esp+1h] [ebp-3h]
  char v7; // [esp+1h] [ebp-3h]
  char v8; // [esp+2h] [ebp-2h]
  char v9; // [esp+2h] [ebp-2h]
  char v10; // [esp+3h] [ebp-1h]
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  word_10C1E0[a2] = a3;
  v10 = 7;
  do
  {
    v3 = a2;
    v4 = (unsigned __int8)(1 << v10);
    v6 = 1 << (7 - v10);
    do
    {
      v8 = 1 << (7 - v10);
      do
      {
        sub_72652(v4, v3, (int)&savedregs, a1);
        --v8;
      }
      while ( v8 );
      BYTE1(v3) += v4 + v4;
      --v6;
    }
    while ( v6 );
    v7 = 1 << (7 - v10);
    do
    {
      v9 = 1 << (7 - v10);
      do
      {
        sub_726E7(v4, v3, (int)&savedregs, a1);
        --v9;
      }
      while ( v9 );
      BYTE1(v3) += v4 + v4;
      --v7;
    }
    while ( v7 );
  }
  while ( v10-- >= 1 );
}
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (00072652) --------------------------------------------------------
__int16 sub_72652fix(__int16 a1, int a2, int a3, __int16 a4)
{
  __int16 v4; // di
  __int16 v5; // di
  __int16 v6; // di
  __int16 v7; // di
  __int16 v8; // di
  __int16 result; // ax

  v4 = word_10C1E0[a2];
  LOBYTE(a2) = a1 + a1 + a2;
  v5 = word_10C1E0[a2] + v4;
  BYTE1(a2) += a1 + a1;
  v6 = word_10C1E0[a2] + v5;
  LOBYTE(a2) = a2 - a1 - a1;
  v7 = word_10C1E0[a2] + v6;
  LOBYTE(a2) = a1 + a2;
  BYTE1(a2) -= a1;
  v8 = (unsigned __int16)(9377 * a4 + 9439) % (unsigned __int16)(2 * *(_WORD *)(a3 + 20) + 1)
     + (unsigned __int16)(9377 * a4 + 9439) % (unsigned __int16)((a1 << 6) + 1)
     + (v7 >> 2)
     - 32 * a1
     - *(_WORD *)(a3 + 20);
  result = v8;
  if ( !word_10C1E0[a2] )
    word_10C1E0[a2] = v8;
  return result;
}
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (000726E7) --------------------------------------------------------
__int16 sub_726E7fix(__int16 a1, int a2, int a3, __int16 a4)
{
  __int16 v4; // di
  __int16 v5; // di
  unsigned __int16 v6; // si
  __int16 v7; // ax
  __int16 v8; // di
  __int16 v9; // di
  __int16 v10; // di
  __int16 v11; // di
  __int16 result; // ax
  __int16 v13; // [esp-2h] [ebp-2h]

  v13 = word_10C1E0[a2];
  LOBYTE(a2) = a1 + a2;
  BYTE1(a2) -= a1;
  v4 = word_10C1E0[a2] + v13;
  LOBYTE(a2) = a1 + a2;
  BYTE1(a2) += a1;
  v5 = word_10C1E0[a2] + v4;
  LOBYTE(a2) = a2 - a1;
  BYTE1(a2) += a1;
  v6 = 9377 * a4 + 9439;
  v7 = v6 % (unsigned __int16)(2 * *(_WORD *)(a3 + 20) + 1)
     + v6 % (unsigned __int16)((a1 << 6) + 1)
     + ((__int16)(word_10C1E0[a2] + v5) >> 2)
     - 32 * a1
     - *(_WORD *)(a3 + 20);
  v8 = word_10C1E0[a2];
  BYTE1(a2) -= a1;
  if ( !word_10C1E0[a2] )
    word_10C1E0[a2] = v7;
  LOBYTE(a2) = a2 - a1 - a1;
  BYTE1(a2) += a1;
  v9 = word_10C1E0[a2] + v13 + v8;
  LOBYTE(a2) = a1 + a2;
  BYTE1(a2) += a1;
  v10 = word_10C1E0[a2] + v9;
  BYTE1(a2) -= a1;
  v11 = (unsigned __int16)(9377 * v6 + 9439) % (unsigned __int16)(2 * *(_WORD *)(a3 + 20) + 1)
      + (unsigned __int16)(9377 * v6 + 9439) % (unsigned __int16)((a1 << 6) + 1)
      + (v10 >> 2)
      - 32 * a1
      - *(_WORD *)(a3 + 20);
  result = v11;
  if ( !word_10C1E0[a2] )
    word_10C1E0[a2] = v11;
  return result;
}
// 10C1E0: using guessed type __int16 word_10C1E0[7953];

//----- (00072807) --------------------------------------------------------
char sub_72807(unsigned __int8 *a1, _BYTE *a2)
{
  unsigned __int8 *v2; // edi
  unsigned int v3; // ebx
  unsigned int v4; // ecx
  unsigned int v5; // edx
  int v6; // eax
  unsigned __int8 *v7; // esi
  unsigned int v8; // ebx
  unsigned int v9; // ecx
  unsigned int v10; // edx
  unsigned __int8 *v11; // esi
  __int16 v12; // di
  char result; // al
  char v14; // [esp+6h] [ebp-Ah]
  char v15; // [esp+7h] [ebp-9h]
  char v16; // [esp+8h] [ebp-8h]
  char v17; // [esp+8h] [ebp-8h]
  char v18; // [esp+9h] [ebp-7h]
  __int16 v19; // [esp+Ah] [ebp-6h]
  int *v20; // [esp+Ch] [ebp-4h]

  v18 = 0;
  v20 = (int*)&dword_9334C;
  do
  {
    v2 = (unsigned __int8 *)*v20;
    v3 = 0;
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v15 = 32;
    do
    {
      v16 = 32;
      do
      {
        v7 = &a1[3 * *v2];
        LOBYTE(v6) = *v7++;
        v3 += v6;
        LOBYTE(v6) = *v7;
        v4 += v6;
        LOBYTE(v6) = v7[1];
        v5 += v6;
        ++v2;
        --v16;
      }
      while ( v16 );
      v2 += 224;
      --v15;
    }
    while ( v15 );
    v8 = v3 >> 10;
    v9 = v4 >> 10;
    v10 = v5 >> 10;
    v19 = 0x7FFF;
    v14 = 0;
    v11 = a1;
    v17 = 0;
    do
    {
      v12 = (v11[2] - (_WORD)v10) * (v11[2] - (_WORD)v10);
      if ( (__int16)(v12 + (v11[1] - (_WORD)v9) * (v11[1] - (_WORD)v9) + (*v11 - (_WORD)v8) * (*v11 - (_WORD)v8)) < v19 )
      {
        v19 = v12 + (v11[1] - (_WORD)v9) * (v11[1] - (_WORD)v9) + (*v11 - (_WORD)v8) * (*v11 - (_WORD)v8);
        v14 = v17;
      }
      v11 += 3;
      ++v17;
    }
    while ( v17 );
    result = v14;
    *a2 = v14;
    a2[128] = v14;
    ++a2;
    ++v20;
    --v18;
  }
  while ( v18 );
  return result;
}
// 9334C: using guessed type int dword_9334C;

//----- (000729A3) --------------------------------------------------------
void sub_729A3(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // esi
  _DWORD *v4; // edi
  _DWORD *v5; // ecx
  int v6; // eax
  int v7; // ebx
  int v8; // edx
  int v9; // eax
  int v10; // ebx
  int v11; // ebx
  int v12; // ebx
  int v13; // eax
  int v14; // ebx
  _BOOL1 v15; // zf
  char v16; // cc
  int v17; // ebx
  int v18; // ebx
  int v19; // eax
  int v20; // ebx
  int v21; // ecx
  int v22; // edx
  int v23; // esi
  int v24; // ebx
  _DWORD *v25; // edi
  int v26; // edi
  _BOOL1 v27; // of
  int v28; // edi
  unsigned int v29; // eax
  int v30; // eax
  int v31; // ebx
  _BOOL1 v32; // zf
  int v33; // ebx
  int v34; // ebx
  int v35; // eax
  int v36; // ebx
  int v37; // ecx
  int v38; // edx
  int v39; // ebx
  _DWORD *v40; // edi
  int v41; // edi
  int v42; // edi
  int v43; // eax
  int v44; // ebx
  _BOOL1 v45; // zf
  int v46; // ebx
  int v47; // eax
  int v48; // ebx
  int v49; // esi
  int v50; // ebx
  _DWORD *v51; // edi
  int v52; // edi
  int v53; // edi
  int v54; // eax
  int v55; // ebx
  int v56; // ebx
  _DWORD *v57; // edi
  int v58; // edi
  int v59; // edi
  int v60; // eax
  int v61; // ebx
  int v62; // ebx
  int v63; // ebx
  int v64; // eax
  int v65; // ebx
  _BOOL1 v66; // zf
  int v67; // ebx
  int v68; // ebx
  int v69; // eax
  int v70; // ebx
  int v71; // ecx
  int v72; // edx
  int v73; // esi
  int v74; // eax
  _DWORD *v75; // edi
  int v76; // edi
  int v77; // edi
  int v78; // eax
  int v79; // ebx
  _BOOL1 v80; // zf
  int v81; // ebx
  int v82; // ebx
  int v83; // eax
  int v84; // ebx
  int v85; // ecx
  int v86; // edx
  int v87; // eax
  _DWORD *v88; // edi
  int v89; // edi
  int v90; // edi
  int v91; // eax
  int v92; // ebx
  _BOOL1 v93; // zf
  int v94; // ebx
  int v95; // eax
  int v96; // ebx
  int v97; // esi
  int v98; // eax
  _DWORD *v99; // edi
  int v100; // edi
  int v101; // edi
  int v102; // eax
  int v103; // ebx
  int v104; // eax
  _DWORD *v105; // edi
  int v106; // edi
  int v107; // edi
  int v108; // eax
  int v109; // ebx
  int v110; // ebx
  int v111; // eax
  int v112; // ebx
  int v113; // ecx
  int v114; // edx
  int v115; // esi
  int v116; // edi
  _DWORD *v117; // edi
  int v118; // ebx
  int v119; // eax
  int v120; // ebx
  int v121; // ecx
  int v122; // edx
  int v123; // edi
  _DWORD *v124; // edi
  int v125; // eax
  int v126; // ebx
  int v127; // esi
  int v128; // edi
  _DWORD *v129; // edi
  int v130; // eax
  int v131; // ebx
  int v132; // edi
  _DWORD *v133; // edi
  int v134; // eax
  int v135; // ebx
  int v136; // ebx
  int v137; // eax
  int v138; // ebx
  int v139; // ecx
  int v140; // edx
  int v141; // esi
  int v142; // edi
  _DWORD *v143; // edi
  int v144; // ebx
  int v145; // eax
  int v146; // ebx
  int v147; // ecx
  int v148; // edx
  int v149; // edi
  _DWORD *v150; // edi
  int v151; // eax
  int v152; // ebx
  int v153; // esi
  int v154; // edi
  _DWORD *v155; // edi
  int v156; // eax
  int v157; // ebx
  int v158; // edi
  _DWORD *v159; // edi
  unsigned __int16 *v160; // esi
  char *v161; // edx
  char v162; // al
  int v163; // ebx
  signed int v164; // ecx
  char *v165; // edi
  _WORD *i; // esi
  int v167; // ecx
  _BYTE *v168; // edi
  unsigned int v169; // eax
  __int16 v170; // bx
  _BOOL1 v171; // cf
  __int16 v172; // bx
  __int16 v173; // bx
  char v174; // ah
  __int16 v175; // cx
  __int16 v176; // bx
  char v177; // ah
  __int16 v178; // cx
  __int16 v179; // bx
  char v180; // ah
  __int16 v181; // cx
  __int16 v182; // bx
  char v183; // ah
  __int16 v184; // cx
  __int16 v185; // bx
  char v186; // ah
  __int16 v187; // cx
  __int16 v188; // bx
  char v189; // ah
  __int16 v190; // cx
  __int16 v191; // bx
  char v192; // ah
  __int16 v193; // cx
  __int16 v194; // bx
  char v195; // ah
  __int16 v196; // cx
  __int16 v197; // bx
  char v198; // ah
  __int16 v199; // cx
  __int16 v200; // bx
  char v201; // ah
  __int16 v202; // cx
  __int16 v203; // bx
  char v204; // ah
  __int16 v205; // cx
  __int16 v206; // bx
  char v207; // ah
  __int16 v208; // cx
  __int16 v209; // bx
  char v210; // ah
  __int16 v211; // cx
  __int16 v212; // bx
  char v213; // ah
  __int16 v214; // cx
  __int16 v215; // bx
  char v216; // ah
  __int16 v217; // cx
  unsigned __int16 *v218; // esi
  int v219; // eax
  int v220; // ebx
  int v221; // ecx
  _BYTE *v222; // edi
  int v223; // eax
  unsigned int v224; // eax
  int v225; // edx
  unsigned int v226; // eax
  int v227; // esi
  char v228; // al
  int v229; // edx
  __int16 v230; // cx
  char v231; // al
  int v232; // edx
  __int16 v233; // cx
  char v234; // al
  int v235; // edx
  __int16 v236; // cx
  char v237; // al
  int v238; // edx
  __int16 v239; // cx
  char v240; // al
  int v241; // edx
  __int16 v242; // cx
  char v243; // al
  int v244; // edx
  __int16 v245; // cx
  char v246; // al
  int v247; // edx
  __int16 v248; // cx
  char v249; // al
  int v250; // edx
  __int16 v251; // cx
  char v252; // al
  int v253; // edx
  __int16 v254; // cx
  char v255; // al
  int v256; // edx
  __int16 v257; // cx
  char v258; // al
  int v259; // edx
  __int16 v260; // cx
  char v261; // al
  int v262; // edx
  __int16 v263; // cx
  char v264; // al
  int v265; // edx
  __int16 v266; // cx
  char v267; // al
  int v268; // edx
  __int16 v269; // cx
  char v270; // al
  int v271; // edx
  __int16 v272; // cx
  char v273; // al
  unsigned __int16 *v274; // esi
  int v275; // eax
  int v276; // ebx
  int v277; // ecx
  _BYTE *v278; // edi
  int v279; // eax
  unsigned int v280; // eax
  int v281; // edx
  unsigned int v282; // eax
  int v283; // esi
  char v284; // al
  int v285; // edx
  __int16 v286; // cx
  char v287; // al
  int v288; // edx
  __int16 v289; // cx
  char v290; // al
  int v291; // edx
  __int16 v292; // cx
  char v293; // al
  int v294; // edx
  __int16 v295; // cx
  char v296; // al
  int v297; // edx
  __int16 v298; // cx
  char v299; // al
  int v300; // edx
  __int16 v301; // cx
  char v302; // al
  int v303; // edx
  __int16 v304; // cx
  char v305; // al
  int v306; // edx
  __int16 v307; // cx
  char v308; // al
  int v309; // edx
  __int16 v310; // cx
  char v311; // al
  int v312; // edx
  __int16 v313; // cx
  char v314; // al
  int v315; // edx
  __int16 v316; // cx
  char v317; // al
  int v318; // edx
  __int16 v319; // cx
  char v320; // al
  int v321; // edx
  __int16 v322; // cx
  char v323; // al
  int v324; // edx
  __int16 v325; // cx
  char v326; // al
  int v327; // edx
  __int16 v328; // cx
  char v329; // al
  _WORD *j; // esi
  int v331; // ecx
  _BYTE *v332; // edi
  unsigned int v333; // eax
  __int16 v334; // bx
  __int16 v335; // bx
  __int16 v336; // bx
  __int16 v337; // cx
  __int16 v338; // bx
  __int16 v339; // cx
  __int16 v340; // bx
  __int16 v341; // cx
  __int16 v342; // bx
  __int16 v343; // cx
  __int16 v344; // bx
  __int16 v345; // cx
  __int16 v346; // bx
  __int16 v347; // cx
  __int16 v348; // bx
  __int16 v349; // cx
  __int16 v350; // bx
  __int16 v351; // cx
  __int16 v352; // bx
  __int16 v353; // cx
  __int16 v354; // bx
  __int16 v355; // cx
  __int16 v356; // bx
  __int16 v357; // cx
  __int16 v358; // bx
  __int16 v359; // cx
  __int16 v360; // bx
  __int16 v361; // cx
  __int16 v362; // bx
  __int16 v363; // cx
  __int16 v364; // bx
  __int16 v365; // cx
  unsigned int v366; // eax
  int v367; // ebx
  char *v368; // esi
  int v369; // ecx
  int v370; // edi
  int v371; // ecx
  int v372; // edx
  int v373; // ecx
  __int16 v374; // cx
  __int16 v375; // bp
  _BYTE *v376; // edi
  int v377; // ebp
  unsigned int v378; // eax
  int v379; // ebx
  char *v380; // esi
  int v381; // ecx
  int v382; // edi
  int v383; // ecx
  int v384; // edx
  int v385; // ecx
  __int16 v386; // cx
  __int16 v387; // bp
  _BYTE *v388; // edi
  int v389; // ebp
  unsigned __int16 *v390; // esi
  int v391; // eax
  int v392; // ebx
  int v393; // ecx
  _BYTE *v394; // edi
  int v395; // eax
  unsigned int v396; // eax
  int v397; // edx
  unsigned int v398; // eax
  int v399; // esi
  int v400; // edx
  __int16 v401; // cx
  int v402; // edx
  __int16 v403; // cx
  int v404; // edx
  __int16 v405; // cx
  int v406; // edx
  __int16 v407; // cx
  int v408; // edx
  __int16 v409; // cx
  int v410; // edx
  __int16 v411; // cx
  int v412; // edx
  __int16 v413; // cx
  int v414; // edx
  __int16 v415; // cx
  int v416; // edx
  __int16 v417; // cx
  int v418; // edx
  __int16 v419; // cx
  int v420; // edx
  __int16 v421; // cx
  int v422; // edx
  __int16 v423; // cx
  int v424; // edx
  __int16 v425; // cx
  int v426; // edx
  __int16 v427; // cx
  int v428; // edx
  __int16 v429; // cx
  unsigned __int16 *v430; // esi
  int v431; // eax
  int v432; // ebx
  int v433; // ecx
  _BYTE *v434; // edi
  int v435; // eax
  unsigned int v436; // eax
  int v437; // edx
  unsigned int v438; // eax
  int v439; // esi
  int v440; // edx
  __int16 v441; // cx
  int v442; // edx
  __int16 v443; // cx
  int v444; // edx
  __int16 v445; // cx
  int v446; // edx
  __int16 v447; // cx
  int v448; // edx
  __int16 v449; // cx
  int v450; // edx
  __int16 v451; // cx
  int v452; // edx
  __int16 v453; // cx
  int v454; // edx
  __int16 v455; // cx
  int v456; // edx
  __int16 v457; // cx
  int v458; // edx
  __int16 v459; // cx
  int v460; // edx
  __int16 v461; // cx
  int v462; // edx
  __int16 v463; // cx
  int v464; // edx
  __int16 v465; // cx
  int v466; // edx
  __int16 v467; // cx
  int v468; // edx
  __int16 v469; // cx
  unsigned __int16 *v470; // esi
  int v471; // eax
  int v472; // ebx
  int v473; // ecx
  _BYTE *v474; // edi
  int v475; // eax
  unsigned int v476; // eax
  int v477; // edx
  unsigned int v478; // eax
  int v479; // esi
  int v480; // edx
  __int16 v481; // cx
  int v482; // edx
  __int16 v483; // cx
  int v484; // edx
  __int16 v485; // cx
  int v486; // edx
  __int16 v487; // cx
  int v488; // edx
  __int16 v489; // cx
  int v490; // edx
  __int16 v491; // cx
  int v492; // edx
  __int16 v493; // cx
  int v494; // edx
  __int16 v495; // cx
  int v496; // edx
  __int16 v497; // cx
  int v498; // edx
  __int16 v499; // cx
  int v500; // edx
  __int16 v501; // cx
  int v502; // edx
  __int16 v503; // cx
  int v504; // edx
  __int16 v505; // cx
  int v506; // edx
  __int16 v507; // cx
  int v508; // edx
  __int16 v509; // cx
  unsigned __int16 *v510; // esi
  int v511; // eax
  int v512; // ebx
  int v513; // ecx
  _BYTE *v514; // edi
  int v515; // eax
  unsigned int v516; // eax
  int v517; // edx
  unsigned int v518; // eax
  int v519; // esi
  int v520; // edx
  __int16 v521; // cx
  int v522; // edx
  __int16 v523; // cx
  int v524; // edx
  __int16 v525; // cx
  int v526; // edx
  __int16 v527; // cx
  int v528; // edx
  __int16 v529; // cx
  int v530; // edx
  __int16 v531; // cx
  int v532; // edx
  __int16 v533; // cx
  int v534; // edx
  __int16 v535; // cx
  int v536; // edx
  __int16 v537; // cx
  int v538; // edx
  __int16 v539; // cx
  int v540; // edx
  __int16 v541; // cx
  int v542; // edx
  __int16 v543; // cx
  int v544; // edx
  __int16 v545; // cx
  int v546; // edx
  __int16 v547; // cx
  int v548; // edx
  __int16 v549; // cx
  unsigned __int16 *v550; // esi
  int v551; // eax
  int v552; // ebx
  int v553; // ecx
  _BYTE *v554; // edi
  int v555; // eax
  unsigned int v556; // eax
  int v557; // edx
  unsigned int v558; // eax
  int v559; // esi
  int v560; // edx
  __int16 v561; // cx
  int v562; // edx
  __int16 v563; // cx
  int v564; // edx
  __int16 v565; // cx
  int v566; // edx
  __int16 v567; // cx
  int v568; // edx
  __int16 v569; // cx
  int v570; // edx
  __int16 v571; // cx
  int v572; // edx
  __int16 v573; // cx
  int v574; // edx
  __int16 v575; // cx
  int v576; // edx
  __int16 v577; // cx
  int v578; // edx
  __int16 v579; // cx
  int v580; // edx
  __int16 v581; // cx
  int v582; // edx
  __int16 v583; // cx
  int v584; // edx
  __int16 v585; // cx
  int v586; // edx
  __int16 v587; // cx
  int v588; // edx
  __int16 v589; // cx
  unsigned __int16 *v590; // esi
  _BYTE *v591; // edx
  int v592; // eax
  int v593; // ebx
  int v594; // ecx
  _BYTE *k; // edi
  __int16 v596; // cx
  __int16 v597; // cx
  __int16 v598; // cx
  __int16 v599; // cx
  __int16 v600; // cx
  __int16 v601; // cx
  __int16 v602; // cx
  __int16 v603; // cx
  __int16 v604; // cx
  __int16 v605; // cx
  __int16 v606; // cx
  __int16 v607; // cx
  __int16 v608; // cx
  __int16 v609; // cx
  __int16 v610; // cx
  unsigned __int16 *v611; // esi
  _BYTE *v612; // edx
  int v613; // eax
  int v614; // ebx
  int v615; // ecx
  _BYTE *m; // edi
  __int16 v617; // cx
  __int16 v618; // cx
  __int16 v619; // cx
  __int16 v620; // cx
  __int16 v621; // cx
  __int16 v622; // cx
  __int16 v623; // cx
  __int16 v624; // cx
  __int16 v625; // cx
  __int16 v626; // cx
  __int16 v627; // cx
  __int16 v628; // cx
  __int16 v629; // cx
  __int16 v630; // cx
  __int16 v631; // cx
  unsigned __int16 *v632; // esi
  int v633; // edx
  int v634; // ecx
  _BYTE *v635; // edi
  unsigned int v636; // eax
  __int16 v637; // bx
  unsigned __int16 v638; // bx
  __int16 v639; // bx
  __int16 v640; // cx
  __int16 v641; // bx
  __int16 v642; // cx
  __int16 v643; // bx
  __int16 v644; // cx
  __int16 v645; // bx
  __int16 v646; // cx
  __int16 v647; // bx
  __int16 v648; // cx
  __int16 v649; // bx
  __int16 v650; // cx
  __int16 v651; // bx
  __int16 v652; // cx
  __int16 v653; // bx
  __int16 v654; // cx
  __int16 v655; // bx
  __int16 v656; // cx
  __int16 v657; // bx
  __int16 v658; // cx
  __int16 v659; // bx
  __int16 v660; // cx
  __int16 v661; // bx
  __int16 v662; // cx
  __int16 v663; // bx
  __int16 v664; // cx
  __int16 v665; // bx
  __int16 v666; // cx
  __int16 v667; // bx
  __int16 v668; // cx
  unsigned __int16 *v669; // esi
  int v670; // edx
  int v671; // ecx
  _BYTE *v672; // edi
  unsigned int v673; // eax
  __int16 v674; // bx
  unsigned __int16 v675; // bx
  __int16 v676; // bx
  __int16 v677; // cx
  __int16 v678; // bx
  __int16 v679; // cx
  __int16 v680; // bx
  __int16 v681; // cx
  __int16 v682; // bx
  __int16 v683; // cx
  __int16 v684; // bx
  __int16 v685; // cx
  __int16 v686; // bx
  __int16 v687; // cx
  __int16 v688; // bx
  __int16 v689; // cx
  __int16 v690; // bx
  __int16 v691; // cx
  __int16 v692; // bx
  __int16 v693; // cx
  __int16 v694; // bx
  __int16 v695; // cx
  __int16 v696; // bx
  __int16 v697; // cx
  __int16 v698; // bx
  __int16 v699; // cx
  __int16 v700; // bx
  __int16 v701; // cx
  __int16 v702; // bx
  __int16 v703; // cx
  __int16 v704; // bx
  __int16 v705; // cx
  unsigned __int16 *v706; // esi
  int v707; // eax
  int v708; // ebx
  int v709; // ecx
  _BYTE *v710; // edi
  int v711; // eax
  unsigned int v712; // eax
  int v713; // edx
  unsigned int v714; // eax
  int v715; // esi
  int v716; // edx
  __int16 v717; // cx
  int v718; // edx
  __int16 v719; // cx
  int v720; // edx
  __int16 v721; // cx
  int v722; // edx
  __int16 v723; // cx
  int v724; // edx
  __int16 v725; // cx
  int v726; // edx
  __int16 v727; // cx
  int v728; // edx
  __int16 v729; // cx
  int v730; // edx
  __int16 v731; // cx
  int v732; // edx
  __int16 v733; // cx
  int v734; // edx
  __int16 v735; // cx
  int v736; // edx
  __int16 v737; // cx
  int v738; // edx
  __int16 v739; // cx
  int v740; // edx
  __int16 v741; // cx
  int v742; // edx
  __int16 v743; // cx
  int v744; // edx
  __int16 v745; // cx
  unsigned __int16 *v746; // esi
  int v747; // eax
  int v748; // ebx
  int v749; // ecx
  _BYTE *v750; // edi
  int v751; // eax
  unsigned int v752; // eax
  int v753; // edx
  unsigned int v754; // eax
  int v755; // esi
  int v756; // edx
  __int16 v757; // cx
  int v758; // edx
  __int16 v759; // cx
  int v760; // edx
  __int16 v761; // cx
  int v762; // edx
  __int16 v763; // cx
  int v764; // edx
  __int16 v765; // cx
  int v766; // edx
  __int16 v767; // cx
  int v768; // edx
  __int16 v769; // cx
  int v770; // edx
  __int16 v771; // cx
  int v772; // edx
  __int16 v773; // cx
  int v774; // edx
  __int16 v775; // cx
  int v776; // edx
  __int16 v777; // cx
  int v778; // edx
  __int16 v779; // cx
  int v780; // edx
  __int16 v781; // cx
  int v782; // edx
  __int16 v783; // cx
  int v784; // edx
  __int16 v785; // cx
  unsigned __int16 *v786; // esi
  unsigned int v787; // eax
  int v788; // ebx
  int v789; // ecx
  _BYTE *v790; // edi
  int v791; // ecx
  int v792; // edx
  int v793; // ecx
  int v794; // esi
  int v795; // edx
  int v796; // ecx
  int v797; // edx
  int v798; // ecx
  int v799; // edx
  int v800; // ecx
  int v801; // edx
  int v802; // ecx
  int v803; // edx
  int v804; // ecx
  int v805; // edx
  int v806; // ecx
  int v807; // edx
  int v808; // ecx
  int v809; // edx
  int v810; // ecx
  int v811; // edx
  int v812; // ecx
  int v813; // edx
  int v814; // ecx
  int v815; // edx
  int v816; // ecx
  int v817; // edx
  int v818; // ecx
  int v819; // edx
  int v820; // ecx
  int v821; // edx
  int v822; // ecx
  int v823; // edx
  int v824; // ecx
  unsigned __int16 *v825; // esi
  unsigned int v826; // eax
  int v827; // ebx
  int v828; // ecx
  _BYTE *v829; // edi
  int v830; // ecx
  int v831; // edx
  int v832; // ecx
  int v833; // esi
  int v834; // edx
  int v835; // ecx
  int v836; // edx
  int v837; // ecx
  int v838; // edx
  int v839; // ecx
  int v840; // edx
  int v841; // ecx
  int v842; // edx
  int v843; // ecx
  int v844; // edx
  int v845; // ecx
  int v846; // edx
  int v847; // ecx
  int v848; // edx
  int v849; // ecx
  int v850; // edx
  int v851; // ecx
  int v852; // edx
  int v853; // ecx
  int v854; // edx
  int v855; // ecx
  int v856; // edx
  int v857; // ecx
  int v858; // edx
  int v859; // ecx
  int v860; // edx
  int v861; // ecx
  int v862; // edx
  int v863; // ecx
  unsigned __int16 *v864; // esi
  int v865; // eax
  int v866; // ebx
  int v867; // ecx
  _BYTE *v868; // edi
  int v869; // eax
  unsigned int v870; // eax
  int v871; // edx
  unsigned int v872; // eax
  int v873; // esi
  int v874; // edx
  __int16 v875; // cx
  int v876; // edx
  __int16 v877; // cx
  int v878; // edx
  __int16 v879; // cx
  int v880; // edx
  __int16 v881; // cx
  int v882; // edx
  __int16 v883; // cx
  int v884; // edx
  __int16 v885; // cx
  int v886; // edx
  __int16 v887; // cx
  int v888; // edx
  __int16 v889; // cx
  int v890; // edx
  __int16 v891; // cx
  int v892; // edx
  __int16 v893; // cx
  int v894; // edx
  __int16 v895; // cx
  int v896; // edx
  __int16 v897; // cx
  int v898; // edx
  __int16 v899; // cx
  int v900; // edx
  __int16 v901; // cx
  int v902; // edx
  __int16 v903; // cx
  unsigned __int16 *v904; // esi
  int v905; // eax
  int v906; // ebx
  int v907; // ecx
  _BYTE *v908; // edi
  int v909; // eax
  unsigned int v910; // eax
  int v911; // edx
  unsigned int v912; // eax
  int v913; // esi
  int v914; // edx
  __int16 v915; // cx
  int v916; // edx
  __int16 v917; // cx
  int v918; // edx
  __int16 v919; // cx
  int v920; // edx
  __int16 v921; // cx
  int v922; // edx
  __int16 v923; // cx
  int v924; // edx
  __int16 v925; // cx
  int v926; // edx
  __int16 v927; // cx
  int v928; // edx
  __int16 v929; // cx
  int v930; // edx
  __int16 v931; // cx
  int v932; // edx
  __int16 v933; // cx
  int v934; // edx
  __int16 v935; // cx
  int v936; // edx
  __int16 v937; // cx
  int v938; // edx
  __int16 v939; // cx
  int v940; // edx
  __int16 v941; // cx
  int v942; // edx
  __int16 v943; // cx
  unsigned __int16 *v944; // esi
  unsigned int v945; // eax
  int v946; // ebx
  int v947; // ecx
  _BYTE *v948; // edi
  int v949; // ecx
  int v950; // edx
  int v951; // ecx
  int v952; // esi
  int v953; // edx
  int v954; // ecx
  int v955; // edx
  int v956; // ecx
  int v957; // edx
  int v958; // ecx
  int v959; // edx
  int v960; // ecx
  int v961; // edx
  int v962; // ecx
  int v963; // edx
  int v964; // ecx
  int v965; // edx
  int v966; // ecx
  int v967; // edx
  int v968; // ecx
  int v969; // edx
  int v970; // ecx
  int v971; // edx
  int v972; // ecx
  int v973; // edx
  int v974; // ecx
  int v975; // edx
  int v976; // ecx
  int v977; // edx
  int v978; // ecx
  int v979; // edx
  int v980; // ecx
  int v981; // edx
  int v982; // ecx
  unsigned __int16 *v983; // esi
  unsigned int v984; // eax
  int v985; // ebx
  int v986; // ecx
  _BYTE *v987; // edi
  int v988; // ecx
  int v989; // edx
  int v990; // ecx
  int v991; // esi
  int v992; // edx
  int v993; // ecx
  int v994; // edx
  int v995; // ecx
  int v996; // edx
  int v997; // ecx
  int v998; // edx
  int v999; // ecx
  int v1000; // edx
  int v1001; // ecx
  int v1002; // edx
  int v1003; // ecx
  int v1004; // edx
  int v1005; // ecx
  int v1006; // edx
  int v1007; // ecx
  int v1008; // edx
  int v1009; // ecx
  int v1010; // edx
  int v1011; // ecx
  int v1012; // edx
  int v1013; // ecx
  int v1014; // edx
  int v1015; // ecx
  int v1016; // edx
  int v1017; // ecx
  int v1018; // edx
  int v1019; // ecx
  int v1020; // edx
  int v1021; // ecx
  unsigned __int16 *v1022; // esi
  unsigned int v1023; // eax
  int v1024; // ebx
  int v1025; // ecx
  char *v1026; // edi
  int v1027; // ecx
  int v1028; // edx
  int v1029; // ecx
  int v1030; // esi
  char v1031; // al
  int v1032; // edx
  int v1033; // ecx
  char v1034; // al
  int v1035; // edx
  int v1036; // ecx
  char v1037; // al
  int v1038; // edx
  int v1039; // ecx
  char v1040; // al
  int v1041; // edx
  int v1042; // ecx
  char v1043; // al
  int v1044; // edx
  int v1045; // ecx
  char v1046; // al
  int v1047; // edx
  int v1048; // ecx
  char v1049; // al
  int v1050; // edx
  int v1051; // ecx
  char v1052; // al
  int v1053; // edx
  int v1054; // ecx
  char v1055; // al
  int v1056; // edx
  int v1057; // ecx
  char v1058; // al
  int v1059; // edx
  int v1060; // ecx
  char v1061; // al
  int v1062; // edx
  int v1063; // ecx
  char v1064; // al
  int v1065; // edx
  int v1066; // ecx
  char v1067; // al
  int v1068; // edx
  int v1069; // ecx
  char v1070; // al
  int v1071; // edx
  int v1072; // ecx
  char v1073; // al
  int v1074; // edx
  int v1075; // ecx
  char v1076; // al
  int v1077; // [esp+0h] [ebp-88h]
  int v1078; // [esp+4h] [ebp-84h]
  int v1079; // [esp+4h] [ebp-84h]
  int v1080; // [esp+4h] [ebp-84h]
  int v1081; // [esp+4h] [ebp-84h]
  int v1082; // [esp+8h] [ebp-80h]
  int v1083; // [esp+8h] [ebp-80h]
  int v1084; // [esp+8h] [ebp-80h]
  int v1085; // [esp+8h] [ebp-80h]
  int v1086; // [esp+Ch] [ebp-7Ch]
  int v1087; // [esp+Ch] [ebp-7Ch]
  int v1088; // [esp+10h] [ebp-78h]
  int v1089; // [esp+10h] [ebp-78h]
  int v1090; // [esp+10h] [ebp-78h]
  int v1091; // [esp+10h] [ebp-78h]
  int v1092; // [esp+14h] [ebp-74h]
  int v1093; // [esp+14h] [ebp-74h]
  int v1094; // [esp+18h] [ebp-70h]
  int v1095; // [esp+18h] [ebp-70h]
  int v1096; // [esp+1Ch] [ebp-6Ch]
  int v1097; // [esp+1Ch] [ebp-6Ch]
  int v1098; // [esp+20h] [ebp-68h]
  int v1099; // [esp+24h] [ebp-64h]
  int v1100; // [esp+28h] [ebp-60h]
  int v1101; // [esp+28h] [ebp-60h]
  int v1102; // [esp+28h] [ebp-60h]
  int v1103; // [esp+28h] [ebp-60h]
  int v1104; // [esp+28h] [ebp-60h]
  int v1105; // [esp+28h] [ebp-60h]
  int v1106; // [esp+28h] [ebp-60h]
  int v1107; // [esp+28h] [ebp-60h]
  int v1108; // [esp+2Ch] [ebp-5Ch]
  int v1109; // [esp+2Ch] [ebp-5Ch]
  int v1110; // [esp+30h] [ebp-58h]
  int v1111; // [esp+34h] [ebp-54h]
  int v1112; // [esp+34h] [ebp-54h]
  int v1113; // [esp+34h] [ebp-54h]
  int v1114; // [esp+34h] [ebp-54h]
  int v1115; // [esp+34h] [ebp-54h]
  int v1116; // [esp+34h] [ebp-54h]
  int v1117; // [esp+34h] [ebp-54h]
  int v1118; // [esp+34h] [ebp-54h]
  int v1119; // [esp+38h] [ebp-50h]
  int v1120; // [esp+38h] [ebp-50h]
  int v1121; // [esp+3Ch] [ebp-4Ch]
  int v1122; // [esp+40h] [ebp-48h]
  int v1123; // [esp+40h] [ebp-48h]
  int v1124; // [esp+40h] [ebp-48h]
  int v1125; // [esp+40h] [ebp-48h]
  int v1126; // [esp+40h] [ebp-48h]
  int v1127; // [esp+40h] [ebp-48h]
  int v1128; // [esp+40h] [ebp-48h]
  int v1129; // [esp+40h] [ebp-48h]
  int v1130; // [esp+44h] [ebp-44h]
  int v1131; // [esp+44h] [ebp-44h]
  int v1132; // [esp+48h] [ebp-40h]
  int v1133; // [esp+48h] [ebp-40h]
  int v1134; // [esp+48h] [ebp-40h]
  int v1135; // [esp+48h] [ebp-40h]
  int v1136; // [esp+48h] [ebp-40h]
  int v1137; // [esp+48h] [ebp-40h]
  int v1138; // [esp+48h] [ebp-40h]
  int v1139; // [esp+48h] [ebp-40h]
  int v1140; // [esp+48h] [ebp-40h]
  int v1141; // [esp+48h] [ebp-40h]
  int v1142; // [esp+48h] [ebp-40h]
  int v1143; // [esp+48h] [ebp-40h]
  int v1144; // [esp+48h] [ebp-40h]
  int v1145; // [esp+48h] [ebp-40h]
  int v1146; // [esp+48h] [ebp-40h]
  int v1147; // [esp+48h] [ebp-40h]
  int v1148; // [esp+4Ch] [ebp-3Ch]
  int v1149; // [esp+4Ch] [ebp-3Ch]
  int v1150; // [esp+4Ch] [ebp-3Ch]
  int v1151; // [esp+4Ch] [ebp-3Ch]
  int v1152; // [esp+4Ch] [ebp-3Ch]
  int v1153; // [esp+4Ch] [ebp-3Ch]
  int v1154; // [esp+4Ch] [ebp-3Ch]
  int v1155; // [esp+4Ch] [ebp-3Ch]
  int v1156; // [esp+4Ch] [ebp-3Ch]
  int v1157; // [esp+4Ch] [ebp-3Ch]
  int v1158; // [esp+4Ch] [ebp-3Ch]
  int v1159; // [esp+4Ch] [ebp-3Ch]
  int v1160; // [esp+4Ch] [ebp-3Ch]
  int v1161; // [esp+4Ch] [ebp-3Ch]
  int v1162; // [esp+4Ch] [ebp-3Ch]
  int v1163; // [esp+4Ch] [ebp-3Ch]
  int v1164; // [esp+4Ch] [ebp-3Ch]
  int v1165; // [esp+4Ch] [ebp-3Ch]
  int v1166; // [esp+50h] [ebp-38h]
  int v1167; // [esp+50h] [ebp-38h]
  int v1168; // [esp+50h] [ebp-38h]
  int v1169; // [esp+50h] [ebp-38h]
  int v1170; // [esp+50h] [ebp-38h]
  int v1171; // [esp+50h] [ebp-38h]
  int v1172; // [esp+50h] [ebp-38h]
  int v1173; // [esp+54h] [ebp-34h]
  int v1174; // [esp+54h] [ebp-34h]
  int v1175; // [esp+54h] [ebp-34h]
  int v1176; // [esp+54h] [ebp-34h]
  int v1177; // [esp+58h] [ebp-30h]
  int v1178; // [esp+58h] [ebp-30h]
  int v1179; // [esp+58h] [ebp-30h]
  int v1180; // [esp+58h] [ebp-30h]
  int v1181; // [esp+58h] [ebp-30h]
  int v1182; // [esp+58h] [ebp-30h]
  int v1183; // [esp+58h] [ebp-30h]
  int v1184; // [esp+58h] [ebp-30h]
  int v1185; // [esp+58h] [ebp-30h]
  int v1186; // [esp+58h] [ebp-30h]
  int v1187; // [esp+58h] [ebp-30h]
  int v1188; // [esp+58h] [ebp-30h]
  int v1189; // [esp+58h] [ebp-30h]
  int v1190; // [esp+58h] [ebp-30h]
  int v1191; // [esp+58h] [ebp-30h]
  int v1192; // [esp+58h] [ebp-30h]
  int v1193; // [esp+58h] [ebp-30h]
  int v1194; // [esp+58h] [ebp-30h]
  int v1195; // [esp+58h] [ebp-30h]
  int v1196; // [esp+58h] [ebp-30h]
  int v1197; // [esp+58h] [ebp-30h]
  int v1198; // [esp+58h] [ebp-30h]
  int v1199; // [esp+58h] [ebp-30h]
  int v1200; // [esp+58h] [ebp-30h]
  int v1201; // [esp+58h] [ebp-30h]
  int v1202; // [esp+58h] [ebp-30h]
  int v1203; // [esp+58h] [ebp-30h]
  int v1204; // [esp+58h] [ebp-30h]
  int v1205; // [esp+58h] [ebp-30h]
  int v1206; // [esp+58h] [ebp-30h]
  int v1207; // [esp+58h] [ebp-30h]
  int v1208; // [esp+58h] [ebp-30h]
  int v1209; // [esp+58h] [ebp-30h]
  int v1210; // [esp+58h] [ebp-30h]
  int v1211; // [esp+58h] [ebp-30h]
  int v1212; // [esp+58h] [ebp-30h]
  int v1213; // [esp+58h] [ebp-30h]
  int v1214; // [esp+58h] [ebp-30h]
  int v1215; // [esp+58h] [ebp-30h]
  int v1216; // [esp+58h] [ebp-30h]
  int v1217; // [esp+58h] [ebp-30h]
  int v1218; // [esp+58h] [ebp-30h]
  int v1219; // [esp+58h] [ebp-30h]
  int v1220; // [esp+58h] [ebp-30h]
  int v1221; // [esp+58h] [ebp-30h]
  int v1222; // [esp+58h] [ebp-30h]
  int v1223; // [esp+58h] [ebp-30h]
  int v1224; // [esp+58h] [ebp-30h]
  int v1225; // [esp+58h] [ebp-30h]
  int v1226; // [esp+58h] [ebp-30h]
  int v1227; // [esp+58h] [ebp-30h]
  int v1228; // [esp+58h] [ebp-30h]
  int v1229; // [esp+58h] [ebp-30h]
  int v1230; // [esp+58h] [ebp-30h]
  int v1231; // [esp+58h] [ebp-30h]
  int v1232; // [esp+58h] [ebp-30h]
  int v1233; // [esp+58h] [ebp-30h]
  int v1234; // [esp+58h] [ebp-30h]
  int v1235; // [esp+58h] [ebp-30h]
  int v1236; // [esp+58h] [ebp-30h]
  int v1237; // [esp+58h] [ebp-30h]
  int v1238; // [esp+58h] [ebp-30h]
  int v1239; // [esp+58h] [ebp-30h]
  int v1240; // [esp+58h] [ebp-30h]
  int v1241; // [esp+58h] [ebp-30h]
  int v1242; // [esp+58h] [ebp-30h]
  int v1243; // [esp+58h] [ebp-30h]
  int v1244; // [esp+58h] [ebp-30h]
  int v1245; // [esp+58h] [ebp-30h]
  int v1246; // [esp+58h] [ebp-30h]
  int v1247; // [esp+58h] [ebp-30h]
  int v1248; // [esp+58h] [ebp-30h]
  int v1249; // [esp+58h] [ebp-30h]
  int v1250; // [esp+58h] [ebp-30h]
  int v1251; // [esp+58h] [ebp-30h]
  int v1252; // [esp+58h] [ebp-30h]
  int v1253; // [esp+58h] [ebp-30h]
  int v1254; // [esp+58h] [ebp-30h]
  int v1255; // [esp+58h] [ebp-30h]
  int v1256; // [esp+58h] [ebp-30h]
  unsigned __int16 *v1257; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1258; // [esp+5Ch] [ebp-2Ch]
  char *v1259; // [esp+5Ch] [ebp-2Ch]
  char *v1260; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1261; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1262; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1263; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1264; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1265; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1266; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1267; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1268; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1269; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1270; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1271; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1272; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1273; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1274; // [esp+5Ch] [ebp-2Ch]
  char v1275; // [esp+62h] [ebp-26h]
  char v1276; // [esp+62h] [ebp-26h]
  char v1277; // [esp+62h] [ebp-26h]
  char v1278; // [esp+62h] [ebp-26h]
  char v1279; // [esp+63h] [ebp-25h]
  char v1280; // [esp+63h] [ebp-25h]
  _BOOL1 v1281; // [esp+63h] [ebp-25h]
  _BOOL1 v1282; // [esp+63h] [ebp-25h]
  _BOOL1 v1283; // [esp+64h] [ebp-24h]
  _BOOL1 v1284; // [esp+64h] [ebp-24h]

  //fix
  v16 = 0;
  v27 = 0;
  v1022 = 0;
  //fix

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = a1[1];
  v7 = a2[1];
  v8 = a3[1];
  if ( v6 == v7 )
  {
    if ( v6 == v8 )
      return;
    if ( v6 >= v8 )
    {
      if ( *a1 <= *a2 )
        return;
      v3 = a3;
      v4 = a1;
      v5 = a2;
      goto LABEL_225;
    }
    if ( *a2 <= *a1 )
      return;
    goto LABEL_268;
  }
  if ( v6 <= v7 )
  {
    if ( v6 != v8 )
    {
      if ( v6 >= v8 )
      {
        v3 = a3;
        v4 = a1;
        v5 = a2;
LABEL_24:
        v9 = v3[1];
        v1173 = v9;
        if ( v9 >= 0 )
        {
          if ( v9 >= dword_93ADC )
            return;
          v1077 = dword_93AC8 + dword_93AD4 * v9;
          v1275 = 0;
        }
        else
        {
          v1077 = dword_93AC8;
          v1275 = 1;
        }
        v10 = v5[1];
        v1283 = v10 > dword_93ADC;
        v1088 = v10 - v9;
        v1098 = v10 - v9;
        v11 = v4[1];
        v1279 = v11 > dword_93ADC;
        v12 = v11 - v9;
        v1092 = v12;
        v1078 = ((*v5 - *v3) << 16) / v1088;
        if ( ((*v4 - *v3) << 16) / v12 > v1078 )
        {
          v1082 = ((*v4 - *v3) << 16) / v12;
          v1086 = ((*v5 - *v4) << 16) / (v5[1] - v4[1]);
          v1094 = v5[1] - v4[1];
          v1096 = *v4 << 16;
          switch ( byte_967E1 )
          {
            case 0:
            case 14:
            case 15:
              v54 = *v3 << 16;
              v55 = v54;
              if ( !v1275 )
              {
                if ( v1283 )
                {
                  v58 = dword_93ADC - v1173;
                  v1098 = dword_93ADC - v1173;
                  if ( v1279 )
                  {
                    v1092 = dword_93ADC - v1173;
                  }
                  else
                  {
                    //fix v27 = __OFSUB__(v58, v1092);
                    v59 = v58 - v1092;
                    v1279 = (v59 < 0) ^ v27 | (v59 == 0);
                    v1094 = v59;
                  }
                }
                goto LABEL_116;
              }
              v16 = v1098 <= -v1173;
              v1098 += v1173;
              if ( !v16 )
              {
                v1138 = -v1173;
                if ( -v1173 - v1092 >= 0 )
                {
                  v1094 -= v1138 - v1092;
                  v1139 = v1138 - v1092;
                  v54 += v1078 * v1139 + v1092 * v1078;
                  v56 = v1086 * v1139 + v1096;
                  if ( v1283 )
                  {
                    v1094 = dword_93ADC;
                    v1098 = dword_93ADC;
                  }
                  v57 = (uint32*)&unk_93AE0;
LABEL_119:
                  if ( v1279 )
                  {
                    v29 = (unsigned __int8)byte_967E1;
                    switch ( byte_967E1 )
                    {
                      case 0:
                        goto LABEL_309;
                      case 1:
                        goto LABEL_322;
                      case 2:
                        goto LABEL_351;
                      case 3:
                        goto LABEL_382;
                      case 4:
                        goto LABEL_445;
                      case 5:
                        goto LABEL_474;
                      case 6:
                        goto LABEL_503;
                      case 7:
                      case 11:
                        goto LABEL_564;
                      case 8:
                        goto LABEL_595;
                      case 9:
                      case 10:
                        goto LABEL_658;
                      case 12:
                        goto LABEL_721;
                      case 13:
                        goto LABEL_752;
                      case 14:
                        goto LABEL_783;
                      case 15:
                        goto LABEL_812;
                      case 16:
                        goto LABEL_841;
                      case 17:
                        goto LABEL_870;
                      case 18:
                        goto LABEL_899;
                      case 19:
                        goto LABEL_930;
                      case 20:
                        goto LABEL_961;
                      case 21:
                        goto LABEL_992;
                      case 22:
                        goto LABEL_1023;
                      case 23:
                        goto LABEL_1086;
                      case 24:
                        goto LABEL_1149;
                      case 25:
                        goto LABEL_1212;
                      case 26:
                        goto LABEL_1275;
                    }
                  }
                  do
                  {
                    *v57 = v54;
                    v54 += v1078;
                    v57[1] = v56;
                    v56 += v1086;
                    v57 += 5;
                    --v1094;
                  }
                  while ( v1094 );
                  v29 = (unsigned __int8)byte_967E1;
                  switch ( byte_967E1 )
                  {
                    case 0:
                      goto LABEL_309;
                    case 1:
                      goto LABEL_322;
                    case 2:
                      goto LABEL_351;
                    case 3:
                      goto LABEL_382;
                    case 4:
                      goto LABEL_445;
                    case 5:
                      goto LABEL_474;
                    case 6:
                      goto LABEL_503;
                    case 7:
                    case 11:
                      goto LABEL_564;
                    case 8:
                      goto LABEL_595;
                    case 9:
                    case 10:
                      goto LABEL_658;
                    case 12:
                      goto LABEL_721;
                    case 13:
                      goto LABEL_752;
                    case 14:
                      goto LABEL_783;
                    case 15:
                      goto LABEL_812;
                    case 16:
                      goto LABEL_841;
                    case 17:
                      goto LABEL_870;
                    case 18:
                      goto LABEL_899;
                    case 19:
                      goto LABEL_930;
                    case 20:
                      goto LABEL_961;
                    case 21:
                      goto LABEL_992;
                    case 22:
                      goto LABEL_1023;
                    case 23:
                      goto LABEL_1086;
                    case 24:
                      goto LABEL_1149;
                    case 25:
                      goto LABEL_1212;
                    case 26:
                      goto LABEL_1275;
                  }
                }
                v1092 += v1173;
                v54 += v1078 * v1138;
                v55 += v1138 * v1082;
                if ( v1283 )
                {
                  v1098 = dword_93ADC;
                  if ( v1279 )
                  {
                    v1092 = dword_93ADC;
                  }
                  else
                  {
                    v1279 = dword_93ADC <= v1092;
                    v1094 = dword_93ADC - v1092;
                  }
                }
LABEL_116:
                v57 = (uint32*)&unk_93AE0;
                do
                {
                  *v57 = v54;
                  v54 += v1078;
                  v57[1] = v55;
                  v55 += v1082;
                  v57 += 5;
                  --v1092;
                }
                while ( v1092 );
                v56 = v1096;
                goto LABEL_119;
              }
              return;
            case 1:
            case 4:
            case 16:
            case 17:
              v43 = v12 * (__int64)(*v3 - *v5) / v1088;
              v44 = *v4 - *v3;
              v45 = v43 + v44 == 0;
              //fix v16 = (v43 + v44 < 0) ^ __OFADD__(v43, v44);
              v46 = v43 + v44;
              if ( v16 )
                return;
              if ( !v45 )
                v1121 = (int)(v4[4] + v1092 * (__int64)(v3[4] - v5[4]) / v1088 - v3[4]) / (v46 + 1);
              v1123 = (v5[4] - v3[4]) / v1088;
              v47 = *v3 << 16;
              v48 = v47;
              v49 = v3[4];
              if ( !v1275 )
              {
                if ( v1283 )
                {
                  v52 = dword_93ADC - v1173;
                  v1098 = dword_93ADC - v1173;
                  if ( v1279 )
                  {
                    v1092 = dword_93ADC - v1173;
                  }
                  else
                  {
                    //fix v27 = __OFSUB__(v52, v1092);
                    v53 = v52 - v1092;
                    v1279 = (v53 < 0) ^ v27 | (v53 == 0);
                    v1094 = v53;
                  }
                }
                goto LABEL_95;
              }
              v16 = v1098 <= -v1173;
              v1098 += v1173;
              if ( !v16 )
              {
                v1136 = -v1173;
                if ( -v1173 - v1092 >= 0 )
                {
                  v1094 -= v1136 - v1092;
                  v1137 = v1136 - v1092;
                  v47 += v1078 * v1137 + v1092 * v1078;
                  v50 = v1086 * v1137 + v1096;
                  v49 += v1137 * v1123 + v1092 * v1123;
                  if ( v1283 )
                  {
                    v1094 = dword_93ADC;
                    v1098 = dword_93ADC;
                  }
                  v51 = (uint32*)&unk_93AE0;
LABEL_98:
                  if ( v1279 )
                  {
                    v29 = (unsigned __int8)byte_967E1;
                    switch ( byte_967E1 )
                    {
                      case 0:
                        goto LABEL_309;
                      case 1:
                        goto LABEL_322;
                      case 2:
                        goto LABEL_351;
                      case 3:
                        goto LABEL_382;
                      case 4:
                        goto LABEL_445;
                      case 5:
                        goto LABEL_474;
                      case 6:
                        goto LABEL_503;
                      case 7:
                      case 11:
                        goto LABEL_564;
                      case 8:
                        goto LABEL_595;
                      case 9:
                      case 10:
                        goto LABEL_658;
                      case 12:
                        goto LABEL_721;
                      case 13:
                        goto LABEL_752;
                      case 14:
                        goto LABEL_783;
                      case 15:
                        goto LABEL_812;
                      case 16:
                        goto LABEL_841;
                      case 17:
                        goto LABEL_870;
                      case 18:
                        goto LABEL_899;
                      case 19:
                        goto LABEL_930;
                      case 20:
                        goto LABEL_961;
                      case 21:
                        goto LABEL_992;
                      case 22:
                        goto LABEL_1023;
                      case 23:
                        goto LABEL_1086;
                      case 24:
                        goto LABEL_1149;
                      case 25:
                        goto LABEL_1212;
                      case 26:
                        goto LABEL_1275;
                    }
                  }
                  do
                  {
                    *v51 = v47;
                    v47 += v1078;
                    v51[1] = v50;
                    v50 += v1086;
                    v51[4] = v49;
                    v49 += v1123;
                    v51 += 5;
                    --v1094;
                  }
                  while ( v1094 );
                  v29 = (unsigned __int8)byte_967E1;
                  switch ( byte_967E1 )
                  {
                    case 0:
                      goto LABEL_309;
                    case 1:
                      goto LABEL_322;
                    case 2:
                      goto LABEL_351;
                    case 3:
                      goto LABEL_382;
                    case 4:
                      goto LABEL_445;
                    case 5:
                      goto LABEL_474;
                    case 6:
                      goto LABEL_503;
                    case 7:
                    case 11:
                      goto LABEL_564;
                    case 8:
                      goto LABEL_595;
                    case 9:
                    case 10:
                      goto LABEL_658;
                    case 12:
                      goto LABEL_721;
                    case 13:
                      goto LABEL_752;
                    case 14:
                      goto LABEL_783;
                    case 15:
                      goto LABEL_812;
                    case 16:
                      goto LABEL_841;
                    case 17:
                      goto LABEL_870;
                    case 18:
                      goto LABEL_899;
                    case 19:
                      goto LABEL_930;
                    case 20:
                      goto LABEL_961;
                    case 21:
                      goto LABEL_992;
                    case 22:
                      goto LABEL_1023;
                    case 23:
                      goto LABEL_1086;
                    case 24:
                      goto LABEL_1149;
                    case 25:
                      goto LABEL_1212;
                    case 26:
                      goto LABEL_1275;
                  }
                }
                v1092 += v1173;
                v47 += v1078 * v1136;
                v48 += v1136 * v1082;
                v49 += v1136 * v1123;
                if ( v1283 )
                {
                  v1098 = dword_93ADC;
                  if ( v1279 )
                  {
                    v1092 = dword_93ADC;
                  }
                  else
                  {
                    v1279 = dword_93ADC <= v1092;
                    v1094 = dword_93ADC - v1092;
                  }
                }
LABEL_95:
                v51 = (uint32*)&unk_93AE0;
                do
                {
                  *v51 = v47;
                  v47 += v1078;
                  v51[1] = v48;
                  v48 += v1082;
                  v51[4] = v49;
                  v49 += v1123;
                  v51 += 5;
                  --v1092;
                }
                while ( v1092 );
                v50 = v1096;
                goto LABEL_98;
              }
              return;
            case 2:
            case 3:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 18:
            case 19:
            case 22:
            case 23:
              v30 = v12 * (__int64)(*v3 - *v5) / v1088;
              v31 = *v4 - *v3;
              v32 = v30 + v31 == 0;
              //fix v16 = (v30 + v31 < 0) ^ __OFADD__(v30, v31);
              v33 = v30 + v31;
              if ( v16 )
                return;
              if ( !v32 )
              {
                v34 = v33 + 1;
                v1099 = (int)(v4[2] + v1092 * (__int64)(v3[2] - v5[2]) / v1088 - v3[2]) / v34;
                v1110 = (int)(v4[3] + v1092 * (__int64)(v3[3] - v5[3]) / v1088 - v3[3]) / v34;
              }
              v1101 = (v5[2] - v3[2]) / v1088;
              v1112 = (v5[3] - v3[3]) / v1088;
              v35 = *v3 << 16;
              v36 = v35;
              v37 = v3[2];
              v38 = v3[3];
              if ( !v1275 )
              {
                if ( v1283 )
                {
                  v41 = dword_93ADC - v1173;
                  v1098 = dword_93ADC - v1173;
                  if ( v1279 )
                  {
                    v1092 = dword_93ADC - v1173;
                  }
                  else
                  {
                    //fix v27 = __OFSUB__(v41, v1092);
                    v42 = v41 - v1092;
                    v1279 = (v42 < 0) ^ v27 | (v42 == 0);
                    v1094 = v42;
                  }
                }
                goto LABEL_71;
              }
              v16 = v1098 <= -v1173;
              v1098 += v1173;
              if ( !v16 )
              {
                v1134 = -v1173;
                if ( -v1173 - v1092 >= 0 )
                {
                  v1094 -= v1134 - v1092;
                  v1135 = v1134 - v1092;
                  v35 += v1078 * v1135 + v1092 * v1078;
                  v39 = v1086 * v1135 + v1096;
                  v37 += v1135 * v1101 + v1092 * v1101;
                  v38 += v1135 * v1112 + v1092 * v1112;
                  if ( v1283 )
                  {
                    v1094 = dword_93ADC;
                    v1098 = dword_93ADC;
                  }
                  v40 = (uint32*)&unk_93AE0;
LABEL_74:
                  if ( v1279 )
                  {
                    v29 = (unsigned __int8)byte_967E1;
                    switch ( byte_967E1 )
                    {
                      case 0:
                        goto LABEL_309;
                      case 1:
                        goto LABEL_322;
                      case 2:
                        goto LABEL_351;
                      case 3:
                        goto LABEL_382;
                      case 4:
                        goto LABEL_445;
                      case 5:
                        goto LABEL_474;
                      case 6:
                        goto LABEL_503;
                      case 7:
                      case 11:
                        goto LABEL_564;
                      case 8:
                        goto LABEL_595;
                      case 9:
                      case 10:
                        goto LABEL_658;
                      case 12:
                        goto LABEL_721;
                      case 13:
                        goto LABEL_752;
                      case 14:
                        goto LABEL_783;
                      case 15:
                        goto LABEL_812;
                      case 16:
                        goto LABEL_841;
                      case 17:
                        goto LABEL_870;
                      case 18:
                        goto LABEL_899;
                      case 19:
                        goto LABEL_930;
                      case 20:
                        goto LABEL_961;
                      case 21:
                        goto LABEL_992;
                      case 22:
                        goto LABEL_1023;
                      case 23:
                        goto LABEL_1086;
                      case 24:
                        goto LABEL_1149;
                      case 25:
                        goto LABEL_1212;
                      case 26:
                        goto LABEL_1275;
                    }
                  }
                  do
                  {
                    *v40 = v35;
                    v35 += v1078;
                    v40[1] = v39;
                    v39 += v1086;
                    v40[2] = v37;
                    v37 += v1101;
                    v40[3] = v38;
                    v38 += v1112;
                    v40 += 5;
                    --v1094;
                  }
                  while ( v1094 );
                  v29 = (unsigned __int8)byte_967E1;
                  switch ( byte_967E1 )
                  {
                    case 0:
                      goto LABEL_309;
                    case 1:
                      goto LABEL_322;
                    case 2:
                      goto LABEL_351;
                    case 3:
                      goto LABEL_382;
                    case 4:
                      goto LABEL_445;
                    case 5:
                      goto LABEL_474;
                    case 6:
                      goto LABEL_503;
                    case 7:
                    case 11:
                      goto LABEL_564;
                    case 8:
                      goto LABEL_595;
                    case 9:
                    case 10:
                      goto LABEL_658;
                    case 12:
                      goto LABEL_721;
                    case 13:
                      goto LABEL_752;
                    case 14:
                      goto LABEL_783;
                    case 15:
                      goto LABEL_812;
                    case 16:
                      goto LABEL_841;
                    case 17:
                      goto LABEL_870;
                    case 18:
                      goto LABEL_899;
                    case 19:
                      goto LABEL_930;
                    case 20:
                      goto LABEL_961;
                    case 21:
                      goto LABEL_992;
                    case 22:
                      goto LABEL_1023;
                    case 23:
                      goto LABEL_1086;
                    case 24:
                      goto LABEL_1149;
                    case 25:
                      goto LABEL_1212;
                    case 26:
                      goto LABEL_1275;
                  }
                }
                v1092 += v1173;
                v35 += v1078 * v1134;
                v36 += v1134 * v1082;
                v37 += v1134 * v1101;
                v38 += v1134 * v1112;
                if ( v1283 )
                {
                  v1098 = dword_93ADC;
                  if ( v1279 )
                  {
                    v1092 = dword_93ADC;
                  }
                  else
                  {
                    v1279 = dword_93ADC <= v1092;
                    v1094 = dword_93ADC - v1092;
                  }
                }
LABEL_71:
                v40 = (uint32*)&unk_93AE0;
                do
                {
                  *v40 = v35;
                  v35 += v1078;
                  v40[1] = v36;
                  v36 += v1082;
                  v40[2] = v37;
                  v37 += v1101;
                  v40[3] = v38;
                  v38 += v1112;
                  v40 += 5;
                  --v1092;
                }
                while ( v1092 );
                v39 = v1096;
                goto LABEL_74;
              }
              return;
            case 5:
            case 6:
            case 20:
            case 21:
            case 24:
            case 25:
            case 26:
              v13 = v12 * (__int64)(*v3 - *v5) / v1088;
              v14 = *v4 - *v3;
              v15 = v13 + v14 == 0;
              //fix v16 = (v13 + v14 < 0) ^ __OFADD__(v13, v14);
              v17 = v13 + v14;
              if ( v16 )
                return;
              if ( !v15 )
              {
                v18 = v17 + 1;
                v1099 = (int)(v4[2] + v1092 * (__int64)(v3[2] - v5[2]) / v1088 - v3[2]) / v18;
                v1110 = (int)(v4[3] + v1092 * (__int64)(v3[3] - v5[3]) / v1088 - v3[3]) / v18;
                v1121 = (int)(v4[4] + v1092 * (__int64)(v3[4] - v5[4]) / v1088 - v3[4]) / v18;
              }
              v1100 = (v5[2] - v3[2]) / v1088;
              v1111 = (v5[3] - v3[3]) / v1088;
              v1122 = (v5[4] - v3[4]) / v1088;
              v19 = *v3 << 16;
              v20 = v19;
              v21 = v3[2];
              v22 = v3[3];
              v23 = v3[4];
              if ( !v1275 )
              {
                if ( v1283 )
                {
                  v26 = dword_93ADC - v1173;
                  v1098 = dword_93ADC - v1173;
                  if ( v1279 )
                  {
                    v1092 = dword_93ADC - v1173;
                  }
                  else
                  {
                    //fix v27 = __OFSUB__(v26, v1092);
                    v28 = v26 - v1092;
                    v1279 = (v28 < 0) ^ v27 | (v28 == 0);
                    v1094 = v28;
                  }
                }
                goto LABEL_47;
              }
              v16 = v1098 <= -v1173;
              v1098 += v1173;
              if ( !v16 )
              {
                v1132 = -v1173;
                if ( -v1173 - v1092 >= 0 )
                {
                  v1094 -= v1132 - v1092;
                  v1133 = v1132 - v1092;
                  v19 += v1078 * v1133 + v1092 * v1078;
                  v24 = v1086 * v1133 + v1096;
                  v21 += v1133 * v1100 + v1092 * v1100;
                  v22 += v1133 * v1111 + v1092 * v1111;
                  v23 += v1133 * v1122 + v1092 * v1122;
                  if ( v1283 )
                  {
                    v1094 = dword_93ADC;
                    v1098 = dword_93ADC;
                  }
                  v25 = (uint32*)&unk_93AE0;
LABEL_50:
                  if ( v1279 )
                  {
                    v29 = (unsigned __int8)byte_967E1;
                    switch ( byte_967E1 )
                    {
                      case 0:
                        goto LABEL_309;
                      case 1:
                        goto LABEL_322;
                      case 2:
                        goto LABEL_351;
                      case 3:
                        goto LABEL_382;
                      case 4:
                        goto LABEL_445;
                      case 5:
                        goto LABEL_474;
                      case 6:
                        goto LABEL_503;
                      case 7:
                      case 11:
                        goto LABEL_564;
                      case 8:
                        goto LABEL_595;
                      case 9:
                      case 10:
                        goto LABEL_658;
                      case 12:
                        goto LABEL_721;
                      case 13:
                        goto LABEL_752;
                      case 14:
                        goto LABEL_783;
                      case 15:
                        goto LABEL_812;
                      case 16:
                        goto LABEL_841;
                      case 17:
                        goto LABEL_870;
                      case 18:
                        goto LABEL_899;
                      case 19:
                        goto LABEL_930;
                      case 20:
                        goto LABEL_961;
                      case 21:
                        goto LABEL_992;
                      case 22:
                        goto LABEL_1023;
                      case 23:
                        goto LABEL_1086;
                      case 24:
                        goto LABEL_1149;
                      case 25:
                        goto LABEL_1212;
                      case 26:
                        goto LABEL_1275;
                    }
                  }
                  do
                  {
                    *v25 = v19;
                    v19 += v1078;
                    v25[1] = v24;
                    v24 += v1086;
                    v25[2] = v21;
                    v21 += v1100;
                    v25[3] = v22;
                    v22 += v1111;
                    v25[4] = v23;
                    v23 += v1122;
                    v25 += 5;
                    --v1094;
                  }
                  while ( v1094 );
                  v29 = (unsigned __int8)byte_967E1;
                  switch ( byte_967E1 )
                  {
                    case 0:
                      goto LABEL_309;
                    case 1:
                      goto LABEL_322;
                    case 2:
                      goto LABEL_351;
                    case 3:
                      goto LABEL_382;
                    case 4:
                      goto LABEL_445;
                    case 5:
                      goto LABEL_474;
                    case 6:
                      goto LABEL_503;
                    case 7:
                    case 11:
                      goto LABEL_564;
                    case 8:
                      goto LABEL_595;
                    case 9:
                    case 10:
                      goto LABEL_658;
                    case 12:
                      goto LABEL_721;
                    case 13:
                      goto LABEL_752;
                    case 14:
                      goto LABEL_783;
                    case 15:
                      goto LABEL_812;
                    case 16:
                      goto LABEL_841;
                    case 17:
                      goto LABEL_870;
                    case 18:
                      goto LABEL_899;
                    case 19:
                      goto LABEL_930;
                    case 20:
                      goto LABEL_961;
                    case 21:
                      goto LABEL_992;
                    case 22:
                      goto LABEL_1023;
                    case 23:
                      goto LABEL_1086;
                    case 24:
                      goto LABEL_1149;
                    case 25:
                      goto LABEL_1212;
                    case 26:
                      goto LABEL_1275;
                  }
                }
                v1092 += v1173;
                v19 += v1078 * v1132;
                v20 += v1132 * v1082;
                v21 += v1132 * v1100;
                v22 += v1132 * v1111;
                v23 += v1132 * v1122;
                if ( v1283 )
                {
                  v1098 = dword_93ADC;
                  if ( v1279 )
                  {
                    v1092 = dword_93ADC;
                  }
                  else
                  {
                    v1279 = dword_93ADC <= v1092;
                    v1094 = dword_93ADC - v1092;
                  }
                }
LABEL_47:
                v25 = (uint32*)&unk_93AE0;
                do
                {
                  *v25 = v19;
                  v19 += v1078;
                  v25[1] = v20;
                  v20 += v1082;
                  v25[2] = v21;
                  v21 += v1100;
                  v25[3] = v22;
                  v22 += v1111;
                  v25[4] = v23;
                  v23 += v1122;
                  v25 += 5;
                  --v1092;
                }
                while ( v1092 );
                v24 = v1096;
                goto LABEL_50;
              }
              break;
          }
        }
        return;
      }
      if ( v7 != v8 )
      {
        if ( v7 <= v8 )
          goto LABEL_24;
        goto LABEL_124;
      }
      if ( *a2 <= *a3 )
        return;
LABEL_225:
      v108 = v3[1];
      v1175 = v108;
      if ( v108 >= 0 )
      {
        if ( v108 >= dword_93ADC )
          return;
        v1077 = dword_93AC8 + dword_93AD4 * v108;
        v1277 = 0;
      }
      else
      {
        v1077 = dword_93AC8;
        v1277 = 1;
      }
      v109 = v5[1];
      v1281 = v109 > dword_93ADC;
      v1090 = v109 - v108;
      v1098 = v109 - v108;
      v1080 = ((*v5 - *v3) << 16) / (v109 - v108);
      v1084 = ((*v4 - *v3) << 16) / (v109 - v108);
      switch ( byte_967E1 )
      {
        case 0:
        case 14:
        case 15:
          v130 = *v3 << 16;
          v131 = v130;
          if ( v1277 )
          {
            v132 = -v1175;
            v1090 += v1175;
            v16 = v1098 <= -v1175;
            v1098 += v1175;
            if ( v16 )
              return;
            v130 += v1080 * v132;
            v131 += v132 * v1084;
            if ( v1281 )
            {
              v1098 = dword_93ADC;
              v1090 = dword_93ADC;
            }
          }
          else if ( v1281 )
          {
            v1098 = dword_93ADC - v1175;
            v1090 = dword_93ADC - v1175;
          }
          v133 = (uint32*)&unk_93AE0;
          do
          {
            *v133 = v130;
            v130 += v1080;
            v133[1] = v131;
            v131 += v1084;
            v133 += 5;
            --v1090;
          }
          while ( v1090 );
          v29 = (unsigned __int8)byte_967E1;
          switch ( byte_967E1 )
          {
            case 0:
              goto LABEL_309;
            case 1:
              goto LABEL_322;
            case 2:
              goto LABEL_351;
            case 3:
              goto LABEL_382;
            case 4:
              goto LABEL_445;
            case 5:
              goto LABEL_474;
            case 6:
              goto LABEL_503;
            case 7:
            case 11:
              goto LABEL_564;
            case 8:
              goto LABEL_595;
            case 9:
            case 10:
              goto LABEL_658;
            case 12:
              goto LABEL_721;
            case 13:
              goto LABEL_752;
            case 14:
              goto LABEL_783;
            case 15:
              goto LABEL_812;
            case 16:
              goto LABEL_841;
            case 17:
              goto LABEL_870;
            case 18:
              goto LABEL_899;
            case 19:
              goto LABEL_930;
            case 20:
              goto LABEL_961;
            case 21:
              goto LABEL_992;
            case 22:
              goto LABEL_1023;
            case 23:
              goto LABEL_1086;
            case 24:
              goto LABEL_1149;
            case 25:
              goto LABEL_1212;
            case 26:
              goto LABEL_1275;
          }
        case 1:
        case 4:
        case 16:
        case 17:
          v1121 = (v4[4] - v5[4]) / (*v4 - *v5);
          v1127 = (v5[4] - v3[4]) / v1098;
          v125 = *v3 << 16;
          v126 = v125;
          v127 = v3[4];
          if ( v1277 )
          {
            v128 = -v1175;
            v1090 += v1175;
            v16 = v1098 <= -v1175;
            v1098 += v1175;
            if ( v16 )
              return;
            v125 += v1080 * v128;
            v126 += v128 * v1084;
            v127 += v128 * v1127;
            if ( v1281 )
            {
              v1098 = dword_93ADC;
              v1090 = dword_93ADC;
            }
          }
          else if ( v1281 )
          {
            v1098 = dword_93ADC - v1175;
            v1090 = dword_93ADC - v1175;
          }
          v129 = (uint32*)&unk_93AE0;
          do
          {
            *v129 = v125;
            v125 += v1080;
            v129[1] = v126;
            v126 += v1084;
            v129[4] = v127;
            v127 += v1127;
            v129 += 5;
            --v1090;
          }
          while ( v1090 );
          v29 = (unsigned __int8)byte_967E1;
          switch ( byte_967E1 )
          {
            case 0:
              goto LABEL_309;
            case 1:
              goto LABEL_322;
            case 2:
              goto LABEL_351;
            case 3:
              goto LABEL_382;
            case 4:
              goto LABEL_445;
            case 5:
              goto LABEL_474;
            case 6:
              goto LABEL_503;
            case 7:
            case 11:
              goto LABEL_564;
            case 8:
              goto LABEL_595;
            case 9:
            case 10:
              goto LABEL_658;
            case 12:
              goto LABEL_721;
            case 13:
              goto LABEL_752;
            case 14:
              goto LABEL_783;
            case 15:
              goto LABEL_812;
            case 16:
              goto LABEL_841;
            case 17:
              goto LABEL_870;
            case 18:
              goto LABEL_899;
            case 19:
              goto LABEL_930;
            case 20:
              goto LABEL_961;
            case 21:
              goto LABEL_992;
            case 22:
              goto LABEL_1023;
            case 23:
              goto LABEL_1086;
            case 24:
              goto LABEL_1149;
            case 25:
              goto LABEL_1212;
            case 26:
              goto LABEL_1275;
          }
        case 2:
        case 3:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 18:
        case 19:
        case 22:
        case 23:
          v118 = *v4 - *v5;
          v1099 = (v4[2] - v5[2]) / v118;
          v1110 = (v4[3] - v5[3]) / v118;
          v1105 = (v5[2] - v3[2]) / v1098;
          v1116 = (v5[3] - v3[3]) / v1098;
          v119 = *v3 << 16;
          v120 = v119;
          v121 = v3[2];
          v122 = v3[3];
          if ( v1277 )
          {
            v123 = -v1175;
            v1090 += v1175;
            v16 = v1098 <= -v1175;
            v1098 += v1175;
            if ( v16 )
              return;
            v119 += v1080 * v123;
            v120 += v123 * v1084;
            v121 += v123 * v1105;
            v122 += v123 * v1116;
            if ( v1281 )
            {
              v1098 = dword_93ADC;
              v1090 = dword_93ADC;
            }
          }
          else if ( v1281 )
          {
            v1098 = dword_93ADC - v1175;
            v1090 = dword_93ADC - v1175;
          }
          v124 = (uint32*)&unk_93AE0;
          do
          {
            *v124 = v119;
            v119 += v1080;
            v124[1] = v120;
            v120 += v1084;
            v124[2] = v121;
            v121 += v1105;
            v124[3] = v122;
            v122 += v1116;
            v124 += 5;
            --v1090;
          }
          while ( v1090 );
          v29 = (unsigned __int8)byte_967E1;
          switch ( byte_967E1 )
          {
            case 0:
              goto LABEL_309;
            case 1:
              goto LABEL_322;
            case 2:
              goto LABEL_351;
            case 3:
              goto LABEL_382;
            case 4:
              goto LABEL_445;
            case 5:
              goto LABEL_474;
            case 6:
              goto LABEL_503;
            case 7:
            case 11:
              goto LABEL_564;
            case 8:
              goto LABEL_595;
            case 9:
            case 10:
              goto LABEL_658;
            case 12:
              goto LABEL_721;
            case 13:
              goto LABEL_752;
            case 14:
              goto LABEL_783;
            case 15:
              goto LABEL_812;
            case 16:
              goto LABEL_841;
            case 17:
              goto LABEL_870;
            case 18:
              goto LABEL_899;
            case 19:
              goto LABEL_930;
            case 20:
              goto LABEL_961;
            case 21:
              goto LABEL_992;
            case 22:
              goto LABEL_1023;
            case 23:
              goto LABEL_1086;
            case 24:
              goto LABEL_1149;
            case 25:
              goto LABEL_1212;
            case 26:
              goto LABEL_1275;
          }
        case 5:
        case 6:
        case 20:
        case 21:
        case 24:
        case 25:
        case 26:
          v110 = *v4 - *v5;
          v1099 = (v4[2] - v5[2]) / v110;
          v1110 = (v4[3] - v5[3]) / v110;
          v1121 = (v4[4] - v5[4]) / v110;
          v1104 = (v5[2] - v3[2]) / v1098;
          v1115 = (v5[3] - v3[3]) / v1098;
          v1126 = (v5[4] - v3[4]) / v1098;
          v111 = *v3 << 16;
          v112 = v111;
          v113 = v3[2];
          v114 = v3[3];
          v115 = v3[4];
          if ( v1277 )
          {
            v116 = -v1175;
            v1090 += v1175;
            v16 = v1098 <= -v1175;
            v1098 += v1175;
            if ( v16 )
              return;
            v111 += v1080 * v116;
            v112 += v116 * v1084;
            v113 += v116 * v1104;
            v114 += v116 * v1115;
            v115 += v116 * v1126;
            if ( v1281 )
            {
              v1098 = dword_93ADC;
              v1090 = dword_93ADC;
            }
          }
          else if ( v1281 )
          {
            v1098 = dword_93ADC - v1175;
            v1090 = dword_93ADC - v1175;
          }
          v117 = (uint32*)&unk_93AE0;
          do
          {
            *v117 = v111;
            v111 += v1080;
            v117[1] = v112;
            v112 += v1084;
            v117[2] = v113;
            v113 += v1104;
            v117[3] = v114;
            v114 += v1115;
            v117[4] = v115;
            v115 += v1126;
            v117 += 5;
            --v1090;
          }
          while ( v1090 );
          v29 = (unsigned __int8)byte_967E1;
          switch ( byte_967E1 )
          {
            case 0:
              goto LABEL_309;
            case 1:
              goto LABEL_322;
            case 2:
              goto LABEL_351;
            case 3:
              goto LABEL_382;
            case 4:
              goto LABEL_445;
            case 5:
              goto LABEL_474;
            case 6:
              goto LABEL_503;
            case 7:
            case 11:
              goto LABEL_564;
            case 8:
              goto LABEL_595;
            case 9:
            case 10:
              goto LABEL_658;
            case 12:
              goto LABEL_721;
            case 13:
              goto LABEL_752;
            case 14:
              goto LABEL_783;
            case 15:
              goto LABEL_812;
            case 16:
              goto LABEL_841;
            case 17:
              goto LABEL_870;
            case 18:
              goto LABEL_899;
            case 19:
              goto LABEL_930;
            case 20:
              goto LABEL_961;
            case 21:
              goto LABEL_992;
            case 22:
              goto LABEL_1023;
            case 23:
              goto LABEL_1086;
            case 24:
              goto LABEL_1149;
            case 25:
              goto LABEL_1212;
            case 26:
              goto LABEL_1275;
          }
      }
    }
    if ( *a1 <= *a3 )
      return;
    v3 = a3;
    v4 = a1;
    v5 = a2;
LABEL_268:
    v134 = v3[1];
    v1176 = v134;
    if ( v134 >= 0 )
    {
      if ( v134 >= dword_93ADC )
        return;
      v1077 = dword_93AC8 + dword_93AD4 * v134;
      v1278 = 0;
    }
    else
    {
      v1077 = dword_93AC8;
      v1278 = 1;
    }
    v135 = v5[1];
    v1282 = v135 > dword_93ADC;
    v1091 = v135 - v134;
    v1098 = v135 - v134;
    v1081 = ((*v5 - *v3) << 16) / (v135 - v134);
    v1085 = ((*v5 - *v4) << 16) / (v135 - v134);
    switch ( byte_967E1 )
    {
      case 0:
      case 14:
      case 15:
        v156 = *v3 << 16;
        v157 = *v4 << 16;
        if ( v1278 )
        {
          v158 = -v1176;
          v1091 += v1176;
          v16 = v1098 <= -v1176;
          v1098 += v1176;
          if ( v16 )
            return;
          v156 += v1081 * v158;
          v157 += v158 * v1085;
          if ( v1282 )
          {
            v1098 = dword_93ADC;
            v1091 = dword_93ADC;
          }
        }
        else if ( v1282 )
        {
          v1098 = dword_93ADC - v1176;
          v1091 = dword_93ADC - v1176;
        }
        v159 = (uint32*)&unk_93AE0;
        do
        {
          *v159 = v156;
          v156 += v1081;
          v159[1] = v157;
          v157 += v1085;
          v159 += 5;
          --v1091;
        }
        while ( v1091 );
        v29 = (unsigned __int8)byte_967E1;
        switch ( byte_967E1 )
        {
          case 0:
            goto LABEL_309;
          case 1:
            goto LABEL_322;
          case 2:
            goto LABEL_351;
          case 3:
            goto LABEL_382;
          case 4:
            goto LABEL_445;
          case 5:
            goto LABEL_474;
          case 6:
            goto LABEL_503;
          case 7:
          case 11:
            goto LABEL_564;
          case 8:
            goto LABEL_595;
          case 9:
          case 10:
            goto LABEL_658;
          case 12:
            goto LABEL_721;
          case 13:
            goto LABEL_752;
          case 14:
            goto LABEL_783;
          case 15:
            goto LABEL_812;
          case 16:
            goto LABEL_841;
          case 17:
            goto LABEL_870;
          case 18:
            goto LABEL_899;
          case 19:
            goto LABEL_930;
          case 20:
            goto LABEL_961;
          case 21:
            goto LABEL_992;
          case 22:
            goto LABEL_1023;
          case 23:
            goto LABEL_1086;
          case 24:
            goto LABEL_1149;
          case 25:
            goto LABEL_1212;
          case 26:
            goto LABEL_1275;
        }
      case 1:
      case 4:
      case 16:
      case 17:
        v1121 = (v4[4] - v3[4]) / (*v4 - *v3);
        v1129 = (v5[4] - v3[4]) / v1098;
        v151 = *v3 << 16;
        v152 = *v4 << 16;
        v153 = v3[4];
        if ( v1278 )
        {
          v154 = -v1176;
          v1091 += v1176;
          v16 = v1098 <= -v1176;
          v1098 += v1176;
          if ( v16 )
            return;
          v151 += v1081 * v154;
          v152 += v154 * v1085;
          v153 += v154 * v1129;
          if ( v1282 )
          {
            v1098 = dword_93ADC;
            v1091 = dword_93ADC;
          }
        }
        else if ( v1282 )
        {
          v1098 = dword_93ADC - v1176;
          v1091 = dword_93ADC - v1176;
        }
        v155 = (uint32*)&unk_93AE0;
        do
        {
          *v155 = v151;
          v151 += v1081;
          v155[1] = v152;
          v152 += v1085;
          v155[4] = v153;
          v153 += v1129;
          v155 += 5;
          --v1091;
        }
        while ( v1091 );
        v29 = (unsigned __int8)byte_967E1;
        switch ( byte_967E1 )
        {
          case 0:
            goto LABEL_309;
          case 1:
            goto LABEL_322;
          case 2:
            goto LABEL_351;
          case 3:
            goto LABEL_382;
          case 4:
            goto LABEL_445;
          case 5:
            goto LABEL_474;
          case 6:
            goto LABEL_503;
          case 7:
          case 11:
            goto LABEL_564;
          case 8:
            goto LABEL_595;
          case 9:
          case 10:
            goto LABEL_658;
          case 12:
            goto LABEL_721;
          case 13:
            goto LABEL_752;
          case 14:
            goto LABEL_783;
          case 15:
            goto LABEL_812;
          case 16:
            goto LABEL_841;
          case 17:
            goto LABEL_870;
          case 18:
            goto LABEL_899;
          case 19:
            goto LABEL_930;
          case 20:
            goto LABEL_961;
          case 21:
            goto LABEL_992;
          case 22:
            goto LABEL_1023;
          case 23:
            goto LABEL_1086;
          case 24:
            goto LABEL_1149;
          case 25:
            goto LABEL_1212;
          case 26:
            goto LABEL_1275;
        }
      case 2:
      case 3:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 18:
      case 19:
      case 22:
      case 23:
        v144 = *v4 - *v3;
        v1099 = (v4[2] - v3[2]) / v144;
        v1110 = (v4[3] - v3[3]) / v144;
        v1107 = (v5[2] - v3[2]) / v1098;
        v1118 = (v5[3] - v3[3]) / v1098;
        v145 = *v3 << 16;
        v146 = *v4 << 16;
        v147 = v3[2];
        v148 = v3[3];
        if ( v1278 )
        {
          v149 = -v1176;
          v1091 += v1176;
          v16 = v1098 <= -v1176;
          v1098 += v1176;
          if ( v16 )
            return;
          v145 += v1081 * v149;
          v146 += v149 * v1085;
          v147 += v149 * v1107;
          v148 += v149 * v1118;
          if ( v1282 )
          {
            v1098 = dword_93ADC;
            v1091 = dword_93ADC;
          }
        }
        else if ( v1282 )
        {
          v1098 = dword_93ADC - v1176;
          v1091 = dword_93ADC - v1176;
        }
        v150 = (uint32*)&unk_93AE0;
        do
        {
          *v150 = v145;
          v145 += v1081;
          v150[1] = v146;
          v146 += v1085;
          v150[2] = v147;
          v147 += v1107;
          v150[3] = v148;
          v148 += v1118;
          v150 += 5;
          --v1091;
        }
        while ( v1091 );
        v29 = (unsigned __int8)byte_967E1;
        switch ( byte_967E1 )
        {
          case 0:
            goto LABEL_309;
          case 1:
            goto LABEL_322;
          case 2:
            goto LABEL_351;
          case 3:
            goto LABEL_382;
          case 4:
            goto LABEL_445;
          case 5:
            goto LABEL_474;
          case 6:
            goto LABEL_503;
          case 7:
          case 11:
            goto LABEL_564;
          case 8:
            goto LABEL_595;
          case 9:
          case 10:
            goto LABEL_658;
          case 12:
            goto LABEL_721;
          case 13:
            goto LABEL_752;
          case 14:
            goto LABEL_783;
          case 15:
            goto LABEL_812;
          case 16:
            goto LABEL_841;
          case 17:
            goto LABEL_870;
          case 18:
            goto LABEL_899;
          case 19:
            goto LABEL_930;
          case 20:
            goto LABEL_961;
          case 21:
            goto LABEL_992;
          case 22:
            goto LABEL_1023;
          case 23:
            goto LABEL_1086;
          case 24:
            goto LABEL_1149;
          case 25:
            goto LABEL_1212;
          case 26:
            goto LABEL_1275;
        }
      case 5:
      case 6:
      case 20:
      case 21:
      case 24:
      case 25:
      case 26:
        v136 = *v4 - *v3;
        v1099 = (v4[2] - v3[2]) / v136;
        v1110 = (v4[3] - v3[3]) / v136;
        v1121 = (v4[4] - v3[4]) / v136;
        v1106 = (v5[2] - v3[2]) / v1098;
        v1117 = (v5[3] - v3[3]) / v1098;
        v1128 = (v5[4] - v3[4]) / v1098;
        v137 = *v3 << 16;
        v138 = *v4 << 16;
        v139 = v3[2];
        v140 = v3[3];
        v141 = v3[4];
        if ( v1278 )
        {
          v142 = -v1176;
          v1091 += v1176;
          v16 = v1098 <= -v1176;
          v1098 += v1176;
          if ( v16 )
            return;
          v137 += v1081 * v142;
          v138 += v142 * v1085;
          v139 += v142 * v1106;
          v140 += v142 * v1117;
          v141 += v142 * v1128;
          if ( v1282 )
          {
            v1098 = dword_93ADC;
            v1091 = dword_93ADC;
          }
        }
        else if ( v1282 )
        {
          v1098 = dword_93ADC - v1176;
          v1091 = dword_93ADC - v1176;
        }
        v143 = (uint32*)&unk_93AE0;
        do
        {
          *v143 = v137;
          v137 += v1081;
          v143[1] = v138;
          v138 += v1085;
          v143[2] = v139;
          v139 += v1106;
          v143[3] = v140;
          v140 += v1117;
          v143[4] = v141;
          v141 += v1128;
          v143 += 5;
          --v1091;
        }
        while ( v1091 );
        break;
    }
    v29 = (unsigned __int8)byte_967E1;
    switch ( byte_967E1 )
    {
      case 0:
LABEL_309:
        v160 = (unsigned __int16 *)&unk_93AE0;
        v161 = (char *)v1077;
        v162 = byte_967E0;
        HIWORD(v163) = 0;
        while ( 1 )
        {
          LOWORD(v163) = v160[1];
          v164 = v160[3];
          v161 += dword_93AD4;
          if ( (v163 & 0x8000u) == 0 )
            break;
          if ( (__int16)v164 > 0 )
          {
            if ( v164 > dword_93AD8 )
              v164 = dword_93AD8;
            v165 = v161;
LABEL_319:
            memset(v165, v162, v164);
          }
LABEL_320:
          v160 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v164 > dword_93AD8 )
          v164 = dword_93AD8;
        v16 = (__int16)v164 <= (__int16)v163;
        LOWORD(v164) = v164 - v163;
        if ( v16 )
          goto LABEL_320;
        v165 = &v161[v163];
        goto LABEL_319;
      case 1:
LABEL_322:
        for ( i = (uint16*)&unk_93AE0; ; i += 10 )
        {
          LOWORD(v29) = i[1];
          v167 = (unsigned __int16)i[3];
          v168 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v29 & 0x8000u) == 0 )
            break;
          if ( (__int16)v167 > 0 )
          {
            v169 = v1121 * (unsigned __int16)-(__int16)v29;
            v170 = v169;
            v29 = v169 >> 8;
            v171 = __CFADD__(i[8], v170);
            v172 = i[8] + v170;
            BYTE1(v29) += *((_BYTE *)i + 18) + v171;
            if ( v167 > dword_93AD8 )
              LOWORD(v167) = dword_93AD8;
            v29 = (unsigned __int16)v29;
LABEL_332:
            while ( 1 )
            {
              *v168 = BYTE1(v29);
              v171 = __CFADD__((_WORD)v1121, v172);
              v173 = v1121 + v172;
              v174 = BYTE2(v1121) + v171 + BYTE1(v29);
              v175 = v167 - 1;
              if ( !v175 )
                break;
              v168[1] = v174;
              v171 = __CFADD__((_WORD)v1121, v173);
              v176 = v1121 + v173;
              v177 = BYTE2(v1121) + v171 + v174;
              v178 = v175 - 1;
              if ( !v178 )
                break;
              v168[2] = v177;
              v171 = __CFADD__((_WORD)v1121, v176);
              v179 = v1121 + v176;
              v180 = BYTE2(v1121) + v171 + v177;
              v181 = v178 - 1;
              if ( !v181 )
                break;
              v168[3] = v180;
              v171 = __CFADD__((_WORD)v1121, v179);
              v182 = v1121 + v179;
              v183 = BYTE2(v1121) + v171 + v180;
              v184 = v181 - 1;
              if ( !v184 )
                break;
              v168[4] = v183;
              v171 = __CFADD__((_WORD)v1121, v182);
              v185 = v1121 + v182;
              v186 = BYTE2(v1121) + v171 + v183;
              v187 = v184 - 1;
              if ( !v187 )
                break;
              v168[5] = v186;
              v171 = __CFADD__((_WORD)v1121, v185);
              v188 = v1121 + v185;
              v189 = BYTE2(v1121) + v171 + v186;
              v190 = v187 - 1;
              if ( !v190 )
                break;
              v168[6] = v189;
              v171 = __CFADD__((_WORD)v1121, v188);
              v191 = v1121 + v188;
              v192 = BYTE2(v1121) + v171 + v189;
              v193 = v190 - 1;
              if ( !v193 )
                break;
              v168[7] = v192;
              v171 = __CFADD__((_WORD)v1121, v191);
              v194 = v1121 + v191;
              v195 = BYTE2(v1121) + v171 + v192;
              v196 = v193 - 1;
              if ( !v196 )
                break;
              v168[8] = v195;
              v171 = __CFADD__((_WORD)v1121, v194);
              v197 = v1121 + v194;
              v198 = BYTE2(v1121) + v171 + v195;
              v199 = v196 - 1;
              if ( !v199 )
                break;
              v168[9] = v198;
              v171 = __CFADD__((_WORD)v1121, v197);
              v200 = v1121 + v197;
              v201 = BYTE2(v1121) + v171 + v198;
              v202 = v199 - 1;
              if ( !v202 )
                break;
              v168[10] = v201;
              v171 = __CFADD__((_WORD)v1121, v200);
              v203 = v1121 + v200;
              v204 = BYTE2(v1121) + v171 + v201;
              v205 = v202 - 1;
              if ( !v205 )
                break;
              v168[11] = v204;
              v171 = __CFADD__((_WORD)v1121, v203);
              v206 = v1121 + v203;
              v207 = BYTE2(v1121) + v171 + v204;
              v208 = v205 - 1;
              if ( !v208 )
                break;
              v168[12] = v207;
              v171 = __CFADD__((_WORD)v1121, v206);
              v209 = v1121 + v206;
              v210 = BYTE2(v1121) + v171 + v207;
              v211 = v208 - 1;
              if ( !v211 )
                break;
              v168[13] = v210;
              v171 = __CFADD__((_WORD)v1121, v209);
              v212 = v1121 + v209;
              v213 = BYTE2(v1121) + v171 + v210;
              v214 = v211 - 1;
              if ( !v214 )
                break;
              v168[14] = v213;
              v171 = __CFADD__((_WORD)v1121, v212);
              v215 = v1121 + v212;
              v216 = BYTE2(v1121) + v171 + v213;
              v217 = v214 - 1;
              if ( !v217 )
                break;
              v168[15] = v216;
              v171 = __CFADD__((_WORD)v1121, v215);
              v172 = v1121 + v215;
              BYTE1(v29) = BYTE2(v1121) + v171 + v216;
              LOWORD(v167) = v217 - 1;
              if ( !(_WORD)v167 )
                break;
              v168 += 16;
            }
          }
LABEL_349:
          if ( !--v1098 )
            return;
        }
        if ( v167 > dword_93AD8 )
          LOWORD(v167) = dword_93AD8;
        v16 = (__int16)v167 <= (__int16)v29;
        LOWORD(v167) = v167 - v29;
        if ( v16 )
          goto LABEL_349;
        v168 += v29;
        v29 = (unsigned __int8)byte_967E0;
        v172 = i[8];
        BYTE1(v29) = *((_BYTE *)i + 18);
        goto LABEL_332;
      case 2:
LABEL_351:
        v218 = (unsigned __int16 *)&unk_93AE0;
        v1148 = v1110 << 16;
        HIWORD(v219) = 0;
        HIWORD(v220) = 0;
        while ( 1 )
        {
          LOWORD(v219) = v218[1];
          v221 = v218[3];
          v222 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v219 & 0x8000u) == 0 )
            break;
          if ( (__int16)v221 > 0 )
          {
            v223 = (unsigned __int16)-(__int16)v219;
            v225 = __ROL4__(*((_DWORD *)v218 + 3) + v1110 * v223, 16);
            BYTE1(v220) = v225;
            v224 = *((_DWORD *)v218 + 2) + v1099 * v223;
            LOWORD(v225) = v224;
            v226 = v224 >> 8;
            LOBYTE(v220) = BYTE1(v226);
            if ( v221 > dword_93AD8 )
              LOWORD(v221) = dword_93AD8;
            v219 = (unsigned __int16)v226;
LABEL_361:
            v1257 = v218;
            v227 = dword_93AD0;
            while ( 1 )
            {
              v228 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v225);
              LOWORD(v225) = v1099 + v225;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              *v222 = v228;
              v171 = __CFADD__(v1148, v225);
              v229 = v1148 + v225;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v230 = v221 - 1;
              if ( !v230 )
                break;
              v231 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v229);
              LOWORD(v229) = v1099 + v229;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[1] = v231;
              v171 = __CFADD__(v1148, v229);
              v232 = v1148 + v229;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v233 = v230 - 1;
              if ( !v233 )
                break;
              v234 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v232);
              LOWORD(v232) = v1099 + v232;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[2] = v234;
              v171 = __CFADD__(v1148, v232);
              v235 = v1148 + v232;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v236 = v233 - 1;
              if ( !v236 )
                break;
              v237 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v235);
              LOWORD(v235) = v1099 + v235;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[3] = v237;
              v171 = __CFADD__(v1148, v235);
              v238 = v1148 + v235;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v239 = v236 - 1;
              if ( !v239 )
                break;
              v240 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v238);
              LOWORD(v238) = v1099 + v238;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[4] = v240;
              v171 = __CFADD__(v1148, v238);
              v241 = v1148 + v238;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v242 = v239 - 1;
              if ( !v242 )
                break;
              v243 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v241);
              LOWORD(v241) = v1099 + v241;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[5] = v243;
              v171 = __CFADD__(v1148, v241);
              v244 = v1148 + v241;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v245 = v242 - 1;
              if ( !v245 )
                break;
              v246 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v244);
              LOWORD(v244) = v1099 + v244;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[6] = v246;
              v171 = __CFADD__(v1148, v244);
              v247 = v1148 + v244;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v248 = v245 - 1;
              if ( !v248 )
                break;
              v249 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v247);
              LOWORD(v247) = v1099 + v247;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[7] = v249;
              v171 = __CFADD__(v1148, v247);
              v250 = v1148 + v247;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v251 = v248 - 1;
              if ( !v251 )
                break;
              v252 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v250);
              LOWORD(v250) = v1099 + v250;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[8] = v252;
              v171 = __CFADD__(v1148, v250);
              v253 = v1148 + v250;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v254 = v251 - 1;
              if ( !v254 )
                break;
              v255 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v253);
              LOWORD(v253) = v1099 + v253;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[9] = v255;
              v171 = __CFADD__(v1148, v253);
              v256 = v1148 + v253;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v257 = v254 - 1;
              if ( !v257 )
                break;
              v258 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v256);
              LOWORD(v256) = v1099 + v256;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[10] = v258;
              v171 = __CFADD__(v1148, v256);
              v259 = v1148 + v256;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v260 = v257 - 1;
              if ( !v260 )
                break;
              v261 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v259);
              LOWORD(v259) = v1099 + v259;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[11] = v261;
              v171 = __CFADD__(v1148, v259);
              v262 = v1148 + v259;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v263 = v260 - 1;
              if ( !v263 )
                break;
              v264 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v262);
              LOWORD(v262) = v1099 + v262;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[12] = v264;
              v171 = __CFADD__(v1148, v262);
              v265 = v1148 + v262;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v266 = v263 - 1;
              if ( !v266 )
                break;
              v267 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v265);
              LOWORD(v265) = v1099 + v265;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[13] = v267;
              v171 = __CFADD__(v1148, v265);
              v268 = v1148 + v265;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v269 = v266 - 1;
              if ( !v269 )
                break;
              v270 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v268);
              LOWORD(v268) = v1099 + v268;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[14] = v270;
              v171 = __CFADD__(v1148, v268);
              v271 = v1148 + v268;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v272 = v269 - 1;
              if ( !v272 )
                break;
              v273 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v271);
              LOWORD(v271) = v1099 + v271;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[15] = v273;
              v171 = __CFADD__(v1148, v271);
              v225 = v1148 + v271;
              BYTE1(v220) += BYTE2(v1110) + v171;
              LOWORD(v221) = v272 - 1;
              if ( !(_WORD)v221 )
                break;
              v222 += 16;
            }
            v218 = v1257;
          }
LABEL_380:
          v218 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v221 > dword_93AD8 )
          LOWORD(v221) = dword_93AD8;
        v16 = (__int16)v221 <= (__int16)v219;
        LOWORD(v221) = v221 - v219;
        if ( v16 )
          goto LABEL_380;
        v222 += v219;
        v225 = __ROL4__(*((_DWORD *)v218 + 3), 16);
        BYTE1(v220) = v225;
        LOWORD(v225) = v218[4];
        LOBYTE(v220) = *((_BYTE *)v218 + 10);
        goto LABEL_361;
      case 3:
LABEL_382:
        v274 = (unsigned __int16 *)&unk_93AE0;
        v1149 = v1110 << 16;
        HIWORD(v275) = 0;
        HIWORD(v276) = 0;
        while ( 1 )
        {
          LOWORD(v275) = v274[1];
          v277 = v274[3];
          v278 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v275 & 0x8000u) == 0 )
            break;
          if ( (__int16)v277 > 0 )
          {
            v279 = (unsigned __int16)-(__int16)v275;
            v281 = __ROL4__(*((_DWORD *)v274 + 3) + v1110 * v279, 16);
            BYTE1(v276) = v281;
            v280 = *((_DWORD *)v274 + 2) + v1099 * v279;
            LOWORD(v281) = v280;
            v282 = v280 >> 8;
            LOBYTE(v276) = BYTE1(v282);
            if ( v277 > dword_93AD8 )
              LOWORD(v277) = dword_93AD8;
            v275 = (unsigned __int16)v282;
LABEL_392:
            v1258 = v274;
            v283 = dword_93AD0;
            while ( 1 )
            {
              v284 = *(_BYTE *)(v276 + v283);
              if ( v284 )
                *v278 = v284;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v281);
              LOWORD(v281) = v1099 + v281;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v281);
              v285 = v1149 + v281;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v286 = v277 - 1;
              if ( !v286 )
                break;
              v287 = *(_BYTE *)(v276 + v283);
              if ( v287 )
                v278[1] = v287;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v285);
              LOWORD(v285) = v1099 + v285;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v285);
              v288 = v1149 + v285;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v289 = v286 - 1;
              if ( !v289 )
                break;
              v290 = *(_BYTE *)(v276 + v283);
              if ( v290 )
                v278[2] = v290;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v288);
              LOWORD(v288) = v1099 + v288;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v288);
              v291 = v1149 + v288;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v292 = v289 - 1;
              if ( !v292 )
                break;
              v293 = *(_BYTE *)(v276 + v283);
              if ( v293 )
                v278[3] = v293;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v291);
              LOWORD(v291) = v1099 + v291;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v291);
              v294 = v1149 + v291;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v295 = v292 - 1;
              if ( !v295 )
                break;
              v296 = *(_BYTE *)(v276 + v283);
              if ( v296 )
                v278[4] = v296;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v294);
              LOWORD(v294) = v1099 + v294;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v294);
              v297 = v1149 + v294;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v298 = v295 - 1;
              if ( !v298 )
                break;
              v299 = *(_BYTE *)(v276 + v283);
              if ( v299 )
                v278[5] = v299;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v297);
              LOWORD(v297) = v1099 + v297;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v297);
              v300 = v1149 + v297;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v301 = v298 - 1;
              if ( !v301 )
                break;
              v302 = *(_BYTE *)(v276 + v283);
              if ( v302 )
                v278[6] = v302;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v300);
              LOWORD(v300) = v1099 + v300;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v300);
              v303 = v1149 + v300;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v304 = v301 - 1;
              if ( !v304 )
                break;
              v305 = *(_BYTE *)(v276 + v283);
              if ( v305 )
                v278[7] = v305;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v303);
              LOWORD(v303) = v1099 + v303;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v303);
              v306 = v1149 + v303;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v307 = v304 - 1;
              if ( !v307 )
                break;
              v308 = *(_BYTE *)(v276 + v283);
              if ( v308 )
                v278[8] = v308;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v306);
              LOWORD(v306) = v1099 + v306;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v306);
              v309 = v1149 + v306;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v310 = v307 - 1;
              if ( !v310 )
                break;
              v311 = *(_BYTE *)(v276 + v283);
              if ( v311 )
                v278[9] = v311;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v309);
              LOWORD(v309) = v1099 + v309;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v309);
              v312 = v1149 + v309;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v313 = v310 - 1;
              if ( !v313 )
                break;
              v314 = *(_BYTE *)(v276 + v283);
              if ( v314 )
                v278[10] = v314;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v312);
              LOWORD(v312) = v1099 + v312;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v312);
              v315 = v1149 + v312;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v316 = v313 - 1;
              if ( !v316 )
                break;
              v317 = *(_BYTE *)(v276 + v283);
              if ( v317 )
                v278[11] = v317;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v315);
              LOWORD(v315) = v1099 + v315;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v315);
              v318 = v1149 + v315;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v319 = v316 - 1;
              if ( !v319 )
                break;
              v320 = *(_BYTE *)(v276 + v283);
              if ( v320 )
                v278[12] = v320;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v318);
              LOWORD(v318) = v1099 + v318;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v318);
              v321 = v1149 + v318;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v322 = v319 - 1;
              if ( !v322 )
                break;
              v323 = *(_BYTE *)(v276 + v283);
              if ( v323 )
                v278[13] = v323;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v321);
              LOWORD(v321) = v1099 + v321;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v321);
              v324 = v1149 + v321;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v325 = v322 - 1;
              if ( !v325 )
                break;
              v326 = *(_BYTE *)(v276 + v283);
              if ( v326 )
                v278[14] = v326;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v324);
              LOWORD(v324) = v1099 + v324;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v324);
              v327 = v1149 + v324;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v328 = v325 - 1;
              if ( !v328 )
                break;
              v329 = *(_BYTE *)(v276 + v283);
              if ( v329 )
                v278[15] = v329;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v327);
              LOWORD(v327) = v1099 + v327;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v327);
              v281 = v1149 + v327;
              BYTE1(v276) += BYTE2(v1110) + v171;
              LOWORD(v277) = v328 - 1;
              if ( !(_WORD)v277 )
                break;
              v278 += 16;
            }
            v274 = v1258;
          }
LABEL_443:
          v274 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v277 > dword_93AD8 )
          LOWORD(v277) = dword_93AD8;
        v16 = (__int16)v277 <= (__int16)v275;
        LOWORD(v277) = v277 - v275;
        if ( v16 )
          goto LABEL_443;
        v278 += v275;
        v281 = __ROL4__(*((_DWORD *)v274 + 3), 16);
        BYTE1(v276) = v281;
        LOWORD(v281) = v274[4];
        LOBYTE(v276) = *((_BYTE *)v274 + 10);
        goto LABEL_392;
      case 4:
LABEL_445:
        for ( j = (uint16*)&unk_93AE0; ; j += 10 )
        {
          LOWORD(v29) = j[1];
          v331 = (unsigned __int16)j[3];
          v332 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v29 & 0x8000u) == 0 )
            break;
          if ( (__int16)v331 > 0 )
          {
            v333 = v1121 * (unsigned __int16)-(__int16)v29;
            v334 = v333;
            v29 = v333 >> 8;
            v171 = __CFADD__(j[8], v334);
            v335 = j[8] + v334;
            BYTE1(v29) += *((_BYTE *)j + 18) + v171;
            if ( v331 > dword_93AD8 )
              LOWORD(v331) = dword_93AD8;
            v29 = (unsigned __int16)v29;
            LOBYTE(v29) = byte_967E0;
LABEL_455:
            while ( 1 )
            {
              *v332 = byte_B7934[v29];
              v171 = __CFADD__((_WORD)v1121, v335);
              v336 = v1121 + v335;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v337 = v331 - 1;
              if ( !v337 )
                break;
              v332[1] = byte_B7934[v29];
              v171 = __CFADD__((_WORD)v1121, v336);
              v338 = v1121 + v336;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v339 = v337 - 1;
              if ( !v339 )
                break;
              v332[2] = byte_B7934[v29];
              v171 = __CFADD__((_WORD)v1121, v338);
              v340 = v1121 + v338;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v341 = v339 - 1;
              if ( !v341 )
                break;
              v332[3] = byte_B7934[v29];
              v171 = __CFADD__((_WORD)v1121, v340);
              v342 = v1121 + v340;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v343 = v341 - 1;
              if ( !v343 )
                break;
              v332[4] = byte_B7934[v29];
              v171 = __CFADD__((_WORD)v1121, v342);
              v344 = v1121 + v342;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v345 = v343 - 1;
              if ( !v345 )
                break;
              v332[5] = byte_B7934[v29];
              v171 = __CFADD__((_WORD)v1121, v344);
              v346 = v1121 + v344;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v347 = v345 - 1;
              if ( !v347 )
                break;
              v332[6] = byte_B7934[v29];
              v171 = __CFADD__((_WORD)v1121, v346);
              v348 = v1121 + v346;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v349 = v347 - 1;
              if ( !v349 )
                break;
              v332[7] = byte_B7934[v29];
              v171 = __CFADD__((_WORD)v1121, v348);
              v350 = v1121 + v348;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v351 = v349 - 1;
              if ( !v351 )
                break;
              v332[8] = byte_B7934[v29];
              v171 = __CFADD__((_WORD)v1121, v350);
              v352 = v1121 + v350;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v353 = v351 - 1;
              if ( !v353 )
                break;
              v332[9] = byte_B7934[v29];
              v171 = __CFADD__((_WORD)v1121, v352);
              v354 = v1121 + v352;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v355 = v353 - 1;
              if ( !v355 )
                break;
              v332[10] = byte_B7934[v29];
              v171 = __CFADD__((_WORD)v1121, v354);
              v356 = v1121 + v354;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v357 = v355 - 1;
              if ( !v357 )
                break;
              v332[11] = byte_B7934[v29];
              v171 = __CFADD__((_WORD)v1121, v356);
              v358 = v1121 + v356;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v359 = v357 - 1;
              if ( !v359 )
                break;
              v332[12] = byte_B7934[v29];
              v171 = __CFADD__((_WORD)v1121, v358);
              v360 = v1121 + v358;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v361 = v359 - 1;
              if ( !v361 )
                break;
              v332[13] = byte_B7934[v29];
              v171 = __CFADD__((_WORD)v1121, v360);
              v362 = v1121 + v360;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v363 = v361 - 1;
              if ( !v363 )
                break;
              v332[14] = byte_B7934[v29];
              v171 = __CFADD__((_WORD)v1121, v362);
              v364 = v1121 + v362;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v365 = v363 - 1;
              if ( !v365 )
                break;
              v332[15] = byte_B7934[v29];
              v171 = __CFADD__((_WORD)v1121, v364);
              v335 = v1121 + v364;
              BYTE1(v29) += BYTE2(v1121) + v171;
              LOWORD(v331) = v365 - 1;
              if ( !(_WORD)v331 )
                break;
              v332 += 16;
            }
          }
LABEL_472:
          if ( !--v1098 )
            return;
        }
        if ( v331 > dword_93AD8 )
          LOWORD(v331) = dword_93AD8;
        v16 = (__int16)v331 <= (__int16)v29;
        LOWORD(v331) = v331 - v29;
        if ( v16 )
          goto LABEL_472;
        v332 += v29;
        v29 = (unsigned __int8)byte_967E0;
        v335 = j[8];
        BYTE1(v29) = *((_BYTE *)j + 18);
        goto LABEL_455;
      case 5:
LABEL_474:
        v1259 = (char *)&unk_93AE0;
        v1150 = v1110 << 16;
        v1166 = v1121 << 16;
        HIWORD(v366) = 0;
        HIWORD(v367) = 0;
        while ( 1 )
        {
          v368 = v1259;
          v1259 += 20;
          LOWORD(v366) = *((_WORD *)v368 + 1);
          v369 = *((unsigned __int16 *)v368 + 3);
          v370 = dword_93AD4 + v1077;
          v1077 += dword_93AD4;
          if ( (v366 & 0x8000u) == 0 )
            break;
          if ( (__int16)v369 > 0 )
          {
            v371 = (unsigned __int16)-(__int16)v366;
            v372 = __ROL4__(*((_DWORD *)v368 + 3) + v1110 * v371, 16);
            BYTE1(v367) = v372;
            LOWORD(v372) = *((_WORD *)v368 + 4) + v1099 * v371;
            v366 = (unsigned int)(*((_DWORD *)v368 + 2) + v1099 * v371) >> 8;
            LOBYTE(v367) = (unsigned int)(*((_DWORD *)v368 + 2) + v1099 * v371) >> 16;
            v373 = __ROL4__(*((_DWORD *)v368 + 4) + v1121 * v371, 16);
            BYTE1(v366) = v373;
            LOWORD(v373) = *((_WORD *)v368 + 3);
            v366 = (unsigned __int16)v366;
            if ( (__int16)v373 > (__int16)dword_93AD8 )
              LOWORD(v373) = dword_93AD8;
LABEL_484:
            v376 = (_BYTE *)(dword_74F95[v373 & 0xF] + v370);
            v377 = dword_93AD0;
            switch ( v373 & 0xF )
            {
              case 0:
                goto LABEL_485;
              case 1:
                goto LABEL_500;
              case 2:
                goto LABEL_499;
              case 3:
                goto LABEL_498;
              case 4:
                goto LABEL_497;
              case 5:
                goto LABEL_496;
              case 6:
                goto LABEL_495;
              case 7:
                goto LABEL_494;
              case 8:
                goto LABEL_493;
              case 9:
                goto LABEL_492;
              case 0xA:
                goto LABEL_491;
              case 0xB:
                goto LABEL_490;
              case 0xC:
                goto LABEL_489;
              case 0xD:
                goto LABEL_488;
              case 0xE:
                goto LABEL_487;
              case 0xF:
                while ( 1 )
                {
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[1] = byte_B7934[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_487:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[2] = byte_B7934[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_488:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[3] = byte_B7934[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_489:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[4] = byte_B7934[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_490:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[5] = byte_B7934[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_491:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[6] = byte_B7934[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_492:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[7] = byte_B7934[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_493:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[8] = byte_B7934[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_494:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[9] = byte_B7934[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_495:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[10] = byte_B7934[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_496:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[11] = byte_B7934[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_497:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[12] = byte_B7934[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_498:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[13] = byte_B7934[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_499:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[14] = byte_B7934[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_500:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[15] = byte_B7934[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
                  v376 += 16;
                  v16 = (__int16)v373 <= 16;
                  LOWORD(v373) = v373 - 16;
                  if ( v16 )
                    break;
LABEL_485:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  *v376 = byte_B7934[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
                }
                break;
            }
          }
LABEL_501:
          if ( !--v1098 )
            return;
        }
        if ( v369 > dword_93AD8 )
          LOWORD(v369) = dword_93AD8;
        v16 = (__int16)v369 <= (__int16)v366;
        v374 = v369 - v366;
        if ( v16 )
          goto LABEL_501;
        v370 += v366;
        LOBYTE(v367) = v368[10];
        v372 = __ROL4__(*((_DWORD *)v368 + 3), 16);
        v375 = v374;
        BYTE1(v367) = v372;
        LOWORD(v372) = *((_WORD *)v368 + 4);
        v373 = __ROL4__(*((_DWORD *)v368 + 4), 16);
        BYTE1(v366) = v373;
        LOWORD(v373) = v375;
        goto LABEL_484;
      case 6:
LABEL_503:
        v1260 = (char *)&unk_93AE0;
        v1151 = v1110 << 16;
        v1167 = v1121 << 16;
        HIWORD(v378) = 0;
        HIWORD(v379) = 0;
        while ( 1 )
        {
          v380 = v1260;
          v1260 += 20;
          LOWORD(v378) = *((_WORD *)v380 + 1);
          v381 = *((unsigned __int16 *)v380 + 3);
          v382 = dword_93AD4 + v1077;
          v1077 += dword_93AD4;
          if ( (v378 & 0x8000u) == 0 )
            break;
          if ( (__int16)v381 > 0 )
          {
            v383 = (unsigned __int16)-(__int16)v378;
            v384 = __ROL4__(*((_DWORD *)v380 + 3) + v1110 * v383, 16);
            BYTE1(v379) = v384;
            LOWORD(v384) = *((_WORD *)v380 + 4) + v1099 * v383;
            v378 = (unsigned int)(*((_DWORD *)v380 + 2) + v1099 * v383) >> 8;
            LOBYTE(v379) = (unsigned int)(*((_DWORD *)v380 + 2) + v1099 * v383) >> 16;
            v385 = __ROL4__(*((_DWORD *)v380 + 4) + v1121 * v383, 16);
            BYTE1(v378) = v385;
            LOWORD(v385) = *((_WORD *)v380 + 3);
            v378 = (unsigned __int16)v378;
            if ( (__int16)v385 > (__int16)dword_93AD8 )
              LOWORD(v385) = dword_93AD8;
LABEL_513:
            v388 = (_BYTE *)(dword_74F95[v385 & 0xF] + v382);
            v389 = dword_93AD0;
            switch ( v385 & 0xF )
            {
              case 0:
                goto LABEL_514;
              case 1:
                goto LABEL_559;
              case 2:
                goto LABEL_556;
              case 3:
                goto LABEL_553;
              case 4:
                goto LABEL_550;
              case 5:
                goto LABEL_547;
              case 6:
                goto LABEL_544;
              case 7:
                goto LABEL_541;
              case 8:
                goto LABEL_538;
              case 9:
                goto LABEL_535;
              case 0xA:
                goto LABEL_532;
              case 0xB:
                goto LABEL_529;
              case 0xC:
                goto LABEL_526;
              case 0xD:
                goto LABEL_523;
              case 0xE:
                goto LABEL_520;
              case 0xF:
                while ( 1 )
                {
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[1] = byte_B7934[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_520:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[2] = byte_B7934[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_523:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[3] = byte_B7934[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_526:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[4] = byte_B7934[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_529:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[5] = byte_B7934[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_532:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[6] = byte_B7934[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_535:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[7] = byte_B7934[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_538:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[8] = byte_B7934[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_541:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[9] = byte_B7934[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_544:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[10] = byte_B7934[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_547:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[11] = byte_B7934[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_550:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[12] = byte_B7934[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_553:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[13] = byte_B7934[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_556:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[14] = byte_B7934[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_559:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[15] = byte_B7934[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
                  v388 += 16;
                  v16 = (__int16)v385 <= 16;
                  LOWORD(v385) = v385 - 16;
                  if ( v16 )
                    break;
LABEL_514:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    *v388 = byte_B7934[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
                }
                break;
            }
          }
LABEL_562:
          if ( !--v1098 )
            return;
        }
        if ( v381 > dword_93AD8 )
          LOWORD(v381) = dword_93AD8;
        v16 = (__int16)v381 <= (__int16)v378;
        v386 = v381 - v378;
        if ( v16 )
          goto LABEL_562;
        v382 += v378;
        LOBYTE(v379) = v380[10];
        v384 = __ROL4__(*((_DWORD *)v380 + 3), 16);
        v387 = v386;
        BYTE1(v379) = v384;
        LOWORD(v384) = *((_WORD *)v380 + 4);
        v385 = __ROL4__(*((_DWORD *)v380 + 4), 16);
        BYTE1(v378) = v385;
        LOWORD(v385) = v387;
        goto LABEL_513;
      case 7:
      case 11:
LABEL_564:
        v390 = (unsigned __int16 *)&unk_93AE0;
        v1152 = v1110 << 16;
        HIWORD(v391) = 0;
        HIWORD(v392) = 0;
        while ( 1 )
        {
          LOWORD(v391) = v390[1];
          v393 = v390[3];
          v394 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v391 & 0x8000u) == 0 )
            break;
          if ( (__int16)v393 > 0 )
          {
            v395 = (unsigned __int16)-(__int16)v391;
            v397 = __ROL4__(*((_DWORD *)v390 + 3) + v1110 * v395, 16);
            BYTE1(v392) = v397;
            v396 = *((_DWORD *)v390 + 2) + v1099 * v395;
            LOWORD(v397) = v396;
            v398 = v396 >> 8;
            LOBYTE(v392) = BYTE1(v398);
            if ( v393 > dword_93AD8 )
              LOWORD(v393) = dword_93AD8;
            v391 = (unsigned __int16)v398;
LABEL_574:
            v1261 = v390;
            v399 = dword_93AD0;
            BYTE1(v391) = byte_967E0;
            while ( 1 )
            {
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v397);
              LOWORD(v397) = v1099 + v397;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v397);
              v400 = v1152 + v397;
              *v394 = byte_B7934[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v401 = v393 - 1;
              if ( !v401 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v400);
              LOWORD(v400) = v1099 + v400;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v400);
              v402 = v1152 + v400;
              v394[1] = byte_B7934[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v403 = v401 - 1;
              if ( !v403 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v402);
              LOWORD(v402) = v1099 + v402;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v402);
              v404 = v1152 + v402;
              v394[2] = byte_B7934[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v405 = v403 - 1;
              if ( !v405 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v404);
              LOWORD(v404) = v1099 + v404;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v404);
              v406 = v1152 + v404;
              v394[3] = byte_B7934[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v407 = v405 - 1;
              if ( !v407 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v406);
              LOWORD(v406) = v1099 + v406;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v406);
              v408 = v1152 + v406;
              v394[4] = byte_B7934[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v409 = v407 - 1;
              if ( !v409 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v408);
              LOWORD(v408) = v1099 + v408;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v408);
              v410 = v1152 + v408;
              v394[5] = byte_B7934[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v411 = v409 - 1;
              if ( !v411 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v410);
              LOWORD(v410) = v1099 + v410;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v410);
              v412 = v1152 + v410;
              v394[6] = byte_B7934[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v413 = v411 - 1;
              if ( !v413 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v412);
              LOWORD(v412) = v1099 + v412;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v412);
              v414 = v1152 + v412;
              v394[7] = byte_B7934[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v415 = v413 - 1;
              if ( !v415 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v414);
              LOWORD(v414) = v1099 + v414;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v414);
              v416 = v1152 + v414;
              v394[8] = byte_B7934[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v417 = v415 - 1;
              if ( !v417 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v416);
              LOWORD(v416) = v1099 + v416;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v416);
              v418 = v1152 + v416;
              v394[9] = byte_B7934[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v419 = v417 - 1;
              if ( !v419 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v418);
              LOWORD(v418) = v1099 + v418;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v418);
              v420 = v1152 + v418;
              v394[10] = byte_B7934[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v421 = v419 - 1;
              if ( !v421 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v420);
              LOWORD(v420) = v1099 + v420;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v420);
              v422 = v1152 + v420;
              v394[11] = byte_B7934[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v423 = v421 - 1;
              if ( !v423 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v422);
              LOWORD(v422) = v1099 + v422;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v422);
              v424 = v1152 + v422;
              v394[12] = byte_B7934[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v425 = v423 - 1;
              if ( !v425 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v424);
              LOWORD(v424) = v1099 + v424;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v424);
              v426 = v1152 + v424;
              v394[13] = byte_B7934[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v427 = v425 - 1;
              if ( !v427 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v426);
              LOWORD(v426) = v1099 + v426;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v426);
              v428 = v1152 + v426;
              v394[14] = byte_B7934[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v429 = v427 - 1;
              if ( !v429 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v428);
              LOWORD(v428) = v1099 + v428;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v428);
              v397 = v1152 + v428;
              v394[15] = byte_B7934[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              LOWORD(v393) = v429 - 1;
              if ( !(_WORD)v393 )
                break;
              v394 += 16;
            }
            v390 = v1261;
          }
LABEL_593:
          v390 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v393 > dword_93AD8 )
          LOWORD(v393) = dword_93AD8;
        v16 = (__int16)v393 <= (__int16)v391;
        LOWORD(v393) = v393 - v391;
        if ( v16 )
          goto LABEL_593;
        v394 += v391;
        v397 = __ROL4__(*((_DWORD *)v390 + 3), 16);
        BYTE1(v392) = v397;
        LOWORD(v397) = v390[4];
        LOBYTE(v392) = *((_BYTE *)v390 + 10);
        goto LABEL_574;
      case 8:
LABEL_595:
        v430 = (unsigned __int16 *)&unk_93AE0;
        v1153 = v1110 << 16;
        HIWORD(v431) = 0;
        HIWORD(v432) = 0;
        while ( 1 )
        {
          LOWORD(v431) = v430[1];
          v433 = v430[3];
          v434 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v431 & 0x8000u) == 0 )
            break;
          if ( (__int16)v433 > 0 )
          {
            v435 = (unsigned __int16)-(__int16)v431;
            v437 = __ROL4__(*((_DWORD *)v430 + 3) + v1110 * v435, 16);
            BYTE1(v432) = v437;
            v436 = *((_DWORD *)v430 + 2) + v1099 * v435;
            LOWORD(v437) = v436;
            v438 = v436 >> 8;
            LOBYTE(v432) = BYTE1(v438);
            if ( v433 > dword_93AD8 )
              LOWORD(v433) = dword_93AD8;
            v431 = (unsigned __int16)v438;
LABEL_605:
            v1262 = v430;
            v439 = dword_93AD0;
            BYTE1(v431) = byte_967E0;
            while ( 1 )
            {
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v437);
              LOWORD(v437) = v1099 + v437;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                *v434 = byte_B7934[v431];
              v171 = __CFADD__(v1153, v437);
              v440 = v1153 + v437;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v441 = v433 - 1;
              if ( !v441 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v440);
              LOWORD(v440) = v1099 + v440;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[1] = byte_B7934[v431];
              v171 = __CFADD__(v1153, v440);
              v442 = v1153 + v440;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v443 = v441 - 1;
              if ( !v443 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v442);
              LOWORD(v442) = v1099 + v442;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[2] = byte_B7934[v431];
              v171 = __CFADD__(v1153, v442);
              v444 = v1153 + v442;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v445 = v443 - 1;
              if ( !v445 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v444);
              LOWORD(v444) = v1099 + v444;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[3] = byte_B7934[v431];
              v171 = __CFADD__(v1153, v444);
              v446 = v1153 + v444;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v447 = v445 - 1;
              if ( !v447 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v446);
              LOWORD(v446) = v1099 + v446;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[4] = byte_B7934[v431];
              v171 = __CFADD__(v1153, v446);
              v448 = v1153 + v446;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v449 = v447 - 1;
              if ( !v449 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v448);
              LOWORD(v448) = v1099 + v448;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[5] = byte_B7934[v431];
              v171 = __CFADD__(v1153, v448);
              v450 = v1153 + v448;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v451 = v449 - 1;
              if ( !v451 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v450);
              LOWORD(v450) = v1099 + v450;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[6] = byte_B7934[v431];
              v171 = __CFADD__(v1153, v450);
              v452 = v1153 + v450;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v453 = v451 - 1;
              if ( !v453 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v452);
              LOWORD(v452) = v1099 + v452;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[7] = byte_B7934[v431];
              v171 = __CFADD__(v1153, v452);
              v454 = v1153 + v452;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v455 = v453 - 1;
              if ( !v455 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v454);
              LOWORD(v454) = v1099 + v454;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[8] = byte_B7934[v431];
              v171 = __CFADD__(v1153, v454);
              v456 = v1153 + v454;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v457 = v455 - 1;
              if ( !v457 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v456);
              LOWORD(v456) = v1099 + v456;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[9] = byte_B7934[v431];
              v171 = __CFADD__(v1153, v456);
              v458 = v1153 + v456;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v459 = v457 - 1;
              if ( !v459 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v458);
              LOWORD(v458) = v1099 + v458;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[10] = byte_B7934[v431];
              v171 = __CFADD__(v1153, v458);
              v460 = v1153 + v458;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v461 = v459 - 1;
              if ( !v461 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v460);
              LOWORD(v460) = v1099 + v460;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[11] = byte_B7934[v431];
              v171 = __CFADD__(v1153, v460);
              v462 = v1153 + v460;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v463 = v461 - 1;
              if ( !v463 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v462);
              LOWORD(v462) = v1099 + v462;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[12] = byte_B7934[v431];
              v171 = __CFADD__(v1153, v462);
              v464 = v1153 + v462;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v465 = v463 - 1;
              if ( !v465 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v464);
              LOWORD(v464) = v1099 + v464;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[13] = byte_B7934[v431];
              v171 = __CFADD__(v1153, v464);
              v466 = v1153 + v464;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v467 = v465 - 1;
              if ( !v467 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v466);
              LOWORD(v466) = v1099 + v466;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[14] = byte_B7934[v431];
              v171 = __CFADD__(v1153, v466);
              v468 = v1153 + v466;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v469 = v467 - 1;
              if ( !v469 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v468);
              LOWORD(v468) = v1099 + v468;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[15] = byte_B7934[v431];
              v171 = __CFADD__(v1153, v468);
              v437 = v1153 + v468;
              BYTE1(v432) += BYTE2(v1110) + v171;
              LOWORD(v433) = v469 - 1;
              if ( !(_WORD)v433 )
                break;
              v434 += 16;
            }
            v430 = v1262;
          }
LABEL_656:
          v430 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v433 > dword_93AD8 )
          LOWORD(v433) = dword_93AD8;
        v16 = (__int16)v433 <= (__int16)v431;
        LOWORD(v433) = v433 - v431;
        if ( v16 )
          goto LABEL_656;
        v434 += v431;
        v437 = __ROL4__(*((_DWORD *)v430 + 3), 16);
        BYTE1(v432) = v437;
        LOWORD(v437) = v430[4];
        LOBYTE(v432) = *((_BYTE *)v430 + 10);
        goto LABEL_605;
      case 9:
      case 10:
LABEL_658:
        v470 = (unsigned __int16 *)&unk_93AE0;
        v1154 = v1110 << 16;
        HIWORD(v471) = 0;
        HIWORD(v472) = 0;
        while ( 1 )
        {
          LOWORD(v471) = v470[1];
          v473 = v470[3];
          v474 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v471 & 0x8000u) == 0 )
            break;
          if ( (__int16)v473 > 0 )
          {
            v475 = (unsigned __int16)-(__int16)v471;
            v477 = __ROL4__(*((_DWORD *)v470 + 3) + v1110 * v475, 16);
            BYTE1(v472) = v477;
            v476 = *((_DWORD *)v470 + 2) + v1099 * v475;
            LOWORD(v477) = v476;
            v478 = v476 >> 8;
            LOBYTE(v472) = BYTE1(v478);
            if ( v473 > dword_93AD8 )
              LOWORD(v473) = dword_93AD8;
            v471 = (unsigned __int16)v478;
LABEL_668:
            v1263 = v470;
            v479 = dword_93AD0;
            while ( 1 )
            {
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v477);
              LOWORD(v477) = v1099 + v477;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = *v474;
                *v474 = byte_B7934[v471];
              }
              v171 = __CFADD__(v1154, v477);
              v480 = v1154 + v477;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v481 = v473 - 1;
              if ( !v481 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v480);
              LOWORD(v480) = v1099 + v480;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[1];
                v474[1] = byte_B7934[v471];
              }
              v171 = __CFADD__(v1154, v480);
              v482 = v1154 + v480;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v483 = v481 - 1;
              if ( !v483 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v482);
              LOWORD(v482) = v1099 + v482;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[2];
                v474[2] = byte_B7934[v471];
              }
              v171 = __CFADD__(v1154, v482);
              v484 = v1154 + v482;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v485 = v483 - 1;
              if ( !v485 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v484);
              LOWORD(v484) = v1099 + v484;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[3];
                v474[3] = byte_B7934[v471];
              }
              v171 = __CFADD__(v1154, v484);
              v486 = v1154 + v484;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v487 = v485 - 1;
              if ( !v487 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v486);
              LOWORD(v486) = v1099 + v486;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[4];
                v474[4] = byte_B7934[v471];
              }
              v171 = __CFADD__(v1154, v486);
              v488 = v1154 + v486;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v489 = v487 - 1;
              if ( !v489 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v488);
              LOWORD(v488) = v1099 + v488;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[5];
                v474[5] = byte_B7934[v471];
              }
              v171 = __CFADD__(v1154, v488);
              v490 = v1154 + v488;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v491 = v489 - 1;
              if ( !v491 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v490);
              LOWORD(v490) = v1099 + v490;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[6];
                v474[6] = byte_B7934[v471];
              }
              v171 = __CFADD__(v1154, v490);
              v492 = v1154 + v490;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v493 = v491 - 1;
              if ( !v493 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v492);
              LOWORD(v492) = v1099 + v492;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[7];
                v474[7] = byte_B7934[v471];
              }
              v171 = __CFADD__(v1154, v492);
              v494 = v1154 + v492;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v495 = v493 - 1;
              if ( !v495 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v494);
              LOWORD(v494) = v1099 + v494;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[8];
                v474[8] = byte_B7934[v471];
              }
              v171 = __CFADD__(v1154, v494);
              v496 = v1154 + v494;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v497 = v495 - 1;
              if ( !v497 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v496);
              LOWORD(v496) = v1099 + v496;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[9];
                v474[9] = byte_B7934[v471];
              }
              v171 = __CFADD__(v1154, v496);
              v498 = v1154 + v496;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v499 = v497 - 1;
              if ( !v499 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v498);
              LOWORD(v498) = v1099 + v498;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[10];
                v474[10] = byte_B7934[v471];
              }
              v171 = __CFADD__(v1154, v498);
              v500 = v1154 + v498;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v501 = v499 - 1;
              if ( !v501 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v500);
              LOWORD(v500) = v1099 + v500;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[11];
                v474[11] = byte_B7934[v471];
              }
              v171 = __CFADD__(v1154, v500);
              v502 = v1154 + v500;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v503 = v501 - 1;
              if ( !v503 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v502);
              LOWORD(v502) = v1099 + v502;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[12];
                v474[12] = byte_B7934[v471];
              }
              v171 = __CFADD__(v1154, v502);
              v504 = v1154 + v502;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v505 = v503 - 1;
              if ( !v505 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v504);
              LOWORD(v504) = v1099 + v504;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[13];
                v474[13] = byte_B7934[v471];
              }
              v171 = __CFADD__(v1154, v504);
              v506 = v1154 + v504;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v507 = v505 - 1;
              if ( !v507 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v506);
              LOWORD(v506) = v1099 + v506;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[14];
                v474[14] = byte_B7934[v471];
              }
              v171 = __CFADD__(v1154, v506);
              v508 = v1154 + v506;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v509 = v507 - 1;
              if ( !v509 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v508);
              LOWORD(v508) = v1099 + v508;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[15];
                v474[15] = byte_B7934[v471];
              }
              v171 = __CFADD__(v1154, v508);
              v477 = v1154 + v508;
              BYTE1(v472) += BYTE2(v1110) + v171;
              LOWORD(v473) = v509 - 1;
              if ( !(_WORD)v473 )
                break;
              v474 += 16;
            }
            v470 = v1263;
          }
LABEL_719:
          v470 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v473 > dword_93AD8 )
          LOWORD(v473) = dword_93AD8;
        v16 = (__int16)v473 <= (__int16)v471;
        LOWORD(v473) = v473 - v471;
        if ( v16 )
          goto LABEL_719;
        v474 += v471;
        v477 = __ROL4__(*((_DWORD *)v470 + 3), 16);
        BYTE1(v472) = v477;
        LOWORD(v477) = v470[4];
        LOBYTE(v472) = *((_BYTE *)v470 + 10);
        goto LABEL_668;
      case 12:
LABEL_721:
        v510 = (unsigned __int16 *)&unk_93AE0;
        v1155 = v1110 << 16;
        HIWORD(v511) = 0;
        HIWORD(v512) = 0;
        while ( 1 )
        {
          LOWORD(v511) = v510[1];
          v513 = v510[3];
          v514 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v511 & 0x8000u) == 0 )
            break;
          if ( (__int16)v513 > 0 )
          {
            v515 = (unsigned __int16)-(__int16)v511;
            v517 = __ROL4__(*((_DWORD *)v510 + 3) + v1110 * v515, 16);
            BYTE1(v512) = v517;
            v516 = *((_DWORD *)v510 + 2) + v1099 * v515;
            LOWORD(v517) = v516;
            v518 = v516 >> 8;
            LOBYTE(v512) = BYTE1(v518);
            if ( v513 > dword_93AD8 )
              LOWORD(v513) = dword_93AD8;
            v511 = (unsigned __int16)v518;
LABEL_731:
            v1264 = v510;
            v519 = dword_93AD0;
            LOBYTE(v511) = byte_967E0;
            while ( 1 )
            {
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v517);
              LOWORD(v517) = v1099 + v517;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v517);
              v520 = v1155 + v517;
              *v514 = byte_BB934[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v521 = v513 - 1;
              if ( !v521 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v520);
              LOWORD(v520) = v1099 + v520;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v520);
              v522 = v1155 + v520;
              v514[1] = byte_BB934[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v523 = v521 - 1;
              if ( !v523 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v522);
              LOWORD(v522) = v1099 + v522;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v522);
              v524 = v1155 + v522;
              v514[2] = byte_BB934[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v525 = v523 - 1;
              if ( !v525 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v524);
              LOWORD(v524) = v1099 + v524;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v524);
              v526 = v1155 + v524;
              v514[3] = byte_BB934[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v527 = v525 - 1;
              if ( !v527 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v526);
              LOWORD(v526) = v1099 + v526;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v526);
              v528 = v1155 + v526;
              v514[4] = byte_BB934[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v529 = v527 - 1;
              if ( !v529 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v528);
              LOWORD(v528) = v1099 + v528;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v528);
              v530 = v1155 + v528;
              v514[5] = byte_BB934[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v531 = v529 - 1;
              if ( !v531 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v530);
              LOWORD(v530) = v1099 + v530;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v530);
              v532 = v1155 + v530;
              v514[6] = byte_BB934[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v533 = v531 - 1;
              if ( !v533 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v532);
              LOWORD(v532) = v1099 + v532;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v532);
              v534 = v1155 + v532;
              v514[7] = byte_BB934[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v535 = v533 - 1;
              if ( !v535 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v534);
              LOWORD(v534) = v1099 + v534;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v534);
              v536 = v1155 + v534;
              v514[8] = byte_BB934[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v537 = v535 - 1;
              if ( !v537 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v536);
              LOWORD(v536) = v1099 + v536;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v536);
              v538 = v1155 + v536;
              v514[9] = byte_BB934[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v539 = v537 - 1;
              if ( !v539 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v538);
              LOWORD(v538) = v1099 + v538;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v538);
              v540 = v1155 + v538;
              v514[10] = byte_BB934[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v541 = v539 - 1;
              if ( !v541 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v540);
              LOWORD(v540) = v1099 + v540;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v540);
              v542 = v1155 + v540;
              v514[11] = byte_BB934[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v543 = v541 - 1;
              if ( !v543 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v542);
              LOWORD(v542) = v1099 + v542;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v542);
              v544 = v1155 + v542;
              v514[12] = byte_BB934[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v545 = v543 - 1;
              if ( !v545 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v544);
              LOWORD(v544) = v1099 + v544;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v544);
              v546 = v1155 + v544;
              v514[13] = byte_BB934[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v547 = v545 - 1;
              if ( !v547 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v546);
              LOWORD(v546) = v1099 + v546;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v546);
              v548 = v1155 + v546;
              v514[14] = byte_BB934[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v549 = v547 - 1;
              if ( !v549 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v548);
              LOWORD(v548) = v1099 + v548;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v548);
              v517 = v1155 + v548;
              v514[15] = byte_BB934[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              LOWORD(v513) = v549 - 1;
              if ( !(_WORD)v513 )
                break;
              v514 += 16;
            }
            v510 = v1264;
          }
LABEL_750:
          v510 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v513 > dword_93AD8 )
          LOWORD(v513) = dword_93AD8;
        v16 = (__int16)v513 <= (__int16)v511;
        LOWORD(v513) = v513 - v511;
        if ( v16 )
          goto LABEL_750;
        v514 += v511;
        v517 = __ROL4__(*((_DWORD *)v510 + 3), 16);
        BYTE1(v512) = v517;
        LOWORD(v517) = v510[4];
        LOBYTE(v512) = *((_BYTE *)v510 + 10);
        goto LABEL_731;
      case 13:
LABEL_752:
        v550 = (unsigned __int16 *)&unk_93AE0;
        v1156 = v1110 << 16;
        HIWORD(v551) = 0;
        HIWORD(v552) = 0;
        while ( 1 )
        {
          LOWORD(v551) = v550[1];
          v553 = v550[3];
          v554 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v551 & 0x8000u) == 0 )
            break;
          if ( (__int16)v553 > 0 )
          {
            v555 = (unsigned __int16)-(__int16)v551;
            v557 = __ROL4__(*((_DWORD *)v550 + 3) + v1110 * v555, 16);
            BYTE1(v552) = v557;
            v556 = *((_DWORD *)v550 + 2) + v1099 * v555;
            LOWORD(v557) = v556;
            v558 = v556 >> 8;
            LOBYTE(v552) = BYTE1(v558);
            if ( v553 > dword_93AD8 )
              LOWORD(v553) = dword_93AD8;
            v551 = (unsigned __int16)v558;
LABEL_762:
            v1265 = v550;
            v559 = dword_93AD0;
            BYTE1(v551) = byte_967E0;
            while ( 1 )
            {
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v557);
              LOWORD(v557) = v1099 + v557;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v557);
              v560 = v1156 + v557;
              *v554 = byte_BB934[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v561 = v553 - 1;
              if ( !v561 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v560);
              LOWORD(v560) = v1099 + v560;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v560);
              v562 = v1156 + v560;
              v554[1] = byte_BB934[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v563 = v561 - 1;
              if ( !v563 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v562);
              LOWORD(v562) = v1099 + v562;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v562);
              v564 = v1156 + v562;
              v554[2] = byte_BB934[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v565 = v563 - 1;
              if ( !v565 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v564);
              LOWORD(v564) = v1099 + v564;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v564);
              v566 = v1156 + v564;
              v554[3] = byte_BB934[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v567 = v565 - 1;
              if ( !v567 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v566);
              LOWORD(v566) = v1099 + v566;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v566);
              v568 = v1156 + v566;
              v554[4] = byte_BB934[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v569 = v567 - 1;
              if ( !v569 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v568);
              LOWORD(v568) = v1099 + v568;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v568);
              v570 = v1156 + v568;
              v554[5] = byte_BB934[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v571 = v569 - 1;
              if ( !v571 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v570);
              LOWORD(v570) = v1099 + v570;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v570);
              v572 = v1156 + v570;
              v554[6] = byte_BB934[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v573 = v571 - 1;
              if ( !v573 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v572);
              LOWORD(v572) = v1099 + v572;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v572);
              v574 = v1156 + v572;
              v554[7] = byte_BB934[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v575 = v573 - 1;
              if ( !v575 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v574);
              LOWORD(v574) = v1099 + v574;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v574);
              v576 = v1156 + v574;
              v554[8] = byte_BB934[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v577 = v575 - 1;
              if ( !v577 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v576);
              LOWORD(v576) = v1099 + v576;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v576);
              v578 = v1156 + v576;
              v554[9] = byte_BB934[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v579 = v577 - 1;
              if ( !v579 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v578);
              LOWORD(v578) = v1099 + v578;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v578);
              v580 = v1156 + v578;
              v554[10] = byte_BB934[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v581 = v579 - 1;
              if ( !v581 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v580);
              LOWORD(v580) = v1099 + v580;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v580);
              v582 = v1156 + v580;
              v554[11] = byte_BB934[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v583 = v581 - 1;
              if ( !v583 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v582);
              LOWORD(v582) = v1099 + v582;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v582);
              v584 = v1156 + v582;
              v554[12] = byte_BB934[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v585 = v583 - 1;
              if ( !v585 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v584);
              LOWORD(v584) = v1099 + v584;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v584);
              v586 = v1156 + v584;
              v554[13] = byte_BB934[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v587 = v585 - 1;
              if ( !v587 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v586);
              LOWORD(v586) = v1099 + v586;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v586);
              v588 = v1156 + v586;
              v554[14] = byte_BB934[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v589 = v587 - 1;
              if ( !v589 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v588);
              LOWORD(v588) = v1099 + v588;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v588);
              v557 = v1156 + v588;
              v554[15] = byte_BB934[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              LOWORD(v553) = v589 - 1;
              if ( !(_WORD)v553 )
                break;
              v554 += 16;
            }
            v550 = v1265;
          }
LABEL_781:
          v550 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v553 > dword_93AD8 )
          LOWORD(v553) = dword_93AD8;
        v16 = (__int16)v553 <= (__int16)v551;
        LOWORD(v553) = v553 - v551;
        if ( v16 )
          goto LABEL_781;
        v554 += v551;
        v557 = __ROL4__(*((_DWORD *)v550 + 3), 16);
        BYTE1(v552) = v557;
        LOWORD(v557) = v550[4];
        LOBYTE(v552) = *((_BYTE *)v550 + 10);
        goto LABEL_762;
      case 14:
LABEL_783:
        v590 = (unsigned __int16 *)&unk_93AE0;
        v591 = (_BYTE *)v1077;
        HIWORD(v592) = 0;
        BYTE1(v592) = byte_967E0;
        HIWORD(v593) = 0;
        while ( 1 )
        {
          LOWORD(v593) = v590[1];
          v594 = v590[3];
          v591 += dword_93AD4;
          if ( (v593 & 0x8000u) == 0 )
            break;
          if ( (__int16)v594 > 0 )
          {
            if ( v594 > dword_93AD8 )
              LOWORD(v594) = dword_93AD8;
LABEL_793:
            for ( k = v591; ; k += 16 )
            {
              LOBYTE(v592) = *k;
              *k = byte_BB934[v592];
              v596 = v594 - 1;
              if ( !v596 )
                break;
              LOBYTE(v592) = k[1];
              k[1] = byte_BB934[v592];
              v597 = v596 - 1;
              if ( !v597 )
                break;
              LOBYTE(v592) = k[2];
              k[2] = byte_BB934[v592];
              v598 = v597 - 1;
              if ( !v598 )
                break;
              LOBYTE(v592) = k[3];
              k[3] = byte_BB934[v592];
              v599 = v598 - 1;
              if ( !v599 )
                break;
              LOBYTE(v592) = k[4];
              k[4] = byte_BB934[v592];
              v600 = v599 - 1;
              if ( !v600 )
                break;
              LOBYTE(v592) = k[5];
              k[5] = byte_BB934[v592];
              v601 = v600 - 1;
              if ( !v601 )
                break;
              LOBYTE(v592) = k[6];
              k[6] = byte_BB934[v592];
              v602 = v601 - 1;
              if ( !v602 )
                break;
              LOBYTE(v592) = k[7];
              k[7] = byte_BB934[v592];
              v603 = v602 - 1;
              if ( !v603 )
                break;
              LOBYTE(v592) = k[8];
              k[8] = byte_BB934[v592];
              v604 = v603 - 1;
              if ( !v604 )
                break;
              LOBYTE(v592) = k[9];
              k[9] = byte_BB934[v592];
              v605 = v604 - 1;
              if ( !v605 )
                break;
              LOBYTE(v592) = k[10];
              k[10] = byte_BB934[v592];
              v606 = v605 - 1;
              if ( !v606 )
                break;
              LOBYTE(v592) = k[11];
              k[11] = byte_BB934[v592];
              v607 = v606 - 1;
              if ( !v607 )
                break;
              LOBYTE(v592) = k[12];
              k[12] = byte_BB934[v592];
              v608 = v607 - 1;
              if ( !v608 )
                break;
              LOBYTE(v592) = k[13];
              k[13] = byte_BB934[v592];
              v609 = v608 - 1;
              if ( !v609 )
                break;
              LOBYTE(v592) = k[14];
              k[14] = byte_BB934[v592];
              v610 = v609 - 1;
              if ( !v610 )
                break;
              LOBYTE(v592) = k[15];
              k[15] = byte_BB934[v592];
              LOWORD(v594) = v610 - 1;
              if ( !(_WORD)v594 )
                break;
            }
          }
LABEL_810:
          v590 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v594 > dword_93AD8 )
          LOWORD(v594) = dword_93AD8;
        v16 = (__int16)v594 <= (__int16)v593;
        LOWORD(v594) = v594 - v593;
        if ( v16 )
          goto LABEL_810;
        k = &v591[v593];
        goto LABEL_793;
      case 15:
LABEL_812:
        v611 = (unsigned __int16 *)&unk_93AE0;
        v612 = (_BYTE *)v1077;
        v613 = (unsigned __int8)byte_967E0;
        HIWORD(v614) = 0;
        while ( 1 )
        {
          LOWORD(v614) = v611[1];
          v615 = v611[3];
          v612 += dword_93AD4;
          if ( (v614 & 0x8000u) == 0 )
            break;
          if ( (__int16)v615 > 0 )
          {
            if ( v615 > dword_93AD8 )
              LOWORD(v615) = dword_93AD8;
LABEL_822:
            for ( m = v612; ; m += 16 )
            {
              BYTE1(v613) = *m;
              *m = byte_BB934[v613];
              v617 = v615 - 1;
              if ( !v617 )
                break;
              BYTE1(v613) = m[1];
              m[1] = byte_BB934[v613];
              v618 = v617 - 1;
              if ( !v618 )
                break;
              BYTE1(v613) = m[2];
              m[2] = byte_BB934[v613];
              v619 = v618 - 1;
              if ( !v619 )
                break;
              BYTE1(v613) = m[3];
              m[3] = byte_BB934[v613];
              v620 = v619 - 1;
              if ( !v620 )
                break;
              BYTE1(v613) = m[4];
              m[4] = byte_BB934[v613];
              v621 = v620 - 1;
              if ( !v621 )
                break;
              BYTE1(v613) = m[5];
              m[5] = byte_BB934[v613];
              v622 = v621 - 1;
              if ( !v622 )
                break;
              BYTE1(v613) = m[6];
              m[6] = byte_BB934[v613];
              v623 = v622 - 1;
              if ( !v623 )
                break;
              BYTE1(v613) = m[7];
              m[7] = byte_BB934[v613];
              v624 = v623 - 1;
              if ( !v624 )
                break;
              BYTE1(v613) = m[8];
              m[8] = byte_BB934[v613];
              v625 = v624 - 1;
              if ( !v625 )
                break;
              BYTE1(v613) = m[9];
              m[9] = byte_BB934[v613];
              v626 = v625 - 1;
              if ( !v626 )
                break;
              BYTE1(v613) = m[10];
              m[10] = byte_BB934[v613];
              v627 = v626 - 1;
              if ( !v627 )
                break;
              BYTE1(v613) = m[11];
              m[11] = byte_BB934[v613];
              v628 = v627 - 1;
              if ( !v628 )
                break;
              BYTE1(v613) = m[12];
              m[12] = byte_BB934[v613];
              v629 = v628 - 1;
              if ( !v629 )
                break;
              BYTE1(v613) = m[13];
              m[13] = byte_BB934[v613];
              v630 = v629 - 1;
              if ( !v630 )
                break;
              BYTE1(v613) = m[14];
              m[14] = byte_BB934[v613];
              v631 = v630 - 1;
              if ( !v631 )
                break;
              BYTE1(v613) = m[15];
              m[15] = byte_BB934[v613];
              LOWORD(v615) = v631 - 1;
              if ( !(_WORD)v615 )
                break;
            }
          }
LABEL_839:
          v611 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v615 > dword_93AD8 )
          LOWORD(v615) = dword_93AD8;
        v16 = (__int16)v615 <= (__int16)v614;
        LOWORD(v615) = v615 - v614;
        if ( v16 )
          goto LABEL_839;
        m = &v612[v614];
        goto LABEL_822;
      case 16:
LABEL_841:
        v632 = (unsigned __int16 *)&unk_93AE0;
        HIWORD(v633) = 0;
        while ( 1 )
        {
          LOWORD(v29) = v632[1];
          v634 = v632[3];
          v635 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v29 & 0x8000u) == 0 )
            break;
          if ( (__int16)v634 > 0 )
          {
            v636 = v1121 * (unsigned __int16)-(__int16)v29;
            v637 = v636;
            v29 = v636 >> 8;
            v171 = __CFADD__(v632[8], v637);
            v638 = v632[8] + v637;
            BYTE1(v29) += *((_BYTE *)v632 + 18) + v171;
            if ( v634 > dword_93AD8 )
              LOWORD(v634) = dword_93AD8;
            v29 = (unsigned __int16)v29;
            LOBYTE(v29) = byte_967E0;
LABEL_851:
            while ( 1 )
            {
              BYTE1(v633) = byte_B7934[v29];
              LOBYTE(v633) = *v635;
              *v635 = byte_BB934[v633];
              v171 = __CFADD__((_WORD)v1121, v638);
              v639 = v1121 + v638;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v640 = v634 - 1;
              if ( !v640 )
                break;
              BYTE1(v633) = byte_B7934[v29];
              LOBYTE(v633) = v635[1];
              v635[1] = byte_BB934[v633];
              v171 = __CFADD__((_WORD)v1121, v639);
              v641 = v1121 + v639;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v642 = v640 - 1;
              if ( !v642 )
                break;
              BYTE1(v633) = byte_B7934[v29];
              LOBYTE(v633) = v635[2];
              v635[2] = byte_BB934[v633];
              v171 = __CFADD__((_WORD)v1121, v641);
              v643 = v1121 + v641;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v644 = v642 - 1;
              if ( !v644 )
                break;
              BYTE1(v633) = byte_B7934[v29];
              LOBYTE(v633) = v635[3];
              v635[3] = byte_BB934[v633];
              v171 = __CFADD__((_WORD)v1121, v643);
              v645 = v1121 + v643;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v646 = v644 - 1;
              if ( !v646 )
                break;
              BYTE1(v633) = byte_B7934[v29];
              LOBYTE(v633) = v635[4];
              v635[4] = byte_BB934[v633];
              v171 = __CFADD__((_WORD)v1121, v645);
              v647 = v1121 + v645;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v648 = v646 - 1;
              if ( !v648 )
                break;
              BYTE1(v633) = byte_B7934[v29];
              LOBYTE(v633) = v635[5];
              v635[5] = byte_BB934[v633];
              v171 = __CFADD__((_WORD)v1121, v647);
              v649 = v1121 + v647;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v650 = v648 - 1;
              if ( !v650 )
                break;
              BYTE1(v633) = byte_B7934[v29];
              LOBYTE(v633) = v635[6];
              v635[6] = byte_BB934[v633];
              v171 = __CFADD__((_WORD)v1121, v649);
              v651 = v1121 + v649;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v652 = v650 - 1;
              if ( !v652 )
                break;
              BYTE1(v633) = byte_B7934[v29];
              LOBYTE(v633) = v635[7];
              v635[7] = byte_BB934[v633];
              v171 = __CFADD__((_WORD)v1121, v651);
              v653 = v1121 + v651;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v654 = v652 - 1;
              if ( !v654 )
                break;
              BYTE1(v633) = byte_B7934[v29];
              LOBYTE(v633) = v635[8];
              v635[8] = byte_BB934[v633];
              v171 = __CFADD__((_WORD)v1121, v653);
              v655 = v1121 + v653;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v656 = v654 - 1;
              if ( !v656 )
                break;
              BYTE1(v633) = byte_B7934[v29];
              LOBYTE(v633) = v635[9];
              v635[9] = byte_BB934[v633];
              v171 = __CFADD__((_WORD)v1121, v655);
              v657 = v1121 + v655;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v658 = v656 - 1;
              if ( !v658 )
                break;
              BYTE1(v633) = byte_B7934[v29];
              LOBYTE(v633) = v635[10];
              v635[10] = byte_BB934[v633];
              v171 = __CFADD__((_WORD)v1121, v657);
              v659 = v1121 + v657;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v660 = v658 - 1;
              if ( !v660 )
                break;
              BYTE1(v633) = byte_B7934[v29];
              LOBYTE(v633) = v635[11];
              v635[11] = byte_BB934[v633];
              v171 = __CFADD__((_WORD)v1121, v659);
              v661 = v1121 + v659;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v662 = v660 - 1;
              if ( !v662 )
                break;
              BYTE1(v633) = byte_B7934[v29];
              LOBYTE(v633) = v635[12];
              v635[12] = byte_BB934[v633];
              v171 = __CFADD__((_WORD)v1121, v661);
              v663 = v1121 + v661;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v664 = v662 - 1;
              if ( !v664 )
                break;
              BYTE1(v633) = byte_B7934[v29];
              LOBYTE(v633) = v635[13];
              v635[13] = byte_BB934[v633];
              v171 = __CFADD__((_WORD)v1121, v663);
              v665 = v1121 + v663;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v666 = v664 - 1;
              if ( !v666 )
                break;
              BYTE1(v633) = byte_B7934[v29];
              LOBYTE(v633) = v635[14];
              v635[14] = byte_BB934[v633];
              v171 = __CFADD__((_WORD)v1121, v665);
              v667 = v1121 + v665;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v668 = v666 - 1;
              if ( !v668 )
                break;
              BYTE1(v633) = byte_B7934[v29];
              LOBYTE(v633) = v635[15];
              v635[15] = byte_BB934[v633];
              v171 = __CFADD__((_WORD)v1121, v667);
              v638 = v1121 + v667;
              BYTE1(v29) += BYTE2(v1121) + v171;
              LOWORD(v634) = v668 - 1;
              if ( !(_WORD)v634 )
                break;
              v635 += 16;
            }
          }
LABEL_868:
          v632 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v634 > dword_93AD8 )
          LOWORD(v634) = dword_93AD8;
        v16 = (__int16)v634 <= (__int16)v29;
        LOWORD(v634) = v634 - v29;
        if ( v16 )
          goto LABEL_868;
        v635 += v29;
        v29 = (unsigned __int8)byte_967E0;
        v638 = v632[8];
        BYTE1(v29) = *((_BYTE *)v632 + 18);
        goto LABEL_851;
      case 17:
LABEL_870:
        v669 = (unsigned __int16 *)&unk_93AE0;
        HIWORD(v670) = 0;
        while ( 1 )
        {
          LOWORD(v29) = v669[1];
          v671 = v669[3];
          v672 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v29 & 0x8000u) == 0 )
            break;
          if ( (__int16)v671 > 0 )
          {
            v673 = v1121 * (unsigned __int16)-(__int16)v29;
            v674 = v673;
            v29 = v673 >> 8;
            v171 = __CFADD__(v669[8], v674);
            v675 = v669[8] + v674;
            BYTE1(v29) += *((_BYTE *)v669 + 18) + v171;
            if ( v671 > dword_93AD8 )
              LOWORD(v671) = dword_93AD8;
            v29 = (unsigned __int16)v29;
            LOBYTE(v29) = byte_967E0;
LABEL_880:
            while ( 1 )
            {
              LOBYTE(v670) = byte_B7934[v29];
              BYTE1(v670) = *v672;
              *v672 = byte_BB934[v670];
              v171 = __CFADD__((_WORD)v1121, v675);
              v676 = v1121 + v675;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v677 = v671 - 1;
              if ( !v677 )
                break;
              LOBYTE(v670) = byte_B7934[v29];
              BYTE1(v670) = v672[1];
              v672[1] = byte_BB934[v670];
              v171 = __CFADD__((_WORD)v1121, v676);
              v678 = v1121 + v676;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v679 = v677 - 1;
              if ( !v679 )
                break;
              LOBYTE(v670) = byte_B7934[v29];
              BYTE1(v670) = v672[2];
              v672[2] = byte_BB934[v670];
              v171 = __CFADD__((_WORD)v1121, v678);
              v680 = v1121 + v678;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v681 = v679 - 1;
              if ( !v681 )
                break;
              LOBYTE(v670) = byte_B7934[v29];
              BYTE1(v670) = v672[3];
              v672[3] = byte_BB934[v670];
              v171 = __CFADD__((_WORD)v1121, v680);
              v682 = v1121 + v680;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v683 = v681 - 1;
              if ( !v683 )
                break;
              LOBYTE(v670) = byte_B7934[v29];
              BYTE1(v670) = v672[4];
              v672[4] = byte_BB934[v670];
              v171 = __CFADD__((_WORD)v1121, v682);
              v684 = v1121 + v682;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v685 = v683 - 1;
              if ( !v685 )
                break;
              LOBYTE(v670) = byte_B7934[v29];
              BYTE1(v670) = v672[5];
              v672[5] = byte_BB934[v670];
              v171 = __CFADD__((_WORD)v1121, v684);
              v686 = v1121 + v684;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v687 = v685 - 1;
              if ( !v687 )
                break;
              LOBYTE(v670) = byte_B7934[v29];
              BYTE1(v670) = v672[6];
              v672[6] = byte_BB934[v670];
              v171 = __CFADD__((_WORD)v1121, v686);
              v688 = v1121 + v686;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v689 = v687 - 1;
              if ( !v689 )
                break;
              LOBYTE(v670) = byte_B7934[v29];
              BYTE1(v670) = v672[7];
              v672[7] = byte_BB934[v670];
              v171 = __CFADD__((_WORD)v1121, v688);
              v690 = v1121 + v688;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v691 = v689 - 1;
              if ( !v691 )
                break;
              LOBYTE(v670) = byte_B7934[v29];
              BYTE1(v670) = v672[8];
              v672[8] = byte_BB934[v670];
              v171 = __CFADD__((_WORD)v1121, v690);
              v692 = v1121 + v690;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v693 = v691 - 1;
              if ( !v693 )
                break;
              LOBYTE(v670) = byte_B7934[v29];
              BYTE1(v670) = v672[9];
              v672[9] = byte_BB934[v670];
              v171 = __CFADD__((_WORD)v1121, v692);
              v694 = v1121 + v692;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v695 = v693 - 1;
              if ( !v695 )
                break;
              LOBYTE(v670) = byte_B7934[v29];
              BYTE1(v670) = v672[10];
              v672[10] = byte_BB934[v670];
              v171 = __CFADD__((_WORD)v1121, v694);
              v696 = v1121 + v694;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v697 = v695 - 1;
              if ( !v697 )
                break;
              LOBYTE(v670) = byte_B7934[v29];
              BYTE1(v670) = v672[11];
              v672[11] = byte_BB934[v670];
              v171 = __CFADD__((_WORD)v1121, v696);
              v698 = v1121 + v696;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v699 = v697 - 1;
              if ( !v699 )
                break;
              LOBYTE(v670) = byte_B7934[v29];
              BYTE1(v670) = v672[12];
              v672[12] = byte_BB934[v670];
              v171 = __CFADD__((_WORD)v1121, v698);
              v700 = v1121 + v698;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v701 = v699 - 1;
              if ( !v701 )
                break;
              LOBYTE(v670) = byte_B7934[v29];
              BYTE1(v670) = v672[13];
              v672[13] = byte_BB934[v670];
              v171 = __CFADD__((_WORD)v1121, v700);
              v702 = v1121 + v700;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v703 = v701 - 1;
              if ( !v703 )
                break;
              LOBYTE(v670) = byte_B7934[v29];
              BYTE1(v670) = v672[14];
              v672[14] = byte_BB934[v670];
              v171 = __CFADD__((_WORD)v1121, v702);
              v704 = v1121 + v702;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v705 = v703 - 1;
              if ( !v705 )
                break;
              LOBYTE(v670) = byte_B7934[v29];
              BYTE1(v670) = v672[15];
              v672[15] = byte_BB934[v670];
              v171 = __CFADD__((_WORD)v1121, v704);
              v675 = v1121 + v704;
              BYTE1(v29) += BYTE2(v1121) + v171;
              LOWORD(v671) = v705 - 1;
              if ( !(_WORD)v671 )
                break;
              v672 += 16;
            }
          }
LABEL_897:
          v669 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v671 > dword_93AD8 )
          LOWORD(v671) = dword_93AD8;
        v16 = (__int16)v671 <= (__int16)v29;
        LOWORD(v671) = v671 - v29;
        if ( v16 )
          goto LABEL_897;
        v672 += v29;
        v29 = (unsigned __int8)byte_967E0;
        v675 = v669[8];
        BYTE1(v29) = *((_BYTE *)v669 + 18);
        goto LABEL_880;
      case 18:
LABEL_899:
        v706 = (unsigned __int16 *)&unk_93AE0;
        v1157 = v1110 << 16;
        HIWORD(v707) = 0;
        HIWORD(v708) = 0;
        while ( 1 )
        {
          LOWORD(v707) = v706[1];
          v709 = v706[3];
          v710 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v707 & 0x8000u) == 0 )
            break;
          if ( (__int16)v709 > 0 )
          {
            v711 = (unsigned __int16)-(__int16)v707;
            v713 = __ROL4__(*((_DWORD *)v706 + 3) + v1110 * v711, 16);
            BYTE1(v708) = v713;
            v712 = *((_DWORD *)v706 + 2) + v1099 * v711;
            LOWORD(v713) = v712;
            v714 = v712 >> 8;
            LOBYTE(v708) = BYTE1(v714);
            if ( v709 > dword_93AD8 )
              LOWORD(v709) = dword_93AD8;
            v707 = (unsigned __int16)v714;
LABEL_909:
            v1266 = v706;
            v715 = dword_93AD0;
            while ( 1 )
            {
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v713);
              LOWORD(v713) = v1099 + v713;
              LOBYTE(v707) = *v710;
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v713);
              v716 = v1157 + v713;
              *v710 = byte_BB934[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v717 = v709 - 1;
              if ( !v717 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v716);
              LOWORD(v716) = v1099 + v716;
              LOBYTE(v707) = v710[1];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v716);
              v718 = v1157 + v716;
              v710[1] = byte_BB934[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v719 = v717 - 1;
              if ( !v719 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v718);
              LOWORD(v718) = v1099 + v718;
              LOBYTE(v707) = v710[2];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v718);
              v720 = v1157 + v718;
              v710[2] = byte_BB934[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v721 = v719 - 1;
              if ( !v721 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v720);
              LOWORD(v720) = v1099 + v720;
              LOBYTE(v707) = v710[3];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v720);
              v722 = v1157 + v720;
              v710[3] = byte_BB934[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v723 = v721 - 1;
              if ( !v723 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v722);
              LOWORD(v722) = v1099 + v722;
              LOBYTE(v707) = v710[4];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v722);
              v724 = v1157 + v722;
              v710[4] = byte_BB934[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v725 = v723 - 1;
              if ( !v725 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v724);
              LOWORD(v724) = v1099 + v724;
              LOBYTE(v707) = v710[5];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v724);
              v726 = v1157 + v724;
              v710[5] = byte_BB934[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v727 = v725 - 1;
              if ( !v727 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v726);
              LOWORD(v726) = v1099 + v726;
              LOBYTE(v707) = v710[6];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v726);
              v728 = v1157 + v726;
              v710[6] = byte_BB934[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v729 = v727 - 1;
              if ( !v729 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v728);
              LOWORD(v728) = v1099 + v728;
              LOBYTE(v707) = v710[7];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v728);
              v730 = v1157 + v728;
              v710[7] = byte_BB934[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v731 = v729 - 1;
              if ( !v731 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v730);
              LOWORD(v730) = v1099 + v730;
              LOBYTE(v707) = v710[8];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v730);
              v732 = v1157 + v730;
              v710[8] = byte_BB934[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v733 = v731 - 1;
              if ( !v733 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v732);
              LOWORD(v732) = v1099 + v732;
              LOBYTE(v707) = v710[9];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v732);
              v734 = v1157 + v732;
              v710[9] = byte_BB934[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v735 = v733 - 1;
              if ( !v735 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v734);
              LOWORD(v734) = v1099 + v734;
              LOBYTE(v707) = v710[10];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v734);
              v736 = v1157 + v734;
              v710[10] = byte_BB934[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v737 = v735 - 1;
              if ( !v737 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v736);
              LOWORD(v736) = v1099 + v736;
              LOBYTE(v707) = v710[11];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v736);
              v738 = v1157 + v736;
              v710[11] = byte_BB934[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v739 = v737 - 1;
              if ( !v739 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v738);
              LOWORD(v738) = v1099 + v738;
              LOBYTE(v707) = v710[12];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v738);
              v740 = v1157 + v738;
              v710[12] = byte_BB934[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v741 = v739 - 1;
              if ( !v741 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v740);
              LOWORD(v740) = v1099 + v740;
              LOBYTE(v707) = v710[13];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v740);
              v742 = v1157 + v740;
              v710[13] = byte_BB934[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v743 = v741 - 1;
              if ( !v743 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v742);
              LOWORD(v742) = v1099 + v742;
              LOBYTE(v707) = v710[14];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v742);
              v744 = v1157 + v742;
              v710[14] = byte_BB934[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v745 = v743 - 1;
              if ( !v745 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v744);
              LOWORD(v744) = v1099 + v744;
              LOBYTE(v707) = v710[15];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v744);
              v713 = v1157 + v744;
              v710[15] = byte_BB934[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              LOWORD(v709) = v745 - 1;
              if ( !(_WORD)v709 )
                break;
              v710 += 16;
            }
            v706 = v1266;
          }
LABEL_928:
          v706 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v709 > dword_93AD8 )
          LOWORD(v709) = dword_93AD8;
        v16 = (__int16)v709 <= (__int16)v707;
        LOWORD(v709) = v709 - v707;
        if ( v16 )
          goto LABEL_928;
        v710 += v707;
        v713 = __ROL4__(*((_DWORD *)v706 + 3), 16);
        BYTE1(v708) = v713;
        LOWORD(v713) = v706[4];
        LOBYTE(v708) = *((_BYTE *)v706 + 10);
        goto LABEL_909;
      case 19:
LABEL_930:
        v746 = (unsigned __int16 *)&unk_93AE0;
        v1158 = v1110 << 16;
        HIWORD(v747) = 0;
        HIWORD(v748) = 0;
        while ( 1 )
        {
          LOWORD(v747) = v746[1];
          v749 = v746[3];
          v750 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v747 & 0x8000u) == 0 )
            break;
          if ( (__int16)v749 > 0 )
          {
            v751 = (unsigned __int16)-(__int16)v747;
            v753 = __ROL4__(*((_DWORD *)v746 + 3) + v1110 * v751, 16);
            BYTE1(v748) = v753;
            v752 = *((_DWORD *)v746 + 2) + v1099 * v751;
            LOWORD(v753) = v752;
            v754 = v752 >> 8;
            LOBYTE(v748) = BYTE1(v754);
            if ( v749 > dword_93AD8 )
              LOWORD(v749) = dword_93AD8;
            v747 = (unsigned __int16)v754;
LABEL_940:
            v1267 = v746;
            v755 = dword_93AD0;
            while ( 1 )
            {
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v753);
              LOWORD(v753) = v1099 + v753;
              BYTE1(v747) = *v750;
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v753);
              v756 = v1158 + v753;
              *v750 = byte_BB934[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v757 = v749 - 1;
              if ( !v757 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v756);
              LOWORD(v756) = v1099 + v756;
              BYTE1(v747) = v750[1];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v756);
              v758 = v1158 + v756;
              v750[1] = byte_BB934[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v759 = v757 - 1;
              if ( !v759 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v758);
              LOWORD(v758) = v1099 + v758;
              BYTE1(v747) = v750[2];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v758);
              v760 = v1158 + v758;
              v750[2] = byte_BB934[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v761 = v759 - 1;
              if ( !v761 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v760);
              LOWORD(v760) = v1099 + v760;
              BYTE1(v747) = v750[3];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v760);
              v762 = v1158 + v760;
              v750[3] = byte_BB934[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v763 = v761 - 1;
              if ( !v763 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v762);
              LOWORD(v762) = v1099 + v762;
              BYTE1(v747) = v750[4];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v762);
              v764 = v1158 + v762;
              v750[4] = byte_BB934[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v765 = v763 - 1;
              if ( !v765 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v764);
              LOWORD(v764) = v1099 + v764;
              BYTE1(v747) = v750[5];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v764);
              v766 = v1158 + v764;
              v750[5] = byte_BB934[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v767 = v765 - 1;
              if ( !v767 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v766);
              LOWORD(v766) = v1099 + v766;
              BYTE1(v747) = v750[6];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v766);
              v768 = v1158 + v766;
              v750[6] = byte_BB934[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v769 = v767 - 1;
              if ( !v769 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v768);
              LOWORD(v768) = v1099 + v768;
              BYTE1(v747) = v750[7];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v768);
              v770 = v1158 + v768;
              v750[7] = byte_BB934[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v771 = v769 - 1;
              if ( !v771 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v770);
              LOWORD(v770) = v1099 + v770;
              BYTE1(v747) = v750[8];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v770);
              v772 = v1158 + v770;
              v750[8] = byte_BB934[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v773 = v771 - 1;
              if ( !v773 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v772);
              LOWORD(v772) = v1099 + v772;
              BYTE1(v747) = v750[9];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v772);
              v774 = v1158 + v772;
              v750[9] = byte_BB934[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v775 = v773 - 1;
              if ( !v775 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v774);
              LOWORD(v774) = v1099 + v774;
              BYTE1(v747) = v750[10];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v774);
              v776 = v1158 + v774;
              v750[10] = byte_BB934[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v777 = v775 - 1;
              if ( !v777 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v776);
              LOWORD(v776) = v1099 + v776;
              BYTE1(v747) = v750[11];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v776);
              v778 = v1158 + v776;
              v750[11] = byte_BB934[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v779 = v777 - 1;
              if ( !v779 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v778);
              LOWORD(v778) = v1099 + v778;
              BYTE1(v747) = v750[12];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v778);
              v780 = v1158 + v778;
              v750[12] = byte_BB934[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v781 = v779 - 1;
              if ( !v781 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v780);
              LOWORD(v780) = v1099 + v780;
              BYTE1(v747) = v750[13];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v780);
              v782 = v1158 + v780;
              v750[13] = byte_BB934[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v783 = v781 - 1;
              if ( !v783 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v782);
              LOWORD(v782) = v1099 + v782;
              BYTE1(v747) = v750[14];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v782);
              v784 = v1158 + v782;
              v750[14] = byte_BB934[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v785 = v783 - 1;
              if ( !v785 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v784);
              LOWORD(v784) = v1099 + v784;
              BYTE1(v747) = v750[15];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v784);
              v753 = v1158 + v784;
              v750[15] = byte_BB934[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              LOWORD(v749) = v785 - 1;
              if ( !(_WORD)v749 )
                break;
              v750 += 16;
            }
            v746 = v1267;
          }
LABEL_959:
          v746 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v749 > dword_93AD8 )
          LOWORD(v749) = dword_93AD8;
        v16 = (__int16)v749 <= (__int16)v747;
        LOWORD(v749) = v749 - v747;
        if ( v16 )
          goto LABEL_959;
        v750 += v747;
        v753 = __ROL4__(*((_DWORD *)v746 + 3), 16);
        BYTE1(v748) = v753;
        LOWORD(v753) = v746[4];
        LOBYTE(v748) = *((_BYTE *)v746 + 10);
        goto LABEL_940;
      case 20:
LABEL_961:
        v786 = (unsigned __int16 *)&unk_93AE0;
        v1159 = v1110 << 16;
        v1168 = v1121 << 16;
        HIWORD(v787) = 0;
        HIWORD(v788) = 0;
        while ( 1 )
        {
          LOWORD(v787) = v786[1];
          v789 = v786[3];
          v790 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v787 & 0x8000u) == 0 )
            break;
          if ( (__int16)v789 > 0 )
          {
            if ( v789 > dword_93AD8 )
              v789 = dword_93AD8;
            v1177 = v789;
            v791 = (unsigned __int16)-(__int16)v787;
            v792 = __ROL4__(*((_DWORD *)v786 + 3) + v1110 * v791, 16);
            BYTE1(v788) = v792;
            LOWORD(v792) = v786[4] + v1099 * v791;
            v787 = (unsigned int)(*((_DWORD *)v786 + 2) + v1099 * v791) >> 8;
            LOBYTE(v788) = (unsigned int)(*((_DWORD *)v786 + 2) + v1099 * v791) >> 16;
            v793 = __ROL4__(*((_DWORD *)v786 + 4) + v1121 * v791, 16);
            v787 = (unsigned __int16)v787;
LABEL_971:
            v1268 = v786;
            v794 = dword_93AD0;
            while ( 1 )
            {
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v792);
              LOWORD(v792) = v1099 + v792;
              BYTE1(v787) = v793;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_B7934[v787];
              v171 = __CFADD__(v1159, v792);
              v795 = v1159 + v792;
              LOBYTE(v787) = *v790;
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v793);
              v796 = v1168 + v793;
              *v790 = byte_BB934[v787];
              LOBYTE(v796) = BYTE2(v1121) + v171 + v796;
              v1178 = v1177 - 1;
              if ( !v1178 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v795);
              LOWORD(v795) = v1099 + v795;
              BYTE1(v787) = v796;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_B7934[v787];
              v171 = __CFADD__(v1159, v795);
              v797 = v1159 + v795;
              LOBYTE(v787) = v790[1];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v796);
              v798 = v1168 + v796;
              v790[1] = byte_BB934[v787];
              LOBYTE(v798) = BYTE2(v1121) + v171 + v798;
              v1179 = v1178 - 1;
              if ( !v1179 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v797);
              LOWORD(v797) = v1099 + v797;
              BYTE1(v787) = v798;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_B7934[v787];
              v171 = __CFADD__(v1159, v797);
              v799 = v1159 + v797;
              LOBYTE(v787) = v790[2];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v798);
              v800 = v1168 + v798;
              v790[2] = byte_BB934[v787];
              LOBYTE(v800) = BYTE2(v1121) + v171 + v800;
              v1180 = v1179 - 1;
              if ( !v1180 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v799);
              LOWORD(v799) = v1099 + v799;
              BYTE1(v787) = v800;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_B7934[v787];
              v171 = __CFADD__(v1159, v799);
              v801 = v1159 + v799;
              LOBYTE(v787) = v790[3];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v800);
              v802 = v1168 + v800;
              v790[3] = byte_BB934[v787];
              LOBYTE(v802) = BYTE2(v1121) + v171 + v802;
              v1181 = v1180 - 1;
              if ( !v1181 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v801);
              LOWORD(v801) = v1099 + v801;
              BYTE1(v787) = v802;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_B7934[v787];
              v171 = __CFADD__(v1159, v801);
              v803 = v1159 + v801;
              LOBYTE(v787) = v790[4];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v802);
              v804 = v1168 + v802;
              v790[4] = byte_BB934[v787];
              LOBYTE(v804) = BYTE2(v1121) + v171 + v804;
              v1182 = v1181 - 1;
              if ( !v1182 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v803);
              LOWORD(v803) = v1099 + v803;
              BYTE1(v787) = v804;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_B7934[v787];
              v171 = __CFADD__(v1159, v803);
              v805 = v1159 + v803;
              LOBYTE(v787) = v790[5];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v804);
              v806 = v1168 + v804;
              v790[5] = byte_BB934[v787];
              LOBYTE(v806) = BYTE2(v1121) + v171 + v806;
              v1183 = v1182 - 1;
              if ( !v1183 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v805);
              LOWORD(v805) = v1099 + v805;
              BYTE1(v787) = v806;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_B7934[v787];
              v171 = __CFADD__(v1159, v805);
              v807 = v1159 + v805;
              LOBYTE(v787) = v790[6];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v806);
              v808 = v1168 + v806;
              v790[6] = byte_BB934[v787];
              LOBYTE(v808) = BYTE2(v1121) + v171 + v808;
              v1184 = v1183 - 1;
              if ( !v1184 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v807);
              LOWORD(v807) = v1099 + v807;
              BYTE1(v787) = v808;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_B7934[v787];
              v171 = __CFADD__(v1159, v807);
              v809 = v1159 + v807;
              LOBYTE(v787) = v790[7];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v808);
              v810 = v1168 + v808;
              v790[7] = byte_BB934[v787];
              LOBYTE(v810) = BYTE2(v1121) + v171 + v810;
              v1185 = v1184 - 1;
              if ( !v1185 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v809);
              LOWORD(v809) = v1099 + v809;
              BYTE1(v787) = v810;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_B7934[v787];
              v171 = __CFADD__(v1159, v809);
              v811 = v1159 + v809;
              LOBYTE(v787) = v790[8];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v810);
              v812 = v1168 + v810;
              v790[8] = byte_BB934[v787];
              LOBYTE(v812) = BYTE2(v1121) + v171 + v812;
              v1186 = v1185 - 1;
              if ( !v1186 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v811);
              LOWORD(v811) = v1099 + v811;
              BYTE1(v787) = v812;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_B7934[v787];
              v171 = __CFADD__(v1159, v811);
              v813 = v1159 + v811;
              LOBYTE(v787) = v790[9];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v812);
              v814 = v1168 + v812;
              v790[9] = byte_BB934[v787];
              LOBYTE(v814) = BYTE2(v1121) + v171 + v814;
              v1187 = v1186 - 1;
              if ( !v1187 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v813);
              LOWORD(v813) = v1099 + v813;
              BYTE1(v787) = v814;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_B7934[v787];
              v171 = __CFADD__(v1159, v813);
              v815 = v1159 + v813;
              LOBYTE(v787) = v790[10];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v814);
              v816 = v1168 + v814;
              v790[10] = byte_BB934[v787];
              LOBYTE(v816) = BYTE2(v1121) + v171 + v816;
              v1188 = v1187 - 1;
              if ( !v1188 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v815);
              LOWORD(v815) = v1099 + v815;
              BYTE1(v787) = v816;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_B7934[v787];
              v171 = __CFADD__(v1159, v815);
              v817 = v1159 + v815;
              LOBYTE(v787) = v790[11];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v816);
              v818 = v1168 + v816;
              v790[11] = byte_BB934[v787];
              LOBYTE(v818) = BYTE2(v1121) + v171 + v818;
              v1189 = v1188 - 1;
              if ( !v1189 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v817);
              LOWORD(v817) = v1099 + v817;
              BYTE1(v787) = v818;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_B7934[v787];
              v171 = __CFADD__(v1159, v817);
              v819 = v1159 + v817;
              LOBYTE(v787) = v790[12];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v818);
              v820 = v1168 + v818;
              v790[12] = byte_BB934[v787];
              LOBYTE(v820) = BYTE2(v1121) + v171 + v820;
              v1190 = v1189 - 1;
              if ( !v1190 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v819);
              LOWORD(v819) = v1099 + v819;
              BYTE1(v787) = v820;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_B7934[v787];
              v171 = __CFADD__(v1159, v819);
              v821 = v1159 + v819;
              LOBYTE(v787) = v790[13];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v820);
              v822 = v1168 + v820;
              v790[13] = byte_BB934[v787];
              LOBYTE(v822) = BYTE2(v1121) + v171 + v822;
              v1191 = v1190 - 1;
              if ( !v1191 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v821);
              LOWORD(v821) = v1099 + v821;
              BYTE1(v787) = v822;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_B7934[v787];
              v171 = __CFADD__(v1159, v821);
              v823 = v1159 + v821;
              LOBYTE(v787) = v790[14];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v822);
              v824 = v1168 + v822;
              v790[14] = byte_BB934[v787];
              LOBYTE(v824) = BYTE2(v1121) + v171 + v824;
              v1192 = v1191 - 1;
              if ( !v1192 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v823);
              LOWORD(v823) = v1099 + v823;
              BYTE1(v787) = v824;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_B7934[v787];
              v171 = __CFADD__(v1159, v823);
              v792 = v1159 + v823;
              LOBYTE(v787) = v790[15];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v824);
              v793 = v1168 + v824;
              v790[15] = byte_BB934[v787];
              LOBYTE(v793) = BYTE2(v1121) + v171 + v793;
              v1177 = v1192 - 1;
              if ( !v1177 )
                break;
              v790 += 16;
            }
            v786 = v1268;
          }
LABEL_990:
          v786 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v789 > dword_93AD8 )
          v789 = dword_93AD8;
        v16 = (__int16)v789 <= (__int16)v787;
        LOWORD(v789) = v789 - v787;
        if ( v16 )
          goto LABEL_990;
        v790 += v787;
        v792 = __ROL4__(*((_DWORD *)v786 + 3), 16);
        BYTE1(v788) = v792;
        LOWORD(v792) = v786[4];
        LOBYTE(v788) = *((_BYTE *)v786 + 10);
        v1177 = v789;
        v793 = __ROL4__(*((_DWORD *)v786 + 4), 16);
        goto LABEL_971;
      case 21:
LABEL_992:
        v825 = (unsigned __int16 *)&unk_93AE0;
        v1160 = v1110 << 16;
        v1169 = v1121 << 16;
        HIWORD(v826) = 0;
        HIWORD(v827) = 0;
        while ( 1 )
        {
          LOWORD(v826) = v825[1];
          v828 = v825[3];
          v829 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v826 & 0x8000u) == 0 )
            break;
          if ( (__int16)v828 > 0 )
          {
            if ( v828 > dword_93AD8 )
              v828 = dword_93AD8;
            v1193 = v828;
            v830 = (unsigned __int16)-(__int16)v826;
            v831 = __ROL4__(*((_DWORD *)v825 + 3) + v1110 * v830, 16);
            BYTE1(v827) = v831;
            LOWORD(v831) = v825[4] + v1099 * v830;
            v826 = (unsigned int)(*((_DWORD *)v825 + 2) + v1099 * v830) >> 8;
            LOBYTE(v827) = (unsigned int)(*((_DWORD *)v825 + 2) + v1099 * v830) >> 16;
            v832 = __ROL4__(*((_DWORD *)v825 + 4) + v1121 * v830, 16);
            v826 = (unsigned __int16)v826;
LABEL_1002:
            v1269 = v825;
            v833 = dword_93AD0;
            while ( 1 )
            {
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v831);
              LOWORD(v831) = v1099 + v831;
              BYTE1(v826) = v832;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_B7934[v826];
              v171 = __CFADD__(v1160, v831);
              v834 = v1160 + v831;
              BYTE1(v826) = *v829;
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v832);
              v835 = v1169 + v832;
              *v829 = byte_BB934[v826];
              LOBYTE(v835) = BYTE2(v1121) + v171 + v835;
              v1194 = v1193 - 1;
              if ( !v1194 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v834);
              LOWORD(v834) = v1099 + v834;
              BYTE1(v826) = v835;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_B7934[v826];
              v171 = __CFADD__(v1160, v834);
              v836 = v1160 + v834;
              BYTE1(v826) = v829[1];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v835);
              v837 = v1169 + v835;
              v829[1] = byte_BB934[v826];
              LOBYTE(v837) = BYTE2(v1121) + v171 + v837;
              v1195 = v1194 - 1;
              if ( !v1195 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v836);
              LOWORD(v836) = v1099 + v836;
              BYTE1(v826) = v837;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_B7934[v826];
              v171 = __CFADD__(v1160, v836);
              v838 = v1160 + v836;
              BYTE1(v826) = v829[2];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v837);
              v839 = v1169 + v837;
              v829[2] = byte_BB934[v826];
              LOBYTE(v839) = BYTE2(v1121) + v171 + v839;
              v1196 = v1195 - 1;
              if ( !v1196 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v838);
              LOWORD(v838) = v1099 + v838;
              BYTE1(v826) = v839;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_B7934[v826];
              v171 = __CFADD__(v1160, v838);
              v840 = v1160 + v838;
              BYTE1(v826) = v829[3];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v839);
              v841 = v1169 + v839;
              v829[3] = byte_BB934[v826];
              LOBYTE(v841) = BYTE2(v1121) + v171 + v841;
              v1197 = v1196 - 1;
              if ( !v1197 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v840);
              LOWORD(v840) = v1099 + v840;
              BYTE1(v826) = v841;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_B7934[v826];
              v171 = __CFADD__(v1160, v840);
              v842 = v1160 + v840;
              BYTE1(v826) = v829[4];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v841);
              v843 = v1169 + v841;
              v829[4] = byte_BB934[v826];
              LOBYTE(v843) = BYTE2(v1121) + v171 + v843;
              v1198 = v1197 - 1;
              if ( !v1198 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v842);
              LOWORD(v842) = v1099 + v842;
              BYTE1(v826) = v843;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_B7934[v826];
              v171 = __CFADD__(v1160, v842);
              v844 = v1160 + v842;
              BYTE1(v826) = v829[5];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v843);
              v845 = v1169 + v843;
              v829[5] = byte_BB934[v826];
              LOBYTE(v845) = BYTE2(v1121) + v171 + v845;
              v1199 = v1198 - 1;
              if ( !v1199 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v844);
              LOWORD(v844) = v1099 + v844;
              BYTE1(v826) = v845;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_B7934[v826];
              v171 = __CFADD__(v1160, v844);
              v846 = v1160 + v844;
              BYTE1(v826) = v829[6];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v845);
              v847 = v1169 + v845;
              v829[6] = byte_BB934[v826];
              LOBYTE(v847) = BYTE2(v1121) + v171 + v847;
              v1200 = v1199 - 1;
              if ( !v1200 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v846);
              LOWORD(v846) = v1099 + v846;
              BYTE1(v826) = v847;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_B7934[v826];
              v171 = __CFADD__(v1160, v846);
              v848 = v1160 + v846;
              BYTE1(v826) = v829[7];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v847);
              v849 = v1169 + v847;
              v829[7] = byte_BB934[v826];
              LOBYTE(v849) = BYTE2(v1121) + v171 + v849;
              v1201 = v1200 - 1;
              if ( !v1201 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v848);
              LOWORD(v848) = v1099 + v848;
              BYTE1(v826) = v849;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_B7934[v826];
              v171 = __CFADD__(v1160, v848);
              v850 = v1160 + v848;
              BYTE1(v826) = v829[8];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v849);
              v851 = v1169 + v849;
              v829[8] = byte_BB934[v826];
              LOBYTE(v851) = BYTE2(v1121) + v171 + v851;
              v1202 = v1201 - 1;
              if ( !v1202 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v850);
              LOWORD(v850) = v1099 + v850;
              BYTE1(v826) = v851;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_B7934[v826];
              v171 = __CFADD__(v1160, v850);
              v852 = v1160 + v850;
              BYTE1(v826) = v829[9];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v851);
              v853 = v1169 + v851;
              v829[9] = byte_BB934[v826];
              LOBYTE(v853) = BYTE2(v1121) + v171 + v853;
              v1203 = v1202 - 1;
              if ( !v1203 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v852);
              LOWORD(v852) = v1099 + v852;
              BYTE1(v826) = v853;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_B7934[v826];
              v171 = __CFADD__(v1160, v852);
              v854 = v1160 + v852;
              BYTE1(v826) = v829[10];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v853);
              v855 = v1169 + v853;
              v829[10] = byte_BB934[v826];
              LOBYTE(v855) = BYTE2(v1121) + v171 + v855;
              v1204 = v1203 - 1;
              if ( !v1204 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v854);
              LOWORD(v854) = v1099 + v854;
              BYTE1(v826) = v855;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_B7934[v826];
              v171 = __CFADD__(v1160, v854);
              v856 = v1160 + v854;
              BYTE1(v826) = v829[11];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v855);
              v857 = v1169 + v855;
              v829[11] = byte_BB934[v826];
              LOBYTE(v857) = BYTE2(v1121) + v171 + v857;
              v1205 = v1204 - 1;
              if ( !v1205 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v856);
              LOWORD(v856) = v1099 + v856;
              BYTE1(v826) = v857;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_B7934[v826];
              v171 = __CFADD__(v1160, v856);
              v858 = v1160 + v856;
              BYTE1(v826) = v829[12];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v857);
              v859 = v1169 + v857;
              v829[12] = byte_BB934[v826];
              LOBYTE(v859) = BYTE2(v1121) + v171 + v859;
              v1206 = v1205 - 1;
              if ( !v1206 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v858);
              LOWORD(v858) = v1099 + v858;
              BYTE1(v826) = v859;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_B7934[v826];
              v171 = __CFADD__(v1160, v858);
              v860 = v1160 + v858;
              BYTE1(v826) = v829[13];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v859);
              v861 = v1169 + v859;
              v829[13] = byte_BB934[v826];
              LOBYTE(v861) = BYTE2(v1121) + v171 + v861;
              v1207 = v1206 - 1;
              if ( !v1207 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v860);
              LOWORD(v860) = v1099 + v860;
              BYTE1(v826) = v861;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_B7934[v826];
              v171 = __CFADD__(v1160, v860);
              v862 = v1160 + v860;
              BYTE1(v826) = v829[14];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v861);
              v863 = v1169 + v861;
              v829[14] = byte_BB934[v826];
              LOBYTE(v863) = BYTE2(v1121) + v171 + v863;
              v1208 = v1207 - 1;
              if ( !v1208 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v862);
              LOWORD(v862) = v1099 + v862;
              BYTE1(v826) = v863;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_B7934[v826];
              v171 = __CFADD__(v1160, v862);
              v831 = v1160 + v862;
              BYTE1(v826) = v829[15];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v863);
              v832 = v1169 + v863;
              v829[15] = byte_BB934[v826];
              LOBYTE(v832) = BYTE2(v1121) + v171 + v832;
              v1193 = v1208 - 1;
              if ( !v1193 )
                break;
              v829 += 16;
            }
            v825 = v1269;
          }
LABEL_1021:
          v825 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v828 > dword_93AD8 )
          v828 = dword_93AD8;
        v16 = (__int16)v828 <= (__int16)v826;
        LOWORD(v828) = v828 - v826;
        if ( v16 )
          goto LABEL_1021;
        v829 += v826;
        v831 = __ROL4__(*((_DWORD *)v825 + 3), 16);
        BYTE1(v827) = v831;
        LOWORD(v831) = v825[4];
        LOBYTE(v827) = *((_BYTE *)v825 + 10);
        v1193 = v828;
        v832 = __ROL4__(*((_DWORD *)v825 + 4), 16);
        goto LABEL_1002;
      case 22:
LABEL_1023:
        v864 = (unsigned __int16 *)&unk_93AE0;
        v1161 = v1110 << 16;
        HIWORD(v865) = 0;
        HIWORD(v866) = 0;
        while ( 1 )
        {
          LOWORD(v865) = v864[1];
          v867 = v864[3];
          v868 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v865 & 0x8000u) == 0 )
            break;
          if ( (__int16)v867 > 0 )
          {
            v869 = (unsigned __int16)-(__int16)v865;
            v871 = __ROL4__(*((_DWORD *)v864 + 3) + v1110 * v869, 16);
            BYTE1(v866) = v871;
            v870 = *((_DWORD *)v864 + 2) + v1099 * v869;
            LOWORD(v871) = v870;
            v872 = v870 >> 8;
            LOBYTE(v866) = BYTE1(v872);
            if ( v867 > dword_93AD8 )
              LOWORD(v867) = dword_93AD8;
            v865 = (unsigned __int16)v872;
LABEL_1033:
            v1270 = v864;
            v873 = dword_93AD0;
            while ( 1 )
            {
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = *v868;
                *v868 = byte_BB934[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v871);
              LOWORD(v871) = v1099 + v871;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v871);
              v874 = v1161 + v871;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v875 = v867 - 1;
              if ( !v875 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[1];
                v868[1] = byte_BB934[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v874);
              LOWORD(v874) = v1099 + v874;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v874);
              v876 = v1161 + v874;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v877 = v875 - 1;
              if ( !v877 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[2];
                v868[2] = byte_BB934[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v876);
              LOWORD(v876) = v1099 + v876;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v876);
              v878 = v1161 + v876;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v879 = v877 - 1;
              if ( !v879 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[3];
                v868[3] = byte_BB934[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v878);
              LOWORD(v878) = v1099 + v878;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v878);
              v880 = v1161 + v878;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v881 = v879 - 1;
              if ( !v881 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[4];
                v868[4] = byte_BB934[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v880);
              LOWORD(v880) = v1099 + v880;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v880);
              v882 = v1161 + v880;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v883 = v881 - 1;
              if ( !v883 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[5];
                v868[5] = byte_BB934[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v882);
              LOWORD(v882) = v1099 + v882;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v882);
              v884 = v1161 + v882;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v885 = v883 - 1;
              if ( !v885 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[6];
                v868[6] = byte_BB934[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v884);
              LOWORD(v884) = v1099 + v884;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v884);
              v886 = v1161 + v884;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v887 = v885 - 1;
              if ( !v887 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[7];
                v868[7] = byte_BB934[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v886);
              LOWORD(v886) = v1099 + v886;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v886);
              v888 = v1161 + v886;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v889 = v887 - 1;
              if ( !v889 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[8];
                v868[8] = byte_BB934[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v888);
              LOWORD(v888) = v1099 + v888;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v888);
              v890 = v1161 + v888;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v891 = v889 - 1;
              if ( !v891 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[9];
                v868[9] = byte_BB934[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v890);
              LOWORD(v890) = v1099 + v890;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v890);
              v892 = v1161 + v890;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v893 = v891 - 1;
              if ( !v893 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[10];
                v868[10] = byte_BB934[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v892);
              LOWORD(v892) = v1099 + v892;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v892);
              v894 = v1161 + v892;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v895 = v893 - 1;
              if ( !v895 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[11];
                v868[11] = byte_BB934[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v894);
              LOWORD(v894) = v1099 + v894;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v894);
              v896 = v1161 + v894;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v897 = v895 - 1;
              if ( !v897 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[12];
                v868[12] = byte_BB934[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v896);
              LOWORD(v896) = v1099 + v896;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v896);
              v898 = v1161 + v896;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v899 = v897 - 1;
              if ( !v899 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[13];
                v868[13] = byte_BB934[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v898);
              LOWORD(v898) = v1099 + v898;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v898);
              v900 = v1161 + v898;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v901 = v899 - 1;
              if ( !v901 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[14];
                v868[14] = byte_BB934[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v900);
              LOWORD(v900) = v1099 + v900;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v900);
              v902 = v1161 + v900;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v903 = v901 - 1;
              if ( !v903 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[15];
                v868[15] = byte_BB934[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v902);
              LOWORD(v902) = v1099 + v902;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v902);
              v871 = v1161 + v902;
              BYTE1(v866) += BYTE2(v1110) + v171;
              LOWORD(v867) = v903 - 1;
              if ( !(_WORD)v867 )
                break;
              v868 += 16;
            }
            v864 = v1270;
          }
LABEL_1084:
          v864 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v867 > dword_93AD8 )
          LOWORD(v867) = dword_93AD8;
        v16 = (__int16)v867 <= (__int16)v865;
        LOWORD(v867) = v867 - v865;
        if ( v16 )
          goto LABEL_1084;
        v868 += v865;
        v871 = __ROL4__(*((_DWORD *)v864 + 3), 16);
        BYTE1(v866) = v871;
        LOWORD(v871) = v864[4];
        LOBYTE(v866) = *((_BYTE *)v864 + 10);
        goto LABEL_1033;
      case 23:
LABEL_1086:
        v904 = (unsigned __int16 *)&unk_93AE0;
        v1162 = v1110 << 16;
        HIWORD(v905) = 0;
        HIWORD(v906) = 0;
        while ( 1 )
        {
          LOWORD(v905) = v904[1];
          v907 = v904[3];
          v908 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v905 & 0x8000u) == 0 )
            break;
          if ( (__int16)v907 > 0 )
          {
            v909 = (unsigned __int16)-(__int16)v905;
            v911 = __ROL4__(*((_DWORD *)v904 + 3) + v1110 * v909, 16);
            BYTE1(v906) = v911;
            v910 = *((_DWORD *)v904 + 2) + v1099 * v909;
            LOWORD(v911) = v910;
            v912 = v910 >> 8;
            LOBYTE(v906) = BYTE1(v912);
            if ( v907 > dword_93AD8 )
              LOWORD(v907) = dword_93AD8;
            v905 = (unsigned __int16)v912;
LABEL_1096:
            v1271 = v904;
            v913 = dword_93AD0;
            while ( 1 )
            {
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = *v908;
                *v908 = byte_BB934[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v911);
              LOWORD(v911) = v1099 + v911;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v911);
              v914 = v1162 + v911;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v915 = v907 - 1;
              if ( !v915 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[1];
                v908[1] = byte_BB934[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v914);
              LOWORD(v914) = v1099 + v914;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v914);
              v916 = v1162 + v914;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v917 = v915 - 1;
              if ( !v917 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[2];
                v908[2] = byte_BB934[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v916);
              LOWORD(v916) = v1099 + v916;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v916);
              v918 = v1162 + v916;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v919 = v917 - 1;
              if ( !v919 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[3];
                v908[3] = byte_BB934[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v918);
              LOWORD(v918) = v1099 + v918;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v918);
              v920 = v1162 + v918;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v921 = v919 - 1;
              if ( !v921 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[4];
                v908[4] = byte_BB934[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v920);
              LOWORD(v920) = v1099 + v920;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v920);
              v922 = v1162 + v920;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v923 = v921 - 1;
              if ( !v923 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[5];
                v908[5] = byte_BB934[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v922);
              LOWORD(v922) = v1099 + v922;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v922);
              v924 = v1162 + v922;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v925 = v923 - 1;
              if ( !v925 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[6];
                v908[6] = byte_BB934[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v924);
              LOWORD(v924) = v1099 + v924;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v924);
              v926 = v1162 + v924;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v927 = v925 - 1;
              if ( !v927 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[7];
                v908[7] = byte_BB934[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v926);
              LOWORD(v926) = v1099 + v926;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v926);
              v928 = v1162 + v926;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v929 = v927 - 1;
              if ( !v929 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[8];
                v908[8] = byte_BB934[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v928);
              LOWORD(v928) = v1099 + v928;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v928);
              v930 = v1162 + v928;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v931 = v929 - 1;
              if ( !v931 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[9];
                v908[9] = byte_BB934[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v930);
              LOWORD(v930) = v1099 + v930;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v930);
              v932 = v1162 + v930;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v933 = v931 - 1;
              if ( !v933 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[10];
                v908[10] = byte_BB934[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v932);
              LOWORD(v932) = v1099 + v932;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v932);
              v934 = v1162 + v932;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v935 = v933 - 1;
              if ( !v935 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[11];
                v908[11] = byte_BB934[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v934);
              LOWORD(v934) = v1099 + v934;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v934);
              v936 = v1162 + v934;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v937 = v935 - 1;
              if ( !v937 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[12];
                v908[12] = byte_BB934[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v936);
              LOWORD(v936) = v1099 + v936;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v936);
              v938 = v1162 + v936;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v939 = v937 - 1;
              if ( !v939 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[13];
                v908[13] = byte_BB934[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v938);
              LOWORD(v938) = v1099 + v938;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v938);
              v940 = v1162 + v938;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v941 = v939 - 1;
              if ( !v941 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[14];
                v908[14] = byte_BB934[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v940);
              LOWORD(v940) = v1099 + v940;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v940);
              v942 = v1162 + v940;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v943 = v941 - 1;
              if ( !v943 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[15];
                v908[15] = byte_BB934[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v942);
              LOWORD(v942) = v1099 + v942;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v942);
              v911 = v1162 + v942;
              BYTE1(v906) += BYTE2(v1110) + v171;
              LOWORD(v907) = v943 - 1;
              if ( !(_WORD)v907 )
                break;
              v908 += 16;
            }
            v904 = v1271;
          }
LABEL_1147:
          v904 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v907 > dword_93AD8 )
          LOWORD(v907) = dword_93AD8;
        v16 = (__int16)v907 <= (__int16)v905;
        LOWORD(v907) = v907 - v905;
        if ( v16 )
          goto LABEL_1147;
        v908 += v905;
        v911 = __ROL4__(*((_DWORD *)v904 + 3), 16);
        BYTE1(v906) = v911;
        LOWORD(v911) = v904[4];
        LOBYTE(v906) = *((_BYTE *)v904 + 10);
        goto LABEL_1096;
      case 24:
LABEL_1149:
        v944 = (unsigned __int16 *)&unk_93AE0;
        v1163 = v1110 << 16;
        v1170 = v1121 << 16;
        HIWORD(v945) = 0;
        HIWORD(v946) = 0;
        while ( 1 )
        {
          LOWORD(v945) = v944[1];
          v947 = v944[3];
          v948 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v945 & 0x8000u) == 0 )
            break;
          if ( (__int16)v947 > 0 )
          {
            if ( v947 > dword_93AD8 )
              v947 = dword_93AD8;
            v1209 = v947;
            v949 = (unsigned __int16)-(__int16)v945;
            v950 = __ROL4__(*((_DWORD *)v944 + 3) + v1110 * v949, 16);
            BYTE1(v946) = v950;
            LOWORD(v950) = v944[4] + v1099 * v949;
            v945 = (unsigned int)(*((_DWORD *)v944 + 2) + v1099 * v949) >> 8;
            LOBYTE(v946) = (unsigned int)(*((_DWORD *)v944 + 2) + v1099 * v949) >> 16;
            v951 = __ROL4__(*((_DWORD *)v944 + 4) + v1121 * v949, 16);
            v945 = (unsigned __int16)v945;
LABEL_1159:
            v1272 = v944;
            v952 = dword_93AD0;
            while ( 1 )
            {
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v951;
                BYTE1(v945) = byte_B7934[v945];
                LOBYTE(v945) = *v948;
                *v948 = byte_BB934[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v950);
              LOWORD(v950) = v1099 + v950;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v950);
              v953 = v1163 + v950;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v951);
              v954 = v1170 + v951;
              LOBYTE(v954) = BYTE2(v1121) + v171 + v954;
              v1210 = v1209 - 1;
              if ( !v1210 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v954;
                BYTE1(v945) = byte_B7934[v945];
                LOBYTE(v945) = v948[1];
                v948[1] = byte_BB934[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v953);
              LOWORD(v953) = v1099 + v953;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v953);
              v955 = v1163 + v953;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v954);
              v956 = v1170 + v954;
              LOBYTE(v956) = BYTE2(v1121) + v171 + v956;
              v1211 = v1210 - 1;
              if ( !v1211 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v956;
                BYTE1(v945) = byte_B7934[v945];
                LOBYTE(v945) = v948[2];
                v948[2] = byte_BB934[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v955);
              LOWORD(v955) = v1099 + v955;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v955);
              v957 = v1163 + v955;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v956);
              v958 = v1170 + v956;
              LOBYTE(v958) = BYTE2(v1121) + v171 + v958;
              v1212 = v1211 - 1;
              if ( !v1212 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v958;
                BYTE1(v945) = byte_B7934[v945];
                LOBYTE(v945) = v948[3];
                v948[3] = byte_BB934[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v957);
              LOWORD(v957) = v1099 + v957;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v957);
              v959 = v1163 + v957;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v958);
              v960 = v1170 + v958;
              LOBYTE(v960) = BYTE2(v1121) + v171 + v960;
              v1213 = v1212 - 1;
              if ( !v1213 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v960;
                BYTE1(v945) = byte_B7934[v945];
                LOBYTE(v945) = v948[4];
                v948[4] = byte_BB934[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v959);
              LOWORD(v959) = v1099 + v959;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v959);
              v961 = v1163 + v959;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v960);
              v962 = v1170 + v960;
              LOBYTE(v962) = BYTE2(v1121) + v171 + v962;
              v1214 = v1213 - 1;
              if ( !v1214 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v962;
                BYTE1(v945) = byte_B7934[v945];
                LOBYTE(v945) = v948[5];
                v948[5] = byte_BB934[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v961);
              LOWORD(v961) = v1099 + v961;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v961);
              v963 = v1163 + v961;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v962);
              v964 = v1170 + v962;
              LOBYTE(v964) = BYTE2(v1121) + v171 + v964;
              v1215 = v1214 - 1;
              if ( !v1215 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v964;
                BYTE1(v945) = byte_B7934[v945];
                LOBYTE(v945) = v948[6];
                v948[6] = byte_BB934[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v963);
              LOWORD(v963) = v1099 + v963;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v963);
              v965 = v1163 + v963;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v964);
              v966 = v1170 + v964;
              LOBYTE(v966) = BYTE2(v1121) + v171 + v966;
              v1216 = v1215 - 1;
              if ( !v1216 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v966;
                BYTE1(v945) = byte_B7934[v945];
                LOBYTE(v945) = v948[7];
                v948[7] = byte_BB934[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v965);
              LOWORD(v965) = v1099 + v965;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v965);
              v967 = v1163 + v965;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v966);
              v968 = v1170 + v966;
              LOBYTE(v968) = BYTE2(v1121) + v171 + v968;
              v1217 = v1216 - 1;
              if ( !v1217 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v968;
                BYTE1(v945) = byte_B7934[v945];
                LOBYTE(v945) = v948[8];
                v948[8] = byte_BB934[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v967);
              LOWORD(v967) = v1099 + v967;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v967);
              v969 = v1163 + v967;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v968);
              v970 = v1170 + v968;
              LOBYTE(v970) = BYTE2(v1121) + v171 + v970;
              v1218 = v1217 - 1;
              if ( !v1218 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v970;
                BYTE1(v945) = byte_B7934[v945];
                LOBYTE(v945) = v948[9];
                v948[9] = byte_BB934[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v969);
              LOWORD(v969) = v1099 + v969;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v969);
              v971 = v1163 + v969;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v970);
              v972 = v1170 + v970;
              LOBYTE(v972) = BYTE2(v1121) + v171 + v972;
              v1219 = v1218 - 1;
              if ( !v1219 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v972;
                BYTE1(v945) = byte_B7934[v945];
                LOBYTE(v945) = v948[10];
                v948[10] = byte_BB934[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v971);
              LOWORD(v971) = v1099 + v971;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v971);
              v973 = v1163 + v971;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v972);
              v974 = v1170 + v972;
              LOBYTE(v974) = BYTE2(v1121) + v171 + v974;
              v1220 = v1219 - 1;
              if ( !v1220 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v974;
                BYTE1(v945) = byte_B7934[v945];
                LOBYTE(v945) = v948[11];
                v948[11] = byte_BB934[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v973);
              LOWORD(v973) = v1099 + v973;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v973);
              v975 = v1163 + v973;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v974);
              v976 = v1170 + v974;
              LOBYTE(v976) = BYTE2(v1121) + v171 + v976;
              v1221 = v1220 - 1;
              if ( !v1221 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v976;
                BYTE1(v945) = byte_B7934[v945];
                LOBYTE(v945) = v948[12];
                v948[12] = byte_BB934[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v975);
              LOWORD(v975) = v1099 + v975;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v975);
              v977 = v1163 + v975;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v976);
              v978 = v1170 + v976;
              LOBYTE(v978) = BYTE2(v1121) + v171 + v978;
              v1222 = v1221 - 1;
              if ( !v1222 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v978;
                BYTE1(v945) = byte_B7934[v945];
                LOBYTE(v945) = v948[13];
                v948[13] = byte_BB934[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v977);
              LOWORD(v977) = v1099 + v977;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v977);
              v979 = v1163 + v977;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v978);
              v980 = v1170 + v978;
              LOBYTE(v980) = BYTE2(v1121) + v171 + v980;
              v1223 = v1222 - 1;
              if ( !v1223 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v980;
                BYTE1(v945) = byte_B7934[v945];
                LOBYTE(v945) = v948[14];
                v948[14] = byte_BB934[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v979);
              LOWORD(v979) = v1099 + v979;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v979);
              v981 = v1163 + v979;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v980);
              v982 = v1170 + v980;
              LOBYTE(v982) = BYTE2(v1121) + v171 + v982;
              v1224 = v1223 - 1;
              if ( !v1224 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v982;
                BYTE1(v945) = byte_B7934[v945];
                LOBYTE(v945) = v948[15];
                v948[15] = byte_BB934[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v981);
              LOWORD(v981) = v1099 + v981;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v981);
              v950 = v1163 + v981;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v982);
              v951 = v1170 + v982;
              LOBYTE(v951) = BYTE2(v1121) + v171 + v951;
              v1209 = v1224 - 1;
              if ( !v1209 )
                break;
              v948 += 16;
            }
            v944 = v1272;
          }
LABEL_1210:
          v944 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v947 > dword_93AD8 )
          v947 = dword_93AD8;
        v16 = (__int16)v947 <= (__int16)v945;
        LOWORD(v947) = v947 - v945;
        if ( v16 )
          goto LABEL_1210;
        v948 += v945;
        v950 = __ROL4__(*((_DWORD *)v944 + 3), 16);
        BYTE1(v946) = v950;
        LOWORD(v950) = v944[4];
        LOBYTE(v946) = *((_BYTE *)v944 + 10);
        v1209 = v947;
        v951 = __ROL4__(*((_DWORD *)v944 + 4), 16);
        goto LABEL_1159;
      case 25:
LABEL_1212:
        v983 = (unsigned __int16 *)&unk_93AE0;
        v1164 = v1110 << 16;
        v1171 = v1121 << 16;
        HIWORD(v984) = 0;
        HIWORD(v985) = 0;
        while ( 1 )
        {
          LOWORD(v984) = v983[1];
          v986 = v983[3];
          v987 = (_BYTE *)(dword_93AD4 + v1077);
          v1077 += dword_93AD4;
          if ( (v984 & 0x8000u) == 0 )
            break;
          if ( (__int16)v986 > 0 )
          {
            if ( v986 > dword_93AD8 )
              v986 = dword_93AD8;
            v1225 = v986;
            v988 = (unsigned __int16)-(__int16)v984;
            v989 = __ROL4__(*((_DWORD *)v983 + 3) + v1110 * v988, 16);
            BYTE1(v985) = v989;
            LOWORD(v989) = v983[4] + v1099 * v988;
            v984 = (unsigned int)(*((_DWORD *)v983 + 2) + v1099 * v988) >> 8;
            LOBYTE(v985) = (unsigned int)(*((_DWORD *)v983 + 2) + v1099 * v988) >> 16;
            v990 = __ROL4__(*((_DWORD *)v983 + 4) + v1121 * v988, 16);
            v984 = (unsigned __int16)v984;
LABEL_1222:
            v1273 = v983;
            v991 = dword_93AD0;
            while ( 1 )
            {
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v990;
                LOBYTE(v984) = byte_B7934[v984];
                BYTE1(v984) = *v987;
                *v987 = byte_BB934[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v989);
              LOWORD(v989) = v1099 + v989;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v989);
              v992 = v1164 + v989;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v990);
              v993 = v1171 + v990;
              LOBYTE(v993) = BYTE2(v1121) + v171 + v993;
              v1226 = v1225 - 1;
              if ( !v1226 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v993;
                LOBYTE(v984) = byte_B7934[v984];
                BYTE1(v984) = v987[1];
                v987[1] = byte_BB934[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v992);
              LOWORD(v992) = v1099 + v992;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v992);
              v994 = v1164 + v992;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v993);
              v995 = v1171 + v993;
              LOBYTE(v995) = BYTE2(v1121) + v171 + v995;
              v1227 = v1226 - 1;
              if ( !v1227 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v995;
                LOBYTE(v984) = byte_B7934[v984];
                BYTE1(v984) = v987[2];
                v987[2] = byte_BB934[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v994);
              LOWORD(v994) = v1099 + v994;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v994);
              v996 = v1164 + v994;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v995);
              v997 = v1171 + v995;
              LOBYTE(v997) = BYTE2(v1121) + v171 + v997;
              v1228 = v1227 - 1;
              if ( !v1228 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v997;
                LOBYTE(v984) = byte_B7934[v984];
                BYTE1(v984) = v987[3];
                v987[3] = byte_BB934[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v996);
              LOWORD(v996) = v1099 + v996;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v996);
              v998 = v1164 + v996;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v997);
              v999 = v1171 + v997;
              LOBYTE(v999) = BYTE2(v1121) + v171 + v999;
              v1229 = v1228 - 1;
              if ( !v1229 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v999;
                LOBYTE(v984) = byte_B7934[v984];
                BYTE1(v984) = v987[4];
                v987[4] = byte_BB934[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v998);
              LOWORD(v998) = v1099 + v998;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v998);
              v1000 = v1164 + v998;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v999);
              v1001 = v1171 + v999;
              LOBYTE(v1001) = BYTE2(v1121) + v171 + v1001;
              v1230 = v1229 - 1;
              if ( !v1230 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1001;
                LOBYTE(v984) = byte_B7934[v984];
                BYTE1(v984) = v987[5];
                v987[5] = byte_BB934[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1000);
              LOWORD(v1000) = v1099 + v1000;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1000);
              v1002 = v1164 + v1000;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1001);
              v1003 = v1171 + v1001;
              LOBYTE(v1003) = BYTE2(v1121) + v171 + v1003;
              v1231 = v1230 - 1;
              if ( !v1231 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1003;
                LOBYTE(v984) = byte_B7934[v984];
                BYTE1(v984) = v987[6];
                v987[6] = byte_BB934[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1002);
              LOWORD(v1002) = v1099 + v1002;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1002);
              v1004 = v1164 + v1002;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1003);
              v1005 = v1171 + v1003;
              LOBYTE(v1005) = BYTE2(v1121) + v171 + v1005;
              v1232 = v1231 - 1;
              if ( !v1232 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1005;
                LOBYTE(v984) = byte_B7934[v984];
                BYTE1(v984) = v987[7];
                v987[7] = byte_BB934[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1004);
              LOWORD(v1004) = v1099 + v1004;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1004);
              v1006 = v1164 + v1004;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1005);
              v1007 = v1171 + v1005;
              LOBYTE(v1007) = BYTE2(v1121) + v171 + v1007;
              v1233 = v1232 - 1;
              if ( !v1233 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1007;
                LOBYTE(v984) = byte_B7934[v984];
                BYTE1(v984) = v987[8];
                v987[8] = byte_BB934[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1006);
              LOWORD(v1006) = v1099 + v1006;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1006);
              v1008 = v1164 + v1006;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1007);
              v1009 = v1171 + v1007;
              LOBYTE(v1009) = BYTE2(v1121) + v171 + v1009;
              v1234 = v1233 - 1;
              if ( !v1234 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1009;
                LOBYTE(v984) = byte_B7934[v984];
                BYTE1(v984) = v987[9];
                v987[9] = byte_BB934[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1008);
              LOWORD(v1008) = v1099 + v1008;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1008);
              v1010 = v1164 + v1008;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1009);
              v1011 = v1171 + v1009;
              LOBYTE(v1011) = BYTE2(v1121) + v171 + v1011;
              v1235 = v1234 - 1;
              if ( !v1235 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1011;
                LOBYTE(v984) = byte_B7934[v984];
                BYTE1(v984) = v987[10];
                v987[10] = byte_BB934[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1010);
              LOWORD(v1010) = v1099 + v1010;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1010);
              v1012 = v1164 + v1010;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1011);
              v1013 = v1171 + v1011;
              LOBYTE(v1013) = BYTE2(v1121) + v171 + v1013;
              v1236 = v1235 - 1;
              if ( !v1236 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1013;
                LOBYTE(v984) = byte_B7934[v984];
                BYTE1(v984) = v987[11];
                v987[11] = byte_BB934[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1012);
              LOWORD(v1012) = v1099 + v1012;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1012);
              v1014 = v1164 + v1012;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1013);
              v1015 = v1171 + v1013;
              LOBYTE(v1015) = BYTE2(v1121) + v171 + v1015;
              v1237 = v1236 - 1;
              if ( !v1237 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1015;
                LOBYTE(v984) = byte_B7934[v984];
                BYTE1(v984) = v987[12];
                v987[12] = byte_BB934[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1014);
              LOWORD(v1014) = v1099 + v1014;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1014);
              v1016 = v1164 + v1014;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1015);
              v1017 = v1171 + v1015;
              LOBYTE(v1017) = BYTE2(v1121) + v171 + v1017;
              v1238 = v1237 - 1;
              if ( !v1238 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1017;
                LOBYTE(v984) = byte_B7934[v984];
                BYTE1(v984) = v987[13];
                v987[13] = byte_BB934[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1016);
              LOWORD(v1016) = v1099 + v1016;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1016);
              v1018 = v1164 + v1016;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1017);
              v1019 = v1171 + v1017;
              LOBYTE(v1019) = BYTE2(v1121) + v171 + v1019;
              v1239 = v1238 - 1;
              if ( !v1239 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1019;
                LOBYTE(v984) = byte_B7934[v984];
                BYTE1(v984) = v987[14];
                v987[14] = byte_BB934[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1018);
              LOWORD(v1018) = v1099 + v1018;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1018);
              v1020 = v1164 + v1018;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1019);
              v1021 = v1171 + v1019;
              LOBYTE(v1021) = BYTE2(v1121) + v171 + v1021;
              v1240 = v1239 - 1;
              if ( !v1240 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1021;
                LOBYTE(v984) = byte_B7934[v984];
                BYTE1(v984) = v987[15];
                v987[15] = byte_BB934[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1020);
              LOWORD(v1020) = v1099 + v1020;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1020);
              v989 = v1164 + v1020;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1021);
              v990 = v1171 + v1021;
              LOBYTE(v990) = BYTE2(v1121) + v171 + v990;
              v1225 = v1240 - 1;
              if ( !v1225 )
                break;
              v987 += 16;
            }
            v983 = v1273;
          }
LABEL_1273:
          v983 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v986 > dword_93AD8 )
          v986 = dword_93AD8;
        v16 = (__int16)v986 <= (__int16)v984;
        LOWORD(v986) = v986 - v984;
        if ( v16 )
          goto LABEL_1273;
        v987 += v984;
        v989 = __ROL4__(*((_DWORD *)v983 + 3), 16);
        BYTE1(v985) = v989;
        LOWORD(v989) = v983[4];
        LOBYTE(v985) = *((_BYTE *)v983 + 10);
        v1225 = v986;
        v990 = __ROL4__(*((_DWORD *)v983 + 4), 16);
        goto LABEL_1222;
      case 26:
LABEL_1275:
        v1022 = (unsigned __int16 *)&unk_93AE0;
        v1165 = v1110 << 16;
        v1172 = v1121 << 16;
        HIWORD(v1023) = 0;
        HIWORD(v1024) = 0;
        break;
    }
    while ( 1 )
    {
      LOWORD(v1023) = v1022[1];
      v1025 = v1022[3];
      v1026 = (char *)(dword_93AD4 + v1077);
      v1077 += dword_93AD4;
      if ( (v1023 & 0x8000u) == 0 )
        break;
      if ( (__int16)v1025 > 0 )
      {
        if ( v1025 > dword_93AD8 )
          v1025 = dword_93AD8;
        v1241 = v1025;
        v1027 = (unsigned __int16)-(__int16)v1023;
        v1028 = __ROL4__(*((_DWORD *)v1022 + 3) + v1110 * v1027, 16);
        BYTE1(v1024) = v1028;
        LOWORD(v1028) = v1022[4] + v1099 * v1027;
        v1023 = (unsigned int)(*((_DWORD *)v1022 + 2) + v1099 * v1027) >> 8;
        LOBYTE(v1024) = (unsigned int)(*((_DWORD *)v1022 + 2) + v1099 * v1027) >> 16;
        v1029 = __ROL4__(*((_DWORD *)v1022 + 4) + v1121 * v1027, 16);
        v1023 = (unsigned __int16)v1023;
LABEL_1285:
        v1274 = v1022;
        v1030 = dword_93AD0;
        while ( 1 )
        {
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1028);
          LOWORD(v1028) = v1099 + v1028;
          BYTE1(v1023) = v1029;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1031 = byte_B7934[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_B7934[v1023];
            BYTE1(v1023) = *v1026;
            v1031 = byte_BB934[v1023];
          }
          v171 = __CFADD__(v1165, v1028);
          v1032 = v1165 + v1028;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1029);
          v1033 = v1172 + v1029;
          *v1026 = v1031;
          LOBYTE(v1033) = BYTE2(v1121) + v171 + v1033;
          v1242 = v1241 - 1;
          if ( !v1242 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1032);
          LOWORD(v1032) = v1099 + v1032;
          BYTE1(v1023) = v1033;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1034 = byte_B7934[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_B7934[v1023];
            BYTE1(v1023) = v1026[1];
            v1034 = byte_BB934[v1023];
          }
          v171 = __CFADD__(v1165, v1032);
          v1035 = v1165 + v1032;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1033);
          v1036 = v1172 + v1033;
          v1026[1] = v1034;
          LOBYTE(v1036) = BYTE2(v1121) + v171 + v1036;
          v1243 = v1242 - 1;
          if ( !v1243 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1035);
          LOWORD(v1035) = v1099 + v1035;
          BYTE1(v1023) = v1036;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1037 = byte_B7934[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_B7934[v1023];
            BYTE1(v1023) = v1026[2];
            v1037 = byte_BB934[v1023];
          }
          v171 = __CFADD__(v1165, v1035);
          v1038 = v1165 + v1035;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1036);
          v1039 = v1172 + v1036;
          v1026[2] = v1037;
          LOBYTE(v1039) = BYTE2(v1121) + v171 + v1039;
          v1244 = v1243 - 1;
          if ( !v1244 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1038);
          LOWORD(v1038) = v1099 + v1038;
          BYTE1(v1023) = v1039;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1040 = byte_B7934[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_B7934[v1023];
            BYTE1(v1023) = v1026[3];
            v1040 = byte_BB934[v1023];
          }
          v171 = __CFADD__(v1165, v1038);
          v1041 = v1165 + v1038;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1039);
          v1042 = v1172 + v1039;
          v1026[3] = v1040;
          LOBYTE(v1042) = BYTE2(v1121) + v171 + v1042;
          v1245 = v1244 - 1;
          if ( !v1245 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1041);
          LOWORD(v1041) = v1099 + v1041;
          BYTE1(v1023) = v1042;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1043 = byte_B7934[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_B7934[v1023];
            BYTE1(v1023) = v1026[4];
            v1043 = byte_BB934[v1023];
          }
          v171 = __CFADD__(v1165, v1041);
          v1044 = v1165 + v1041;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1042);
          v1045 = v1172 + v1042;
          v1026[4] = v1043;
          LOBYTE(v1045) = BYTE2(v1121) + v171 + v1045;
          v1246 = v1245 - 1;
          if ( !v1246 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1044);
          LOWORD(v1044) = v1099 + v1044;
          BYTE1(v1023) = v1045;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1046 = byte_B7934[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_B7934[v1023];
            BYTE1(v1023) = v1026[5];
            v1046 = byte_BB934[v1023];
          }
          v171 = __CFADD__(v1165, v1044);
          v1047 = v1165 + v1044;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1045);
          v1048 = v1172 + v1045;
          v1026[5] = v1046;
          LOBYTE(v1048) = BYTE2(v1121) + v171 + v1048;
          v1247 = v1246 - 1;
          if ( !v1247 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1047);
          LOWORD(v1047) = v1099 + v1047;
          BYTE1(v1023) = v1048;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1049 = byte_B7934[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_B7934[v1023];
            BYTE1(v1023) = v1026[6];
            v1049 = byte_BB934[v1023];
          }
          v171 = __CFADD__(v1165, v1047);
          v1050 = v1165 + v1047;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1048);
          v1051 = v1172 + v1048;
          v1026[6] = v1049;
          LOBYTE(v1051) = BYTE2(v1121) + v171 + v1051;
          v1248 = v1247 - 1;
          if ( !v1248 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1050);
          LOWORD(v1050) = v1099 + v1050;
          BYTE1(v1023) = v1051;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1052 = byte_B7934[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_B7934[v1023];
            BYTE1(v1023) = v1026[7];
            v1052 = byte_BB934[v1023];
          }
          v171 = __CFADD__(v1165, v1050);
          v1053 = v1165 + v1050;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1051);
          v1054 = v1172 + v1051;
          v1026[7] = v1052;
          LOBYTE(v1054) = BYTE2(v1121) + v171 + v1054;
          v1249 = v1248 - 1;
          if ( !v1249 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1053);
          LOWORD(v1053) = v1099 + v1053;
          BYTE1(v1023) = v1054;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1055 = byte_B7934[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_B7934[v1023];
            BYTE1(v1023) = v1026[8];
            v1055 = byte_BB934[v1023];
          }
          v171 = __CFADD__(v1165, v1053);
          v1056 = v1165 + v1053;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1054);
          v1057 = v1172 + v1054;
          v1026[8] = v1055;
          LOBYTE(v1057) = BYTE2(v1121) + v171 + v1057;
          v1250 = v1249 - 1;
          if ( !v1250 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1056);
          LOWORD(v1056) = v1099 + v1056;
          BYTE1(v1023) = v1057;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1058 = byte_B7934[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_B7934[v1023];
            BYTE1(v1023) = v1026[9];
            v1058 = byte_BB934[v1023];
          }
          v171 = __CFADD__(v1165, v1056);
          v1059 = v1165 + v1056;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1057);
          v1060 = v1172 + v1057;
          v1026[9] = v1058;
          LOBYTE(v1060) = BYTE2(v1121) + v171 + v1060;
          v1251 = v1250 - 1;
          if ( !v1251 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1059);
          LOWORD(v1059) = v1099 + v1059;
          BYTE1(v1023) = v1060;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1061 = byte_B7934[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_B7934[v1023];
            BYTE1(v1023) = v1026[10];
            v1061 = byte_BB934[v1023];
          }
          v171 = __CFADD__(v1165, v1059);
          v1062 = v1165 + v1059;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1060);
          v1063 = v1172 + v1060;
          v1026[10] = v1061;
          LOBYTE(v1063) = BYTE2(v1121) + v171 + v1063;
          v1252 = v1251 - 1;
          if ( !v1252 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1062);
          LOWORD(v1062) = v1099 + v1062;
          BYTE1(v1023) = v1063;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1064 = byte_B7934[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_B7934[v1023];
            BYTE1(v1023) = v1026[11];
            v1064 = byte_BB934[v1023];
          }
          v171 = __CFADD__(v1165, v1062);
          v1065 = v1165 + v1062;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1063);
          v1066 = v1172 + v1063;
          v1026[11] = v1064;
          LOBYTE(v1066) = BYTE2(v1121) + v171 + v1066;
          v1253 = v1252 - 1;
          if ( !v1253 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1065);
          LOWORD(v1065) = v1099 + v1065;
          BYTE1(v1023) = v1066;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1067 = byte_B7934[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_B7934[v1023];
            BYTE1(v1023) = v1026[12];
            v1067 = byte_BB934[v1023];
          }
          v171 = __CFADD__(v1165, v1065);
          v1068 = v1165 + v1065;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1066);
          v1069 = v1172 + v1066;
          v1026[12] = v1067;
          LOBYTE(v1069) = BYTE2(v1121) + v171 + v1069;
          v1254 = v1253 - 1;
          if ( !v1254 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1068);
          LOWORD(v1068) = v1099 + v1068;
          BYTE1(v1023) = v1069;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1070 = byte_B7934[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_B7934[v1023];
            BYTE1(v1023) = v1026[13];
            v1070 = byte_BB934[v1023];
          }
          v171 = __CFADD__(v1165, v1068);
          v1071 = v1165 + v1068;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1069);
          v1072 = v1172 + v1069;
          v1026[13] = v1070;
          LOBYTE(v1072) = BYTE2(v1121) + v171 + v1072;
          v1255 = v1254 - 1;
          if ( !v1255 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1071);
          LOWORD(v1071) = v1099 + v1071;
          BYTE1(v1023) = v1072;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1073 = byte_B7934[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_B7934[v1023];
            BYTE1(v1023) = v1026[14];
            v1073 = byte_BB934[v1023];
          }
          v171 = __CFADD__(v1165, v1071);
          v1074 = v1165 + v1071;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1072);
          v1075 = v1172 + v1072;
          v1026[14] = v1073;
          LOBYTE(v1075) = BYTE2(v1121) + v171 + v1075;
          v1256 = v1255 - 1;
          if ( !v1256 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1074);
          LOWORD(v1074) = v1099 + v1074;
          BYTE1(v1023) = v1075;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1076 = byte_B7934[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_B7934[v1023];
            BYTE1(v1023) = v1026[15];
            v1076 = byte_BB934[v1023];
          }
          v171 = __CFADD__(v1165, v1074);
          v1028 = v1165 + v1074;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1075);
          v1029 = v1172 + v1075;
          v1026[15] = v1076;
          LOBYTE(v1029) = BYTE2(v1121) + v171 + v1029;
          v1241 = v1256 - 1;
          if ( !v1241 )
            break;
          v1026 += 16;
        }
        v1022 = v1274;
      }
LABEL_1352:
      v1022 += 10;
      if ( !--v1098 )
        return;
    }
    if ( v1025 > dword_93AD8 )
      v1025 = dword_93AD8;
    v16 = (__int16)v1025 <= (__int16)v1023;
    LOWORD(v1025) = v1025 - v1023;
    if ( v16 )
      goto LABEL_1352;
    v1026 += v1023;
    v1028 = __ROL4__(*((_DWORD *)v1022 + 3), 16);
    BYTE1(v1024) = v1028;
    LOWORD(v1028) = v1022[4];
    LOBYTE(v1024) = *((_BYTE *)v1022 + 10);
    v1241 = v1025;
    v1029 = __ROL4__(*((_DWORD *)v1022 + 4), 16);
    goto LABEL_1285;
  }
  if ( v6 == v8 )
  {
    if ( *a3 <= *a1 )
      return;
    v3 = a2;
    v4 = a3;
    v5 = a1;
    goto LABEL_225;
  }
  if ( v6 < v8 )
  {
    v3 = a2;
    v4 = a3;
    v5 = a1;
    goto LABEL_124;
  }
  if ( v7 == v8 )
  {
    if ( *a3 <= *a2 )
      return;
    v3 = a2;
    v4 = a3;
    v5 = a1;
    goto LABEL_268;
  }
  if ( v7 < v8 )
  {
    v3 = a2;
    v4 = a3;
    v5 = a1;
    goto LABEL_24;
  }
  v3 = a3;
  v4 = a1;
  v5 = a2;
LABEL_124:
  v60 = v3[1];
  v1174 = v60;
  if ( v60 >= 0 )
  {
    if ( v60 >= dword_93ADC )
      return;
    v1077 = dword_93AC8 + dword_93AD4 * v60;
    v1276 = 0;
  }
  else
  {
    v1077 = dword_93AC8;
    v1276 = 1;
  }
  v61 = v5[1];
  v1280 = v61 > dword_93ADC;
  v1089 = v61 - v60;
  v62 = v4[1];
  v1284 = v62 > dword_93ADC;
  v63 = v62 - v60;
  v1093 = v63;
  v1098 = v63;
  v1079 = ((*v5 - *v3) << 16) / v1089;
  if ( ((*v4 - *v3) << 16) / v63 > v1079 )
  {
    v1083 = ((*v4 - *v3) << 16) / v63;
    v1087 = ((*v4 - *v5) << 16) / (v4[1] - v5[1]);
    v1095 = v4[1] - v5[1];
    v1097 = *v5 << 16;
    switch ( byte_967E1 )
    {
      case 0:
      case 14:
      case 15:
        v102 = *v3 << 16;
        v103 = v102;
        if ( v1276 )
        {
          v16 = v1098 <= -v1174;
          v1098 += v1174;
          if ( v16 )
            return;
          v1146 = -v1174;
          if ( -v1174 - v1089 >= 0 )
          {
            v1147 = v1146 - v1089;
            v1095 -= v1147;
            v104 = v1087 * v1147 + v1097;
            v103 += v1147 * v1083 + v1089 * v1083;
            if ( v1284 )
            {
              v1095 = dword_93ADC;
              v1098 = dword_93ADC;
            }
            v105 = (uint32*)&unk_93AE0;
LABEL_219:
            if ( v1280 )
            {
              v29 = (unsigned __int8)byte_967E1;
              switch ( byte_967E1 )
              {
                case 0:
                  goto LABEL_309;
                case 1:
                  goto LABEL_322;
                case 2:
                  goto LABEL_351;
                case 3:
                  goto LABEL_382;
                case 4:
                  goto LABEL_445;
                case 5:
                  goto LABEL_474;
                case 6:
                  goto LABEL_503;
                case 7:
                case 11:
                  goto LABEL_564;
                case 8:
                  goto LABEL_595;
                case 9:
                case 10:
                  goto LABEL_658;
                case 12:
                  goto LABEL_721;
                case 13:
                  goto LABEL_752;
                case 14:
                  goto LABEL_783;
                case 15:
                  goto LABEL_812;
                case 16:
                  goto LABEL_841;
                case 17:
                  goto LABEL_870;
                case 18:
                  goto LABEL_899;
                case 19:
                  goto LABEL_930;
                case 20:
                  goto LABEL_961;
                case 21:
                  goto LABEL_992;
                case 22:
                  goto LABEL_1023;
                case 23:
                  goto LABEL_1086;
                case 24:
                  goto LABEL_1149;
                case 25:
                  goto LABEL_1212;
                case 26:
                  goto LABEL_1275;
              }
            }
            do
            {
              *v105 = v104;
              v104 += v1087;
              v105[1] = v103;
              v103 += v1083;
              v105 += 5;
              --v1095;
            }
            while ( v1095 );
            v29 = (unsigned __int8)byte_967E1;
            switch ( byte_967E1 )
            {
              case 0:
                goto LABEL_309;
              case 1:
                goto LABEL_322;
              case 2:
                goto LABEL_351;
              case 3:
                goto LABEL_382;
              case 4:
                goto LABEL_445;
              case 5:
                goto LABEL_474;
              case 6:
                goto LABEL_503;
              case 7:
              case 11:
                goto LABEL_564;
              case 8:
                goto LABEL_595;
              case 9:
              case 10:
                goto LABEL_658;
              case 12:
                goto LABEL_721;
              case 13:
                goto LABEL_752;
              case 14:
                goto LABEL_783;
              case 15:
                goto LABEL_812;
              case 16:
                goto LABEL_841;
              case 17:
                goto LABEL_870;
              case 18:
                goto LABEL_899;
              case 19:
                goto LABEL_930;
              case 20:
                goto LABEL_961;
              case 21:
                goto LABEL_992;
              case 22:
                goto LABEL_1023;
              case 23:
                goto LABEL_1086;
              case 24:
                goto LABEL_1149;
              case 25:
                goto LABEL_1212;
              case 26:
                goto LABEL_1275;
            }
          }
          v1089 += v1174;
          v102 += v1079 * v1146;
          v103 += v1146 * v1083;
          if ( v1284 )
          {
            v1098 = dword_93ADC;
            if ( v1280 )
            {
              v1089 = dword_93ADC;
            }
            else
            {
              v1280 = dword_93ADC <= v1089;
              v1095 = dword_93ADC - v1089;
            }
          }
        }
        else if ( v1284 )
        {
          v106 = dword_93ADC - v1174;
          v1098 = dword_93ADC - v1174;
          if ( v1280 )
          {
            v1089 = dword_93ADC - v1174;
          }
          else
          {
            //fix v27 = __OFSUB__(v106, v1089);
            v107 = v106 - v1089;
            v1280 = (v107 < 0) ^ v27 | (v107 == 0);
            v1095 = v107;
          }
        }
        v105 = (uint32*)&unk_93AE0;
        do
        {
          *v105 = v102;
          v102 += v1079;
          v105[1] = v103;
          v103 += v1083;
          v105 += 5;
          --v1089;
        }
        while ( v1089 );
        v104 = v1097;
        goto LABEL_219;
      case 1:
      case 4:
      case 16:
      case 17:
        v91 = v1089 * (__int64)(*v4 - *v3) / v63;
        v92 = *v3 - *v5;
        v93 = v91 + v92 == 0;
        //fix v16 = (v91 + v92 < 0) ^ __OFADD__(v91, v92);
        v94 = v91 + v92;
        if ( v16 )
          return;
        if ( !v93 )
          v1121 = (int)(v3[4] + v1089 * (__int64)(v4[4] - v3[4]) / v1093 - v5[4]) / (v94 + 1);
        v1125 = (v5[4] - v3[4]) / v1089;
        v1131 = (v4[4] - v5[4]) / v1095;
        v95 = *v3 << 16;
        v96 = v95;
        v97 = v3[4];
        if ( v1276 )
        {
          v16 = v1098 <= -v1174;
          v1098 += v1174;
          if ( v16 )
            return;
          v1144 = -v1174;
          if ( -v1174 - v1089 >= 0 )
          {
            v1145 = v1144 - v1089;
            v1095 -= v1145;
            v98 = v1087 * v1145 + v1097;
            v96 += v1145 * v1083 + v1089 * v1083;
            v97 += v1145 * v1131 + v1089 * v1125;
            if ( v1284 )
            {
              v1095 = dword_93ADC;
              v1098 = dword_93ADC;
            }
            v99 = (uint32*)&unk_93AE0;
LABEL_198:
            if ( v1280 )
            {
              v29 = (unsigned __int8)byte_967E1;
              switch ( byte_967E1 )
              {
                case 0:
                  goto LABEL_309;
                case 1:
                  goto LABEL_322;
                case 2:
                  goto LABEL_351;
                case 3:
                  goto LABEL_382;
                case 4:
                  goto LABEL_445;
                case 5:
                  goto LABEL_474;
                case 6:
                  goto LABEL_503;
                case 7:
                case 11:
                  goto LABEL_564;
                case 8:
                  goto LABEL_595;
                case 9:
                case 10:
                  goto LABEL_658;
                case 12:
                  goto LABEL_721;
                case 13:
                  goto LABEL_752;
                case 14:
                  goto LABEL_783;
                case 15:
                  goto LABEL_812;
                case 16:
                  goto LABEL_841;
                case 17:
                  goto LABEL_870;
                case 18:
                  goto LABEL_899;
                case 19:
                  goto LABEL_930;
                case 20:
                  goto LABEL_961;
                case 21:
                  goto LABEL_992;
                case 22:
                  goto LABEL_1023;
                case 23:
                  goto LABEL_1086;
                case 24:
                  goto LABEL_1149;
                case 25:
                  goto LABEL_1212;
                case 26:
                  goto LABEL_1275;
              }
            }
            do
            {
              *v99 = v98;
              v98 += v1087;
              v99[1] = v96;
              v96 += v1083;
              v99[4] = v97;
              v97 += v1131;
              v99 += 5;
              --v1095;
            }
            while ( v1095 );
            v29 = (unsigned __int8)byte_967E1;
            switch ( byte_967E1 )
            {
              case 0:
                goto LABEL_309;
              case 1:
                goto LABEL_322;
              case 2:
                goto LABEL_351;
              case 3:
                goto LABEL_382;
              case 4:
                goto LABEL_445;
              case 5:
                goto LABEL_474;
              case 6:
                goto LABEL_503;
              case 7:
              case 11:
                goto LABEL_564;
              case 8:
                goto LABEL_595;
              case 9:
              case 10:
                goto LABEL_658;
              case 12:
                goto LABEL_721;
              case 13:
                goto LABEL_752;
              case 14:
                goto LABEL_783;
              case 15:
                goto LABEL_812;
              case 16:
                goto LABEL_841;
              case 17:
                goto LABEL_870;
              case 18:
                goto LABEL_899;
              case 19:
                goto LABEL_930;
              case 20:
                goto LABEL_961;
              case 21:
                goto LABEL_992;
              case 22:
                goto LABEL_1023;
              case 23:
                goto LABEL_1086;
              case 24:
                goto LABEL_1149;
              case 25:
                goto LABEL_1212;
              case 26:
                goto LABEL_1275;
            }
          }
          v1089 += v1174;
          v95 += v1079 * v1144;
          v96 += v1144 * v1083;
          v97 += v1144 * v1125;
          if ( v1284 )
          {
            v1098 = dword_93ADC;
            if ( v1280 )
            {
              v1089 = dword_93ADC;
            }
            else
            {
              v1280 = dword_93ADC <= v1089;
              v1095 = dword_93ADC - v1089;
            }
          }
        }
        else if ( v1284 )
        {
          v100 = dword_93ADC - v1174;
          v1098 = dword_93ADC - v1174;
          if ( v1280 )
          {
            v1089 = dword_93ADC - v1174;
          }
          else
          {
            //fix v27 = __OFSUB__(v100, v1089);
            v101 = v100 - v1089;
            v1280 = (v101 < 0) ^ v27 | (v101 == 0);
            v1095 = v101;
          }
        }
        v99 = (uint32*)&unk_93AE0;
        do
        {
          *v99 = v95;
          v95 += v1079;
          v99[1] = v96;
          v96 += v1083;
          v99[4] = v97;
          v97 += v1125;
          v99 += 5;
          --v1089;
        }
        while ( v1089 );
        v98 = v1097;
        goto LABEL_198;
      case 2:
      case 3:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 18:
      case 19:
      case 22:
      case 23:
        v78 = v1089 * (__int64)(*v4 - *v3) / v63;
        v79 = *v3 - *v5;
        v80 = v78 + v79 == 0;
        //fix v16 = (v78 + v79 < 0) ^ __OFADD__(v78, v79);
        v81 = v78 + v79;
        if ( v16 )
          return;
        if ( !v80 )
        {
          v82 = v81 + 1;
          v1099 = (int)(v3[2] + v1089 * (__int64)(v4[2] - v3[2]) / v1093 - v5[2]) / v82;
          v1110 = (int)(v3[3] + v1089 * (__int64)(v4[3] - v3[3]) / v1093 - v5[3]) / v82;
        }
        v1103 = (v5[2] - v3[2]) / v1089;
        v1114 = (v5[3] - v3[3]) / v1089;
        v1109 = (v4[2] - v5[2]) / v1095;
        v1120 = (v4[3] - v5[3]) / v1095;
        v83 = *v3 << 16;
        v84 = v83;
        v85 = v3[2];
        v86 = v3[3];
        if ( v1276 )
        {
          v16 = v1098 <= -v1174;
          v1098 += v1174;
          if ( v16 )
            return;
          v1142 = -v1174;
          if ( -v1174 - v1089 >= 0 )
          {
            v1143 = v1142 - v1089;
            v1095 -= v1143;
            v87 = v1087 * v1143 + v1097;
            v84 += v1143 * v1083 + v1089 * v1083;
            v85 += v1143 * v1109 + v1089 * v1103;
            v86 += v1143 * v1120 + v1089 * v1114;
            if ( v1284 )
            {
              v1095 = dword_93ADC;
              v1098 = dword_93ADC;
            }
            v88 = (uint32*)&unk_93AE0;
LABEL_174:
            if ( v1280 )
            {
              v29 = (unsigned __int8)byte_967E1;
              switch ( byte_967E1 )
              {
                case 0:
                  goto LABEL_309;
                case 1:
                  goto LABEL_322;
                case 2:
                  goto LABEL_351;
                case 3:
                  goto LABEL_382;
                case 4:
                  goto LABEL_445;
                case 5:
                  goto LABEL_474;
                case 6:
                  goto LABEL_503;
                case 7:
                case 11:
                  goto LABEL_564;
                case 8:
                  goto LABEL_595;
                case 9:
                case 10:
                  goto LABEL_658;
                case 12:
                  goto LABEL_721;
                case 13:
                  goto LABEL_752;
                case 14:
                  goto LABEL_783;
                case 15:
                  goto LABEL_812;
                case 16:
                  goto LABEL_841;
                case 17:
                  goto LABEL_870;
                case 18:
                  goto LABEL_899;
                case 19:
                  goto LABEL_930;
                case 20:
                  goto LABEL_961;
                case 21:
                  goto LABEL_992;
                case 22:
                  goto LABEL_1023;
                case 23:
                  goto LABEL_1086;
                case 24:
                  goto LABEL_1149;
                case 25:
                  goto LABEL_1212;
                case 26:
                  goto LABEL_1275;
              }
            }
            do
            {
              *v88 = v87;
              v87 += v1087;
              v88[1] = v84;
              v84 += v1083;
              v88[2] = v85;
              v85 += v1109;
              v88[3] = v86;
              v86 += v1120;
              v88 += 5;
              --v1095;
            }
            while ( v1095 );
            v29 = (unsigned __int8)byte_967E1;
            switch ( byte_967E1 )
            {
              case 0:
                goto LABEL_309;
              case 1:
                goto LABEL_322;
              case 2:
                goto LABEL_351;
              case 3:
                goto LABEL_382;
              case 4:
                goto LABEL_445;
              case 5:
                goto LABEL_474;
              case 6:
                goto LABEL_503;
              case 7:
              case 11:
                goto LABEL_564;
              case 8:
                goto LABEL_595;
              case 9:
              case 10:
                goto LABEL_658;
              case 12:
                goto LABEL_721;
              case 13:
                goto LABEL_752;
              case 14:
                goto LABEL_783;
              case 15:
                goto LABEL_812;
              case 16:
                goto LABEL_841;
              case 17:
                goto LABEL_870;
              case 18:
                goto LABEL_899;
              case 19:
                goto LABEL_930;
              case 20:
                goto LABEL_961;
              case 21:
                goto LABEL_992;
              case 22:
                goto LABEL_1023;
              case 23:
                goto LABEL_1086;
              case 24:
                goto LABEL_1149;
              case 25:
                goto LABEL_1212;
              case 26:
                goto LABEL_1275;
            }
          }
          v1089 += v1174;
          v83 += v1079 * v1142;
          v84 += v1142 * v1083;
          v85 += v1142 * v1103;
          v86 += v1142 * v1114;
          if ( v1284 )
          {
            v1098 = dword_93ADC;
            if ( v1280 )
            {
              v1089 = dword_93ADC;
            }
            else
            {
              v1280 = dword_93ADC <= v1089;
              v1095 = dword_93ADC - v1089;
            }
          }
        }
        else if ( v1284 )
        {
          v89 = dword_93ADC - v1174;
          v1098 = dword_93ADC - v1174;
          if ( v1280 )
          {
            v1089 = dword_93ADC - v1174;
          }
          else
          {
            //fix v27 = __OFSUB__(v89, v1089);
            v90 = v89 - v1089;
            v1280 = (v90 < 0) ^ v27 | (v90 == 0);
            v1095 = v90;
          }
        }
        v88 = (uint32*)&unk_93AE0;
        do
        {
          *v88 = v83;
          v83 += v1079;
          v88[1] = v84;
          v84 += v1083;
          v88[2] = v85;
          v85 += v1103;
          v88[3] = v86;
          v86 += v1114;
          v88 += 5;
          --v1089;
        }
        while ( v1089 );
        v87 = v1097;
        goto LABEL_174;
      case 5:
      case 6:
      case 20:
      case 21:
      case 24:
      case 25:
      case 26:
        v64 = v1089 * (__int64)(*v4 - *v3) / v63;
        v65 = *v3 - *v5;
        v66 = v64 + v65 == 0;
        //fix v16 = (v64 + v65 < 0) ^ __OFADD__(v64, v65);
        v67 = v64 + v65;
        if ( v16 )
          return;
        if ( !v66 )
        {
          v68 = v67 + 1;
          v1099 = (int)(v3[2] + v1089 * (__int64)(v4[2] - v3[2]) / v1093 - v5[2]) / v68;
          v1110 = (int)(v3[3] + v1089 * (__int64)(v4[3] - v3[3]) / v1093 - v5[3]) / v68;
          v64 = (int)(v3[4] + v1089 * (__int64)(v4[4] - v3[4]) / v1093 - v5[4]) / v68;
        }
        v1121 = v64;
        v1102 = (v5[2] - v3[2]) / v1089;
        v1113 = (v5[3] - v3[3]) / v1089;
        v1124 = (v5[4] - v3[4]) / v1089;
        v1108 = (v4[2] - v5[2]) / v1095;
        v1119 = (v4[3] - v5[3]) / v1095;
        v1130 = (v4[4] - v5[4]) / v1095;
        v69 = *v3 << 16;
        v70 = v69;
        v71 = v3[2];
        v72 = v3[3];
        v73 = v3[4];
        if ( v1276 )
        {
          v16 = v1098 <= -v1174;
          v1098 += v1174;
          if ( v16 )
            return;
          v1140 = -v1174;
          if ( -v1174 - v1089 >= 0 )
          {
            v1141 = v1140 - v1089;
            v1095 -= v1141;
            v74 = v1087 * v1141 + v1097;
            v70 += v1141 * v1083 + v1089 * v1083;
            v71 += v1141 * v1108 + v1089 * v1102;
            v72 += v1141 * v1119 + v1089 * v1113;
            v73 += v1141 * v1130 + v1089 * v1124;
            if ( v1284 )
            {
              v1095 = dword_93ADC;
              v1098 = dword_93ADC;
            }
            v75 = (uint32*)&unk_93AE0;
LABEL_150:
            if ( v1280 )
            {
              v29 = (unsigned __int8)byte_967E1;
              switch ( byte_967E1 )
              {
                case 0:
                  goto LABEL_309;
                case 1:
                  goto LABEL_322;
                case 2:
                  goto LABEL_351;
                case 3:
                  goto LABEL_382;
                case 4:
                  goto LABEL_445;
                case 5:
                  goto LABEL_474;
                case 6:
                  goto LABEL_503;
                case 7:
                case 11:
                  goto LABEL_564;
                case 8:
                  goto LABEL_595;
                case 9:
                case 10:
                  goto LABEL_658;
                case 12:
                  goto LABEL_721;
                case 13:
                  goto LABEL_752;
                case 14:
                  goto LABEL_783;
                case 15:
                  goto LABEL_812;
                case 16:
                  goto LABEL_841;
                case 17:
                  goto LABEL_870;
                case 18:
                  goto LABEL_899;
                case 19:
                  goto LABEL_930;
                case 20:
                  goto LABEL_961;
                case 21:
                  goto LABEL_992;
                case 22:
                  goto LABEL_1023;
                case 23:
                  goto LABEL_1086;
                case 24:
                  goto LABEL_1149;
                case 25:
                  goto LABEL_1212;
                case 26:
                  goto LABEL_1275;
              }
            }
            do
            {
              *v75 = v74;
              v74 += v1087;
              v75[1] = v70;
              v70 += v1083;
              v75[2] = v71;
              v71 += v1108;
              v75[3] = v72;
              v72 += v1119;
              v75[4] = v73;
              v73 += v1130;
              v75 += 5;
              --v1095;
            }
            while ( v1095 );
            v29 = (unsigned __int8)byte_967E1;
            switch ( byte_967E1 )
            {
              case 0:
                goto LABEL_309;
              case 1:
                goto LABEL_322;
              case 2:
                goto LABEL_351;
              case 3:
                goto LABEL_382;
              case 4:
                goto LABEL_445;
              case 5:
                goto LABEL_474;
              case 6:
                goto LABEL_503;
              case 7:
              case 11:
                goto LABEL_564;
              case 8:
                goto LABEL_595;
              case 9:
              case 10:
                goto LABEL_658;
              case 12:
                goto LABEL_721;
              case 13:
                goto LABEL_752;
              case 14:
                goto LABEL_783;
              case 15:
                goto LABEL_812;
              case 16:
                goto LABEL_841;
              case 17:
                goto LABEL_870;
              case 18:
                goto LABEL_899;
              case 19:
                goto LABEL_930;
              case 20:
                goto LABEL_961;
              case 21:
                goto LABEL_992;
              case 22:
                goto LABEL_1023;
              case 23:
                goto LABEL_1086;
              case 24:
                goto LABEL_1149;
              case 25:
                goto LABEL_1212;
              case 26:
                goto LABEL_1275;
            }
          }
          v1089 += v1174;
          v69 += v1079 * v1140;
          v70 += v1140 * v1083;
          v71 += v1140 * v1102;
          v72 += v1140 * v1113;
          v73 += v1140 * v1124;
          if ( v1284 )
          {
            v1098 = dword_93ADC;
            if ( v1280 )
            {
              v1089 = dword_93ADC;
            }
            else
            {
              v1280 = dword_93ADC <= v1089;
              v1095 = dword_93ADC - v1089;
            }
          }
        }
        else if ( v1284 )
        {
          v76 = dword_93ADC - v1174;
          v1098 = dword_93ADC - v1174;
          if ( v1280 )
          {
            v1089 = dword_93ADC - v1174;
          }
          else
          {
            //fix v27 = __OFSUB__(v76, v1089);
            v77 = v76 - v1089;
            v1280 = (v77 < 0) ^ v27 | (v77 == 0);
            v1095 = v77;
          }
        }
        v75 = (uint32*)&unk_93AE0;
        do
        {
          *v75 = v69;
          v69 += v1079;
          v75[1] = v70;
          v70 += v1083;
          v75[2] = v71;
          v71 += v1102;
          v75[3] = v72;
          v72 += v1113;
          v75[4] = v73;
          v73 += v1124;
          v75 += 5;
          --v1089;
        }
        while ( v1089 );
        v74 = v1097;
        goto LABEL_150;
    }
  }
}
// 7466B: variable 'v1121' is possibly undefined
// 74802: variable 'v1110' is possibly undefined
// 74843: variable 'v1099' is possibly undefined
// 74F95: using guessed type int dword_74F95[];
// 93AC8: using guessed type int dword_93AC8;
// 93AD0: using guessed type int dword_93AD0;
// 93AD4: using guessed type int dword_93AD4;
// 93AD8: using guessed type int dword_93AD8;
// 93ADC: using guessed type int dword_93ADC;
// 967E0: using guessed type char byte_967E0;
// 967E1: using guessed type char byte_967E1;

//----- (00079495) --------------------------------------------------------
void sub_79495(int a1, int a2, int a3, int a4, int a5)
{
  if ( a3 )
    dword_93AD4 = a3;
  if ( a1 )
  {
    dword_93ACC = a1;
    dword_93AC8 = a1 - dword_93AD4;
  }
  if ( a2 )
    dword_93AD0 = a2;
  if ( a5 )
    dword_93ADC = a5;
  if ( a4 )
    dword_93AD8 = a4;
}
// 93AC8: using guessed type int dword_93AC8;
// 93ACC: using guessed type int dword_93ACC;
// 93AD0: using guessed type int dword_93AD0;
// 93AD4: using guessed type int dword_93AD4;
// 93AD8: using guessed type int dword_93AD8;
// 93ADC: using guessed type int dword_93ADC;

//----- (00079906) --------------------------------------------------------
void sub_79906(int a1)
{
  _BYTE *v1; // ecx
  _BYTE *v2; // edx
  int v3; // [esp-30h] [ebp-3Ch]
  int v4; // [esp-30h] [ebp-3Ch]
  int v5; // [esp-30h] [ebp-3Ch]
  int v6; // [esp-30h] [ebp-3Ch]
  int v7; // [esp-30h] [ebp-3Ch]
  int v8; // [esp-30h] [ebp-3Ch]
  int v9; // [esp-30h] [ebp-3Ch]
  int v10; // [esp-30h] [ebp-3Ch]
  int v11; // [esp-30h] [ebp-3Ch]
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  sub_61A1C(0);
  v1 = (_BYTE *)dword_AE404;
  v2 = (_BYTE *)dword_12EFF4;
  v3 = sub_79A70(0, (_BYTE *)dword_12EFF4, (_BYTE *)dword_AE404, 0, (int)&savedregs, a1);
  sub_61A1C(1);
  v4 = sub_79A70(v3, v2, v1, 0, (int)&savedregs, a1);
  sub_61A1C(2);
  v5 = sub_79A70(v4, v2, v1, 0, (int)&savedregs, a1);
  sub_61A1C(3);
  v6 = sub_79A70(v5, v2, v1, 0, (int)&savedregs, a1);
  sub_61A1C(4);
  v7 = sub_79A70(v6, v2, v1, 0, (int)&savedregs, a1);
  sub_61A1C(5);
  v8 = sub_79A70(v7, v2, v1, 0, (int)&savedregs, a1);
  sub_61A1C(6);
  v9 = sub_79A70(v8, v2, v1, 0, (int)&savedregs, a1);
  sub_61A1C(7);
  v10 = sub_79A70(v9, v2, v1, 0, (int)&savedregs, a1);
  sub_61A1C(8);
  v11 = sub_79A70(v10, v2, v1, 0, (int)&savedregs, a1);
  sub_61A1C(9);
  sub_79A70(v11, v2, v1, 0, (int)&savedregs, a1);
}
// AE404: using guessed type int dword_AE404;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (00079A1B) --------------------------------------------------------
void sub_79A1B(int a1)
{
  _BYTE *v1; // ecx
  _BYTE *v2; // edx
  int v3; // [esp-30h] [ebp-3Ch]
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  sub_61A1C(0);
  v1 = (_BYTE *)dword_AE404;
  v2 = (_BYTE *)dword_12EFF4;
  v3 = sub_79A70(0, (_BYTE *)dword_12EFF4, (_BYTE *)dword_AE404, 0, (int)&savedregs, a1);
  sub_61A1C(1);
  sub_79A70(v3, v2, v1, 0, (int)&savedregs, a1);
}
// AE404: using guessed type int dword_AE404;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (00079A70) --------------------------------------------------------
int sub_79A70(
        int result,
        _BYTE *a2,
        _BYTE *a3,
        int a4,
        int a5,
        int a6)
{
  int *v6; // edi
  int v7; // eax

  v6 = (int *)&unk_A0000;
  do
  {
    LOBYTE(a4) = a3[1];
    LOWORD(result) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[1];
    LOWORD(result) = *(_WORD *)(a6 + 2 * a4 + 512) + result;
    v7 = result << 16;
    LOBYTE(a4) = *a3;
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = *a2;
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    *v6 = v7;
    LOBYTE(a4) = a3[3];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[3];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    v7 <<= 16;
    LOBYTE(a4) = a3[2];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[2];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    v6[1] = v7;
    LOBYTE(a4) = a3[5];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[5];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    v7 <<= 16;
    LOBYTE(a4) = a3[4];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[4];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    v6[2] = v7;
    LOBYTE(a4) = a3[7];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[7];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    result = v7 << 16;
    LOBYTE(a4) = a3[6];
    LOWORD(result) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[6];
    LOWORD(result) = *(_WORD *)(a6 + 2 * a4 + 512) + result;
    v6[3] = result;
    a3 += 8;
    a2 += 8;
    v6 += 4;
  }
  while ( (*(_DWORD *)(a5 - 4))-- != 1 );
  return result;
}

//----- (00079B2D) --------------------------------------------------------
void sub_79B2D()
{
  char *v0; // edi
  char *v1; // esi
  int v2; // edx
  char *v3; // esi
  char *v4; // esi
  char *v5; // edi
  int v6; // edx
  char *v7; // esi
  char *v8; // esi
  char *v9; // edi
  int v10; // edx
  char *v11; // edi
  int v12; // edx
  char *v13; // edi
  int v14; // edx

  if ( !byte_9AD96 )
    sub_5BDF8();
  sub_61A1C(0);
  v0 = (char *)&unk_A0000 + 51200;
  v1 = (char *)dword_12EFF4;
  v2 = 11;
  do
  {
    qmemcpy(v0, v1, 0x280u);
    v1 += 1280;
    v0 += 1280;
    --v2;
  }
  while ( v2 );
  qmemcpy(v0, v1, 0x100u);
  v3 = v1 + 256;
  sub_61A1C(1);
  qmemcpy(&unk_A0000, v3, 0x180u);
  v4 = v3 + 1024;
  v5 = (char *)&unk_A0000 + 1024;
  v6 = 50;
  do
  {
    qmemcpy(v5, v4, 0x280u);
    v4 += 1280;
    v5 += 1280;
    --v6;
  }
  while ( v6 );
  qmemcpy(v5, v4, 0x200u);
  v7 = v4 + 512;
  sub_61A1C(2);
  qmemcpy(&unk_A0000, v7, 0x80u);
  v8 = v7 + 768;
  v9 = (char *)&unk_A0000 + 768;
  v10 = 51;
  do
  {
    qmemcpy(v9, v8, 0x280u);
    v8 += 1280;
    v9 += 1280;
    --v10;
  }
  while ( v10 );
  sub_61A1C(3);
  v11 = (char *)&unk_A0000 + 512;
  v12 = 51;
  do
  {
    qmemcpy(v11, v8, 0x280u);
    v8 += 1280;
    v11 += 1280;
    --v12;
  }
  while ( v12 );
  sub_61A1C(4);
  v13 = (char *)&unk_A0000 + 256;
  v14 = 34;
  do
  {
    qmemcpy(v13, v8, 0x280u);
    v8 += 1280;
    v13 += 1280;
    --v14;
  }
  while ( v14 );
  if ( !byte_9AD96 )
    sub_5BE50();
}
// 9AD96: using guessed type char byte_9AD96;
// 12EFF4: using guessed type int dword_12EFF4;

//----- (0007B444) --------------------------------------------------------
int sub_7B444()
{
  return dword_A0CA8;
}
// A0CA8: using guessed type int dword_A0CA8;

// nfuncs=1665 queued=1390 decompiled=1390 lumina nreq=0 worse=0 better=0
// ALL OK, 1390 function(s) have been successfully decompiled


